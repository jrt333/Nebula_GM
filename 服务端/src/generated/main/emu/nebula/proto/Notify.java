// Code generated by protocol buffer compiler. Do not edit!
package emu.nebula.proto;

import java.io.IOException;
import us.hebi.quickbuf.FieldName;
import us.hebi.quickbuf.InvalidProtocolBufferException;
import us.hebi.quickbuf.JsonSink;
import us.hebi.quickbuf.JsonSource;
import us.hebi.quickbuf.MessageFactory;
import us.hebi.quickbuf.ProtoMessage;
import us.hebi.quickbuf.ProtoSink;
import us.hebi.quickbuf.ProtoSource;
import us.hebi.quickbuf.RepeatedByte;
import us.hebi.quickbuf.RepeatedInt;
import us.hebi.quickbuf.RepeatedMessage;
import us.hebi.quickbuf.Utf8String;

public final class Notify {
  /**
   * Protobuf type {@code NewAgent}
   */
  public static final class NewAgent extends ProtoMessage<NewAgent> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    /**
     * <code>repeated uint32 Ids = 1;</code>
     */
    private final RepeatedInt ids = RepeatedInt.newEmptyInstance();

    private NewAgent() {
    }

    /**
     * @return a new empty instance of {@code NewAgent}
     */
    public static NewAgent newInstance() {
      return new NewAgent();
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public NewAgent clearNextPackage() {
      bitField0_ &= ~0x00000001;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000001;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public NewAgent addNextPackage(final byte value) {
      bitField0_ |= 0x00000001;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public NewAgent addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000001;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public NewAgent setNextPackage(final byte... values) {
      bitField0_ |= 0x00000001;
      nextPackage.copyFrom(values);
      return this;
    }

    /**
     * <code>repeated uint32 Ids = 1;</code>
     * @return whether the ids field is set
     */
    public boolean hasIds() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>repeated uint32 Ids = 1;</code>
     * @return this
     */
    public NewAgent clearIds() {
      bitField0_ &= ~0x00000002;
      ids.clear();
      return this;
    }

    /**
     * <code>repeated uint32 Ids = 1;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableIds()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedInt getIds() {
      return ids;
    }

    /**
     * <code>repeated uint32 Ids = 1;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedInt getMutableIds() {
      bitField0_ |= 0x00000002;
      return ids;
    }

    /**
     * <code>repeated uint32 Ids = 1;</code>
     * @param value the ids to add
     * @return this
     */
    public NewAgent addIds(final int value) {
      bitField0_ |= 0x00000002;
      ids.add(value);
      return this;
    }

    /**
     * <code>repeated uint32 Ids = 1;</code>
     * @param values the ids to add
     * @return this
     */
    public NewAgent addAllIds(final int... values) {
      bitField0_ |= 0x00000002;
      ids.addAll(values);
      return this;
    }

    @Override
    public NewAgent copyFrom(final NewAgent other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        nextPackage.copyFrom(other.nextPackage);
        ids.copyFrom(other.ids);
      }
      return this;
    }

    @Override
    public NewAgent mergeFrom(final NewAgent other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      if (other.hasIds()) {
        getMutableIds().addAll(other.ids);
      }
      return this;
    }

    @Override
    public NewAgent clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      ids.clear();
      return this;
    }

    @Override
    public NewAgent clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      ids.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof NewAgent)) {
        return false;
      }
      NewAgent other = (NewAgent) o;
      return bitField0_ == other.bitField0_
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage))
        && (!hasIds() || ids.equals(other.ids));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        for (int i = 0; i < ids.length(); i++) {
          output.writeRawByte((byte) 8);
          output.writeUInt32NoTag(ids.array()[i]);
        }
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += (1 * ids.length()) + ProtoSink.computeRepeatedUInt32SizeNoTag(ids);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public NewAgent mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 10) {
              break;
            }
          }
          case 10: {
            // ids [packed=true]
            input.readPackedUInt32(ids, tag);
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
          case 8: {
            // ids [packed=false]
            tag = input.readRepeatedUInt32(ids, tag);
            bitField0_ |= 0x00000002;
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRepeatedUInt32(FieldNames.ids, ids);
      }
      output.endObject();
    }

    @Override
    public NewAgent mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 73368: {
            if (input.isAtField(FieldNames.ids)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedUInt32(ids);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public NewAgent clone() {
      return new NewAgent().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static NewAgent parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new NewAgent(), data).checkInitialized();
    }

    public static NewAgent parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new NewAgent(), input).checkInitialized();
    }

    public static NewAgent parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new NewAgent(), input).checkInitialized();
    }

    /**
     * @return factory for creating NewAgent messages
     */
    public static MessageFactory<NewAgent> getFactory() {
      return NewAgentFactory.INSTANCE;
    }

    private enum NewAgentFactory implements MessageFactory<NewAgent> {
      INSTANCE;

      @Override
      public NewAgent create() {
        return NewAgent.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName nextPackage = FieldName.forField("NextPackage");

      static final FieldName ids = FieldName.forField("Ids");
    }
  }

  /**
   * Protobuf type {@code SigninRewardUpdate}
   */
  public static final class SigninRewardUpdate extends ProtoMessage<SigninRewardUpdate> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional uint32 Index = 1;</code>
     */
    private int index;

    /**
     * <code>optional bool Switch = 6;</code>
     */
    private boolean switch_;

    /**
     * <code>optional .ChangeInfo Change = 2;</code>
     */
    private final Public.ChangeInfo change = Public.ChangeInfo.newInstance();

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    private SigninRewardUpdate() {
    }

    /**
     * @return a new empty instance of {@code SigninRewardUpdate}
     */
    public static SigninRewardUpdate newInstance() {
      return new SigninRewardUpdate();
    }

    /**
     * <code>optional uint32 Index = 1;</code>
     * @return whether the index field is set
     */
    public boolean hasIndex() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional uint32 Index = 1;</code>
     * @return this
     */
    public SigninRewardUpdate clearIndex() {
      bitField0_ &= ~0x00000001;
      index = 0;
      return this;
    }

    /**
     * <code>optional uint32 Index = 1;</code>
     * @return the index
     */
    public int getIndex() {
      return index;
    }

    /**
     * <code>optional uint32 Index = 1;</code>
     * @param value the index to set
     * @return this
     */
    public SigninRewardUpdate setIndex(final int value) {
      bitField0_ |= 0x00000001;
      index = value;
      return this;
    }

    /**
     * <code>optional bool Switch = 6;</code>
     * @return whether the switch_ field is set
     */
    public boolean hasSwitch() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional bool Switch = 6;</code>
     * @return this
     */
    public SigninRewardUpdate clearSwitch() {
      bitField0_ &= ~0x00000002;
      switch_ = false;
      return this;
    }

    /**
     * <code>optional bool Switch = 6;</code>
     * @return the switch_
     */
    public boolean getSwitch() {
      return switch_;
    }

    /**
     * <code>optional bool Switch = 6;</code>
     * @param value the switch_ to set
     * @return this
     */
    public SigninRewardUpdate setSwitch(final boolean value) {
      bitField0_ |= 0x00000002;
      switch_ = value;
      return this;
    }

    /**
     * <code>optional .ChangeInfo Change = 2;</code>
     * @return whether the change field is set
     */
    public boolean hasChange() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional .ChangeInfo Change = 2;</code>
     * @return this
     */
    public SigninRewardUpdate clearChange() {
      bitField0_ &= ~0x00000004;
      change.clear();
      return this;
    }

    /**
     * <code>optional .ChangeInfo Change = 2;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableChange()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public Public.ChangeInfo getChange() {
      return change;
    }

    /**
     * <code>optional .ChangeInfo Change = 2;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public Public.ChangeInfo getMutableChange() {
      bitField0_ |= 0x00000004;
      return change;
    }

    /**
     * <code>optional .ChangeInfo Change = 2;</code>
     * @param value the change to set
     * @return this
     */
    public SigninRewardUpdate setChange(final Public.ChangeInfo value) {
      bitField0_ |= 0x00000004;
      change.copyFrom(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000008) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public SigninRewardUpdate clearNextPackage() {
      bitField0_ &= ~0x00000008;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000008;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public SigninRewardUpdate addNextPackage(final byte value) {
      bitField0_ |= 0x00000008;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public SigninRewardUpdate addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000008;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public SigninRewardUpdate setNextPackage(final byte... values) {
      bitField0_ |= 0x00000008;
      nextPackage.copyFrom(values);
      return this;
    }

    @Override
    public SigninRewardUpdate copyFrom(final SigninRewardUpdate other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        index = other.index;
        switch_ = other.switch_;
        change.copyFrom(other.change);
        nextPackage.copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public SigninRewardUpdate mergeFrom(final SigninRewardUpdate other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasIndex()) {
        setIndex(other.index);
      }
      if (other.hasSwitch()) {
        setSwitch(other.switch_);
      }
      if (other.hasChange()) {
        getMutableChange().mergeFrom(other.change);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public SigninRewardUpdate clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      index = 0;
      switch_ = false;
      change.clear();
      nextPackage.clear();
      return this;
    }

    @Override
    public SigninRewardUpdate clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      change.clearQuick();
      nextPackage.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof SigninRewardUpdate)) {
        return false;
      }
      SigninRewardUpdate other = (SigninRewardUpdate) o;
      return bitField0_ == other.bitField0_
        && (!hasIndex() || index == other.index)
        && (!hasSwitch() || switch_ == other.switch_)
        && (!hasChange() || change.equals(other.change))
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt32NoTag(index);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 48);
        output.writeBoolNoTag(switch_);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawByte((byte) 18);
        output.writeMessageNoTag(change);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(index);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 2;
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 1 + ProtoSink.computeMessageSizeNoTag(change);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public SigninRewardUpdate mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            // index
            index = input.readUInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 48) {
              break;
            }
          }
          case 48: {
            // switch_
            switch_ = input.readBool();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 18) {
              break;
            }
          }
          case 18: {
            // change
            input.readMessage(change);
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000008;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeUInt32(FieldNames.index, index);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeBool(FieldNames.switch_, switch_);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeMessage(FieldNames.change, change);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      output.endObject();
    }

    @Override
    public SigninRewardUpdate mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 70793394: {
            if (input.isAtField(FieldNames.index)) {
              if (!input.trySkipNullValue()) {
                index = input.readUInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1805606060: {
            if (input.isAtField(FieldNames.switch_)) {
              if (!input.trySkipNullValue()) {
                switch_ = input.readBool();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 2017198032: {
            if (input.isAtField(FieldNames.change)) {
              if (!input.trySkipNullValue()) {
                input.readMessage(change);
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000008;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public SigninRewardUpdate clone() {
      return new SigninRewardUpdate().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static SigninRewardUpdate parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new SigninRewardUpdate(), data).checkInitialized();
    }

    public static SigninRewardUpdate parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new SigninRewardUpdate(), input).checkInitialized();
    }

    public static SigninRewardUpdate parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new SigninRewardUpdate(), input).checkInitialized();
    }

    /**
     * @return factory for creating SigninRewardUpdate messages
     */
    public static MessageFactory<SigninRewardUpdate> getFactory() {
      return SigninRewardUpdateFactory.INSTANCE;
    }

    private enum SigninRewardUpdateFactory implements MessageFactory<SigninRewardUpdate> {
      INSTANCE;

      @Override
      public SigninRewardUpdate create() {
        return SigninRewardUpdate.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName index = FieldName.forField("Index");

      static final FieldName switch_ = FieldName.forField("Switch");

      static final FieldName change = FieldName.forField("Change");

      static final FieldName nextPackage = FieldName.forField("NextPackage");
    }
  }

  /**
   * Protobuf type {@code OrderStateChange}
   */
  public static final class OrderStateChange extends ProtoMessage<OrderStateChange> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional uint32 Store = 2;</code>
     */
    private int store;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    /**
     * <code>optional string OrderId = 1;</code>
     */
    private final Utf8String orderId = Utf8String.newEmptyInstance();

    private OrderStateChange() {
    }

    /**
     * @return a new empty instance of {@code OrderStateChange}
     */
    public static OrderStateChange newInstance() {
      return new OrderStateChange();
    }

    /**
     * <code>optional uint32 Store = 2;</code>
     * @return whether the store field is set
     */
    public boolean hasStore() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional uint32 Store = 2;</code>
     * @return this
     */
    public OrderStateChange clearStore() {
      bitField0_ &= ~0x00000001;
      store = 0;
      return this;
    }

    /**
     * <code>optional uint32 Store = 2;</code>
     * @return the store
     */
    public int getStore() {
      return store;
    }

    /**
     * <code>optional uint32 Store = 2;</code>
     * @param value the store to set
     * @return this
     */
    public OrderStateChange setStore(final int value) {
      bitField0_ |= 0x00000001;
      store = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public OrderStateChange clearNextPackage() {
      bitField0_ &= ~0x00000002;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000002;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public OrderStateChange addNextPackage(final byte value) {
      bitField0_ |= 0x00000002;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public OrderStateChange addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000002;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public OrderStateChange setNextPackage(final byte... values) {
      bitField0_ |= 0x00000002;
      nextPackage.copyFrom(values);
      return this;
    }

    /**
     * <code>optional string OrderId = 1;</code>
     * @return whether the orderId field is set
     */
    public boolean hasOrderId() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional string OrderId = 1;</code>
     * @return this
     */
    public OrderStateChange clearOrderId() {
      bitField0_ &= ~0x00000004;
      orderId.clear();
      return this;
    }

    /**
     * <code>optional string OrderId = 1;</code>
     * @return the orderId
     */
    public String getOrderId() {
      return orderId.getString();
    }

    /**
     * <code>optional string OrderId = 1;</code>
     * @return internal {@code Utf8String} representation of orderId for reading
     */
    public Utf8String getOrderIdBytes() {
      return this.orderId;
    }

    /**
     * <code>optional string OrderId = 1;</code>
     * @return internal {@code Utf8String} representation of orderId for modifications
     */
    public Utf8String getMutableOrderIdBytes() {
      bitField0_ |= 0x00000004;
      return this.orderId;
    }

    /**
     * <code>optional string OrderId = 1;</code>
     * @param value the orderId to set
     * @return this
     */
    public OrderStateChange setOrderId(final CharSequence value) {
      bitField0_ |= 0x00000004;
      orderId.copyFrom(value);
      return this;
    }

    /**
     * <code>optional string OrderId = 1;</code>
     * @param value the orderId to set
     * @return this
     */
    public OrderStateChange setOrderId(final Utf8String value) {
      bitField0_ |= 0x00000004;
      orderId.copyFrom(value);
      return this;
    }

    @Override
    public OrderStateChange copyFrom(final OrderStateChange other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        store = other.store;
        nextPackage.copyFrom(other.nextPackage);
        orderId.copyFrom(other.orderId);
      }
      return this;
    }

    @Override
    public OrderStateChange mergeFrom(final OrderStateChange other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasStore()) {
        setStore(other.store);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      if (other.hasOrderId()) {
        getMutableOrderIdBytes().copyFrom(other.orderId);
      }
      return this;
    }

    @Override
    public OrderStateChange clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      store = 0;
      nextPackage.clear();
      orderId.clear();
      return this;
    }

    @Override
    public OrderStateChange clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      orderId.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof OrderStateChange)) {
        return false;
      }
      OrderStateChange other = (OrderStateChange) o;
      return bitField0_ == other.bitField0_
        && (!hasStore() || store == other.store)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage))
        && (!hasOrderId() || orderId.equals(other.orderId));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 16);
        output.writeUInt32NoTag(store);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawByte((byte) 10);
        output.writeStringNoTag(orderId);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(store);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 1 + ProtoSink.computeStringSizeNoTag(orderId);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public OrderStateChange mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 16: {
            // store
            store = input.readUInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 10) {
              break;
            }
          }
          case 10: {
            // orderId
            input.readString(orderId);
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeUInt32(FieldNames.store, store);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeString(FieldNames.orderId, orderId);
      }
      output.endObject();
    }

    @Override
    public OrderStateChange mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 80218305: {
            if (input.isAtField(FieldNames.store)) {
              if (!input.trySkipNullValue()) {
                store = input.readUInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 457542889: {
            if (input.isAtField(FieldNames.orderId)) {
              if (!input.trySkipNullValue()) {
                input.readString(orderId);
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public OrderStateChange clone() {
      return new OrderStateChange().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static OrderStateChange parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new OrderStateChange(), data).checkInitialized();
    }

    public static OrderStateChange parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new OrderStateChange(), input).checkInitialized();
    }

    public static OrderStateChange parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new OrderStateChange(), input).checkInitialized();
    }

    /**
     * @return factory for creating OrderStateChange messages
     */
    public static MessageFactory<OrderStateChange> getFactory() {
      return OrderStateChangeFactory.INSTANCE;
    }

    private enum OrderStateChangeFactory implements MessageFactory<OrderStateChange> {
      INSTANCE;

      @Override
      public OrderStateChange create() {
        return OrderStateChange.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName store = FieldName.forField("Store");

      static final FieldName nextPackage = FieldName.forField("NextPackage");

      static final FieldName orderId = FieldName.forField("OrderId");
    }
  }

  /**
   * Protobuf type {@code StarTowerBookPotentialChange}
   */
  public static final class StarTowerBookPotentialChange extends ProtoMessage<StarTowerBookPotentialChange> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    /**
     * <code>repeated uint32 CharIds = 2;</code>
     */
    private final RepeatedInt charIds = RepeatedInt.newEmptyInstance();

    /**
     * <code>repeated .StarTowerBookCharPotential CharPotentials = 1;</code>
     */
    private final RepeatedMessage<PublicStarTower.StarTowerBookCharPotential> charPotentials = RepeatedMessage.newEmptyInstance(PublicStarTower.StarTowerBookCharPotential.getFactory());

    private StarTowerBookPotentialChange() {
    }

    /**
     * @return a new empty instance of {@code StarTowerBookPotentialChange}
     */
    public static StarTowerBookPotentialChange newInstance() {
      return new StarTowerBookPotentialChange();
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public StarTowerBookPotentialChange clearNextPackage() {
      bitField0_ &= ~0x00000001;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000001;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public StarTowerBookPotentialChange addNextPackage(final byte value) {
      bitField0_ |= 0x00000001;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public StarTowerBookPotentialChange addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000001;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public StarTowerBookPotentialChange setNextPackage(final byte... values) {
      bitField0_ |= 0x00000001;
      nextPackage.copyFrom(values);
      return this;
    }

    /**
     * <code>repeated uint32 CharIds = 2;</code>
     * @return whether the charIds field is set
     */
    public boolean hasCharIds() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>repeated uint32 CharIds = 2;</code>
     * @return this
     */
    public StarTowerBookPotentialChange clearCharIds() {
      bitField0_ &= ~0x00000002;
      charIds.clear();
      return this;
    }

    /**
     * <code>repeated uint32 CharIds = 2;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableCharIds()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedInt getCharIds() {
      return charIds;
    }

    /**
     * <code>repeated uint32 CharIds = 2;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedInt getMutableCharIds() {
      bitField0_ |= 0x00000002;
      return charIds;
    }

    /**
     * <code>repeated uint32 CharIds = 2;</code>
     * @param value the charIds to add
     * @return this
     */
    public StarTowerBookPotentialChange addCharIds(final int value) {
      bitField0_ |= 0x00000002;
      charIds.add(value);
      return this;
    }

    /**
     * <code>repeated uint32 CharIds = 2;</code>
     * @param values the charIds to add
     * @return this
     */
    public StarTowerBookPotentialChange addAllCharIds(final int... values) {
      bitField0_ |= 0x00000002;
      charIds.addAll(values);
      return this;
    }

    /**
     * <code>repeated .StarTowerBookCharPotential CharPotentials = 1;</code>
     * @return whether the charPotentials field is set
     */
    public boolean hasCharPotentials() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>repeated .StarTowerBookCharPotential CharPotentials = 1;</code>
     * @return this
     */
    public StarTowerBookPotentialChange clearCharPotentials() {
      bitField0_ &= ~0x00000004;
      charPotentials.clear();
      return this;
    }

    /**
     * <code>repeated .StarTowerBookCharPotential CharPotentials = 1;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableCharPotentials()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<PublicStarTower.StarTowerBookCharPotential> getCharPotentials() {
      return charPotentials;
    }

    /**
     * <code>repeated .StarTowerBookCharPotential CharPotentials = 1;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<PublicStarTower.StarTowerBookCharPotential> getMutableCharPotentials() {
      bitField0_ |= 0x00000004;
      return charPotentials;
    }

    /**
     * <code>repeated .StarTowerBookCharPotential CharPotentials = 1;</code>
     * @param value the charPotentials to add
     * @return this
     */
    public StarTowerBookPotentialChange addCharPotentials(
        final PublicStarTower.StarTowerBookCharPotential value) {
      bitField0_ |= 0x00000004;
      charPotentials.add(value);
      return this;
    }

    /**
     * <code>repeated .StarTowerBookCharPotential CharPotentials = 1;</code>
     * @param values the charPotentials to add
     * @return this
     */
    public StarTowerBookPotentialChange addAllCharPotentials(
        final PublicStarTower.StarTowerBookCharPotential... values) {
      bitField0_ |= 0x00000004;
      charPotentials.addAll(values);
      return this;
    }

    @Override
    public StarTowerBookPotentialChange copyFrom(final StarTowerBookPotentialChange other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        nextPackage.copyFrom(other.nextPackage);
        charIds.copyFrom(other.charIds);
        charPotentials.copyFrom(other.charPotentials);
      }
      return this;
    }

    @Override
    public StarTowerBookPotentialChange mergeFrom(final StarTowerBookPotentialChange other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      if (other.hasCharIds()) {
        getMutableCharIds().addAll(other.charIds);
      }
      if (other.hasCharPotentials()) {
        getMutableCharPotentials().addAll(other.charPotentials);
      }
      return this;
    }

    @Override
    public StarTowerBookPotentialChange clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      charIds.clear();
      charPotentials.clear();
      return this;
    }

    @Override
    public StarTowerBookPotentialChange clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      charIds.clear();
      charPotentials.clearQuick();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof StarTowerBookPotentialChange)) {
        return false;
      }
      StarTowerBookPotentialChange other = (StarTowerBookPotentialChange) o;
      return bitField0_ == other.bitField0_
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage))
        && (!hasCharIds() || charIds.equals(other.charIds))
        && (!hasCharPotentials() || charPotentials.equals(other.charPotentials));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        for (int i = 0; i < charIds.length(); i++) {
          output.writeRawByte((byte) 16);
          output.writeUInt32NoTag(charIds.array()[i]);
        }
      }
      if ((bitField0_ & 0x00000004) != 0) {
        for (int i = 0; i < charPotentials.length(); i++) {
          output.writeRawByte((byte) 10);
          output.writeMessageNoTag(charPotentials.get(i));
        }
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += (1 * charIds.length()) + ProtoSink.computeRepeatedUInt32SizeNoTag(charIds);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += (1 * charPotentials.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(charPotentials);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public StarTowerBookPotentialChange mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 18) {
              break;
            }
          }
          case 18: {
            // charIds [packed=true]
            input.readPackedUInt32(charIds, tag);
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 10) {
              break;
            }
          }
          case 10: {
            // charPotentials
            tag = input.readRepeatedMessage(charPotentials, tag);
            bitField0_ |= 0x00000004;
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
          case 16: {
            // charIds [packed=false]
            tag = input.readRepeatedUInt32(charIds, tag);
            bitField0_ |= 0x00000002;
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRepeatedUInt32(FieldNames.charIds, charIds);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRepeatedMessage(FieldNames.charPotentials, charPotentials);
      }
      output.endObject();
    }

    @Override
    public StarTowerBookPotentialChange mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1891280030: {
            if (input.isAtField(FieldNames.charIds)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedUInt32(charIds);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1909208021: {
            if (input.isAtField(FieldNames.charPotentials)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedMessage(charPotentials);
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public StarTowerBookPotentialChange clone() {
      return new StarTowerBookPotentialChange().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static StarTowerBookPotentialChange parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new StarTowerBookPotentialChange(), data).checkInitialized();
    }

    public static StarTowerBookPotentialChange parseFrom(final ProtoSource input) throws
        IOException {
      return ProtoMessage.mergeFrom(new StarTowerBookPotentialChange(), input).checkInitialized();
    }

    public static StarTowerBookPotentialChange parseFrom(final JsonSource input) throws
        IOException {
      return ProtoMessage.mergeFrom(new StarTowerBookPotentialChange(), input).checkInitialized();
    }

    /**
     * @return factory for creating StarTowerBookPotentialChange messages
     */
    public static MessageFactory<StarTowerBookPotentialChange> getFactory() {
      return StarTowerBookPotentialChangeFactory.INSTANCE;
    }

    private enum StarTowerBookPotentialChangeFactory implements MessageFactory<StarTowerBookPotentialChange> {
      INSTANCE;

      @Override
      public StarTowerBookPotentialChange create() {
        return StarTowerBookPotentialChange.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName nextPackage = FieldName.forField("NextPackage");

      static final FieldName charIds = FieldName.forField("CharIds");

      static final FieldName charPotentials = FieldName.forField("CharPotentials");
    }
  }

  /**
   * Protobuf type {@code StarTowerBookEventChange}
   */
  public static final class StarTowerBookEventChange extends ProtoMessage<StarTowerBookEventChange> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    /**
     * <code>repeated uint32 EventIds = 1;</code>
     */
    private final RepeatedInt eventIds = RepeatedInt.newEmptyInstance();

    private StarTowerBookEventChange() {
    }

    /**
     * @return a new empty instance of {@code StarTowerBookEventChange}
     */
    public static StarTowerBookEventChange newInstance() {
      return new StarTowerBookEventChange();
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public StarTowerBookEventChange clearNextPackage() {
      bitField0_ &= ~0x00000001;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000001;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public StarTowerBookEventChange addNextPackage(final byte value) {
      bitField0_ |= 0x00000001;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public StarTowerBookEventChange addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000001;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public StarTowerBookEventChange setNextPackage(final byte... values) {
      bitField0_ |= 0x00000001;
      nextPackage.copyFrom(values);
      return this;
    }

    /**
     * <code>repeated uint32 EventIds = 1;</code>
     * @return whether the eventIds field is set
     */
    public boolean hasEventIds() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>repeated uint32 EventIds = 1;</code>
     * @return this
     */
    public StarTowerBookEventChange clearEventIds() {
      bitField0_ &= ~0x00000002;
      eventIds.clear();
      return this;
    }

    /**
     * <code>repeated uint32 EventIds = 1;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableEventIds()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedInt getEventIds() {
      return eventIds;
    }

    /**
     * <code>repeated uint32 EventIds = 1;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedInt getMutableEventIds() {
      bitField0_ |= 0x00000002;
      return eventIds;
    }

    /**
     * <code>repeated uint32 EventIds = 1;</code>
     * @param value the eventIds to add
     * @return this
     */
    public StarTowerBookEventChange addEventIds(final int value) {
      bitField0_ |= 0x00000002;
      eventIds.add(value);
      return this;
    }

    /**
     * <code>repeated uint32 EventIds = 1;</code>
     * @param values the eventIds to add
     * @return this
     */
    public StarTowerBookEventChange addAllEventIds(final int... values) {
      bitField0_ |= 0x00000002;
      eventIds.addAll(values);
      return this;
    }

    @Override
    public StarTowerBookEventChange copyFrom(final StarTowerBookEventChange other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        nextPackage.copyFrom(other.nextPackage);
        eventIds.copyFrom(other.eventIds);
      }
      return this;
    }

    @Override
    public StarTowerBookEventChange mergeFrom(final StarTowerBookEventChange other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      if (other.hasEventIds()) {
        getMutableEventIds().addAll(other.eventIds);
      }
      return this;
    }

    @Override
    public StarTowerBookEventChange clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      eventIds.clear();
      return this;
    }

    @Override
    public StarTowerBookEventChange clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      eventIds.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof StarTowerBookEventChange)) {
        return false;
      }
      StarTowerBookEventChange other = (StarTowerBookEventChange) o;
      return bitField0_ == other.bitField0_
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage))
        && (!hasEventIds() || eventIds.equals(other.eventIds));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        for (int i = 0; i < eventIds.length(); i++) {
          output.writeRawByte((byte) 8);
          output.writeUInt32NoTag(eventIds.array()[i]);
        }
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += (1 * eventIds.length()) + ProtoSink.computeRepeatedUInt32SizeNoTag(eventIds);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public StarTowerBookEventChange mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 10) {
              break;
            }
          }
          case 10: {
            // eventIds [packed=true]
            input.readPackedUInt32(eventIds, tag);
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
          case 8: {
            // eventIds [packed=false]
            tag = input.readRepeatedUInt32(eventIds, tag);
            bitField0_ |= 0x00000002;
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRepeatedUInt32(FieldNames.eventIds, eventIds);
      }
      output.endObject();
    }

    @Override
    public StarTowerBookEventChange mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 342741470: {
            if (input.isAtField(FieldNames.eventIds)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedUInt32(eventIds);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public StarTowerBookEventChange clone() {
      return new StarTowerBookEventChange().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static StarTowerBookEventChange parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new StarTowerBookEventChange(), data).checkInitialized();
    }

    public static StarTowerBookEventChange parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new StarTowerBookEventChange(), input).checkInitialized();
    }

    public static StarTowerBookEventChange parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new StarTowerBookEventChange(), input).checkInitialized();
    }

    /**
     * @return factory for creating StarTowerBookEventChange messages
     */
    public static MessageFactory<StarTowerBookEventChange> getFactory() {
      return StarTowerBookEventChangeFactory.INSTANCE;
    }

    private enum StarTowerBookEventChangeFactory implements MessageFactory<StarTowerBookEventChange> {
      INSTANCE;

      @Override
      public StarTowerBookEventChange create() {
        return StarTowerBookEventChange.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName nextPackage = FieldName.forField("NextPackage");

      static final FieldName eventIds = FieldName.forField("EventIds");
    }
  }

  /**
   * Protobuf type {@code Skin}
   */
  public static final class Skin extends ProtoMessage<Skin> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional .UI32 New = 1;</code>
     */
    private final Public.UI32 new_ = Public.UI32.newInstance();

    /**
     * <code>optional .Skin.Transform Duplicated = 2;</code>
     */
    private final Transform duplicated = Transform.newInstance();

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    private Skin() {
    }

    /**
     * @return a new empty instance of {@code Skin}
     */
    public static Skin newInstance() {
      return new Skin();
    }

    /**
     * <code>optional .UI32 New = 1;</code>
     * @return whether the new_ field is set
     */
    public boolean hasNew() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional .UI32 New = 1;</code>
     * @return this
     */
    public Skin clearNew() {
      bitField0_ &= ~0x00000001;
      new_.clear();
      return this;
    }

    /**
     * <code>optional .UI32 New = 1;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNew()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public Public.UI32 getNew() {
      return new_;
    }

    /**
     * <code>optional .UI32 New = 1;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public Public.UI32 getMutableNew() {
      bitField0_ |= 0x00000001;
      return new_;
    }

    /**
     * <code>optional .UI32 New = 1;</code>
     * @param value the new_ to set
     * @return this
     */
    public Skin setNew(final Public.UI32 value) {
      bitField0_ |= 0x00000001;
      new_.copyFrom(value);
      return this;
    }

    /**
     * <code>optional .Skin.Transform Duplicated = 2;</code>
     * @return whether the duplicated field is set
     */
    public boolean hasDuplicated() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional .Skin.Transform Duplicated = 2;</code>
     * @return this
     */
    public Skin clearDuplicated() {
      bitField0_ &= ~0x00000002;
      duplicated.clear();
      return this;
    }

    /**
     * <code>optional .Skin.Transform Duplicated = 2;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableDuplicated()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public Transform getDuplicated() {
      return duplicated;
    }

    /**
     * <code>optional .Skin.Transform Duplicated = 2;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public Transform getMutableDuplicated() {
      bitField0_ |= 0x00000002;
      return duplicated;
    }

    /**
     * <code>optional .Skin.Transform Duplicated = 2;</code>
     * @param value the duplicated to set
     * @return this
     */
    public Skin setDuplicated(final Transform value) {
      bitField0_ |= 0x00000002;
      duplicated.copyFrom(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public Skin clearNextPackage() {
      bitField0_ &= ~0x00000004;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000004;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public Skin addNextPackage(final byte value) {
      bitField0_ |= 0x00000004;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public Skin addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000004;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public Skin setNextPackage(final byte... values) {
      bitField0_ |= 0x00000004;
      nextPackage.copyFrom(values);
      return this;
    }

    @Override
    public Skin copyFrom(final Skin other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        new_.copyFrom(other.new_);
        duplicated.copyFrom(other.duplicated);
        nextPackage.copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public Skin mergeFrom(final Skin other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasNew()) {
        getMutableNew().mergeFrom(other.new_);
      }
      if (other.hasDuplicated()) {
        getMutableDuplicated().mergeFrom(other.duplicated);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public Skin clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      new_.clear();
      duplicated.clear();
      nextPackage.clear();
      return this;
    }

    @Override
    public Skin clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      new_.clearQuick();
      duplicated.clearQuick();
      nextPackage.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof Skin)) {
        return false;
      }
      Skin other = (Skin) o;
      return bitField0_ == other.bitField0_
        && (!hasNew() || new_.equals(other.new_))
        && (!hasDuplicated() || duplicated.equals(other.duplicated))
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 10);
        output.writeMessageNoTag(new_);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 18);
        output.writeMessageNoTag(duplicated);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeMessageSizeNoTag(new_);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeMessageSizeNoTag(duplicated);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public Skin mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 10: {
            // new_
            input.readMessage(new_);
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 18) {
              break;
            }
          }
          case 18: {
            // duplicated
            input.readMessage(duplicated);
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeMessage(FieldNames.new_, new_);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeMessage(FieldNames.duplicated, duplicated);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      output.endObject();
    }

    @Override
    public Skin mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 78208: {
            if (input.isAtField(FieldNames.new_)) {
              if (!input.trySkipNullValue()) {
                input.readMessage(new_);
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 591081689: {
            if (input.isAtField(FieldNames.duplicated)) {
              if (!input.trySkipNullValue()) {
                input.readMessage(duplicated);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public Skin clone() {
      return new Skin().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static Skin parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new Skin(), data).checkInitialized();
    }

    public static Skin parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new Skin(), input).checkInitialized();
    }

    public static Skin parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new Skin(), input).checkInitialized();
    }

    /**
     * @return factory for creating Skin messages
     */
    public static MessageFactory<Skin> getFactory() {
      return SkinFactory.INSTANCE;
    }

    /**
     * Protobuf type {@code Transform}
     */
    public static final class Transform extends ProtoMessage<Transform> implements Cloneable {
      private static final long serialVersionUID = 0L;

      /**
       * <code>optional uint32 ID = 1;</code>
       */
      private int iD;

      /**
       * <code>repeated .ItemTpl Items = 2;</code>
       */
      private final RepeatedMessage<Public.ItemTpl> items = RepeatedMessage.newEmptyInstance(Public.ItemTpl.getFactory());

      private Transform() {
      }

      /**
       * @return a new empty instance of {@code Transform}
       */
      public static Transform newInstance() {
        return new Transform();
      }

      /**
       * <code>optional uint32 ID = 1;</code>
       * @return whether the iD field is set
       */
      public boolean hasID() {
        return (bitField0_ & 0x00000001) != 0;
      }

      /**
       * <code>optional uint32 ID = 1;</code>
       * @return this
       */
      public Transform clearID() {
        bitField0_ &= ~0x00000001;
        iD = 0;
        return this;
      }

      /**
       * <code>optional uint32 ID = 1;</code>
       * @return the iD
       */
      public int getID() {
        return iD;
      }

      /**
       * <code>optional uint32 ID = 1;</code>
       * @param value the iD to set
       * @return this
       */
      public Transform setID(final int value) {
        bitField0_ |= 0x00000001;
        iD = value;
        return this;
      }

      /**
       * <code>repeated .ItemTpl Items = 2;</code>
       * @return whether the items field is set
       */
      public boolean hasItems() {
        return (bitField0_ & 0x00000002) != 0;
      }

      /**
       * <code>repeated .ItemTpl Items = 2;</code>
       * @return this
       */
      public Transform clearItems() {
        bitField0_ &= ~0x00000002;
        items.clear();
        return this;
      }

      /**
       * <code>repeated .ItemTpl Items = 2;</code>
       *
       * This method returns the internal storage object without modifying any has state.
       * The returned object should not be modified and be treated as read-only.
       *
       * Use {@link #getMutableItems()} if you want to modify it.
       *
       * @return internal storage object for reading
       */
      public RepeatedMessage<Public.ItemTpl> getItems() {
        return items;
      }

      /**
       * <code>repeated .ItemTpl Items = 2;</code>
       *
       * This method returns the internal storage object and sets the corresponding
       * has state. The returned object will become part of this message and its
       * contents may be modified as long as the has state is not cleared.
       *
       * @return internal storage object for modifications
       */
      public RepeatedMessage<Public.ItemTpl> getMutableItems() {
        bitField0_ |= 0x00000002;
        return items;
      }

      /**
       * <code>repeated .ItemTpl Items = 2;</code>
       * @param value the items to add
       * @return this
       */
      public Transform addItems(final Public.ItemTpl value) {
        bitField0_ |= 0x00000002;
        items.add(value);
        return this;
      }

      /**
       * <code>repeated .ItemTpl Items = 2;</code>
       * @param values the items to add
       * @return this
       */
      public Transform addAllItems(final Public.ItemTpl... values) {
        bitField0_ |= 0x00000002;
        items.addAll(values);
        return this;
      }

      @Override
      public Transform copyFrom(final Transform other) {
        cachedSize = other.cachedSize;
        if ((bitField0_ | other.bitField0_) != 0) {
          bitField0_ = other.bitField0_;
          iD = other.iD;
          items.copyFrom(other.items);
        }
        return this;
      }

      @Override
      public Transform mergeFrom(final Transform other) {
        if (other.isEmpty()) {
          return this;
        }
        cachedSize = -1;
        if (other.hasID()) {
          setID(other.iD);
        }
        if (other.hasItems()) {
          getMutableItems().addAll(other.items);
        }
        return this;
      }

      @Override
      public Transform clear() {
        if (isEmpty()) {
          return this;
        }
        cachedSize = -1;
        bitField0_ = 0;
        iD = 0;
        items.clear();
        return this;
      }

      @Override
      public Transform clearQuick() {
        if (isEmpty()) {
          return this;
        }
        cachedSize = -1;
        bitField0_ = 0;
        items.clearQuick();
        return this;
      }

      @Override
      public boolean equals(Object o) {
        if (o == this) {
          return true;
        }
        if (!(o instanceof Transform)) {
          return false;
        }
        Transform other = (Transform) o;
        return bitField0_ == other.bitField0_
          && (!hasID() || iD == other.iD)
          && (!hasItems() || items.equals(other.items));
      }

      @Override
      public void writeTo(final ProtoSink output) throws IOException {
        if ((bitField0_ & 0x00000001) != 0) {
          output.writeRawByte((byte) 8);
          output.writeUInt32NoTag(iD);
        }
        if ((bitField0_ & 0x00000002) != 0) {
          for (int i = 0; i < items.length(); i++) {
            output.writeRawByte((byte) 18);
            output.writeMessageNoTag(items.get(i));
          }
        }
      }

      @Override
      protected int computeSerializedSize() {
        int size = 0;
        if ((bitField0_ & 0x00000001) != 0) {
          size += 1 + ProtoSink.computeUInt32SizeNoTag(iD);
        }
        if ((bitField0_ & 0x00000002) != 0) {
          size += (1 * items.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(items);
        }
        return size;
      }

      @Override
      @SuppressWarnings("fallthrough")
      public Transform mergeFrom(final ProtoSource input) throws IOException {
        // Enabled Fall-Through Optimization (QuickBuffers)
        int tag = input.readTag();
        while (true) {
          switch (tag) {
            case 8: {
              // iD
              iD = input.readUInt32();
              bitField0_ |= 0x00000001;
              tag = input.readTag();
              if (tag != 18) {
                break;
              }
            }
            case 18: {
              // items
              tag = input.readRepeatedMessage(items, tag);
              bitField0_ |= 0x00000002;
              if (tag != 0) {
                break;
              }
            }
            case 0: {
              return this;
            }
            default: {
              if (!input.skipField(tag)) {
                return this;
              }
              tag = input.readTag();
              break;
            }
          }
        }
      }

      @Override
      public void writeTo(final JsonSink output) throws IOException {
        output.beginObject();
        if ((bitField0_ & 0x00000001) != 0) {
          output.writeUInt32(FieldNames.iD, iD);
        }
        if ((bitField0_ & 0x00000002) != 0) {
          output.writeRepeatedMessage(FieldNames.items, items);
        }
        output.endObject();
      }

      @Override
      public Transform mergeFrom(final JsonSource input) throws IOException {
        if (!input.beginObject()) {
          return this;
        }
        while (!input.isAtEnd()) {
          switch (input.readFieldHash()) {
            case 2331: {
              if (input.isAtField(FieldNames.iD)) {
                if (!input.trySkipNullValue()) {
                  iD = input.readUInt32();
                  bitField0_ |= 0x00000001;
                }
              } else {
                input.skipUnknownField();
              }
              break;
            }
            case 70973344: {
              if (input.isAtField(FieldNames.items)) {
                if (!input.trySkipNullValue()) {
                  input.readRepeatedMessage(items);
                  bitField0_ |= 0x00000002;
                }
              } else {
                input.skipUnknownField();
              }
              break;
            }
            default: {
              input.skipUnknownField();
              break;
            }
          }
        }
        input.endObject();
        return this;
      }

      @Override
      public Transform clone() {
        return new Transform().copyFrom(this);
      }

      @Override
      public boolean isEmpty() {
        return ((bitField0_) == 0);
      }

      public static Transform parseFrom(final byte[] data) throws InvalidProtocolBufferException {
        return ProtoMessage.mergeFrom(new Transform(), data).checkInitialized();
      }

      public static Transform parseFrom(final ProtoSource input) throws IOException {
        return ProtoMessage.mergeFrom(new Transform(), input).checkInitialized();
      }

      public static Transform parseFrom(final JsonSource input) throws IOException {
        return ProtoMessage.mergeFrom(new Transform(), input).checkInitialized();
      }

      /**
       * @return factory for creating Transform messages
       */
      public static MessageFactory<Transform> getFactory() {
        return TransformFactory.INSTANCE;
      }

      private enum TransformFactory implements MessageFactory<Transform> {
        INSTANCE;

        @Override
        public Transform create() {
          return Transform.newInstance();
        }
      }

      /**
       * Contains name constants used for serializing JSON
       */
      static class FieldNames {
        static final FieldName iD = FieldName.forField("ID");

        static final FieldName items = FieldName.forField("Items");
      }
    }

    private enum SkinFactory implements MessageFactory<Skin> {
      INSTANCE;

      @Override
      public Skin create() {
        return Skin.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName new_ = FieldName.forField("New");

      static final FieldName duplicated = FieldName.forField("Duplicated");

      static final FieldName nextPackage = FieldName.forField("NextPackage");
    }
  }

  /**
   * Protobuf type {@code SkinChange}
   */
  public static final class SkinChange extends ProtoMessage<SkinChange> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional uint32 CharId = 1;</code>
     */
    private int charId;

    /**
     * <code>optional uint32 SkinId = 2;</code>
     */
    private int skinId;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    private SkinChange() {
    }

    /**
     * @return a new empty instance of {@code SkinChange}
     */
    public static SkinChange newInstance() {
      return new SkinChange();
    }

    /**
     * <code>optional uint32 CharId = 1;</code>
     * @return whether the charId field is set
     */
    public boolean hasCharId() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional uint32 CharId = 1;</code>
     * @return this
     */
    public SkinChange clearCharId() {
      bitField0_ &= ~0x00000001;
      charId = 0;
      return this;
    }

    /**
     * <code>optional uint32 CharId = 1;</code>
     * @return the charId
     */
    public int getCharId() {
      return charId;
    }

    /**
     * <code>optional uint32 CharId = 1;</code>
     * @param value the charId to set
     * @return this
     */
    public SkinChange setCharId(final int value) {
      bitField0_ |= 0x00000001;
      charId = value;
      return this;
    }

    /**
     * <code>optional uint32 SkinId = 2;</code>
     * @return whether the skinId field is set
     */
    public boolean hasSkinId() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional uint32 SkinId = 2;</code>
     * @return this
     */
    public SkinChange clearSkinId() {
      bitField0_ &= ~0x00000002;
      skinId = 0;
      return this;
    }

    /**
     * <code>optional uint32 SkinId = 2;</code>
     * @return the skinId
     */
    public int getSkinId() {
      return skinId;
    }

    /**
     * <code>optional uint32 SkinId = 2;</code>
     * @param value the skinId to set
     * @return this
     */
    public SkinChange setSkinId(final int value) {
      bitField0_ |= 0x00000002;
      skinId = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public SkinChange clearNextPackage() {
      bitField0_ &= ~0x00000004;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000004;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public SkinChange addNextPackage(final byte value) {
      bitField0_ |= 0x00000004;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public SkinChange addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000004;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public SkinChange setNextPackage(final byte... values) {
      bitField0_ |= 0x00000004;
      nextPackage.copyFrom(values);
      return this;
    }

    @Override
    public SkinChange copyFrom(final SkinChange other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        charId = other.charId;
        skinId = other.skinId;
        nextPackage.copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public SkinChange mergeFrom(final SkinChange other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasCharId()) {
        setCharId(other.charId);
      }
      if (other.hasSkinId()) {
        setSkinId(other.skinId);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public SkinChange clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      charId = 0;
      skinId = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public SkinChange clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof SkinChange)) {
        return false;
      }
      SkinChange other = (SkinChange) o;
      return bitField0_ == other.bitField0_
        && (!hasCharId() || charId == other.charId)
        && (!hasSkinId() || skinId == other.skinId)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt32NoTag(charId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 16);
        output.writeUInt32NoTag(skinId);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(charId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(skinId);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public SkinChange mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            // charId
            charId = input.readUInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 16) {
              break;
            }
          }
          case 16: {
            // skinId
            skinId = input.readUInt32();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeUInt32(FieldNames.charId, charId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeUInt32(FieldNames.skinId, skinId);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      output.endObject();
    }

    @Override
    public SkinChange mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 2017200945: {
            if (input.isAtField(FieldNames.charId)) {
              if (!input.trySkipNullValue()) {
                charId = input.readUInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1816694888: {
            if (input.isAtField(FieldNames.skinId)) {
              if (!input.trySkipNullValue()) {
                skinId = input.readUInt32();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public SkinChange clone() {
      return new SkinChange().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static SkinChange parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new SkinChange(), data).checkInitialized();
    }

    public static SkinChange parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new SkinChange(), input).checkInitialized();
    }

    public static SkinChange parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new SkinChange(), input).checkInitialized();
    }

    /**
     * @return factory for creating SkinChange messages
     */
    public static MessageFactory<SkinChange> getFactory() {
      return SkinChangeFactory.INSTANCE;
    }

    private enum SkinChangeFactory implements MessageFactory<SkinChange> {
      INSTANCE;

      @Override
      public SkinChange create() {
        return SkinChange.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName charId = FieldName.forField("CharId");

      static final FieldName skinId = FieldName.forField("SkinId");

      static final FieldName nextPackage = FieldName.forField("NextPackage");
    }
  }

  /**
   * Protobuf type {@code MonthlyCardRewards}
   */
  public static final class MonthlyCardRewards extends ProtoMessage<MonthlyCardRewards> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional int64 EndTime = 3;</code>
     */
    private long endTime;

    /**
     * <code>optional uint32 Id = 1;</code>
     */
    private int id;

    /**
     * <code>optional uint32 Remaining = 5;</code>
     */
    private int remaining;

    /**
     * <code>optional bool Switch = 6;</code>
     */
    private boolean switch_;

    /**
     * <code>optional .ChangeInfo Change = 2;</code>
     */
    private final Public.ChangeInfo change = Public.ChangeInfo.newInstance();

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    /**
     * <code>repeated .ItemTpl Rewards = 4;</code>
     */
    private final RepeatedMessage<Public.ItemTpl> rewards = RepeatedMessage.newEmptyInstance(Public.ItemTpl.getFactory());

    private MonthlyCardRewards() {
    }

    /**
     * @return a new empty instance of {@code MonthlyCardRewards}
     */
    public static MonthlyCardRewards newInstance() {
      return new MonthlyCardRewards();
    }

    /**
     * <code>optional int64 EndTime = 3;</code>
     * @return whether the endTime field is set
     */
    public boolean hasEndTime() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional int64 EndTime = 3;</code>
     * @return this
     */
    public MonthlyCardRewards clearEndTime() {
      bitField0_ &= ~0x00000001;
      endTime = 0L;
      return this;
    }

    /**
     * <code>optional int64 EndTime = 3;</code>
     * @return the endTime
     */
    public long getEndTime() {
      return endTime;
    }

    /**
     * <code>optional int64 EndTime = 3;</code>
     * @param value the endTime to set
     * @return this
     */
    public MonthlyCardRewards setEndTime(final long value) {
      bitField0_ |= 0x00000001;
      endTime = value;
      return this;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @return whether the id field is set
     */
    public boolean hasId() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @return this
     */
    public MonthlyCardRewards clearId() {
      bitField0_ &= ~0x00000002;
      id = 0;
      return this;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @return the id
     */
    public int getId() {
      return id;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @param value the id to set
     * @return this
     */
    public MonthlyCardRewards setId(final int value) {
      bitField0_ |= 0x00000002;
      id = value;
      return this;
    }

    /**
     * <code>optional uint32 Remaining = 5;</code>
     * @return whether the remaining field is set
     */
    public boolean hasRemaining() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional uint32 Remaining = 5;</code>
     * @return this
     */
    public MonthlyCardRewards clearRemaining() {
      bitField0_ &= ~0x00000004;
      remaining = 0;
      return this;
    }

    /**
     * <code>optional uint32 Remaining = 5;</code>
     * @return the remaining
     */
    public int getRemaining() {
      return remaining;
    }

    /**
     * <code>optional uint32 Remaining = 5;</code>
     * @param value the remaining to set
     * @return this
     */
    public MonthlyCardRewards setRemaining(final int value) {
      bitField0_ |= 0x00000004;
      remaining = value;
      return this;
    }

    /**
     * <code>optional bool Switch = 6;</code>
     * @return whether the switch_ field is set
     */
    public boolean hasSwitch() {
      return (bitField0_ & 0x00000008) != 0;
    }

    /**
     * <code>optional bool Switch = 6;</code>
     * @return this
     */
    public MonthlyCardRewards clearSwitch() {
      bitField0_ &= ~0x00000008;
      switch_ = false;
      return this;
    }

    /**
     * <code>optional bool Switch = 6;</code>
     * @return the switch_
     */
    public boolean getSwitch() {
      return switch_;
    }

    /**
     * <code>optional bool Switch = 6;</code>
     * @param value the switch_ to set
     * @return this
     */
    public MonthlyCardRewards setSwitch(final boolean value) {
      bitField0_ |= 0x00000008;
      switch_ = value;
      return this;
    }

    /**
     * <code>optional .ChangeInfo Change = 2;</code>
     * @return whether the change field is set
     */
    public boolean hasChange() {
      return (bitField0_ & 0x00000010) != 0;
    }

    /**
     * <code>optional .ChangeInfo Change = 2;</code>
     * @return this
     */
    public MonthlyCardRewards clearChange() {
      bitField0_ &= ~0x00000010;
      change.clear();
      return this;
    }

    /**
     * <code>optional .ChangeInfo Change = 2;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableChange()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public Public.ChangeInfo getChange() {
      return change;
    }

    /**
     * <code>optional .ChangeInfo Change = 2;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public Public.ChangeInfo getMutableChange() {
      bitField0_ |= 0x00000010;
      return change;
    }

    /**
     * <code>optional .ChangeInfo Change = 2;</code>
     * @param value the change to set
     * @return this
     */
    public MonthlyCardRewards setChange(final Public.ChangeInfo value) {
      bitField0_ |= 0x00000010;
      change.copyFrom(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000020) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public MonthlyCardRewards clearNextPackage() {
      bitField0_ &= ~0x00000020;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000020;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public MonthlyCardRewards addNextPackage(final byte value) {
      bitField0_ |= 0x00000020;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public MonthlyCardRewards addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000020;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public MonthlyCardRewards setNextPackage(final byte... values) {
      bitField0_ |= 0x00000020;
      nextPackage.copyFrom(values);
      return this;
    }

    /**
     * <code>repeated .ItemTpl Rewards = 4;</code>
     * @return whether the rewards field is set
     */
    public boolean hasRewards() {
      return (bitField0_ & 0x00000040) != 0;
    }

    /**
     * <code>repeated .ItemTpl Rewards = 4;</code>
     * @return this
     */
    public MonthlyCardRewards clearRewards() {
      bitField0_ &= ~0x00000040;
      rewards.clear();
      return this;
    }

    /**
     * <code>repeated .ItemTpl Rewards = 4;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableRewards()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<Public.ItemTpl> getRewards() {
      return rewards;
    }

    /**
     * <code>repeated .ItemTpl Rewards = 4;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<Public.ItemTpl> getMutableRewards() {
      bitField0_ |= 0x00000040;
      return rewards;
    }

    /**
     * <code>repeated .ItemTpl Rewards = 4;</code>
     * @param value the rewards to add
     * @return this
     */
    public MonthlyCardRewards addRewards(final Public.ItemTpl value) {
      bitField0_ |= 0x00000040;
      rewards.add(value);
      return this;
    }

    /**
     * <code>repeated .ItemTpl Rewards = 4;</code>
     * @param values the rewards to add
     * @return this
     */
    public MonthlyCardRewards addAllRewards(final Public.ItemTpl... values) {
      bitField0_ |= 0x00000040;
      rewards.addAll(values);
      return this;
    }

    @Override
    public MonthlyCardRewards copyFrom(final MonthlyCardRewards other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        endTime = other.endTime;
        id = other.id;
        remaining = other.remaining;
        switch_ = other.switch_;
        change.copyFrom(other.change);
        nextPackage.copyFrom(other.nextPackage);
        rewards.copyFrom(other.rewards);
      }
      return this;
    }

    @Override
    public MonthlyCardRewards mergeFrom(final MonthlyCardRewards other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasEndTime()) {
        setEndTime(other.endTime);
      }
      if (other.hasId()) {
        setId(other.id);
      }
      if (other.hasRemaining()) {
        setRemaining(other.remaining);
      }
      if (other.hasSwitch()) {
        setSwitch(other.switch_);
      }
      if (other.hasChange()) {
        getMutableChange().mergeFrom(other.change);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      if (other.hasRewards()) {
        getMutableRewards().addAll(other.rewards);
      }
      return this;
    }

    @Override
    public MonthlyCardRewards clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      endTime = 0L;
      id = 0;
      remaining = 0;
      switch_ = false;
      change.clear();
      nextPackage.clear();
      rewards.clear();
      return this;
    }

    @Override
    public MonthlyCardRewards clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      change.clearQuick();
      nextPackage.clear();
      rewards.clearQuick();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof MonthlyCardRewards)) {
        return false;
      }
      MonthlyCardRewards other = (MonthlyCardRewards) o;
      return bitField0_ == other.bitField0_
        && (!hasEndTime() || endTime == other.endTime)
        && (!hasId() || id == other.id)
        && (!hasRemaining() || remaining == other.remaining)
        && (!hasSwitch() || switch_ == other.switch_)
        && (!hasChange() || change.equals(other.change))
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage))
        && (!hasRewards() || rewards.equals(other.rewards));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 24);
        output.writeInt64NoTag(endTime);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt32NoTag(id);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawByte((byte) 40);
        output.writeUInt32NoTag(remaining);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeRawByte((byte) 48);
        output.writeBoolNoTag(switch_);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        output.writeRawByte((byte) 18);
        output.writeMessageNoTag(change);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000040) != 0) {
        for (int i = 0; i < rewards.length(); i++) {
          output.writeRawByte((byte) 34);
          output.writeMessageNoTag(rewards.get(i));
        }
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeInt64SizeNoTag(endTime);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(id);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(remaining);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        size += 2;
      }
      if ((bitField0_ & 0x00000010) != 0) {
        size += 1 + ProtoSink.computeMessageSizeNoTag(change);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000040) != 0) {
        size += (1 * rewards.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(rewards);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public MonthlyCardRewards mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 24: {
            // endTime
            endTime = input.readInt64();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 8) {
              break;
            }
          }
          case 8: {
            // id
            id = input.readUInt32();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 40) {
              break;
            }
          }
          case 40: {
            // remaining
            remaining = input.readUInt32();
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 48) {
              break;
            }
          }
          case 48: {
            // switch_
            switch_ = input.readBool();
            bitField0_ |= 0x00000008;
            tag = input.readTag();
            if (tag != 18) {
              break;
            }
          }
          case 18: {
            // change
            input.readMessage(change);
            bitField0_ |= 0x00000010;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000020;
            tag = input.readTag();
            if (tag != 34) {
              break;
            }
          }
          case 34: {
            // rewards
            tag = input.readRepeatedMessage(rewards, tag);
            bitField0_ |= 0x00000040;
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeInt64(FieldNames.endTime, endTime);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeUInt32(FieldNames.id, id);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeUInt32(FieldNames.remaining, remaining);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeBool(FieldNames.switch_, switch_);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        output.writeMessage(FieldNames.change, change);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      if ((bitField0_ & 0x00000040) != 0) {
        output.writeRepeatedMessage(FieldNames.rewards, rewards);
      }
      output.endObject();
    }

    @Override
    public MonthlyCardRewards mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 57410088: {
            if (input.isAtField(FieldNames.endTime)) {
              if (!input.trySkipNullValue()) {
                endTime = input.readInt64();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 2363: {
            if (input.isAtField(FieldNames.id)) {
              if (!input.trySkipNullValue()) {
                id = input.readUInt32();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1421161002: {
            if (input.isAtField(FieldNames.remaining)) {
              if (!input.trySkipNullValue()) {
                remaining = input.readUInt32();
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1805606060: {
            if (input.isAtField(FieldNames.switch_)) {
              if (!input.trySkipNullValue()) {
                switch_ = input.readBool();
                bitField0_ |= 0x00000008;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 2017198032: {
            if (input.isAtField(FieldNames.change)) {
              if (!input.trySkipNullValue()) {
                input.readMessage(change);
                bitField0_ |= 0x00000010;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000020;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1529663740: {
            if (input.isAtField(FieldNames.rewards)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedMessage(rewards);
                bitField0_ |= 0x00000040;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public MonthlyCardRewards clone() {
      return new MonthlyCardRewards().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static MonthlyCardRewards parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new MonthlyCardRewards(), data).checkInitialized();
    }

    public static MonthlyCardRewards parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new MonthlyCardRewards(), input).checkInitialized();
    }

    public static MonthlyCardRewards parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new MonthlyCardRewards(), input).checkInitialized();
    }

    /**
     * @return factory for creating MonthlyCardRewards messages
     */
    public static MessageFactory<MonthlyCardRewards> getFactory() {
      return MonthlyCardRewardsFactory.INSTANCE;
    }

    private enum MonthlyCardRewardsFactory implements MessageFactory<MonthlyCardRewards> {
      INSTANCE;

      @Override
      public MonthlyCardRewards create() {
        return MonthlyCardRewards.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName endTime = FieldName.forField("EndTime");

      static final FieldName id = FieldName.forField("Id");

      static final FieldName remaining = FieldName.forField("Remaining");

      static final FieldName switch_ = FieldName.forField("Switch");

      static final FieldName change = FieldName.forField("Change");

      static final FieldName nextPackage = FieldName.forField("NextPackage");

      static final FieldName rewards = FieldName.forField("Rewards");
    }
  }

  /**
   * Protobuf type {@code TowerBookFateCardCollectNotify}
   */
  public static final class TowerBookFateCardCollectNotify extends ProtoMessage<TowerBookFateCardCollectNotify> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    /**
     * <code>repeated uint32 Cards = 1;</code>
     */
    private final RepeatedInt cards = RepeatedInt.newEmptyInstance();

    private TowerBookFateCardCollectNotify() {
    }

    /**
     * @return a new empty instance of {@code TowerBookFateCardCollectNotify}
     */
    public static TowerBookFateCardCollectNotify newInstance() {
      return new TowerBookFateCardCollectNotify();
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public TowerBookFateCardCollectNotify clearNextPackage() {
      bitField0_ &= ~0x00000001;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000001;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public TowerBookFateCardCollectNotify addNextPackage(final byte value) {
      bitField0_ |= 0x00000001;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public TowerBookFateCardCollectNotify addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000001;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public TowerBookFateCardCollectNotify setNextPackage(final byte... values) {
      bitField0_ |= 0x00000001;
      nextPackage.copyFrom(values);
      return this;
    }

    /**
     * <code>repeated uint32 Cards = 1;</code>
     * @return whether the cards field is set
     */
    public boolean hasCards() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>repeated uint32 Cards = 1;</code>
     * @return this
     */
    public TowerBookFateCardCollectNotify clearCards() {
      bitField0_ &= ~0x00000002;
      cards.clear();
      return this;
    }

    /**
     * <code>repeated uint32 Cards = 1;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableCards()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedInt getCards() {
      return cards;
    }

    /**
     * <code>repeated uint32 Cards = 1;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedInt getMutableCards() {
      bitField0_ |= 0x00000002;
      return cards;
    }

    /**
     * <code>repeated uint32 Cards = 1;</code>
     * @param value the cards to add
     * @return this
     */
    public TowerBookFateCardCollectNotify addCards(final int value) {
      bitField0_ |= 0x00000002;
      cards.add(value);
      return this;
    }

    /**
     * <code>repeated uint32 Cards = 1;</code>
     * @param values the cards to add
     * @return this
     */
    public TowerBookFateCardCollectNotify addAllCards(final int... values) {
      bitField0_ |= 0x00000002;
      cards.addAll(values);
      return this;
    }

    @Override
    public TowerBookFateCardCollectNotify copyFrom(final TowerBookFateCardCollectNotify other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        nextPackage.copyFrom(other.nextPackage);
        cards.copyFrom(other.cards);
      }
      return this;
    }

    @Override
    public TowerBookFateCardCollectNotify mergeFrom(final TowerBookFateCardCollectNotify other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      if (other.hasCards()) {
        getMutableCards().addAll(other.cards);
      }
      return this;
    }

    @Override
    public TowerBookFateCardCollectNotify clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      cards.clear();
      return this;
    }

    @Override
    public TowerBookFateCardCollectNotify clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      cards.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof TowerBookFateCardCollectNotify)) {
        return false;
      }
      TowerBookFateCardCollectNotify other = (TowerBookFateCardCollectNotify) o;
      return bitField0_ == other.bitField0_
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage))
        && (!hasCards() || cards.equals(other.cards));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        for (int i = 0; i < cards.length(); i++) {
          output.writeRawByte((byte) 8);
          output.writeUInt32NoTag(cards.array()[i]);
        }
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += (1 * cards.length()) + ProtoSink.computeRepeatedUInt32SizeNoTag(cards);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public TowerBookFateCardCollectNotify mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 10) {
              break;
            }
          }
          case 10: {
            // cards [packed=true]
            input.readPackedUInt32(cards, tag);
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
          case 8: {
            // cards [packed=false]
            tag = input.readRepeatedUInt32(cards, tag);
            bitField0_ |= 0x00000002;
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRepeatedUInt32(FieldNames.cards, cards);
      }
      output.endObject();
    }

    @Override
    public TowerBookFateCardCollectNotify mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 64878403: {
            if (input.isAtField(FieldNames.cards)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedUInt32(cards);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public TowerBookFateCardCollectNotify clone() {
      return new TowerBookFateCardCollectNotify().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static TowerBookFateCardCollectNotify parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new TowerBookFateCardCollectNotify(), data).checkInitialized();
    }

    public static TowerBookFateCardCollectNotify parseFrom(final ProtoSource input) throws
        IOException {
      return ProtoMessage.mergeFrom(new TowerBookFateCardCollectNotify(), input).checkInitialized();
    }

    public static TowerBookFateCardCollectNotify parseFrom(final JsonSource input) throws
        IOException {
      return ProtoMessage.mergeFrom(new TowerBookFateCardCollectNotify(), input).checkInitialized();
    }

    /**
     * @return factory for creating TowerBookFateCardCollectNotify messages
     */
    public static MessageFactory<TowerBookFateCardCollectNotify> getFactory() {
      return TowerBookFateCardCollectNotifyFactory.INSTANCE;
    }

    private enum TowerBookFateCardCollectNotifyFactory implements MessageFactory<TowerBookFateCardCollectNotify> {
      INSTANCE;

      @Override
      public TowerBookFateCardCollectNotify create() {
        return TowerBookFateCardCollectNotify.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName nextPackage = FieldName.forField("NextPackage");

      static final FieldName cards = FieldName.forField("Cards");
    }
  }

  /**
   * Protobuf type {@code TowerBookFateCardRewardChangeNotify}
   */
  public static final class TowerBookFateCardRewardChangeNotify extends ProtoMessage<TowerBookFateCardRewardChangeNotify> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional bool Option = 2;</code>
     */
    private boolean option;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    /**
     * <code>repeated uint32 List = 1;</code>
     */
    private final RepeatedInt list = RepeatedInt.newEmptyInstance();

    private TowerBookFateCardRewardChangeNotify() {
    }

    /**
     * @return a new empty instance of {@code TowerBookFateCardRewardChangeNotify}
     */
    public static TowerBookFateCardRewardChangeNotify newInstance() {
      return new TowerBookFateCardRewardChangeNotify();
    }

    /**
     * <code>optional bool Option = 2;</code>
     * @return whether the option field is set
     */
    public boolean hasOption() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional bool Option = 2;</code>
     * @return this
     */
    public TowerBookFateCardRewardChangeNotify clearOption() {
      bitField0_ &= ~0x00000001;
      option = false;
      return this;
    }

    /**
     * <code>optional bool Option = 2;</code>
     * @return the option
     */
    public boolean getOption() {
      return option;
    }

    /**
     * <code>optional bool Option = 2;</code>
     * @param value the option to set
     * @return this
     */
    public TowerBookFateCardRewardChangeNotify setOption(final boolean value) {
      bitField0_ |= 0x00000001;
      option = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public TowerBookFateCardRewardChangeNotify clearNextPackage() {
      bitField0_ &= ~0x00000002;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000002;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public TowerBookFateCardRewardChangeNotify addNextPackage(final byte value) {
      bitField0_ |= 0x00000002;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public TowerBookFateCardRewardChangeNotify addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000002;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public TowerBookFateCardRewardChangeNotify setNextPackage(final byte... values) {
      bitField0_ |= 0x00000002;
      nextPackage.copyFrom(values);
      return this;
    }

    /**
     * <code>repeated uint32 List = 1;</code>
     * @return whether the list field is set
     */
    public boolean hasList() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>repeated uint32 List = 1;</code>
     * @return this
     */
    public TowerBookFateCardRewardChangeNotify clearList() {
      bitField0_ &= ~0x00000004;
      list.clear();
      return this;
    }

    /**
     * <code>repeated uint32 List = 1;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableList()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedInt getList() {
      return list;
    }

    /**
     * <code>repeated uint32 List = 1;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedInt getMutableList() {
      bitField0_ |= 0x00000004;
      return list;
    }

    /**
     * <code>repeated uint32 List = 1;</code>
     * @param value the list to add
     * @return this
     */
    public TowerBookFateCardRewardChangeNotify addList(final int value) {
      bitField0_ |= 0x00000004;
      list.add(value);
      return this;
    }

    /**
     * <code>repeated uint32 List = 1;</code>
     * @param values the list to add
     * @return this
     */
    public TowerBookFateCardRewardChangeNotify addAllList(final int... values) {
      bitField0_ |= 0x00000004;
      list.addAll(values);
      return this;
    }

    @Override
    public TowerBookFateCardRewardChangeNotify copyFrom(
        final TowerBookFateCardRewardChangeNotify other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        option = other.option;
        nextPackage.copyFrom(other.nextPackage);
        list.copyFrom(other.list);
      }
      return this;
    }

    @Override
    public TowerBookFateCardRewardChangeNotify mergeFrom(
        final TowerBookFateCardRewardChangeNotify other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasOption()) {
        setOption(other.option);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      if (other.hasList()) {
        getMutableList().addAll(other.list);
      }
      return this;
    }

    @Override
    public TowerBookFateCardRewardChangeNotify clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      option = false;
      nextPackage.clear();
      list.clear();
      return this;
    }

    @Override
    public TowerBookFateCardRewardChangeNotify clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      list.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof TowerBookFateCardRewardChangeNotify)) {
        return false;
      }
      TowerBookFateCardRewardChangeNotify other = (TowerBookFateCardRewardChangeNotify) o;
      return bitField0_ == other.bitField0_
        && (!hasOption() || option == other.option)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage))
        && (!hasList() || list.equals(other.list));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 16);
        output.writeBoolNoTag(option);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        for (int i = 0; i < list.length(); i++) {
          output.writeRawByte((byte) 8);
          output.writeUInt32NoTag(list.array()[i]);
        }
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 2;
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += (1 * list.length()) + ProtoSink.computeRepeatedUInt32SizeNoTag(list);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public TowerBookFateCardRewardChangeNotify mergeFrom(final ProtoSource input) throws
        IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 16: {
            // option
            option = input.readBool();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 10) {
              break;
            }
          }
          case 10: {
            // list [packed=true]
            input.readPackedUInt32(list, tag);
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
          case 8: {
            // list [packed=false]
            tag = input.readRepeatedUInt32(list, tag);
            bitField0_ |= 0x00000004;
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeBool(FieldNames.option, option);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRepeatedUInt32(FieldNames.list, list);
      }
      output.endObject();
    }

    @Override
    public TowerBookFateCardRewardChangeNotify mergeFrom(final JsonSource input) throws
        IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case -1926269803: {
            if (input.isAtField(FieldNames.option)) {
              if (!input.trySkipNullValue()) {
                option = input.readBool();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 2368702: {
            if (input.isAtField(FieldNames.list)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedUInt32(list);
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public TowerBookFateCardRewardChangeNotify clone() {
      return new TowerBookFateCardRewardChangeNotify().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static TowerBookFateCardRewardChangeNotify parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new TowerBookFateCardRewardChangeNotify(), data).checkInitialized();
    }

    public static TowerBookFateCardRewardChangeNotify parseFrom(final ProtoSource input) throws
        IOException {
      return ProtoMessage.mergeFrom(new TowerBookFateCardRewardChangeNotify(), input).checkInitialized();
    }

    public static TowerBookFateCardRewardChangeNotify parseFrom(final JsonSource input) throws
        IOException {
      return ProtoMessage.mergeFrom(new TowerBookFateCardRewardChangeNotify(), input).checkInitialized();
    }

    /**
     * @return factory for creating TowerBookFateCardRewardChangeNotify messages
     */
    public static MessageFactory<TowerBookFateCardRewardChangeNotify> getFactory() {
      return TowerBookFateCardRewardChangeNotifyFactory.INSTANCE;
    }

    private enum TowerBookFateCardRewardChangeNotifyFactory implements MessageFactory<TowerBookFateCardRewardChangeNotify> {
      INSTANCE;

      @Override
      public TowerBookFateCardRewardChangeNotify create() {
        return TowerBookFateCardRewardChangeNotify.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName option = FieldName.forField("Option");

      static final FieldName nextPackage = FieldName.forField("NextPackage");

      static final FieldName list = FieldName.forField("List");
    }
  }

  /**
   * Protobuf type {@code HonorChangeNotify}
   */
  public static final class HonorChangeNotify extends ProtoMessage<HonorChangeNotify> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    /**
     * <code>repeated .HonorInfo Honors = 1;</code>
     */
    private final RepeatedMessage<Public.HonorInfo> honors = RepeatedMessage.newEmptyInstance(Public.HonorInfo.getFactory());

    private HonorChangeNotify() {
    }

    /**
     * @return a new empty instance of {@code HonorChangeNotify}
     */
    public static HonorChangeNotify newInstance() {
      return new HonorChangeNotify();
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public HonorChangeNotify clearNextPackage() {
      bitField0_ &= ~0x00000001;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000001;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public HonorChangeNotify addNextPackage(final byte value) {
      bitField0_ |= 0x00000001;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public HonorChangeNotify addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000001;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public HonorChangeNotify setNextPackage(final byte... values) {
      bitField0_ |= 0x00000001;
      nextPackage.copyFrom(values);
      return this;
    }

    /**
     * <code>repeated .HonorInfo Honors = 1;</code>
     * @return whether the honors field is set
     */
    public boolean hasHonors() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>repeated .HonorInfo Honors = 1;</code>
     * @return this
     */
    public HonorChangeNotify clearHonors() {
      bitField0_ &= ~0x00000002;
      honors.clear();
      return this;
    }

    /**
     * <code>repeated .HonorInfo Honors = 1;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableHonors()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<Public.HonorInfo> getHonors() {
      return honors;
    }

    /**
     * <code>repeated .HonorInfo Honors = 1;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<Public.HonorInfo> getMutableHonors() {
      bitField0_ |= 0x00000002;
      return honors;
    }

    /**
     * <code>repeated .HonorInfo Honors = 1;</code>
     * @param value the honors to add
     * @return this
     */
    public HonorChangeNotify addHonors(final Public.HonorInfo value) {
      bitField0_ |= 0x00000002;
      honors.add(value);
      return this;
    }

    /**
     * <code>repeated .HonorInfo Honors = 1;</code>
     * @param values the honors to add
     * @return this
     */
    public HonorChangeNotify addAllHonors(final Public.HonorInfo... values) {
      bitField0_ |= 0x00000002;
      honors.addAll(values);
      return this;
    }

    @Override
    public HonorChangeNotify copyFrom(final HonorChangeNotify other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        nextPackage.copyFrom(other.nextPackage);
        honors.copyFrom(other.honors);
      }
      return this;
    }

    @Override
    public HonorChangeNotify mergeFrom(final HonorChangeNotify other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      if (other.hasHonors()) {
        getMutableHonors().addAll(other.honors);
      }
      return this;
    }

    @Override
    public HonorChangeNotify clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      honors.clear();
      return this;
    }

    @Override
    public HonorChangeNotify clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      honors.clearQuick();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof HonorChangeNotify)) {
        return false;
      }
      HonorChangeNotify other = (HonorChangeNotify) o;
      return bitField0_ == other.bitField0_
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage))
        && (!hasHonors() || honors.equals(other.honors));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        for (int i = 0; i < honors.length(); i++) {
          output.writeRawByte((byte) 10);
          output.writeMessageNoTag(honors.get(i));
        }
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += (1 * honors.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(honors);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public HonorChangeNotify mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 10) {
              break;
            }
          }
          case 10: {
            // honors
            tag = input.readRepeatedMessage(honors, tag);
            bitField0_ |= 0x00000002;
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRepeatedMessage(FieldNames.honors, honors);
      }
      output.endObject();
    }

    @Override
    public HonorChangeNotify mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2127770263: {
            if (input.isAtField(FieldNames.honors)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedMessage(honors);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public HonorChangeNotify clone() {
      return new HonorChangeNotify().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static HonorChangeNotify parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new HonorChangeNotify(), data).checkInitialized();
    }

    public static HonorChangeNotify parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new HonorChangeNotify(), input).checkInitialized();
    }

    public static HonorChangeNotify parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new HonorChangeNotify(), input).checkInitialized();
    }

    /**
     * @return factory for creating HonorChangeNotify messages
     */
    public static MessageFactory<HonorChangeNotify> getFactory() {
      return HonorChangeNotifyFactory.INSTANCE;
    }

    private enum HonorChangeNotifyFactory implements MessageFactory<HonorChangeNotify> {
      INSTANCE;

      @Override
      public HonorChangeNotify create() {
        return HonorChangeNotify.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName nextPackage = FieldName.forField("NextPackage");

      static final FieldName honors = FieldName.forField("Honors");
    }
  }

  /**
   * Protobuf type {@code NoticeChangeNotify}
   */
  public static final class NoticeChangeNotify extends ProtoMessage<NoticeChangeNotify> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional int64 StartTime = 3;</code>
     */
    private long startTime;

    /**
     * <code>optional int64 EndTime = 4;</code>
     */
    private long endTime;

    /**
     * <code>optional int32 Interval = 5;</code>
     */
    private int interval;

    /**
     * <code>optional int32 Duration = 6;</code>
     */
    private int duration;

    /**
     * <code>optional bool IsStop = 7;</code>
     */
    private boolean isStop;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    /**
     * <code>optional string Content = 1;</code>
     */
    private final Utf8String content = Utf8String.newEmptyInstance();

    /**
     * <code>repeated int32 Channel = 2;</code>
     */
    private final RepeatedInt channel = RepeatedInt.newEmptyInstance();

    private NoticeChangeNotify() {
    }

    /**
     * @return a new empty instance of {@code NoticeChangeNotify}
     */
    public static NoticeChangeNotify newInstance() {
      return new NoticeChangeNotify();
    }

    /**
     * <code>optional int64 StartTime = 3;</code>
     * @return whether the startTime field is set
     */
    public boolean hasStartTime() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional int64 StartTime = 3;</code>
     * @return this
     */
    public NoticeChangeNotify clearStartTime() {
      bitField0_ &= ~0x00000001;
      startTime = 0L;
      return this;
    }

    /**
     * <code>optional int64 StartTime = 3;</code>
     * @return the startTime
     */
    public long getStartTime() {
      return startTime;
    }

    /**
     * <code>optional int64 StartTime = 3;</code>
     * @param value the startTime to set
     * @return this
     */
    public NoticeChangeNotify setStartTime(final long value) {
      bitField0_ |= 0x00000001;
      startTime = value;
      return this;
    }

    /**
     * <code>optional int64 EndTime = 4;</code>
     * @return whether the endTime field is set
     */
    public boolean hasEndTime() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional int64 EndTime = 4;</code>
     * @return this
     */
    public NoticeChangeNotify clearEndTime() {
      bitField0_ &= ~0x00000002;
      endTime = 0L;
      return this;
    }

    /**
     * <code>optional int64 EndTime = 4;</code>
     * @return the endTime
     */
    public long getEndTime() {
      return endTime;
    }

    /**
     * <code>optional int64 EndTime = 4;</code>
     * @param value the endTime to set
     * @return this
     */
    public NoticeChangeNotify setEndTime(final long value) {
      bitField0_ |= 0x00000002;
      endTime = value;
      return this;
    }

    /**
     * <code>optional int32 Interval = 5;</code>
     * @return whether the interval field is set
     */
    public boolean hasInterval() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional int32 Interval = 5;</code>
     * @return this
     */
    public NoticeChangeNotify clearInterval() {
      bitField0_ &= ~0x00000004;
      interval = 0;
      return this;
    }

    /**
     * <code>optional int32 Interval = 5;</code>
     * @return the interval
     */
    public int getInterval() {
      return interval;
    }

    /**
     * <code>optional int32 Interval = 5;</code>
     * @param value the interval to set
     * @return this
     */
    public NoticeChangeNotify setInterval(final int value) {
      bitField0_ |= 0x00000004;
      interval = value;
      return this;
    }

    /**
     * <code>optional int32 Duration = 6;</code>
     * @return whether the duration field is set
     */
    public boolean hasDuration() {
      return (bitField0_ & 0x00000008) != 0;
    }

    /**
     * <code>optional int32 Duration = 6;</code>
     * @return this
     */
    public NoticeChangeNotify clearDuration() {
      bitField0_ &= ~0x00000008;
      duration = 0;
      return this;
    }

    /**
     * <code>optional int32 Duration = 6;</code>
     * @return the duration
     */
    public int getDuration() {
      return duration;
    }

    /**
     * <code>optional int32 Duration = 6;</code>
     * @param value the duration to set
     * @return this
     */
    public NoticeChangeNotify setDuration(final int value) {
      bitField0_ |= 0x00000008;
      duration = value;
      return this;
    }

    /**
     * <code>optional bool IsStop = 7;</code>
     * @return whether the isStop field is set
     */
    public boolean hasIsStop() {
      return (bitField0_ & 0x00000010) != 0;
    }

    /**
     * <code>optional bool IsStop = 7;</code>
     * @return this
     */
    public NoticeChangeNotify clearIsStop() {
      bitField0_ &= ~0x00000010;
      isStop = false;
      return this;
    }

    /**
     * <code>optional bool IsStop = 7;</code>
     * @return the isStop
     */
    public boolean getIsStop() {
      return isStop;
    }

    /**
     * <code>optional bool IsStop = 7;</code>
     * @param value the isStop to set
     * @return this
     */
    public NoticeChangeNotify setIsStop(final boolean value) {
      bitField0_ |= 0x00000010;
      isStop = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000020) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public NoticeChangeNotify clearNextPackage() {
      bitField0_ &= ~0x00000020;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000020;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public NoticeChangeNotify addNextPackage(final byte value) {
      bitField0_ |= 0x00000020;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public NoticeChangeNotify addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000020;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public NoticeChangeNotify setNextPackage(final byte... values) {
      bitField0_ |= 0x00000020;
      nextPackage.copyFrom(values);
      return this;
    }

    /**
     * <code>optional string Content = 1;</code>
     * @return whether the content field is set
     */
    public boolean hasContent() {
      return (bitField0_ & 0x00000040) != 0;
    }

    /**
     * <code>optional string Content = 1;</code>
     * @return this
     */
    public NoticeChangeNotify clearContent() {
      bitField0_ &= ~0x00000040;
      content.clear();
      return this;
    }

    /**
     * <code>optional string Content = 1;</code>
     * @return the content
     */
    public String getContent() {
      return content.getString();
    }

    /**
     * <code>optional string Content = 1;</code>
     * @return internal {@code Utf8String} representation of content for reading
     */
    public Utf8String getContentBytes() {
      return this.content;
    }

    /**
     * <code>optional string Content = 1;</code>
     * @return internal {@code Utf8String} representation of content for modifications
     */
    public Utf8String getMutableContentBytes() {
      bitField0_ |= 0x00000040;
      return this.content;
    }

    /**
     * <code>optional string Content = 1;</code>
     * @param value the content to set
     * @return this
     */
    public NoticeChangeNotify setContent(final CharSequence value) {
      bitField0_ |= 0x00000040;
      content.copyFrom(value);
      return this;
    }

    /**
     * <code>optional string Content = 1;</code>
     * @param value the content to set
     * @return this
     */
    public NoticeChangeNotify setContent(final Utf8String value) {
      bitField0_ |= 0x00000040;
      content.copyFrom(value);
      return this;
    }

    /**
     * <code>repeated int32 Channel = 2;</code>
     * @return whether the channel field is set
     */
    public boolean hasChannel() {
      return (bitField0_ & 0x00000080) != 0;
    }

    /**
     * <code>repeated int32 Channel = 2;</code>
     * @return this
     */
    public NoticeChangeNotify clearChannel() {
      bitField0_ &= ~0x00000080;
      channel.clear();
      return this;
    }

    /**
     * <code>repeated int32 Channel = 2;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableChannel()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedInt getChannel() {
      return channel;
    }

    /**
     * <code>repeated int32 Channel = 2;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedInt getMutableChannel() {
      bitField0_ |= 0x00000080;
      return channel;
    }

    /**
     * <code>repeated int32 Channel = 2;</code>
     * @param value the channel to add
     * @return this
     */
    public NoticeChangeNotify addChannel(final int value) {
      bitField0_ |= 0x00000080;
      channel.add(value);
      return this;
    }

    /**
     * <code>repeated int32 Channel = 2;</code>
     * @param values the channel to add
     * @return this
     */
    public NoticeChangeNotify addAllChannel(final int... values) {
      bitField0_ |= 0x00000080;
      channel.addAll(values);
      return this;
    }

    @Override
    public NoticeChangeNotify copyFrom(final NoticeChangeNotify other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        startTime = other.startTime;
        endTime = other.endTime;
        interval = other.interval;
        duration = other.duration;
        isStop = other.isStop;
        nextPackage.copyFrom(other.nextPackage);
        content.copyFrom(other.content);
        channel.copyFrom(other.channel);
      }
      return this;
    }

    @Override
    public NoticeChangeNotify mergeFrom(final NoticeChangeNotify other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasStartTime()) {
        setStartTime(other.startTime);
      }
      if (other.hasEndTime()) {
        setEndTime(other.endTime);
      }
      if (other.hasInterval()) {
        setInterval(other.interval);
      }
      if (other.hasDuration()) {
        setDuration(other.duration);
      }
      if (other.hasIsStop()) {
        setIsStop(other.isStop);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      if (other.hasContent()) {
        getMutableContentBytes().copyFrom(other.content);
      }
      if (other.hasChannel()) {
        getMutableChannel().addAll(other.channel);
      }
      return this;
    }

    @Override
    public NoticeChangeNotify clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      startTime = 0L;
      endTime = 0L;
      interval = 0;
      duration = 0;
      isStop = false;
      nextPackage.clear();
      content.clear();
      channel.clear();
      return this;
    }

    @Override
    public NoticeChangeNotify clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      content.clear();
      channel.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof NoticeChangeNotify)) {
        return false;
      }
      NoticeChangeNotify other = (NoticeChangeNotify) o;
      return bitField0_ == other.bitField0_
        && (!hasStartTime() || startTime == other.startTime)
        && (!hasEndTime() || endTime == other.endTime)
        && (!hasInterval() || interval == other.interval)
        && (!hasDuration() || duration == other.duration)
        && (!hasIsStop() || isStop == other.isStop)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage))
        && (!hasContent() || content.equals(other.content))
        && (!hasChannel() || channel.equals(other.channel));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 24);
        output.writeInt64NoTag(startTime);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 32);
        output.writeInt64NoTag(endTime);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawByte((byte) 40);
        output.writeInt32NoTag(interval);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeRawByte((byte) 48);
        output.writeInt32NoTag(duration);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        output.writeRawByte((byte) 56);
        output.writeBoolNoTag(isStop);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000040) != 0) {
        output.writeRawByte((byte) 10);
        output.writeStringNoTag(content);
      }
      if ((bitField0_ & 0x00000080) != 0) {
        for (int i = 0; i < channel.length(); i++) {
          output.writeRawByte((byte) 16);
          output.writeInt32NoTag(channel.array()[i]);
        }
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeInt64SizeNoTag(startTime);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeInt64SizeNoTag(endTime);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 1 + ProtoSink.computeInt32SizeNoTag(interval);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        size += 1 + ProtoSink.computeInt32SizeNoTag(duration);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        size += 2;
      }
      if ((bitField0_ & 0x00000020) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000040) != 0) {
        size += 1 + ProtoSink.computeStringSizeNoTag(content);
      }
      if ((bitField0_ & 0x00000080) != 0) {
        size += (1 * channel.length()) + ProtoSink.computeRepeatedInt32SizeNoTag(channel);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public NoticeChangeNotify mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 24: {
            // startTime
            startTime = input.readInt64();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 32) {
              break;
            }
          }
          case 32: {
            // endTime
            endTime = input.readInt64();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 40) {
              break;
            }
          }
          case 40: {
            // interval
            interval = input.readInt32();
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 48) {
              break;
            }
          }
          case 48: {
            // duration
            duration = input.readInt32();
            bitField0_ |= 0x00000008;
            tag = input.readTag();
            if (tag != 56) {
              break;
            }
          }
          case 56: {
            // isStop
            isStop = input.readBool();
            bitField0_ |= 0x00000010;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000020;
            tag = input.readTag();
            if (tag != 10) {
              break;
            }
          }
          case 10: {
            // content
            input.readString(content);
            bitField0_ |= 0x00000040;
            tag = input.readTag();
            if (tag != 18) {
              break;
            }
          }
          case 18: {
            // channel [packed=true]
            input.readPackedInt32(channel, tag);
            bitField0_ |= 0x00000080;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
          case 16: {
            // channel [packed=false]
            tag = input.readRepeatedInt32(channel, tag);
            bitField0_ |= 0x00000080;
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeInt64(FieldNames.startTime, startTime);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeInt64(FieldNames.endTime, endTime);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeInt32(FieldNames.interval, interval);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeInt32(FieldNames.duration, duration);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        output.writeBool(FieldNames.isStop, isStop);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      if ((bitField0_ & 0x00000040) != 0) {
        output.writeString(FieldNames.content, content);
      }
      if ((bitField0_ & 0x00000080) != 0) {
        output.writeRepeatedInt32(FieldNames.channel, channel);
      }
      output.endObject();
    }

    @Override
    public NoticeChangeNotify mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case -125326801: {
            if (input.isAtField(FieldNames.startTime)) {
              if (!input.trySkipNullValue()) {
                startTime = input.readInt64();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 57410088: {
            if (input.isAtField(FieldNames.endTime)) {
              if (!input.trySkipNullValue()) {
                endTime = input.readInt64();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 635062501: {
            if (input.isAtField(FieldNames.interval)) {
              if (!input.trySkipNullValue()) {
                interval = input.readInt32();
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1927368268: {
            if (input.isAtField(FieldNames.duration)) {
              if (!input.trySkipNullValue()) {
                duration = input.readInt32();
                bitField0_ |= 0x00000008;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2096246676: {
            if (input.isAtField(FieldNames.isStop)) {
              if (!input.trySkipNullValue()) {
                isStop = input.readBool();
                bitField0_ |= 0x00000010;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000020;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1678783399: {
            if (input.isAtField(FieldNames.content)) {
              if (!input.trySkipNullValue()) {
                input.readString(content);
                bitField0_ |= 0x00000040;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1891363613: {
            if (input.isAtField(FieldNames.channel)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedInt32(channel);
                bitField0_ |= 0x00000080;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public NoticeChangeNotify clone() {
      return new NoticeChangeNotify().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static NoticeChangeNotify parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new NoticeChangeNotify(), data).checkInitialized();
    }

    public static NoticeChangeNotify parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new NoticeChangeNotify(), input).checkInitialized();
    }

    public static NoticeChangeNotify parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new NoticeChangeNotify(), input).checkInitialized();
    }

    /**
     * @return factory for creating NoticeChangeNotify messages
     */
    public static MessageFactory<NoticeChangeNotify> getFactory() {
      return NoticeChangeNotifyFactory.INSTANCE;
    }

    private enum NoticeChangeNotifyFactory implements MessageFactory<NoticeChangeNotify> {
      INSTANCE;

      @Override
      public NoticeChangeNotify create() {
        return NoticeChangeNotify.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName startTime = FieldName.forField("StartTime");

      static final FieldName endTime = FieldName.forField("EndTime");

      static final FieldName interval = FieldName.forField("Interval");

      static final FieldName duration = FieldName.forField("Duration");

      static final FieldName isStop = FieldName.forField("IsStop");

      static final FieldName nextPackage = FieldName.forField("NextPackage");

      static final FieldName content = FieldName.forField("Content");

      static final FieldName channel = FieldName.forField("Channel");
    }
  }

  /**
   * Protobuf type {@code PlayerHeadIconChangeNotify}
   */
  public static final class PlayerHeadIconChangeNotify extends ProtoMessage<PlayerHeadIconChangeNotify> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional uint32 Set = 1;</code>
     */
    private int set;

    /**
     * <code>optional uint32 Del = 2;</code>
     */
    private int del;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    private PlayerHeadIconChangeNotify() {
    }

    /**
     * @return a new empty instance of {@code PlayerHeadIconChangeNotify}
     */
    public static PlayerHeadIconChangeNotify newInstance() {
      return new PlayerHeadIconChangeNotify();
    }

    /**
     * <code>optional uint32 Set = 1;</code>
     * @return whether the set field is set
     */
    public boolean hasSet() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional uint32 Set = 1;</code>
     * @return this
     */
    public PlayerHeadIconChangeNotify clearSet() {
      bitField0_ &= ~0x00000001;
      set = 0;
      return this;
    }

    /**
     * <code>optional uint32 Set = 1;</code>
     * @return the set
     */
    public int getSet() {
      return set;
    }

    /**
     * <code>optional uint32 Set = 1;</code>
     * @param value the set to set
     * @return this
     */
    public PlayerHeadIconChangeNotify setSet(final int value) {
      bitField0_ |= 0x00000001;
      set = value;
      return this;
    }

    /**
     * <code>optional uint32 Del = 2;</code>
     * @return whether the del field is set
     */
    public boolean hasDel() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional uint32 Del = 2;</code>
     * @return this
     */
    public PlayerHeadIconChangeNotify clearDel() {
      bitField0_ &= ~0x00000002;
      del = 0;
      return this;
    }

    /**
     * <code>optional uint32 Del = 2;</code>
     * @return the del
     */
    public int getDel() {
      return del;
    }

    /**
     * <code>optional uint32 Del = 2;</code>
     * @param value the del to set
     * @return this
     */
    public PlayerHeadIconChangeNotify setDel(final int value) {
      bitField0_ |= 0x00000002;
      del = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public PlayerHeadIconChangeNotify clearNextPackage() {
      bitField0_ &= ~0x00000004;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000004;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public PlayerHeadIconChangeNotify addNextPackage(final byte value) {
      bitField0_ |= 0x00000004;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public PlayerHeadIconChangeNotify addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000004;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public PlayerHeadIconChangeNotify setNextPackage(final byte... values) {
      bitField0_ |= 0x00000004;
      nextPackage.copyFrom(values);
      return this;
    }

    @Override
    public PlayerHeadIconChangeNotify copyFrom(final PlayerHeadIconChangeNotify other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        set = other.set;
        del = other.del;
        nextPackage.copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public PlayerHeadIconChangeNotify mergeFrom(final PlayerHeadIconChangeNotify other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasSet()) {
        setSet(other.set);
      }
      if (other.hasDel()) {
        setDel(other.del);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public PlayerHeadIconChangeNotify clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      set = 0;
      del = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public PlayerHeadIconChangeNotify clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof PlayerHeadIconChangeNotify)) {
        return false;
      }
      PlayerHeadIconChangeNotify other = (PlayerHeadIconChangeNotify) o;
      return bitField0_ == other.bitField0_
        && (!hasSet() || set == other.set)
        && (!hasDel() || del == other.del)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt32NoTag(set);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 16);
        output.writeUInt32NoTag(del);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(set);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(del);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public PlayerHeadIconChangeNotify mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            // set
            set = input.readUInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 16) {
              break;
            }
          }
          case 16: {
            // del
            del = input.readUInt32();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeUInt32(FieldNames.set, set);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeUInt32(FieldNames.del, del);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      output.endObject();
    }

    @Override
    public PlayerHeadIconChangeNotify mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 83010: {
            if (input.isAtField(FieldNames.set)) {
              if (!input.trySkipNullValue()) {
                set = input.readUInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 68587: {
            if (input.isAtField(FieldNames.del)) {
              if (!input.trySkipNullValue()) {
                del = input.readUInt32();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public PlayerHeadIconChangeNotify clone() {
      return new PlayerHeadIconChangeNotify().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static PlayerHeadIconChangeNotify parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new PlayerHeadIconChangeNotify(), data).checkInitialized();
    }

    public static PlayerHeadIconChangeNotify parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new PlayerHeadIconChangeNotify(), input).checkInitialized();
    }

    public static PlayerHeadIconChangeNotify parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new PlayerHeadIconChangeNotify(), input).checkInitialized();
    }

    /**
     * @return factory for creating PlayerHeadIconChangeNotify messages
     */
    public static MessageFactory<PlayerHeadIconChangeNotify> getFactory() {
      return PlayerHeadIconChangeNotifyFactory.INSTANCE;
    }

    private enum PlayerHeadIconChangeNotifyFactory implements MessageFactory<PlayerHeadIconChangeNotify> {
      INSTANCE;

      @Override
      public PlayerHeadIconChangeNotify create() {
        return PlayerHeadIconChangeNotify.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName set = FieldName.forField("Set");

      static final FieldName del = FieldName.forField("Del");

      static final FieldName nextPackage = FieldName.forField("NextPackage");
    }
  }

  /**
   * Protobuf type {@code ActivityMiningEnterLayerNotify}
   */
  public static final class ActivityMiningEnterLayerNotify extends ProtoMessage<ActivityMiningEnterLayerNotify> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional .MiningLayer Layer = 1;</code>
     */
    private final PublicMining.MiningLayer layer = PublicMining.MiningLayer.newInstance();

    /**
     * <code>optional .MiningChangeInfo MiningChangeInfo = 2;</code>
     */
    private final PublicMining.MiningChangeInfo miningChangeInfo = PublicMining.MiningChangeInfo.newInstance();

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    private ActivityMiningEnterLayerNotify() {
    }

    /**
     * @return a new empty instance of {@code ActivityMiningEnterLayerNotify}
     */
    public static ActivityMiningEnterLayerNotify newInstance() {
      return new ActivityMiningEnterLayerNotify();
    }

    /**
     * <code>optional .MiningLayer Layer = 1;</code>
     * @return whether the layer field is set
     */
    public boolean hasLayer() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional .MiningLayer Layer = 1;</code>
     * @return this
     */
    public ActivityMiningEnterLayerNotify clearLayer() {
      bitField0_ &= ~0x00000001;
      layer.clear();
      return this;
    }

    /**
     * <code>optional .MiningLayer Layer = 1;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableLayer()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public PublicMining.MiningLayer getLayer() {
      return layer;
    }

    /**
     * <code>optional .MiningLayer Layer = 1;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public PublicMining.MiningLayer getMutableLayer() {
      bitField0_ |= 0x00000001;
      return layer;
    }

    /**
     * <code>optional .MiningLayer Layer = 1;</code>
     * @param value the layer to set
     * @return this
     */
    public ActivityMiningEnterLayerNotify setLayer(final PublicMining.MiningLayer value) {
      bitField0_ |= 0x00000001;
      layer.copyFrom(value);
      return this;
    }

    /**
     * <code>optional .MiningChangeInfo MiningChangeInfo = 2;</code>
     * @return whether the miningChangeInfo field is set
     */
    public boolean hasMiningChangeInfo() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional .MiningChangeInfo MiningChangeInfo = 2;</code>
     * @return this
     */
    public ActivityMiningEnterLayerNotify clearMiningChangeInfo() {
      bitField0_ &= ~0x00000002;
      miningChangeInfo.clear();
      return this;
    }

    /**
     * <code>optional .MiningChangeInfo MiningChangeInfo = 2;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableMiningChangeInfo()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public PublicMining.MiningChangeInfo getMiningChangeInfo() {
      return miningChangeInfo;
    }

    /**
     * <code>optional .MiningChangeInfo MiningChangeInfo = 2;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public PublicMining.MiningChangeInfo getMutableMiningChangeInfo() {
      bitField0_ |= 0x00000002;
      return miningChangeInfo;
    }

    /**
     * <code>optional .MiningChangeInfo MiningChangeInfo = 2;</code>
     * @param value the miningChangeInfo to set
     * @return this
     */
    public ActivityMiningEnterLayerNotify setMiningChangeInfo(
        final PublicMining.MiningChangeInfo value) {
      bitField0_ |= 0x00000002;
      miningChangeInfo.copyFrom(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public ActivityMiningEnterLayerNotify clearNextPackage() {
      bitField0_ &= ~0x00000004;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000004;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public ActivityMiningEnterLayerNotify addNextPackage(final byte value) {
      bitField0_ |= 0x00000004;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public ActivityMiningEnterLayerNotify addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000004;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public ActivityMiningEnterLayerNotify setNextPackage(final byte... values) {
      bitField0_ |= 0x00000004;
      nextPackage.copyFrom(values);
      return this;
    }

    @Override
    public ActivityMiningEnterLayerNotify copyFrom(final ActivityMiningEnterLayerNotify other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        layer.copyFrom(other.layer);
        miningChangeInfo.copyFrom(other.miningChangeInfo);
        nextPackage.copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public ActivityMiningEnterLayerNotify mergeFrom(final ActivityMiningEnterLayerNotify other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasLayer()) {
        getMutableLayer().mergeFrom(other.layer);
      }
      if (other.hasMiningChangeInfo()) {
        getMutableMiningChangeInfo().mergeFrom(other.miningChangeInfo);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public ActivityMiningEnterLayerNotify clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      layer.clear();
      miningChangeInfo.clear();
      nextPackage.clear();
      return this;
    }

    @Override
    public ActivityMiningEnterLayerNotify clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      layer.clearQuick();
      miningChangeInfo.clearQuick();
      nextPackage.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof ActivityMiningEnterLayerNotify)) {
        return false;
      }
      ActivityMiningEnterLayerNotify other = (ActivityMiningEnterLayerNotify) o;
      return bitField0_ == other.bitField0_
        && (!hasLayer() || layer.equals(other.layer))
        && (!hasMiningChangeInfo() || miningChangeInfo.equals(other.miningChangeInfo))
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 10);
        output.writeMessageNoTag(layer);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 18);
        output.writeMessageNoTag(miningChangeInfo);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeMessageSizeNoTag(layer);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeMessageSizeNoTag(miningChangeInfo);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public ActivityMiningEnterLayerNotify mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 10: {
            // layer
            input.readMessage(layer);
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 18) {
              break;
            }
          }
          case 18: {
            // miningChangeInfo
            input.readMessage(miningChangeInfo);
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeMessage(FieldNames.layer, layer);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeMessage(FieldNames.miningChangeInfo, miningChangeInfo);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      output.endObject();
    }

    @Override
    public ActivityMiningEnterLayerNotify mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 73196849: {
            if (input.isAtField(FieldNames.layer)) {
              if (!input.trySkipNullValue()) {
                input.readMessage(layer);
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1023670002: {
            if (input.isAtField(FieldNames.miningChangeInfo)) {
              if (!input.trySkipNullValue()) {
                input.readMessage(miningChangeInfo);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public ActivityMiningEnterLayerNotify clone() {
      return new ActivityMiningEnterLayerNotify().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static ActivityMiningEnterLayerNotify parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new ActivityMiningEnterLayerNotify(), data).checkInitialized();
    }

    public static ActivityMiningEnterLayerNotify parseFrom(final ProtoSource input) throws
        IOException {
      return ProtoMessage.mergeFrom(new ActivityMiningEnterLayerNotify(), input).checkInitialized();
    }

    public static ActivityMiningEnterLayerNotify parseFrom(final JsonSource input) throws
        IOException {
      return ProtoMessage.mergeFrom(new ActivityMiningEnterLayerNotify(), input).checkInitialized();
    }

    /**
     * @return factory for creating ActivityMiningEnterLayerNotify messages
     */
    public static MessageFactory<ActivityMiningEnterLayerNotify> getFactory() {
      return ActivityMiningEnterLayerNotifyFactory.INSTANCE;
    }

    private enum ActivityMiningEnterLayerNotifyFactory implements MessageFactory<ActivityMiningEnterLayerNotify> {
      INSTANCE;

      @Override
      public ActivityMiningEnterLayerNotify create() {
        return ActivityMiningEnterLayerNotify.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName layer = FieldName.forField("Layer");

      static final FieldName miningChangeInfo = FieldName.forField("MiningChangeInfo");

      static final FieldName nextPackage = FieldName.forField("NextPackage");
    }
  }

  /**
   * Protobuf type {@code OrderCollected}
   */
  public static final class OrderCollected extends ProtoMessage<OrderCollected> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    /**
     * <code>repeated .OrderStateChange Orders = 1;</code>
     */
    private final RepeatedMessage<OrderStateChange> orders = RepeatedMessage.newEmptyInstance(OrderStateChange.getFactory());

    private OrderCollected() {
    }

    /**
     * @return a new empty instance of {@code OrderCollected}
     */
    public static OrderCollected newInstance() {
      return new OrderCollected();
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public OrderCollected clearNextPackage() {
      bitField0_ &= ~0x00000001;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000001;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public OrderCollected addNextPackage(final byte value) {
      bitField0_ |= 0x00000001;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public OrderCollected addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000001;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public OrderCollected setNextPackage(final byte... values) {
      bitField0_ |= 0x00000001;
      nextPackage.copyFrom(values);
      return this;
    }

    /**
     * <code>repeated .OrderStateChange Orders = 1;</code>
     * @return whether the orders field is set
     */
    public boolean hasOrders() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>repeated .OrderStateChange Orders = 1;</code>
     * @return this
     */
    public OrderCollected clearOrders() {
      bitField0_ &= ~0x00000002;
      orders.clear();
      return this;
    }

    /**
     * <code>repeated .OrderStateChange Orders = 1;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableOrders()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<OrderStateChange> getOrders() {
      return orders;
    }

    /**
     * <code>repeated .OrderStateChange Orders = 1;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<OrderStateChange> getMutableOrders() {
      bitField0_ |= 0x00000002;
      return orders;
    }

    /**
     * <code>repeated .OrderStateChange Orders = 1;</code>
     * @param value the orders to add
     * @return this
     */
    public OrderCollected addOrders(final OrderStateChange value) {
      bitField0_ |= 0x00000002;
      orders.add(value);
      return this;
    }

    /**
     * <code>repeated .OrderStateChange Orders = 1;</code>
     * @param values the orders to add
     * @return this
     */
    public OrderCollected addAllOrders(final OrderStateChange... values) {
      bitField0_ |= 0x00000002;
      orders.addAll(values);
      return this;
    }

    @Override
    public OrderCollected copyFrom(final OrderCollected other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        nextPackage.copyFrom(other.nextPackage);
        orders.copyFrom(other.orders);
      }
      return this;
    }

    @Override
    public OrderCollected mergeFrom(final OrderCollected other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      if (other.hasOrders()) {
        getMutableOrders().addAll(other.orders);
      }
      return this;
    }

    @Override
    public OrderCollected clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      orders.clear();
      return this;
    }

    @Override
    public OrderCollected clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      orders.clearQuick();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof OrderCollected)) {
        return false;
      }
      OrderCollected other = (OrderCollected) o;
      return bitField0_ == other.bitField0_
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage))
        && (!hasOrders() || orders.equals(other.orders));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        for (int i = 0; i < orders.length(); i++) {
          output.writeRawByte((byte) 10);
          output.writeMessageNoTag(orders.get(i));
        }
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += (1 * orders.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(orders);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public OrderCollected mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 10) {
              break;
            }
          }
          case 10: {
            // orders
            tag = input.readRepeatedMessage(orders, tag);
            bitField0_ |= 0x00000002;
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRepeatedMessage(FieldNames.orders, orders);
      }
      output.endObject();
    }

    @Override
    public OrderCollected mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1924903163: {
            if (input.isAtField(FieldNames.orders)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedMessage(orders);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public OrderCollected clone() {
      return new OrderCollected().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static OrderCollected parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new OrderCollected(), data).checkInitialized();
    }

    public static OrderCollected parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new OrderCollected(), input).checkInitialized();
    }

    public static OrderCollected parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new OrderCollected(), input).checkInitialized();
    }

    /**
     * @return factory for creating OrderCollected messages
     */
    public static MessageFactory<OrderCollected> getFactory() {
      return OrderCollectedFactory.INSTANCE;
    }

    private enum OrderCollectedFactory implements MessageFactory<OrderCollected> {
      INSTANCE;

      @Override
      public OrderCollected create() {
        return OrderCollected.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName nextPackage = FieldName.forField("NextPackage");

      static final FieldName orders = FieldName.forField("Orders");
    }
  }
}
