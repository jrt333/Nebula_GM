// Code generated by protocol buffer compiler. Do not edit!
package emu.nebula.proto;

import java.io.IOException;
import us.hebi.quickbuf.FieldName;
import us.hebi.quickbuf.InvalidProtocolBufferException;
import us.hebi.quickbuf.JsonSink;
import us.hebi.quickbuf.JsonSource;
import us.hebi.quickbuf.MessageFactory;
import us.hebi.quickbuf.ProtoMessage;
import us.hebi.quickbuf.ProtoSink;
import us.hebi.quickbuf.ProtoSource;
import us.hebi.quickbuf.RepeatedByte;
import us.hebi.quickbuf.RepeatedInt;
import us.hebi.quickbuf.RepeatedMessage;

public final class NotifyGm {
  /**
   * Protobuf type {@code GmWorldClass}
   */
  public static final class GmWorldClass extends ProtoMessage<GmWorldClass> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional int32 LastExp = 2;</code>
     */
    private int lastExp;

    /**
     * <code>optional uint32 FinalClass = 1;</code>
     */
    private int finalClass;

    /**
     * <code>optional uint32 Stage = 3;</code>
     */
    private int stage;

    /**
     * <code>optional bytes RewardsFlag = 15;</code>
     */
    private final RepeatedByte rewardsFlag = RepeatedByte.newEmptyInstance();

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    private GmWorldClass() {
    }

    /**
     * @return a new empty instance of {@code GmWorldClass}
     */
    public static GmWorldClass newInstance() {
      return new GmWorldClass();
    }

    /**
     * <code>optional int32 LastExp = 2;</code>
     * @return whether the lastExp field is set
     */
    public boolean hasLastExp() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional int32 LastExp = 2;</code>
     * @return this
     */
    public GmWorldClass clearLastExp() {
      bitField0_ &= ~0x00000001;
      lastExp = 0;
      return this;
    }

    /**
     * <code>optional int32 LastExp = 2;</code>
     * @return the lastExp
     */
    public int getLastExp() {
      return lastExp;
    }

    /**
     * <code>optional int32 LastExp = 2;</code>
     * @param value the lastExp to set
     * @return this
     */
    public GmWorldClass setLastExp(final int value) {
      bitField0_ |= 0x00000001;
      lastExp = value;
      return this;
    }

    /**
     * <code>optional uint32 FinalClass = 1;</code>
     * @return whether the finalClass field is set
     */
    public boolean hasFinalClass() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional uint32 FinalClass = 1;</code>
     * @return this
     */
    public GmWorldClass clearFinalClass() {
      bitField0_ &= ~0x00000002;
      finalClass = 0;
      return this;
    }

    /**
     * <code>optional uint32 FinalClass = 1;</code>
     * @return the finalClass
     */
    public int getFinalClass() {
      return finalClass;
    }

    /**
     * <code>optional uint32 FinalClass = 1;</code>
     * @param value the finalClass to set
     * @return this
     */
    public GmWorldClass setFinalClass(final int value) {
      bitField0_ |= 0x00000002;
      finalClass = value;
      return this;
    }

    /**
     * <code>optional uint32 Stage = 3;</code>
     * @return whether the stage field is set
     */
    public boolean hasStage() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional uint32 Stage = 3;</code>
     * @return this
     */
    public GmWorldClass clearStage() {
      bitField0_ &= ~0x00000004;
      stage = 0;
      return this;
    }

    /**
     * <code>optional uint32 Stage = 3;</code>
     * @return the stage
     */
    public int getStage() {
      return stage;
    }

    /**
     * <code>optional uint32 Stage = 3;</code>
     * @param value the stage to set
     * @return this
     */
    public GmWorldClass setStage(final int value) {
      bitField0_ |= 0x00000004;
      stage = value;
      return this;
    }

    /**
     * <code>optional bytes RewardsFlag = 15;</code>
     * @return whether the rewardsFlag field is set
     */
    public boolean hasRewardsFlag() {
      return (bitField0_ & 0x00000008) != 0;
    }

    /**
     * <code>optional bytes RewardsFlag = 15;</code>
     * @return this
     */
    public GmWorldClass clearRewardsFlag() {
      bitField0_ &= ~0x00000008;
      rewardsFlag.clear();
      return this;
    }

    /**
     * <code>optional bytes RewardsFlag = 15;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableRewardsFlag()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getRewardsFlag() {
      return rewardsFlag;
    }

    /**
     * <code>optional bytes RewardsFlag = 15;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableRewardsFlag() {
      bitField0_ |= 0x00000008;
      return rewardsFlag;
    }

    /**
     * <code>optional bytes RewardsFlag = 15;</code>
     * @param value the rewardsFlag to add
     * @return this
     */
    public GmWorldClass addRewardsFlag(final byte value) {
      bitField0_ |= 0x00000008;
      rewardsFlag.add(value);
      return this;
    }

    /**
     * <code>optional bytes RewardsFlag = 15;</code>
     * @param values the rewardsFlag to add
     * @return this
     */
    public GmWorldClass addAllRewardsFlag(final byte... values) {
      bitField0_ |= 0x00000008;
      rewardsFlag.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes RewardsFlag = 15;</code>
     * @param values the rewardsFlag to set
     * @return this
     */
    public GmWorldClass setRewardsFlag(final byte... values) {
      bitField0_ |= 0x00000008;
      rewardsFlag.copyFrom(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000010) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public GmWorldClass clearNextPackage() {
      bitField0_ &= ~0x00000010;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000010;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public GmWorldClass addNextPackage(final byte value) {
      bitField0_ |= 0x00000010;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public GmWorldClass addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000010;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public GmWorldClass setNextPackage(final byte... values) {
      bitField0_ |= 0x00000010;
      nextPackage.copyFrom(values);
      return this;
    }

    @Override
    public GmWorldClass copyFrom(final GmWorldClass other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        lastExp = other.lastExp;
        finalClass = other.finalClass;
        stage = other.stage;
        rewardsFlag.copyFrom(other.rewardsFlag);
        nextPackage.copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public GmWorldClass mergeFrom(final GmWorldClass other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasLastExp()) {
        setLastExp(other.lastExp);
      }
      if (other.hasFinalClass()) {
        setFinalClass(other.finalClass);
      }
      if (other.hasStage()) {
        setStage(other.stage);
      }
      if (other.hasRewardsFlag()) {
        getMutableRewardsFlag().copyFrom(other.rewardsFlag);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public GmWorldClass clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      lastExp = 0;
      finalClass = 0;
      stage = 0;
      rewardsFlag.clear();
      nextPackage.clear();
      return this;
    }

    @Override
    public GmWorldClass clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      rewardsFlag.clear();
      nextPackage.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof GmWorldClass)) {
        return false;
      }
      GmWorldClass other = (GmWorldClass) o;
      return bitField0_ == other.bitField0_
        && (!hasLastExp() || lastExp == other.lastExp)
        && (!hasFinalClass() || finalClass == other.finalClass)
        && (!hasStage() || stage == other.stage)
        && (!hasRewardsFlag() || rewardsFlag.equals(other.rewardsFlag))
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 16);
        output.writeInt32NoTag(lastExp);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt32NoTag(finalClass);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawByte((byte) 24);
        output.writeUInt32NoTag(stage);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeRawByte((byte) 122);
        output.writeBytesNoTag(rewardsFlag);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeInt32SizeNoTag(lastExp);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(finalClass);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(stage);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        size += 1 + ProtoSink.computeBytesSizeNoTag(rewardsFlag);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public GmWorldClass mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 16: {
            // lastExp
            lastExp = input.readInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 8) {
              break;
            }
          }
          case 8: {
            // finalClass
            finalClass = input.readUInt32();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 24) {
              break;
            }
          }
          case 24: {
            // stage
            stage = input.readUInt32();
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 122) {
              break;
            }
          }
          case 122: {
            // rewardsFlag
            input.readBytes(rewardsFlag);
            bitField0_ |= 0x00000008;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000010;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeInt32(FieldNames.lastExp, lastExp);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeUInt32(FieldNames.finalClass, finalClass);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeUInt32(FieldNames.stage, stage);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeBytes(FieldNames.rewardsFlag, rewardsFlag);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      output.endObject();
    }

    @Override
    public GmWorldClass mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 1617561479: {
            if (input.isAtField(FieldNames.lastExp)) {
              if (!input.trySkipNullValue()) {
                lastExp = input.readInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 106057154: {
            if (input.isAtField(FieldNames.finalClass)) {
              if (!input.trySkipNullValue()) {
                finalClass = input.readUInt32();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 80204510: {
            if (input.isAtField(FieldNames.stage)) {
              if (!input.trySkipNullValue()) {
                stage = input.readUInt32();
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1711439728: {
            if (input.isAtField(FieldNames.rewardsFlag)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(rewardsFlag);
                bitField0_ |= 0x00000008;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000010;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public GmWorldClass clone() {
      return new GmWorldClass().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static GmWorldClass parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new GmWorldClass(), data).checkInitialized();
    }

    public static GmWorldClass parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new GmWorldClass(), input).checkInitialized();
    }

    public static GmWorldClass parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new GmWorldClass(), input).checkInitialized();
    }

    /**
     * @return factory for creating GmWorldClass messages
     */
    public static MessageFactory<GmWorldClass> getFactory() {
      return GmWorldClassFactory.INSTANCE;
    }

    private enum GmWorldClassFactory implements MessageFactory<GmWorldClass> {
      INSTANCE;

      @Override
      public GmWorldClass create() {
        return GmWorldClass.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName lastExp = FieldName.forField("LastExp");

      static final FieldName finalClass = FieldName.forField("FinalClass");

      static final FieldName stage = FieldName.forField("Stage");

      static final FieldName rewardsFlag = FieldName.forField("RewardsFlag");

      static final FieldName nextPackage = FieldName.forField("NextPackage");
    }
  }

  /**
   * Protobuf type {@code GmClearAllVampireSurvivor}
   */
  public static final class GmClearAllVampireSurvivor extends ProtoMessage<GmClearAllVampireSurvivor> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    /**
     * <code>repeated .VampireSurvivorLevel Records = 1;</code>
     */
    private final RepeatedMessage<Public.VampireSurvivorLevel> records = RepeatedMessage.newEmptyInstance(Public.VampireSurvivorLevel.getFactory());

    private GmClearAllVampireSurvivor() {
    }

    /**
     * @return a new empty instance of {@code GmClearAllVampireSurvivor}
     */
    public static GmClearAllVampireSurvivor newInstance() {
      return new GmClearAllVampireSurvivor();
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public GmClearAllVampireSurvivor clearNextPackage() {
      bitField0_ &= ~0x00000001;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000001;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public GmClearAllVampireSurvivor addNextPackage(final byte value) {
      bitField0_ |= 0x00000001;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public GmClearAllVampireSurvivor addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000001;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public GmClearAllVampireSurvivor setNextPackage(final byte... values) {
      bitField0_ |= 0x00000001;
      nextPackage.copyFrom(values);
      return this;
    }

    /**
     * <code>repeated .VampireSurvivorLevel Records = 1;</code>
     * @return whether the records field is set
     */
    public boolean hasRecords() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>repeated .VampireSurvivorLevel Records = 1;</code>
     * @return this
     */
    public GmClearAllVampireSurvivor clearRecords() {
      bitField0_ &= ~0x00000002;
      records.clear();
      return this;
    }

    /**
     * <code>repeated .VampireSurvivorLevel Records = 1;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableRecords()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<Public.VampireSurvivorLevel> getRecords() {
      return records;
    }

    /**
     * <code>repeated .VampireSurvivorLevel Records = 1;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<Public.VampireSurvivorLevel> getMutableRecords() {
      bitField0_ |= 0x00000002;
      return records;
    }

    /**
     * <code>repeated .VampireSurvivorLevel Records = 1;</code>
     * @param value the records to add
     * @return this
     */
    public GmClearAllVampireSurvivor addRecords(final Public.VampireSurvivorLevel value) {
      bitField0_ |= 0x00000002;
      records.add(value);
      return this;
    }

    /**
     * <code>repeated .VampireSurvivorLevel Records = 1;</code>
     * @param values the records to add
     * @return this
     */
    public GmClearAllVampireSurvivor addAllRecords(final Public.VampireSurvivorLevel... values) {
      bitField0_ |= 0x00000002;
      records.addAll(values);
      return this;
    }

    @Override
    public GmClearAllVampireSurvivor copyFrom(final GmClearAllVampireSurvivor other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        nextPackage.copyFrom(other.nextPackage);
        records.copyFrom(other.records);
      }
      return this;
    }

    @Override
    public GmClearAllVampireSurvivor mergeFrom(final GmClearAllVampireSurvivor other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      if (other.hasRecords()) {
        getMutableRecords().addAll(other.records);
      }
      return this;
    }

    @Override
    public GmClearAllVampireSurvivor clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      records.clear();
      return this;
    }

    @Override
    public GmClearAllVampireSurvivor clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      records.clearQuick();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof GmClearAllVampireSurvivor)) {
        return false;
      }
      GmClearAllVampireSurvivor other = (GmClearAllVampireSurvivor) o;
      return bitField0_ == other.bitField0_
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage))
        && (!hasRecords() || records.equals(other.records));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        for (int i = 0; i < records.length(); i++) {
          output.writeRawByte((byte) 10);
          output.writeMessageNoTag(records.get(i));
        }
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += (1 * records.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(records);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public GmClearAllVampireSurvivor mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 10) {
              break;
            }
          }
          case 10: {
            // records
            tag = input.readRepeatedMessage(records, tag);
            bitField0_ |= 0x00000002;
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRepeatedMessage(FieldNames.records, records);
      }
      output.endObject();
    }

    @Override
    public GmClearAllVampireSurvivor mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1547717086: {
            if (input.isAtField(FieldNames.records)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedMessage(records);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public GmClearAllVampireSurvivor clone() {
      return new GmClearAllVampireSurvivor().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static GmClearAllVampireSurvivor parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new GmClearAllVampireSurvivor(), data).checkInitialized();
    }

    public static GmClearAllVampireSurvivor parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new GmClearAllVampireSurvivor(), input).checkInitialized();
    }

    public static GmClearAllVampireSurvivor parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new GmClearAllVampireSurvivor(), input).checkInitialized();
    }

    /**
     * @return factory for creating GmClearAllVampireSurvivor messages
     */
    public static MessageFactory<GmClearAllVampireSurvivor> getFactory() {
      return GmClearAllVampireSurvivorFactory.INSTANCE;
    }

    private enum GmClearAllVampireSurvivorFactory implements MessageFactory<GmClearAllVampireSurvivor> {
      INSTANCE;

      @Override
      public GmClearAllVampireSurvivor create() {
        return GmClearAllVampireSurvivor.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName nextPackage = FieldName.forField("NextPackage");

      static final FieldName records = FieldName.forField("Records");
    }
  }

  /**
   * Protobuf type {@code StarTowerSubNoteSkillInfo}
   */
  public static final class StarTowerSubNoteSkillInfo extends ProtoMessage<StarTowerSubNoteSkillInfo> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    /**
     * <code>repeated .StarTowerSubNoteSkillInfo.StageFloorNum SubNoteSkillInfo = 1;</code>
     */
    private final RepeatedMessage<StageFloorNum> subNoteSkillInfo = RepeatedMessage.newEmptyInstance(StageFloorNum.getFactory());

    private StarTowerSubNoteSkillInfo() {
    }

    /**
     * @return a new empty instance of {@code StarTowerSubNoteSkillInfo}
     */
    public static StarTowerSubNoteSkillInfo newInstance() {
      return new StarTowerSubNoteSkillInfo();
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public StarTowerSubNoteSkillInfo clearNextPackage() {
      bitField0_ &= ~0x00000001;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000001;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public StarTowerSubNoteSkillInfo addNextPackage(final byte value) {
      bitField0_ |= 0x00000001;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public StarTowerSubNoteSkillInfo addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000001;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public StarTowerSubNoteSkillInfo setNextPackage(final byte... values) {
      bitField0_ |= 0x00000001;
      nextPackage.copyFrom(values);
      return this;
    }

    /**
     * <code>repeated .StarTowerSubNoteSkillInfo.StageFloorNum SubNoteSkillInfo = 1;</code>
     * @return whether the subNoteSkillInfo field is set
     */
    public boolean hasSubNoteSkillInfo() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>repeated .StarTowerSubNoteSkillInfo.StageFloorNum SubNoteSkillInfo = 1;</code>
     * @return this
     */
    public StarTowerSubNoteSkillInfo clearSubNoteSkillInfo() {
      bitField0_ &= ~0x00000002;
      subNoteSkillInfo.clear();
      return this;
    }

    /**
     * <code>repeated .StarTowerSubNoteSkillInfo.StageFloorNum SubNoteSkillInfo = 1;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableSubNoteSkillInfo()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<StageFloorNum> getSubNoteSkillInfo() {
      return subNoteSkillInfo;
    }

    /**
     * <code>repeated .StarTowerSubNoteSkillInfo.StageFloorNum SubNoteSkillInfo = 1;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<StageFloorNum> getMutableSubNoteSkillInfo() {
      bitField0_ |= 0x00000002;
      return subNoteSkillInfo;
    }

    /**
     * <code>repeated .StarTowerSubNoteSkillInfo.StageFloorNum SubNoteSkillInfo = 1;</code>
     * @param value the subNoteSkillInfo to add
     * @return this
     */
    public StarTowerSubNoteSkillInfo addSubNoteSkillInfo(final StageFloorNum value) {
      bitField0_ |= 0x00000002;
      subNoteSkillInfo.add(value);
      return this;
    }

    /**
     * <code>repeated .StarTowerSubNoteSkillInfo.StageFloorNum SubNoteSkillInfo = 1;</code>
     * @param values the subNoteSkillInfo to add
     * @return this
     */
    public StarTowerSubNoteSkillInfo addAllSubNoteSkillInfo(final StageFloorNum... values) {
      bitField0_ |= 0x00000002;
      subNoteSkillInfo.addAll(values);
      return this;
    }

    @Override
    public StarTowerSubNoteSkillInfo copyFrom(final StarTowerSubNoteSkillInfo other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        nextPackage.copyFrom(other.nextPackage);
        subNoteSkillInfo.copyFrom(other.subNoteSkillInfo);
      }
      return this;
    }

    @Override
    public StarTowerSubNoteSkillInfo mergeFrom(final StarTowerSubNoteSkillInfo other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      if (other.hasSubNoteSkillInfo()) {
        getMutableSubNoteSkillInfo().addAll(other.subNoteSkillInfo);
      }
      return this;
    }

    @Override
    public StarTowerSubNoteSkillInfo clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      subNoteSkillInfo.clear();
      return this;
    }

    @Override
    public StarTowerSubNoteSkillInfo clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      subNoteSkillInfo.clearQuick();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof StarTowerSubNoteSkillInfo)) {
        return false;
      }
      StarTowerSubNoteSkillInfo other = (StarTowerSubNoteSkillInfo) o;
      return bitField0_ == other.bitField0_
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage))
        && (!hasSubNoteSkillInfo() || subNoteSkillInfo.equals(other.subNoteSkillInfo));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        for (int i = 0; i < subNoteSkillInfo.length(); i++) {
          output.writeRawByte((byte) 10);
          output.writeMessageNoTag(subNoteSkillInfo.get(i));
        }
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += (1 * subNoteSkillInfo.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(subNoteSkillInfo);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public StarTowerSubNoteSkillInfo mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 10) {
              break;
            }
          }
          case 10: {
            // subNoteSkillInfo
            tag = input.readRepeatedMessage(subNoteSkillInfo, tag);
            bitField0_ |= 0x00000002;
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRepeatedMessage(FieldNames.subNoteSkillInfo, subNoteSkillInfo);
      }
      output.endObject();
    }

    @Override
    public StarTowerSubNoteSkillInfo mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 1931686029: {
            if (input.isAtField(FieldNames.subNoteSkillInfo)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedMessage(subNoteSkillInfo);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public StarTowerSubNoteSkillInfo clone() {
      return new StarTowerSubNoteSkillInfo().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static StarTowerSubNoteSkillInfo parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new StarTowerSubNoteSkillInfo(), data).checkInitialized();
    }

    public static StarTowerSubNoteSkillInfo parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new StarTowerSubNoteSkillInfo(), input).checkInitialized();
    }

    public static StarTowerSubNoteSkillInfo parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new StarTowerSubNoteSkillInfo(), input).checkInitialized();
    }

    /**
     * @return factory for creating StarTowerSubNoteSkillInfo messages
     */
    public static MessageFactory<StarTowerSubNoteSkillInfo> getFactory() {
      return StarTowerSubNoteSkillInfoFactory.INSTANCE;
    }

    /**
     * Protobuf type {@code FloorNum}
     */
    public static final class FloorNum extends ProtoMessage<FloorNum> implements Cloneable {
      private static final long serialVersionUID = 0L;

      /**
       * <code>optional uint32 Floor = 1;</code>
       */
      private int floor;

      /**
       * <code>optional uint32 Num = 2;</code>
       */
      private int num;

      private FloorNum() {
      }

      /**
       * @return a new empty instance of {@code FloorNum}
       */
      public static FloorNum newInstance() {
        return new FloorNum();
      }

      /**
       * <code>optional uint32 Floor = 1;</code>
       * @return whether the floor field is set
       */
      public boolean hasFloor() {
        return (bitField0_ & 0x00000001) != 0;
      }

      /**
       * <code>optional uint32 Floor = 1;</code>
       * @return this
       */
      public FloorNum clearFloor() {
        bitField0_ &= ~0x00000001;
        floor = 0;
        return this;
      }

      /**
       * <code>optional uint32 Floor = 1;</code>
       * @return the floor
       */
      public int getFloor() {
        return floor;
      }

      /**
       * <code>optional uint32 Floor = 1;</code>
       * @param value the floor to set
       * @return this
       */
      public FloorNum setFloor(final int value) {
        bitField0_ |= 0x00000001;
        floor = value;
        return this;
      }

      /**
       * <code>optional uint32 Num = 2;</code>
       * @return whether the num field is set
       */
      public boolean hasNum() {
        return (bitField0_ & 0x00000002) != 0;
      }

      /**
       * <code>optional uint32 Num = 2;</code>
       * @return this
       */
      public FloorNum clearNum() {
        bitField0_ &= ~0x00000002;
        num = 0;
        return this;
      }

      /**
       * <code>optional uint32 Num = 2;</code>
       * @return the num
       */
      public int getNum() {
        return num;
      }

      /**
       * <code>optional uint32 Num = 2;</code>
       * @param value the num to set
       * @return this
       */
      public FloorNum setNum(final int value) {
        bitField0_ |= 0x00000002;
        num = value;
        return this;
      }

      @Override
      public FloorNum copyFrom(final FloorNum other) {
        cachedSize = other.cachedSize;
        if ((bitField0_ | other.bitField0_) != 0) {
          bitField0_ = other.bitField0_;
          floor = other.floor;
          num = other.num;
        }
        return this;
      }

      @Override
      public FloorNum mergeFrom(final FloorNum other) {
        if (other.isEmpty()) {
          return this;
        }
        cachedSize = -1;
        if (other.hasFloor()) {
          setFloor(other.floor);
        }
        if (other.hasNum()) {
          setNum(other.num);
        }
        return this;
      }

      @Override
      public FloorNum clear() {
        if (isEmpty()) {
          return this;
        }
        cachedSize = -1;
        bitField0_ = 0;
        floor = 0;
        num = 0;
        return this;
      }

      @Override
      public FloorNum clearQuick() {
        if (isEmpty()) {
          return this;
        }
        cachedSize = -1;
        bitField0_ = 0;
        return this;
      }

      @Override
      public boolean equals(Object o) {
        if (o == this) {
          return true;
        }
        if (!(o instanceof FloorNum)) {
          return false;
        }
        FloorNum other = (FloorNum) o;
        return bitField0_ == other.bitField0_
          && (!hasFloor() || floor == other.floor)
          && (!hasNum() || num == other.num);
      }

      @Override
      public void writeTo(final ProtoSink output) throws IOException {
        if ((bitField0_ & 0x00000001) != 0) {
          output.writeRawByte((byte) 8);
          output.writeUInt32NoTag(floor);
        }
        if ((bitField0_ & 0x00000002) != 0) {
          output.writeRawByte((byte) 16);
          output.writeUInt32NoTag(num);
        }
      }

      @Override
      protected int computeSerializedSize() {
        int size = 0;
        if ((bitField0_ & 0x00000001) != 0) {
          size += 1 + ProtoSink.computeUInt32SizeNoTag(floor);
        }
        if ((bitField0_ & 0x00000002) != 0) {
          size += 1 + ProtoSink.computeUInt32SizeNoTag(num);
        }
        return size;
      }

      @Override
      @SuppressWarnings("fallthrough")
      public FloorNum mergeFrom(final ProtoSource input) throws IOException {
        // Enabled Fall-Through Optimization (QuickBuffers)
        int tag = input.readTag();
        while (true) {
          switch (tag) {
            case 8: {
              // floor
              floor = input.readUInt32();
              bitField0_ |= 0x00000001;
              tag = input.readTag();
              if (tag != 16) {
                break;
              }
            }
            case 16: {
              // num
              num = input.readUInt32();
              bitField0_ |= 0x00000002;
              tag = input.readTag();
              if (tag != 0) {
                break;
              }
            }
            case 0: {
              return this;
            }
            default: {
              if (!input.skipField(tag)) {
                return this;
              }
              tag = input.readTag();
              break;
            }
          }
        }
      }

      @Override
      public void writeTo(final JsonSink output) throws IOException {
        output.beginObject();
        if ((bitField0_ & 0x00000001) != 0) {
          output.writeUInt32(FieldNames.floor, floor);
        }
        if ((bitField0_ & 0x00000002) != 0) {
          output.writeUInt32(FieldNames.num, num);
        }
        output.endObject();
      }

      @Override
      public FloorNum mergeFrom(final JsonSource input) throws IOException {
        if (!input.beginObject()) {
          return this;
        }
        while (!input.isAtEnd()) {
          switch (input.readFieldHash()) {
            case 67974124: {
              if (input.isAtField(FieldNames.floor)) {
                if (!input.trySkipNullValue()) {
                  floor = input.readUInt32();
                  bitField0_ |= 0x00000001;
                }
              } else {
                input.skipUnknownField();
              }
              break;
            }
            case 78694: {
              if (input.isAtField(FieldNames.num)) {
                if (!input.trySkipNullValue()) {
                  num = input.readUInt32();
                  bitField0_ |= 0x00000002;
                }
              } else {
                input.skipUnknownField();
              }
              break;
            }
            default: {
              input.skipUnknownField();
              break;
            }
          }
        }
        input.endObject();
        return this;
      }

      @Override
      public FloorNum clone() {
        return new FloorNum().copyFrom(this);
      }

      @Override
      public boolean isEmpty() {
        return ((bitField0_) == 0);
      }

      public static FloorNum parseFrom(final byte[] data) throws InvalidProtocolBufferException {
        return ProtoMessage.mergeFrom(new FloorNum(), data).checkInitialized();
      }

      public static FloorNum parseFrom(final ProtoSource input) throws IOException {
        return ProtoMessage.mergeFrom(new FloorNum(), input).checkInitialized();
      }

      public static FloorNum parseFrom(final JsonSource input) throws IOException {
        return ProtoMessage.mergeFrom(new FloorNum(), input).checkInitialized();
      }

      /**
       * @return factory for creating FloorNum messages
       */
      public static MessageFactory<FloorNum> getFactory() {
        return FloorNumFactory.INSTANCE;
      }

      private enum FloorNumFactory implements MessageFactory<FloorNum> {
        INSTANCE;

        @Override
        public FloorNum create() {
          return FloorNum.newInstance();
        }
      }

      /**
       * Contains name constants used for serializing JSON
       */
      static class FieldNames {
        static final FieldName floor = FieldName.forField("Floor");

        static final FieldName num = FieldName.forField("Num");
      }
    }

    /**
     * Protobuf type {@code StageFloorNum}
     */
    public static final class StageFloorNum extends ProtoMessage<StageFloorNum> implements Cloneable {
      private static final long serialVersionUID = 0L;

      /**
       * <code>optional uint32 StageId = 1;</code>
       */
      private int stageId;

      /**
       * <code>repeated .StarTowerSubNoteSkillInfo.FloorNum Infos = 2;</code>
       */
      private final RepeatedMessage<FloorNum> infos = RepeatedMessage.newEmptyInstance(FloorNum.getFactory());

      private StageFloorNum() {
      }

      /**
       * @return a new empty instance of {@code StageFloorNum}
       */
      public static StageFloorNum newInstance() {
        return new StageFloorNum();
      }

      /**
       * <code>optional uint32 StageId = 1;</code>
       * @return whether the stageId field is set
       */
      public boolean hasStageId() {
        return (bitField0_ & 0x00000001) != 0;
      }

      /**
       * <code>optional uint32 StageId = 1;</code>
       * @return this
       */
      public StageFloorNum clearStageId() {
        bitField0_ &= ~0x00000001;
        stageId = 0;
        return this;
      }

      /**
       * <code>optional uint32 StageId = 1;</code>
       * @return the stageId
       */
      public int getStageId() {
        return stageId;
      }

      /**
       * <code>optional uint32 StageId = 1;</code>
       * @param value the stageId to set
       * @return this
       */
      public StageFloorNum setStageId(final int value) {
        bitField0_ |= 0x00000001;
        stageId = value;
        return this;
      }

      /**
       * <code>repeated .StarTowerSubNoteSkillInfo.FloorNum Infos = 2;</code>
       * @return whether the infos field is set
       */
      public boolean hasInfos() {
        return (bitField0_ & 0x00000002) != 0;
      }

      /**
       * <code>repeated .StarTowerSubNoteSkillInfo.FloorNum Infos = 2;</code>
       * @return this
       */
      public StageFloorNum clearInfos() {
        bitField0_ &= ~0x00000002;
        infos.clear();
        return this;
      }

      /**
       * <code>repeated .StarTowerSubNoteSkillInfo.FloorNum Infos = 2;</code>
       *
       * This method returns the internal storage object without modifying any has state.
       * The returned object should not be modified and be treated as read-only.
       *
       * Use {@link #getMutableInfos()} if you want to modify it.
       *
       * @return internal storage object for reading
       */
      public RepeatedMessage<FloorNum> getInfos() {
        return infos;
      }

      /**
       * <code>repeated .StarTowerSubNoteSkillInfo.FloorNum Infos = 2;</code>
       *
       * This method returns the internal storage object and sets the corresponding
       * has state. The returned object will become part of this message and its
       * contents may be modified as long as the has state is not cleared.
       *
       * @return internal storage object for modifications
       */
      public RepeatedMessage<FloorNum> getMutableInfos() {
        bitField0_ |= 0x00000002;
        return infos;
      }

      /**
       * <code>repeated .StarTowerSubNoteSkillInfo.FloorNum Infos = 2;</code>
       * @param value the infos to add
       * @return this
       */
      public StageFloorNum addInfos(final FloorNum value) {
        bitField0_ |= 0x00000002;
        infos.add(value);
        return this;
      }

      /**
       * <code>repeated .StarTowerSubNoteSkillInfo.FloorNum Infos = 2;</code>
       * @param values the infos to add
       * @return this
       */
      public StageFloorNum addAllInfos(final FloorNum... values) {
        bitField0_ |= 0x00000002;
        infos.addAll(values);
        return this;
      }

      @Override
      public StageFloorNum copyFrom(final StageFloorNum other) {
        cachedSize = other.cachedSize;
        if ((bitField0_ | other.bitField0_) != 0) {
          bitField0_ = other.bitField0_;
          stageId = other.stageId;
          infos.copyFrom(other.infos);
        }
        return this;
      }

      @Override
      public StageFloorNum mergeFrom(final StageFloorNum other) {
        if (other.isEmpty()) {
          return this;
        }
        cachedSize = -1;
        if (other.hasStageId()) {
          setStageId(other.stageId);
        }
        if (other.hasInfos()) {
          getMutableInfos().addAll(other.infos);
        }
        return this;
      }

      @Override
      public StageFloorNum clear() {
        if (isEmpty()) {
          return this;
        }
        cachedSize = -1;
        bitField0_ = 0;
        stageId = 0;
        infos.clear();
        return this;
      }

      @Override
      public StageFloorNum clearQuick() {
        if (isEmpty()) {
          return this;
        }
        cachedSize = -1;
        bitField0_ = 0;
        infos.clearQuick();
        return this;
      }

      @Override
      public boolean equals(Object o) {
        if (o == this) {
          return true;
        }
        if (!(o instanceof StageFloorNum)) {
          return false;
        }
        StageFloorNum other = (StageFloorNum) o;
        return bitField0_ == other.bitField0_
          && (!hasStageId() || stageId == other.stageId)
          && (!hasInfos() || infos.equals(other.infos));
      }

      @Override
      public void writeTo(final ProtoSink output) throws IOException {
        if ((bitField0_ & 0x00000001) != 0) {
          output.writeRawByte((byte) 8);
          output.writeUInt32NoTag(stageId);
        }
        if ((bitField0_ & 0x00000002) != 0) {
          for (int i = 0; i < infos.length(); i++) {
            output.writeRawByte((byte) 18);
            output.writeMessageNoTag(infos.get(i));
          }
        }
      }

      @Override
      protected int computeSerializedSize() {
        int size = 0;
        if ((bitField0_ & 0x00000001) != 0) {
          size += 1 + ProtoSink.computeUInt32SizeNoTag(stageId);
        }
        if ((bitField0_ & 0x00000002) != 0) {
          size += (1 * infos.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(infos);
        }
        return size;
      }

      @Override
      @SuppressWarnings("fallthrough")
      public StageFloorNum mergeFrom(final ProtoSource input) throws IOException {
        // Enabled Fall-Through Optimization (QuickBuffers)
        int tag = input.readTag();
        while (true) {
          switch (tag) {
            case 8: {
              // stageId
              stageId = input.readUInt32();
              bitField0_ |= 0x00000001;
              tag = input.readTag();
              if (tag != 18) {
                break;
              }
            }
            case 18: {
              // infos
              tag = input.readRepeatedMessage(infos, tag);
              bitField0_ |= 0x00000002;
              if (tag != 0) {
                break;
              }
            }
            case 0: {
              return this;
            }
            default: {
              if (!input.skipField(tag)) {
                return this;
              }
              tag = input.readTag();
              break;
            }
          }
        }
      }

      @Override
      public void writeTo(final JsonSink output) throws IOException {
        output.beginObject();
        if ((bitField0_ & 0x00000001) != 0) {
          output.writeUInt32(FieldNames.stageId, stageId);
        }
        if ((bitField0_ & 0x00000002) != 0) {
          output.writeRepeatedMessage(FieldNames.infos, infos);
        }
        output.endObject();
      }

      @Override
      public StageFloorNum mergeFrom(final JsonSource input) throws IOException {
        if (!input.beginObject()) {
          return this;
        }
        while (!input.isAtEnd()) {
          switch (input.readFieldHash()) {
            case -232874855: {
              if (input.isAtField(FieldNames.stageId)) {
                if (!input.trySkipNullValue()) {
                  stageId = input.readUInt32();
                  bitField0_ |= 0x00000001;
                }
              } else {
                input.skipUnknownField();
              }
              break;
            }
            case 70795621: {
              if (input.isAtField(FieldNames.infos)) {
                if (!input.trySkipNullValue()) {
                  input.readRepeatedMessage(infos);
                  bitField0_ |= 0x00000002;
                }
              } else {
                input.skipUnknownField();
              }
              break;
            }
            default: {
              input.skipUnknownField();
              break;
            }
          }
        }
        input.endObject();
        return this;
      }

      @Override
      public StageFloorNum clone() {
        return new StageFloorNum().copyFrom(this);
      }

      @Override
      public boolean isEmpty() {
        return ((bitField0_) == 0);
      }

      public static StageFloorNum parseFrom(final byte[] data) throws
          InvalidProtocolBufferException {
        return ProtoMessage.mergeFrom(new StageFloorNum(), data).checkInitialized();
      }

      public static StageFloorNum parseFrom(final ProtoSource input) throws IOException {
        return ProtoMessage.mergeFrom(new StageFloorNum(), input).checkInitialized();
      }

      public static StageFloorNum parseFrom(final JsonSource input) throws IOException {
        return ProtoMessage.mergeFrom(new StageFloorNum(), input).checkInitialized();
      }

      /**
       * @return factory for creating StageFloorNum messages
       */
      public static MessageFactory<StageFloorNum> getFactory() {
        return StageFloorNumFactory.INSTANCE;
      }

      private enum StageFloorNumFactory implements MessageFactory<StageFloorNum> {
        INSTANCE;

        @Override
        public StageFloorNum create() {
          return StageFloorNum.newInstance();
        }
      }

      /**
       * Contains name constants used for serializing JSON
       */
      static class FieldNames {
        static final FieldName stageId = FieldName.forField("StageId");

        static final FieldName infos = FieldName.forField("Infos");
      }
    }

    private enum StarTowerSubNoteSkillInfoFactory implements MessageFactory<StarTowerSubNoteSkillInfo> {
      INSTANCE;

      @Override
      public StarTowerSubNoteSkillInfo create() {
        return StarTowerSubNoteSkillInfo.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName nextPackage = FieldName.forField("NextPackage");

      static final FieldName subNoteSkillInfo = FieldName.forField("SubNoteSkillInfo");
    }
  }

  /**
   * Protobuf type {@code AgentInfos}
   */
  public static final class AgentInfos extends ProtoMessage<AgentInfos> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    /**
     * <code>repeated .AgentInfo Infos = 1;</code>
     */
    private final RepeatedMessage<Public.AgentInfo> infos = RepeatedMessage.newEmptyInstance(Public.AgentInfo.getFactory());

    private AgentInfos() {
    }

    /**
     * @return a new empty instance of {@code AgentInfos}
     */
    public static AgentInfos newInstance() {
      return new AgentInfos();
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public AgentInfos clearNextPackage() {
      bitField0_ &= ~0x00000001;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000001;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public AgentInfos addNextPackage(final byte value) {
      bitField0_ |= 0x00000001;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public AgentInfos addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000001;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public AgentInfos setNextPackage(final byte... values) {
      bitField0_ |= 0x00000001;
      nextPackage.copyFrom(values);
      return this;
    }

    /**
     * <code>repeated .AgentInfo Infos = 1;</code>
     * @return whether the infos field is set
     */
    public boolean hasInfos() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>repeated .AgentInfo Infos = 1;</code>
     * @return this
     */
    public AgentInfos clearInfos() {
      bitField0_ &= ~0x00000002;
      infos.clear();
      return this;
    }

    /**
     * <code>repeated .AgentInfo Infos = 1;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableInfos()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<Public.AgentInfo> getInfos() {
      return infos;
    }

    /**
     * <code>repeated .AgentInfo Infos = 1;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<Public.AgentInfo> getMutableInfos() {
      bitField0_ |= 0x00000002;
      return infos;
    }

    /**
     * <code>repeated .AgentInfo Infos = 1;</code>
     * @param value the infos to add
     * @return this
     */
    public AgentInfos addInfos(final Public.AgentInfo value) {
      bitField0_ |= 0x00000002;
      infos.add(value);
      return this;
    }

    /**
     * <code>repeated .AgentInfo Infos = 1;</code>
     * @param values the infos to add
     * @return this
     */
    public AgentInfos addAllInfos(final Public.AgentInfo... values) {
      bitField0_ |= 0x00000002;
      infos.addAll(values);
      return this;
    }

    @Override
    public AgentInfos copyFrom(final AgentInfos other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        nextPackage.copyFrom(other.nextPackage);
        infos.copyFrom(other.infos);
      }
      return this;
    }

    @Override
    public AgentInfos mergeFrom(final AgentInfos other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      if (other.hasInfos()) {
        getMutableInfos().addAll(other.infos);
      }
      return this;
    }

    @Override
    public AgentInfos clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      infos.clear();
      return this;
    }

    @Override
    public AgentInfos clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      infos.clearQuick();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof AgentInfos)) {
        return false;
      }
      AgentInfos other = (AgentInfos) o;
      return bitField0_ == other.bitField0_
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage))
        && (!hasInfos() || infos.equals(other.infos));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        for (int i = 0; i < infos.length(); i++) {
          output.writeRawByte((byte) 10);
          output.writeMessageNoTag(infos.get(i));
        }
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += (1 * infos.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(infos);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public AgentInfos mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 10) {
              break;
            }
          }
          case 10: {
            // infos
            tag = input.readRepeatedMessage(infos, tag);
            bitField0_ |= 0x00000002;
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRepeatedMessage(FieldNames.infos, infos);
      }
      output.endObject();
    }

    @Override
    public AgentInfos mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 70795621: {
            if (input.isAtField(FieldNames.infos)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedMessage(infos);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public AgentInfos clone() {
      return new AgentInfos().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static AgentInfos parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new AgentInfos(), data).checkInitialized();
    }

    public static AgentInfos parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new AgentInfos(), input).checkInitialized();
    }

    public static AgentInfos parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new AgentInfos(), input).checkInitialized();
    }

    /**
     * @return factory for creating AgentInfos messages
     */
    public static MessageFactory<AgentInfos> getFactory() {
      return AgentInfosFactory.INSTANCE;
    }

    private enum AgentInfosFactory implements MessageFactory<AgentInfos> {
      INSTANCE;

      @Override
      public AgentInfos create() {
        return AgentInfos.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName nextPackage = FieldName.forField("NextPackage");

      static final FieldName infos = FieldName.forField("Infos");
    }
  }

  /**
   * Protobuf type {@code GmClearAllDailyInstance}
   */
  public static final class GmClearAllDailyInstance extends ProtoMessage<GmClearAllDailyInstance> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional .ChangeInfo Change = 2;</code>
     */
    private final Public.ChangeInfo change = Public.ChangeInfo.newInstance();

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    /**
     * <code>repeated .DailyInstance DailyInstances = 1;</code>
     */
    private final RepeatedMessage<Public.DailyInstance> dailyInstances = RepeatedMessage.newEmptyInstance(Public.DailyInstance.getFactory());

    private GmClearAllDailyInstance() {
    }

    /**
     * @return a new empty instance of {@code GmClearAllDailyInstance}
     */
    public static GmClearAllDailyInstance newInstance() {
      return new GmClearAllDailyInstance();
    }

    /**
     * <code>optional .ChangeInfo Change = 2;</code>
     * @return whether the change field is set
     */
    public boolean hasChange() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional .ChangeInfo Change = 2;</code>
     * @return this
     */
    public GmClearAllDailyInstance clearChange() {
      bitField0_ &= ~0x00000001;
      change.clear();
      return this;
    }

    /**
     * <code>optional .ChangeInfo Change = 2;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableChange()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public Public.ChangeInfo getChange() {
      return change;
    }

    /**
     * <code>optional .ChangeInfo Change = 2;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public Public.ChangeInfo getMutableChange() {
      bitField0_ |= 0x00000001;
      return change;
    }

    /**
     * <code>optional .ChangeInfo Change = 2;</code>
     * @param value the change to set
     * @return this
     */
    public GmClearAllDailyInstance setChange(final Public.ChangeInfo value) {
      bitField0_ |= 0x00000001;
      change.copyFrom(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public GmClearAllDailyInstance clearNextPackage() {
      bitField0_ &= ~0x00000002;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000002;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public GmClearAllDailyInstance addNextPackage(final byte value) {
      bitField0_ |= 0x00000002;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public GmClearAllDailyInstance addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000002;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public GmClearAllDailyInstance setNextPackage(final byte... values) {
      bitField0_ |= 0x00000002;
      nextPackage.copyFrom(values);
      return this;
    }

    /**
     * <code>repeated .DailyInstance DailyInstances = 1;</code>
     * @return whether the dailyInstances field is set
     */
    public boolean hasDailyInstances() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>repeated .DailyInstance DailyInstances = 1;</code>
     * @return this
     */
    public GmClearAllDailyInstance clearDailyInstances() {
      bitField0_ &= ~0x00000004;
      dailyInstances.clear();
      return this;
    }

    /**
     * <code>repeated .DailyInstance DailyInstances = 1;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableDailyInstances()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<Public.DailyInstance> getDailyInstances() {
      return dailyInstances;
    }

    /**
     * <code>repeated .DailyInstance DailyInstances = 1;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<Public.DailyInstance> getMutableDailyInstances() {
      bitField0_ |= 0x00000004;
      return dailyInstances;
    }

    /**
     * <code>repeated .DailyInstance DailyInstances = 1;</code>
     * @param value the dailyInstances to add
     * @return this
     */
    public GmClearAllDailyInstance addDailyInstances(final Public.DailyInstance value) {
      bitField0_ |= 0x00000004;
      dailyInstances.add(value);
      return this;
    }

    /**
     * <code>repeated .DailyInstance DailyInstances = 1;</code>
     * @param values the dailyInstances to add
     * @return this
     */
    public GmClearAllDailyInstance addAllDailyInstances(final Public.DailyInstance... values) {
      bitField0_ |= 0x00000004;
      dailyInstances.addAll(values);
      return this;
    }

    @Override
    public GmClearAllDailyInstance copyFrom(final GmClearAllDailyInstance other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        change.copyFrom(other.change);
        nextPackage.copyFrom(other.nextPackage);
        dailyInstances.copyFrom(other.dailyInstances);
      }
      return this;
    }

    @Override
    public GmClearAllDailyInstance mergeFrom(final GmClearAllDailyInstance other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasChange()) {
        getMutableChange().mergeFrom(other.change);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      if (other.hasDailyInstances()) {
        getMutableDailyInstances().addAll(other.dailyInstances);
      }
      return this;
    }

    @Override
    public GmClearAllDailyInstance clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      change.clear();
      nextPackage.clear();
      dailyInstances.clear();
      return this;
    }

    @Override
    public GmClearAllDailyInstance clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      change.clearQuick();
      nextPackage.clear();
      dailyInstances.clearQuick();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof GmClearAllDailyInstance)) {
        return false;
      }
      GmClearAllDailyInstance other = (GmClearAllDailyInstance) o;
      return bitField0_ == other.bitField0_
        && (!hasChange() || change.equals(other.change))
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage))
        && (!hasDailyInstances() || dailyInstances.equals(other.dailyInstances));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 18);
        output.writeMessageNoTag(change);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        for (int i = 0; i < dailyInstances.length(); i++) {
          output.writeRawByte((byte) 10);
          output.writeMessageNoTag(dailyInstances.get(i));
        }
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeMessageSizeNoTag(change);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += (1 * dailyInstances.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(dailyInstances);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public GmClearAllDailyInstance mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 18: {
            // change
            input.readMessage(change);
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 10) {
              break;
            }
          }
          case 10: {
            // dailyInstances
            tag = input.readRepeatedMessage(dailyInstances, tag);
            bitField0_ |= 0x00000004;
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeMessage(FieldNames.change, change);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRepeatedMessage(FieldNames.dailyInstances, dailyInstances);
      }
      output.endObject();
    }

    @Override
    public GmClearAllDailyInstance mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 2017198032: {
            if (input.isAtField(FieldNames.change)) {
              if (!input.trySkipNullValue()) {
                input.readMessage(change);
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 1187764357: {
            if (input.isAtField(FieldNames.dailyInstances)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedMessage(dailyInstances);
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public GmClearAllDailyInstance clone() {
      return new GmClearAllDailyInstance().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static GmClearAllDailyInstance parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new GmClearAllDailyInstance(), data).checkInitialized();
    }

    public static GmClearAllDailyInstance parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new GmClearAllDailyInstance(), input).checkInitialized();
    }

    public static GmClearAllDailyInstance parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new GmClearAllDailyInstance(), input).checkInitialized();
    }

    /**
     * @return factory for creating GmClearAllDailyInstance messages
     */
    public static MessageFactory<GmClearAllDailyInstance> getFactory() {
      return GmClearAllDailyInstanceFactory.INSTANCE;
    }

    private enum GmClearAllDailyInstanceFactory implements MessageFactory<GmClearAllDailyInstance> {
      INSTANCE;

      @Override
      public GmClearAllDailyInstance create() {
        return GmClearAllDailyInstance.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName change = FieldName.forField("Change");

      static final FieldName nextPackage = FieldName.forField("NextPackage");

      static final FieldName dailyInstances = FieldName.forField("DailyInstances");
    }
  }

  /**
   * Protobuf type {@code WeekBossLevels}
   */
  public static final class WeekBossLevels extends ProtoMessage<WeekBossLevels> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    /**
     * <code>repeated .WeekBossLevel WeekBossLevels = 1;</code>
     */
    private final RepeatedMessage<Public.WeekBossLevel> weekBossLevels = RepeatedMessage.newEmptyInstance(Public.WeekBossLevel.getFactory());

    private WeekBossLevels() {
    }

    /**
     * @return a new empty instance of {@code WeekBossLevels}
     */
    public static WeekBossLevels newInstance() {
      return new WeekBossLevels();
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public WeekBossLevels clearNextPackage() {
      bitField0_ &= ~0x00000001;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000001;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public WeekBossLevels addNextPackage(final byte value) {
      bitField0_ |= 0x00000001;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public WeekBossLevels addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000001;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public WeekBossLevels setNextPackage(final byte... values) {
      bitField0_ |= 0x00000001;
      nextPackage.copyFrom(values);
      return this;
    }

    /**
     * <code>repeated .WeekBossLevel WeekBossLevels = 1;</code>
     * @return whether the weekBossLevels field is set
     */
    public boolean hasWeekBossLevels() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>repeated .WeekBossLevel WeekBossLevels = 1;</code>
     * @return this
     */
    public WeekBossLevels clearWeekBossLevels() {
      bitField0_ &= ~0x00000002;
      weekBossLevels.clear();
      return this;
    }

    /**
     * <code>repeated .WeekBossLevel WeekBossLevels = 1;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableWeekBossLevels()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<Public.WeekBossLevel> getWeekBossLevels() {
      return weekBossLevels;
    }

    /**
     * <code>repeated .WeekBossLevel WeekBossLevels = 1;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<Public.WeekBossLevel> getMutableWeekBossLevels() {
      bitField0_ |= 0x00000002;
      return weekBossLevels;
    }

    /**
     * <code>repeated .WeekBossLevel WeekBossLevels = 1;</code>
     * @param value the weekBossLevels to add
     * @return this
     */
    public WeekBossLevels addWeekBossLevels(final Public.WeekBossLevel value) {
      bitField0_ |= 0x00000002;
      weekBossLevels.add(value);
      return this;
    }

    /**
     * <code>repeated .WeekBossLevel WeekBossLevels = 1;</code>
     * @param values the weekBossLevels to add
     * @return this
     */
    public WeekBossLevels addAllWeekBossLevels(final Public.WeekBossLevel... values) {
      bitField0_ |= 0x00000002;
      weekBossLevels.addAll(values);
      return this;
    }

    @Override
    public WeekBossLevels copyFrom(final WeekBossLevels other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        nextPackage.copyFrom(other.nextPackage);
        weekBossLevels.copyFrom(other.weekBossLevels);
      }
      return this;
    }

    @Override
    public WeekBossLevels mergeFrom(final WeekBossLevels other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      if (other.hasWeekBossLevels()) {
        getMutableWeekBossLevels().addAll(other.weekBossLevels);
      }
      return this;
    }

    @Override
    public WeekBossLevels clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      weekBossLevels.clear();
      return this;
    }

    @Override
    public WeekBossLevels clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      weekBossLevels.clearQuick();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof WeekBossLevels)) {
        return false;
      }
      WeekBossLevels other = (WeekBossLevels) o;
      return bitField0_ == other.bitField0_
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage))
        && (!hasWeekBossLevels() || weekBossLevels.equals(other.weekBossLevels));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        for (int i = 0; i < weekBossLevels.length(); i++) {
          output.writeRawByte((byte) 10);
          output.writeMessageNoTag(weekBossLevels.get(i));
        }
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += (1 * weekBossLevels.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(weekBossLevels);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public WeekBossLevels mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 10) {
              break;
            }
          }
          case 10: {
            // weekBossLevels
            tag = input.readRepeatedMessage(weekBossLevels, tag);
            bitField0_ |= 0x00000002;
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRepeatedMessage(FieldNames.weekBossLevels, weekBossLevels);
      }
      output.endObject();
    }

    @Override
    public WeekBossLevels mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 1516494448: {
            if (input.isAtField(FieldNames.weekBossLevels)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedMessage(weekBossLevels);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public WeekBossLevels clone() {
      return new WeekBossLevels().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static WeekBossLevels parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new WeekBossLevels(), data).checkInitialized();
    }

    public static WeekBossLevels parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new WeekBossLevels(), input).checkInitialized();
    }

    public static WeekBossLevels parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new WeekBossLevels(), input).checkInitialized();
    }

    /**
     * @return factory for creating WeekBossLevels messages
     */
    public static MessageFactory<WeekBossLevels> getFactory() {
      return WeekBossLevelsFactory.INSTANCE;
    }

    private enum WeekBossLevelsFactory implements MessageFactory<WeekBossLevels> {
      INSTANCE;

      @Override
      public WeekBossLevels create() {
        return WeekBossLevels.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName nextPackage = FieldName.forField("NextPackage");

      static final FieldName weekBossLevels = FieldName.forField("WeekBossLevels");
    }
  }

  /**
   * Protobuf type {@code GmClearAllRegionBossLevel}
   */
  public static final class GmClearAllRegionBossLevel extends ProtoMessage<GmClearAllRegionBossLevel> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional .ChangeInfo Change = 2;</code>
     */
    private final Public.ChangeInfo change = Public.ChangeInfo.newInstance();

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    /**
     * <code>repeated .RegionBossLevel RegionBossLevels = 1;</code>
     */
    private final RepeatedMessage<Public.RegionBossLevel> regionBossLevels = RepeatedMessage.newEmptyInstance(Public.RegionBossLevel.getFactory());

    private GmClearAllRegionBossLevel() {
    }

    /**
     * @return a new empty instance of {@code GmClearAllRegionBossLevel}
     */
    public static GmClearAllRegionBossLevel newInstance() {
      return new GmClearAllRegionBossLevel();
    }

    /**
     * <code>optional .ChangeInfo Change = 2;</code>
     * @return whether the change field is set
     */
    public boolean hasChange() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional .ChangeInfo Change = 2;</code>
     * @return this
     */
    public GmClearAllRegionBossLevel clearChange() {
      bitField0_ &= ~0x00000001;
      change.clear();
      return this;
    }

    /**
     * <code>optional .ChangeInfo Change = 2;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableChange()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public Public.ChangeInfo getChange() {
      return change;
    }

    /**
     * <code>optional .ChangeInfo Change = 2;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public Public.ChangeInfo getMutableChange() {
      bitField0_ |= 0x00000001;
      return change;
    }

    /**
     * <code>optional .ChangeInfo Change = 2;</code>
     * @param value the change to set
     * @return this
     */
    public GmClearAllRegionBossLevel setChange(final Public.ChangeInfo value) {
      bitField0_ |= 0x00000001;
      change.copyFrom(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public GmClearAllRegionBossLevel clearNextPackage() {
      bitField0_ &= ~0x00000002;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000002;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public GmClearAllRegionBossLevel addNextPackage(final byte value) {
      bitField0_ |= 0x00000002;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public GmClearAllRegionBossLevel addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000002;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public GmClearAllRegionBossLevel setNextPackage(final byte... values) {
      bitField0_ |= 0x00000002;
      nextPackage.copyFrom(values);
      return this;
    }

    /**
     * <code>repeated .RegionBossLevel RegionBossLevels = 1;</code>
     * @return whether the regionBossLevels field is set
     */
    public boolean hasRegionBossLevels() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>repeated .RegionBossLevel RegionBossLevels = 1;</code>
     * @return this
     */
    public GmClearAllRegionBossLevel clearRegionBossLevels() {
      bitField0_ &= ~0x00000004;
      regionBossLevels.clear();
      return this;
    }

    /**
     * <code>repeated .RegionBossLevel RegionBossLevels = 1;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableRegionBossLevels()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<Public.RegionBossLevel> getRegionBossLevels() {
      return regionBossLevels;
    }

    /**
     * <code>repeated .RegionBossLevel RegionBossLevels = 1;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<Public.RegionBossLevel> getMutableRegionBossLevels() {
      bitField0_ |= 0x00000004;
      return regionBossLevels;
    }

    /**
     * <code>repeated .RegionBossLevel RegionBossLevels = 1;</code>
     * @param value the regionBossLevels to add
     * @return this
     */
    public GmClearAllRegionBossLevel addRegionBossLevels(final Public.RegionBossLevel value) {
      bitField0_ |= 0x00000004;
      regionBossLevels.add(value);
      return this;
    }

    /**
     * <code>repeated .RegionBossLevel RegionBossLevels = 1;</code>
     * @param values the regionBossLevels to add
     * @return this
     */
    public GmClearAllRegionBossLevel addAllRegionBossLevels(
        final Public.RegionBossLevel... values) {
      bitField0_ |= 0x00000004;
      regionBossLevels.addAll(values);
      return this;
    }

    @Override
    public GmClearAllRegionBossLevel copyFrom(final GmClearAllRegionBossLevel other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        change.copyFrom(other.change);
        nextPackage.copyFrom(other.nextPackage);
        regionBossLevels.copyFrom(other.regionBossLevels);
      }
      return this;
    }

    @Override
    public GmClearAllRegionBossLevel mergeFrom(final GmClearAllRegionBossLevel other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasChange()) {
        getMutableChange().mergeFrom(other.change);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      if (other.hasRegionBossLevels()) {
        getMutableRegionBossLevels().addAll(other.regionBossLevels);
      }
      return this;
    }

    @Override
    public GmClearAllRegionBossLevel clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      change.clear();
      nextPackage.clear();
      regionBossLevels.clear();
      return this;
    }

    @Override
    public GmClearAllRegionBossLevel clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      change.clearQuick();
      nextPackage.clear();
      regionBossLevels.clearQuick();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof GmClearAllRegionBossLevel)) {
        return false;
      }
      GmClearAllRegionBossLevel other = (GmClearAllRegionBossLevel) o;
      return bitField0_ == other.bitField0_
        && (!hasChange() || change.equals(other.change))
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage))
        && (!hasRegionBossLevels() || regionBossLevels.equals(other.regionBossLevels));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 18);
        output.writeMessageNoTag(change);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        for (int i = 0; i < regionBossLevels.length(); i++) {
          output.writeRawByte((byte) 10);
          output.writeMessageNoTag(regionBossLevels.get(i));
        }
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeMessageSizeNoTag(change);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += (1 * regionBossLevels.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(regionBossLevels);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public GmClearAllRegionBossLevel mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 18: {
            // change
            input.readMessage(change);
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 10) {
              break;
            }
          }
          case 10: {
            // regionBossLevels
            tag = input.readRepeatedMessage(regionBossLevels, tag);
            bitField0_ |= 0x00000004;
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeMessage(FieldNames.change, change);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRepeatedMessage(FieldNames.regionBossLevels, regionBossLevels);
      }
      output.endObject();
    }

    @Override
    public GmClearAllRegionBossLevel mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 2017198032: {
            if (input.isAtField(FieldNames.change)) {
              if (!input.trySkipNullValue()) {
                input.readMessage(change);
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -231400080: {
            if (input.isAtField(FieldNames.regionBossLevels)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedMessage(regionBossLevels);
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public GmClearAllRegionBossLevel clone() {
      return new GmClearAllRegionBossLevel().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static GmClearAllRegionBossLevel parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new GmClearAllRegionBossLevel(), data).checkInitialized();
    }

    public static GmClearAllRegionBossLevel parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new GmClearAllRegionBossLevel(), input).checkInitialized();
    }

    public static GmClearAllRegionBossLevel parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new GmClearAllRegionBossLevel(), input).checkInitialized();
    }

    /**
     * @return factory for creating GmClearAllRegionBossLevel messages
     */
    public static MessageFactory<GmClearAllRegionBossLevel> getFactory() {
      return GmClearAllRegionBossLevelFactory.INSTANCE;
    }

    private enum GmClearAllRegionBossLevelFactory implements MessageFactory<GmClearAllRegionBossLevel> {
      INSTANCE;

      @Override
      public GmClearAllRegionBossLevel create() {
        return GmClearAllRegionBossLevel.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName change = FieldName.forField("Change");

      static final FieldName nextPackage = FieldName.forField("NextPackage");

      static final FieldName regionBossLevels = FieldName.forField("RegionBossLevels");
    }
  }

  /**
   * Protobuf type {@code GmClearAllTravelerDue}
   */
  public static final class GmClearAllTravelerDue extends ProtoMessage<GmClearAllTravelerDue> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional .ChangeInfo Change = 2;</code>
     */
    private final Public.ChangeInfo change = Public.ChangeInfo.newInstance();

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    /**
     * <code>repeated .TravelerDuelBossLevel Levels = 1;</code>
     */
    private final RepeatedMessage<Public.TravelerDuelBossLevel> levels = RepeatedMessage.newEmptyInstance(Public.TravelerDuelBossLevel.getFactory());

    private GmClearAllTravelerDue() {
    }

    /**
     * @return a new empty instance of {@code GmClearAllTravelerDue}
     */
    public static GmClearAllTravelerDue newInstance() {
      return new GmClearAllTravelerDue();
    }

    /**
     * <code>optional .ChangeInfo Change = 2;</code>
     * @return whether the change field is set
     */
    public boolean hasChange() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional .ChangeInfo Change = 2;</code>
     * @return this
     */
    public GmClearAllTravelerDue clearChange() {
      bitField0_ &= ~0x00000001;
      change.clear();
      return this;
    }

    /**
     * <code>optional .ChangeInfo Change = 2;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableChange()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public Public.ChangeInfo getChange() {
      return change;
    }

    /**
     * <code>optional .ChangeInfo Change = 2;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public Public.ChangeInfo getMutableChange() {
      bitField0_ |= 0x00000001;
      return change;
    }

    /**
     * <code>optional .ChangeInfo Change = 2;</code>
     * @param value the change to set
     * @return this
     */
    public GmClearAllTravelerDue setChange(final Public.ChangeInfo value) {
      bitField0_ |= 0x00000001;
      change.copyFrom(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public GmClearAllTravelerDue clearNextPackage() {
      bitField0_ &= ~0x00000002;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000002;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public GmClearAllTravelerDue addNextPackage(final byte value) {
      bitField0_ |= 0x00000002;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public GmClearAllTravelerDue addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000002;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public GmClearAllTravelerDue setNextPackage(final byte... values) {
      bitField0_ |= 0x00000002;
      nextPackage.copyFrom(values);
      return this;
    }

    /**
     * <code>repeated .TravelerDuelBossLevel Levels = 1;</code>
     * @return whether the levels field is set
     */
    public boolean hasLevels() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>repeated .TravelerDuelBossLevel Levels = 1;</code>
     * @return this
     */
    public GmClearAllTravelerDue clearLevels() {
      bitField0_ &= ~0x00000004;
      levels.clear();
      return this;
    }

    /**
     * <code>repeated .TravelerDuelBossLevel Levels = 1;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableLevels()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<Public.TravelerDuelBossLevel> getLevels() {
      return levels;
    }

    /**
     * <code>repeated .TravelerDuelBossLevel Levels = 1;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<Public.TravelerDuelBossLevel> getMutableLevels() {
      bitField0_ |= 0x00000004;
      return levels;
    }

    /**
     * <code>repeated .TravelerDuelBossLevel Levels = 1;</code>
     * @param value the levels to add
     * @return this
     */
    public GmClearAllTravelerDue addLevels(final Public.TravelerDuelBossLevel value) {
      bitField0_ |= 0x00000004;
      levels.add(value);
      return this;
    }

    /**
     * <code>repeated .TravelerDuelBossLevel Levels = 1;</code>
     * @param values the levels to add
     * @return this
     */
    public GmClearAllTravelerDue addAllLevels(final Public.TravelerDuelBossLevel... values) {
      bitField0_ |= 0x00000004;
      levels.addAll(values);
      return this;
    }

    @Override
    public GmClearAllTravelerDue copyFrom(final GmClearAllTravelerDue other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        change.copyFrom(other.change);
        nextPackage.copyFrom(other.nextPackage);
        levels.copyFrom(other.levels);
      }
      return this;
    }

    @Override
    public GmClearAllTravelerDue mergeFrom(final GmClearAllTravelerDue other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasChange()) {
        getMutableChange().mergeFrom(other.change);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      if (other.hasLevels()) {
        getMutableLevels().addAll(other.levels);
      }
      return this;
    }

    @Override
    public GmClearAllTravelerDue clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      change.clear();
      nextPackage.clear();
      levels.clear();
      return this;
    }

    @Override
    public GmClearAllTravelerDue clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      change.clearQuick();
      nextPackage.clear();
      levels.clearQuick();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof GmClearAllTravelerDue)) {
        return false;
      }
      GmClearAllTravelerDue other = (GmClearAllTravelerDue) o;
      return bitField0_ == other.bitField0_
        && (!hasChange() || change.equals(other.change))
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage))
        && (!hasLevels() || levels.equals(other.levels));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 18);
        output.writeMessageNoTag(change);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        for (int i = 0; i < levels.length(); i++) {
          output.writeRawByte((byte) 10);
          output.writeMessageNoTag(levels.get(i));
        }
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeMessageSizeNoTag(change);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += (1 * levels.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(levels);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public GmClearAllTravelerDue mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 18: {
            // change
            input.readMessage(change);
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 10) {
              break;
            }
          }
          case 10: {
            // levels
            tag = input.readRepeatedMessage(levels, tag);
            bitField0_ |= 0x00000004;
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeMessage(FieldNames.change, change);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRepeatedMessage(FieldNames.levels, levels);
      }
      output.endObject();
    }

    @Override
    public GmClearAllTravelerDue mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 2017198032: {
            if (input.isAtField(FieldNames.change)) {
              if (!input.trySkipNullValue()) {
                input.readMessage(change);
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2022260337: {
            if (input.isAtField(FieldNames.levels)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedMessage(levels);
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public GmClearAllTravelerDue clone() {
      return new GmClearAllTravelerDue().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static GmClearAllTravelerDue parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new GmClearAllTravelerDue(), data).checkInitialized();
    }

    public static GmClearAllTravelerDue parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new GmClearAllTravelerDue(), input).checkInitialized();
    }

    public static GmClearAllTravelerDue parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new GmClearAllTravelerDue(), input).checkInitialized();
    }

    /**
     * @return factory for creating GmClearAllTravelerDue messages
     */
    public static MessageFactory<GmClearAllTravelerDue> getFactory() {
      return GmClearAllTravelerDueFactory.INSTANCE;
    }

    private enum GmClearAllTravelerDueFactory implements MessageFactory<GmClearAllTravelerDue> {
      INSTANCE;

      @Override
      public GmClearAllTravelerDue create() {
        return GmClearAllTravelerDue.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName change = FieldName.forField("Change");

      static final FieldName nextPackage = FieldName.forField("NextPackage");

      static final FieldName levels = FieldName.forField("Levels");
    }
  }

  /**
   * Protobuf type {@code GmClearAllSkillInstance}
   */
  public static final class GmClearAllSkillInstance extends ProtoMessage<GmClearAllSkillInstance> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    /**
     * <code>repeated .SkillInstance SkillInstances = 1;</code>
     */
    private final RepeatedMessage<Public.SkillInstance> skillInstances = RepeatedMessage.newEmptyInstance(Public.SkillInstance.getFactory());

    private GmClearAllSkillInstance() {
    }

    /**
     * @return a new empty instance of {@code GmClearAllSkillInstance}
     */
    public static GmClearAllSkillInstance newInstance() {
      return new GmClearAllSkillInstance();
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public GmClearAllSkillInstance clearNextPackage() {
      bitField0_ &= ~0x00000001;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000001;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public GmClearAllSkillInstance addNextPackage(final byte value) {
      bitField0_ |= 0x00000001;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public GmClearAllSkillInstance addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000001;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public GmClearAllSkillInstance setNextPackage(final byte... values) {
      bitField0_ |= 0x00000001;
      nextPackage.copyFrom(values);
      return this;
    }

    /**
     * <code>repeated .SkillInstance SkillInstances = 1;</code>
     * @return whether the skillInstances field is set
     */
    public boolean hasSkillInstances() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>repeated .SkillInstance SkillInstances = 1;</code>
     * @return this
     */
    public GmClearAllSkillInstance clearSkillInstances() {
      bitField0_ &= ~0x00000002;
      skillInstances.clear();
      return this;
    }

    /**
     * <code>repeated .SkillInstance SkillInstances = 1;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableSkillInstances()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<Public.SkillInstance> getSkillInstances() {
      return skillInstances;
    }

    /**
     * <code>repeated .SkillInstance SkillInstances = 1;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<Public.SkillInstance> getMutableSkillInstances() {
      bitField0_ |= 0x00000002;
      return skillInstances;
    }

    /**
     * <code>repeated .SkillInstance SkillInstances = 1;</code>
     * @param value the skillInstances to add
     * @return this
     */
    public GmClearAllSkillInstance addSkillInstances(final Public.SkillInstance value) {
      bitField0_ |= 0x00000002;
      skillInstances.add(value);
      return this;
    }

    /**
     * <code>repeated .SkillInstance SkillInstances = 1;</code>
     * @param values the skillInstances to add
     * @return this
     */
    public GmClearAllSkillInstance addAllSkillInstances(final Public.SkillInstance... values) {
      bitField0_ |= 0x00000002;
      skillInstances.addAll(values);
      return this;
    }

    @Override
    public GmClearAllSkillInstance copyFrom(final GmClearAllSkillInstance other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        nextPackage.copyFrom(other.nextPackage);
        skillInstances.copyFrom(other.skillInstances);
      }
      return this;
    }

    @Override
    public GmClearAllSkillInstance mergeFrom(final GmClearAllSkillInstance other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      if (other.hasSkillInstances()) {
        getMutableSkillInstances().addAll(other.skillInstances);
      }
      return this;
    }

    @Override
    public GmClearAllSkillInstance clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      skillInstances.clear();
      return this;
    }

    @Override
    public GmClearAllSkillInstance clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      skillInstances.clearQuick();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof GmClearAllSkillInstance)) {
        return false;
      }
      GmClearAllSkillInstance other = (GmClearAllSkillInstance) o;
      return bitField0_ == other.bitField0_
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage))
        && (!hasSkillInstances() || skillInstances.equals(other.skillInstances));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        for (int i = 0; i < skillInstances.length(); i++) {
          output.writeRawByte((byte) 10);
          output.writeMessageNoTag(skillInstances.get(i));
        }
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += (1 * skillInstances.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(skillInstances);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public GmClearAllSkillInstance mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 10) {
              break;
            }
          }
          case 10: {
            // skillInstances
            tag = input.readRepeatedMessage(skillInstances, tag);
            bitField0_ |= 0x00000002;
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRepeatedMessage(FieldNames.skillInstances, skillInstances);
      }
      output.endObject();
    }

    @Override
    public GmClearAllSkillInstance mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 1814965069: {
            if (input.isAtField(FieldNames.skillInstances)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedMessage(skillInstances);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public GmClearAllSkillInstance clone() {
      return new GmClearAllSkillInstance().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static GmClearAllSkillInstance parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new GmClearAllSkillInstance(), data).checkInitialized();
    }

    public static GmClearAllSkillInstance parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new GmClearAllSkillInstance(), input).checkInitialized();
    }

    public static GmClearAllSkillInstance parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new GmClearAllSkillInstance(), input).checkInitialized();
    }

    /**
     * @return factory for creating GmClearAllSkillInstance messages
     */
    public static MessageFactory<GmClearAllSkillInstance> getFactory() {
      return GmClearAllSkillInstanceFactory.INSTANCE;
    }

    private enum GmClearAllSkillInstanceFactory implements MessageFactory<GmClearAllSkillInstance> {
      INSTANCE;

      @Override
      public GmClearAllSkillInstance create() {
        return GmClearAllSkillInstance.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName nextPackage = FieldName.forField("NextPackage");

      static final FieldName skillInstances = FieldName.forField("SkillInstances");
    }
  }

  /**
   * Protobuf type {@code CharAffinity}
   */
  public static final class CharAffinity extends ProtoMessage<CharAffinity> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional .AffinityInfo Info = 1;</code>
     */
    private final Public.AffinityInfo info = Public.AffinityInfo.newInstance();

    /**
     * <code>optional .ChangeInfo Change = 2;</code>
     */
    private final Public.ChangeInfo change = Public.ChangeInfo.newInstance();

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    private CharAffinity() {
    }

    /**
     * @return a new empty instance of {@code CharAffinity}
     */
    public static CharAffinity newInstance() {
      return new CharAffinity();
    }

    /**
     * <code>optional .AffinityInfo Info = 1;</code>
     * @return whether the info field is set
     */
    public boolean hasInfo() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional .AffinityInfo Info = 1;</code>
     * @return this
     */
    public CharAffinity clearInfo() {
      bitField0_ &= ~0x00000001;
      info.clear();
      return this;
    }

    /**
     * <code>optional .AffinityInfo Info = 1;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableInfo()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public Public.AffinityInfo getInfo() {
      return info;
    }

    /**
     * <code>optional .AffinityInfo Info = 1;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public Public.AffinityInfo getMutableInfo() {
      bitField0_ |= 0x00000001;
      return info;
    }

    /**
     * <code>optional .AffinityInfo Info = 1;</code>
     * @param value the info to set
     * @return this
     */
    public CharAffinity setInfo(final Public.AffinityInfo value) {
      bitField0_ |= 0x00000001;
      info.copyFrom(value);
      return this;
    }

    /**
     * <code>optional .ChangeInfo Change = 2;</code>
     * @return whether the change field is set
     */
    public boolean hasChange() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional .ChangeInfo Change = 2;</code>
     * @return this
     */
    public CharAffinity clearChange() {
      bitField0_ &= ~0x00000002;
      change.clear();
      return this;
    }

    /**
     * <code>optional .ChangeInfo Change = 2;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableChange()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public Public.ChangeInfo getChange() {
      return change;
    }

    /**
     * <code>optional .ChangeInfo Change = 2;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public Public.ChangeInfo getMutableChange() {
      bitField0_ |= 0x00000002;
      return change;
    }

    /**
     * <code>optional .ChangeInfo Change = 2;</code>
     * @param value the change to set
     * @return this
     */
    public CharAffinity setChange(final Public.ChangeInfo value) {
      bitField0_ |= 0x00000002;
      change.copyFrom(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public CharAffinity clearNextPackage() {
      bitField0_ &= ~0x00000004;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000004;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public CharAffinity addNextPackage(final byte value) {
      bitField0_ |= 0x00000004;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public CharAffinity addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000004;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public CharAffinity setNextPackage(final byte... values) {
      bitField0_ |= 0x00000004;
      nextPackage.copyFrom(values);
      return this;
    }

    @Override
    public CharAffinity copyFrom(final CharAffinity other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        info.copyFrom(other.info);
        change.copyFrom(other.change);
        nextPackage.copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public CharAffinity mergeFrom(final CharAffinity other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasInfo()) {
        getMutableInfo().mergeFrom(other.info);
      }
      if (other.hasChange()) {
        getMutableChange().mergeFrom(other.change);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public CharAffinity clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      info.clear();
      change.clear();
      nextPackage.clear();
      return this;
    }

    @Override
    public CharAffinity clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      info.clearQuick();
      change.clearQuick();
      nextPackage.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof CharAffinity)) {
        return false;
      }
      CharAffinity other = (CharAffinity) o;
      return bitField0_ == other.bitField0_
        && (!hasInfo() || info.equals(other.info))
        && (!hasChange() || change.equals(other.change))
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 10);
        output.writeMessageNoTag(info);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 18);
        output.writeMessageNoTag(change);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeMessageSizeNoTag(info);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeMessageSizeNoTag(change);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public CharAffinity mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 10: {
            // info
            input.readMessage(info);
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 18) {
              break;
            }
          }
          case 18: {
            // change
            input.readMessage(change);
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeMessage(FieldNames.info, info);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeMessage(FieldNames.change, change);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      output.endObject();
    }

    @Override
    public CharAffinity mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 2283726: {
            if (input.isAtField(FieldNames.info)) {
              if (!input.trySkipNullValue()) {
                input.readMessage(info);
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 2017198032: {
            if (input.isAtField(FieldNames.change)) {
              if (!input.trySkipNullValue()) {
                input.readMessage(change);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public CharAffinity clone() {
      return new CharAffinity().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static CharAffinity parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new CharAffinity(), data).checkInitialized();
    }

    public static CharAffinity parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new CharAffinity(), input).checkInitialized();
    }

    public static CharAffinity parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new CharAffinity(), input).checkInitialized();
    }

    /**
     * @return factory for creating CharAffinity messages
     */
    public static MessageFactory<CharAffinity> getFactory() {
      return CharAffinityFactory.INSTANCE;
    }

    private enum CharAffinityFactory implements MessageFactory<CharAffinity> {
      INSTANCE;

      @Override
      public CharAffinity create() {
        return CharAffinity.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName info = FieldName.forField("Info");

      static final FieldName change = FieldName.forField("Change");

      static final FieldName nextPackage = FieldName.forField("NextPackage");
    }
  }

  /**
   * Protobuf type {@code GmSTClearAllStarTower}
   */
  public static final class GmSTClearAllStarTower extends ProtoMessage<GmSTClearAllStarTower> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    /**
     * <code>repeated uint32 Ids = 1;</code>
     */
    private final RepeatedInt ids = RepeatedInt.newEmptyInstance();

    private GmSTClearAllStarTower() {
    }

    /**
     * @return a new empty instance of {@code GmSTClearAllStarTower}
     */
    public static GmSTClearAllStarTower newInstance() {
      return new GmSTClearAllStarTower();
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public GmSTClearAllStarTower clearNextPackage() {
      bitField0_ &= ~0x00000001;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000001;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public GmSTClearAllStarTower addNextPackage(final byte value) {
      bitField0_ |= 0x00000001;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public GmSTClearAllStarTower addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000001;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public GmSTClearAllStarTower setNextPackage(final byte... values) {
      bitField0_ |= 0x00000001;
      nextPackage.copyFrom(values);
      return this;
    }

    /**
     * <code>repeated uint32 Ids = 1;</code>
     * @return whether the ids field is set
     */
    public boolean hasIds() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>repeated uint32 Ids = 1;</code>
     * @return this
     */
    public GmSTClearAllStarTower clearIds() {
      bitField0_ &= ~0x00000002;
      ids.clear();
      return this;
    }

    /**
     * <code>repeated uint32 Ids = 1;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableIds()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedInt getIds() {
      return ids;
    }

    /**
     * <code>repeated uint32 Ids = 1;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedInt getMutableIds() {
      bitField0_ |= 0x00000002;
      return ids;
    }

    /**
     * <code>repeated uint32 Ids = 1;</code>
     * @param value the ids to add
     * @return this
     */
    public GmSTClearAllStarTower addIds(final int value) {
      bitField0_ |= 0x00000002;
      ids.add(value);
      return this;
    }

    /**
     * <code>repeated uint32 Ids = 1;</code>
     * @param values the ids to add
     * @return this
     */
    public GmSTClearAllStarTower addAllIds(final int... values) {
      bitField0_ |= 0x00000002;
      ids.addAll(values);
      return this;
    }

    @Override
    public GmSTClearAllStarTower copyFrom(final GmSTClearAllStarTower other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        nextPackage.copyFrom(other.nextPackage);
        ids.copyFrom(other.ids);
      }
      return this;
    }

    @Override
    public GmSTClearAllStarTower mergeFrom(final GmSTClearAllStarTower other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      if (other.hasIds()) {
        getMutableIds().addAll(other.ids);
      }
      return this;
    }

    @Override
    public GmSTClearAllStarTower clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      ids.clear();
      return this;
    }

    @Override
    public GmSTClearAllStarTower clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      ids.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof GmSTClearAllStarTower)) {
        return false;
      }
      GmSTClearAllStarTower other = (GmSTClearAllStarTower) o;
      return bitField0_ == other.bitField0_
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage))
        && (!hasIds() || ids.equals(other.ids));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        for (int i = 0; i < ids.length(); i++) {
          output.writeRawByte((byte) 8);
          output.writeUInt32NoTag(ids.array()[i]);
        }
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += (1 * ids.length()) + ProtoSink.computeRepeatedUInt32SizeNoTag(ids);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public GmSTClearAllStarTower mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 10) {
              break;
            }
          }
          case 10: {
            // ids [packed=true]
            input.readPackedUInt32(ids, tag);
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
          case 8: {
            // ids [packed=false]
            tag = input.readRepeatedUInt32(ids, tag);
            bitField0_ |= 0x00000002;
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRepeatedUInt32(FieldNames.ids, ids);
      }
      output.endObject();
    }

    @Override
    public GmSTClearAllStarTower mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 73368: {
            if (input.isAtField(FieldNames.ids)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedUInt32(ids);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public GmSTClearAllStarTower clone() {
      return new GmSTClearAllStarTower().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static GmSTClearAllStarTower parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new GmSTClearAllStarTower(), data).checkInitialized();
    }

    public static GmSTClearAllStarTower parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new GmSTClearAllStarTower(), input).checkInitialized();
    }

    public static GmSTClearAllStarTower parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new GmSTClearAllStarTower(), input).checkInitialized();
    }

    /**
     * @return factory for creating GmSTClearAllStarTower messages
     */
    public static MessageFactory<GmSTClearAllStarTower> getFactory() {
      return GmSTClearAllStarTowerFactory.INSTANCE;
    }

    private enum GmSTClearAllStarTowerFactory implements MessageFactory<GmSTClearAllStarTower> {
      INSTANCE;

      @Override
      public GmSTClearAllStarTower create() {
        return GmSTClearAllStarTower.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName nextPackage = FieldName.forField("NextPackage");

      static final FieldName ids = FieldName.forField("Ids");
    }
  }

  /**
   * Protobuf type {@code STAddTeamExpNtf}
   */
  public static final class STAddTeamExpNtf extends ProtoMessage<STAddTeamExpNtf> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional uint32 Level = 1;</code>
     */
    private int level;

    /**
     * <code>optional uint32 Exp = 2;</code>
     */
    private int exp;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    /**
     * <code>repeated .StarTowerRoomCase Cases = 3;</code>
     */
    private final RepeatedMessage<PublicStarTower.StarTowerRoomCase> cases = RepeatedMessage.newEmptyInstance(PublicStarTower.StarTowerRoomCase.getFactory());

    private STAddTeamExpNtf() {
    }

    /**
     * @return a new empty instance of {@code STAddTeamExpNtf}
     */
    public static STAddTeamExpNtf newInstance() {
      return new STAddTeamExpNtf();
    }

    /**
     * <code>optional uint32 Level = 1;</code>
     * @return whether the level field is set
     */
    public boolean hasLevel() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional uint32 Level = 1;</code>
     * @return this
     */
    public STAddTeamExpNtf clearLevel() {
      bitField0_ &= ~0x00000001;
      level = 0;
      return this;
    }

    /**
     * <code>optional uint32 Level = 1;</code>
     * @return the level
     */
    public int getLevel() {
      return level;
    }

    /**
     * <code>optional uint32 Level = 1;</code>
     * @param value the level to set
     * @return this
     */
    public STAddTeamExpNtf setLevel(final int value) {
      bitField0_ |= 0x00000001;
      level = value;
      return this;
    }

    /**
     * <code>optional uint32 Exp = 2;</code>
     * @return whether the exp field is set
     */
    public boolean hasExp() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional uint32 Exp = 2;</code>
     * @return this
     */
    public STAddTeamExpNtf clearExp() {
      bitField0_ &= ~0x00000002;
      exp = 0;
      return this;
    }

    /**
     * <code>optional uint32 Exp = 2;</code>
     * @return the exp
     */
    public int getExp() {
      return exp;
    }

    /**
     * <code>optional uint32 Exp = 2;</code>
     * @param value the exp to set
     * @return this
     */
    public STAddTeamExpNtf setExp(final int value) {
      bitField0_ |= 0x00000002;
      exp = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public STAddTeamExpNtf clearNextPackage() {
      bitField0_ &= ~0x00000004;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000004;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public STAddTeamExpNtf addNextPackage(final byte value) {
      bitField0_ |= 0x00000004;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public STAddTeamExpNtf addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000004;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public STAddTeamExpNtf setNextPackage(final byte... values) {
      bitField0_ |= 0x00000004;
      nextPackage.copyFrom(values);
      return this;
    }

    /**
     * <code>repeated .StarTowerRoomCase Cases = 3;</code>
     * @return whether the cases field is set
     */
    public boolean hasCases() {
      return (bitField0_ & 0x00000008) != 0;
    }

    /**
     * <code>repeated .StarTowerRoomCase Cases = 3;</code>
     * @return this
     */
    public STAddTeamExpNtf clearCases() {
      bitField0_ &= ~0x00000008;
      cases.clear();
      return this;
    }

    /**
     * <code>repeated .StarTowerRoomCase Cases = 3;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableCases()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<PublicStarTower.StarTowerRoomCase> getCases() {
      return cases;
    }

    /**
     * <code>repeated .StarTowerRoomCase Cases = 3;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<PublicStarTower.StarTowerRoomCase> getMutableCases() {
      bitField0_ |= 0x00000008;
      return cases;
    }

    /**
     * <code>repeated .StarTowerRoomCase Cases = 3;</code>
     * @param value the cases to add
     * @return this
     */
    public STAddTeamExpNtf addCases(final PublicStarTower.StarTowerRoomCase value) {
      bitField0_ |= 0x00000008;
      cases.add(value);
      return this;
    }

    /**
     * <code>repeated .StarTowerRoomCase Cases = 3;</code>
     * @param values the cases to add
     * @return this
     */
    public STAddTeamExpNtf addAllCases(final PublicStarTower.StarTowerRoomCase... values) {
      bitField0_ |= 0x00000008;
      cases.addAll(values);
      return this;
    }

    @Override
    public STAddTeamExpNtf copyFrom(final STAddTeamExpNtf other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        level = other.level;
        exp = other.exp;
        nextPackage.copyFrom(other.nextPackage);
        cases.copyFrom(other.cases);
      }
      return this;
    }

    @Override
    public STAddTeamExpNtf mergeFrom(final STAddTeamExpNtf other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasLevel()) {
        setLevel(other.level);
      }
      if (other.hasExp()) {
        setExp(other.exp);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      if (other.hasCases()) {
        getMutableCases().addAll(other.cases);
      }
      return this;
    }

    @Override
    public STAddTeamExpNtf clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      level = 0;
      exp = 0;
      nextPackage.clear();
      cases.clear();
      return this;
    }

    @Override
    public STAddTeamExpNtf clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      cases.clearQuick();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof STAddTeamExpNtf)) {
        return false;
      }
      STAddTeamExpNtf other = (STAddTeamExpNtf) o;
      return bitField0_ == other.bitField0_
        && (!hasLevel() || level == other.level)
        && (!hasExp() || exp == other.exp)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage))
        && (!hasCases() || cases.equals(other.cases));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt32NoTag(level);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 16);
        output.writeUInt32NoTag(exp);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        for (int i = 0; i < cases.length(); i++) {
          output.writeRawByte((byte) 26);
          output.writeMessageNoTag(cases.get(i));
        }
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(level);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(exp);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        size += (1 * cases.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(cases);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public STAddTeamExpNtf mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            // level
            level = input.readUInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 16) {
              break;
            }
          }
          case 16: {
            // exp
            exp = input.readUInt32();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 26) {
              break;
            }
          }
          case 26: {
            // cases
            tag = input.readRepeatedMessage(cases, tag);
            bitField0_ |= 0x00000008;
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeUInt32(FieldNames.level, level);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeUInt32(FieldNames.exp, exp);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeRepeatedMessage(FieldNames.cases, cases);
      }
      output.endObject();
    }

    @Override
    public STAddTeamExpNtf mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 73313124: {
            if (input.isAtField(FieldNames.level)) {
              if (!input.trySkipNullValue()) {
                level = input.readUInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 70141: {
            if (input.isAtField(FieldNames.exp)) {
              if (!input.trySkipNullValue()) {
                exp = input.readUInt32();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 64879395: {
            if (input.isAtField(FieldNames.cases)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedMessage(cases);
                bitField0_ |= 0x00000008;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public STAddTeamExpNtf clone() {
      return new STAddTeamExpNtf().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static STAddTeamExpNtf parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new STAddTeamExpNtf(), data).checkInitialized();
    }

    public static STAddTeamExpNtf parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new STAddTeamExpNtf(), input).checkInitialized();
    }

    public static STAddTeamExpNtf parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new STAddTeamExpNtf(), input).checkInitialized();
    }

    /**
     * @return factory for creating STAddTeamExpNtf messages
     */
    public static MessageFactory<STAddTeamExpNtf> getFactory() {
      return STAddTeamExpNtfFactory.INSTANCE;
    }

    private enum STAddTeamExpNtfFactory implements MessageFactory<STAddTeamExpNtf> {
      INSTANCE;

      @Override
      public STAddTeamExpNtf create() {
        return STAddTeamExpNtf.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName level = FieldName.forField("Level");

      static final FieldName exp = FieldName.forField("Exp");

      static final FieldName nextPackage = FieldName.forField("NextPackage");

      static final FieldName cases = FieldName.forField("Cases");
    }
  }

  /**
   * Protobuf type {@code GmClearAllEquipmentInstance}
   */
  public static final class GmClearAllEquipmentInstance extends ProtoMessage<GmClearAllEquipmentInstance> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional .ChangeInfo Change = 2;</code>
     */
    private final Public.ChangeInfo change = Public.ChangeInfo.newInstance();

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    /**
     * <code>repeated .EquipmentInstance EquipmentInstances = 1;</code>
     */
    private final RepeatedMessage<Public.EquipmentInstance> equipmentInstances = RepeatedMessage.newEmptyInstance(Public.EquipmentInstance.getFactory());

    private GmClearAllEquipmentInstance() {
    }

    /**
     * @return a new empty instance of {@code GmClearAllEquipmentInstance}
     */
    public static GmClearAllEquipmentInstance newInstance() {
      return new GmClearAllEquipmentInstance();
    }

    /**
     * <code>optional .ChangeInfo Change = 2;</code>
     * @return whether the change field is set
     */
    public boolean hasChange() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional .ChangeInfo Change = 2;</code>
     * @return this
     */
    public GmClearAllEquipmentInstance clearChange() {
      bitField0_ &= ~0x00000001;
      change.clear();
      return this;
    }

    /**
     * <code>optional .ChangeInfo Change = 2;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableChange()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public Public.ChangeInfo getChange() {
      return change;
    }

    /**
     * <code>optional .ChangeInfo Change = 2;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public Public.ChangeInfo getMutableChange() {
      bitField0_ |= 0x00000001;
      return change;
    }

    /**
     * <code>optional .ChangeInfo Change = 2;</code>
     * @param value the change to set
     * @return this
     */
    public GmClearAllEquipmentInstance setChange(final Public.ChangeInfo value) {
      bitField0_ |= 0x00000001;
      change.copyFrom(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public GmClearAllEquipmentInstance clearNextPackage() {
      bitField0_ &= ~0x00000002;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000002;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public GmClearAllEquipmentInstance addNextPackage(final byte value) {
      bitField0_ |= 0x00000002;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public GmClearAllEquipmentInstance addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000002;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public GmClearAllEquipmentInstance setNextPackage(final byte... values) {
      bitField0_ |= 0x00000002;
      nextPackage.copyFrom(values);
      return this;
    }

    /**
     * <code>repeated .EquipmentInstance EquipmentInstances = 1;</code>
     * @return whether the equipmentInstances field is set
     */
    public boolean hasEquipmentInstances() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>repeated .EquipmentInstance EquipmentInstances = 1;</code>
     * @return this
     */
    public GmClearAllEquipmentInstance clearEquipmentInstances() {
      bitField0_ &= ~0x00000004;
      equipmentInstances.clear();
      return this;
    }

    /**
     * <code>repeated .EquipmentInstance EquipmentInstances = 1;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableEquipmentInstances()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<Public.EquipmentInstance> getEquipmentInstances() {
      return equipmentInstances;
    }

    /**
     * <code>repeated .EquipmentInstance EquipmentInstances = 1;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<Public.EquipmentInstance> getMutableEquipmentInstances() {
      bitField0_ |= 0x00000004;
      return equipmentInstances;
    }

    /**
     * <code>repeated .EquipmentInstance EquipmentInstances = 1;</code>
     * @param value the equipmentInstances to add
     * @return this
     */
    public GmClearAllEquipmentInstance addEquipmentInstances(final Public.EquipmentInstance value) {
      bitField0_ |= 0x00000004;
      equipmentInstances.add(value);
      return this;
    }

    /**
     * <code>repeated .EquipmentInstance EquipmentInstances = 1;</code>
     * @param values the equipmentInstances to add
     * @return this
     */
    public GmClearAllEquipmentInstance addAllEquipmentInstances(
        final Public.EquipmentInstance... values) {
      bitField0_ |= 0x00000004;
      equipmentInstances.addAll(values);
      return this;
    }

    @Override
    public GmClearAllEquipmentInstance copyFrom(final GmClearAllEquipmentInstance other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        change.copyFrom(other.change);
        nextPackage.copyFrom(other.nextPackage);
        equipmentInstances.copyFrom(other.equipmentInstances);
      }
      return this;
    }

    @Override
    public GmClearAllEquipmentInstance mergeFrom(final GmClearAllEquipmentInstance other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasChange()) {
        getMutableChange().mergeFrom(other.change);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      if (other.hasEquipmentInstances()) {
        getMutableEquipmentInstances().addAll(other.equipmentInstances);
      }
      return this;
    }

    @Override
    public GmClearAllEquipmentInstance clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      change.clear();
      nextPackage.clear();
      equipmentInstances.clear();
      return this;
    }

    @Override
    public GmClearAllEquipmentInstance clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      change.clearQuick();
      nextPackage.clear();
      equipmentInstances.clearQuick();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof GmClearAllEquipmentInstance)) {
        return false;
      }
      GmClearAllEquipmentInstance other = (GmClearAllEquipmentInstance) o;
      return bitField0_ == other.bitField0_
        && (!hasChange() || change.equals(other.change))
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage))
        && (!hasEquipmentInstances() || equipmentInstances.equals(other.equipmentInstances));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 18);
        output.writeMessageNoTag(change);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        for (int i = 0; i < equipmentInstances.length(); i++) {
          output.writeRawByte((byte) 10);
          output.writeMessageNoTag(equipmentInstances.get(i));
        }
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeMessageSizeNoTag(change);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += (1 * equipmentInstances.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(equipmentInstances);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public GmClearAllEquipmentInstance mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 18: {
            // change
            input.readMessage(change);
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 10) {
              break;
            }
          }
          case 10: {
            // equipmentInstances
            tag = input.readRepeatedMessage(equipmentInstances, tag);
            bitField0_ |= 0x00000004;
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeMessage(FieldNames.change, change);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRepeatedMessage(FieldNames.equipmentInstances, equipmentInstances);
      }
      output.endObject();
    }

    @Override
    public GmClearAllEquipmentInstance mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 2017198032: {
            if (input.isAtField(FieldNames.change)) {
              if (!input.trySkipNullValue()) {
                input.readMessage(change);
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 362304688: {
            if (input.isAtField(FieldNames.equipmentInstances)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedMessage(equipmentInstances);
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public GmClearAllEquipmentInstance clone() {
      return new GmClearAllEquipmentInstance().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static GmClearAllEquipmentInstance parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new GmClearAllEquipmentInstance(), data).checkInitialized();
    }

    public static GmClearAllEquipmentInstance parseFrom(final ProtoSource input) throws
        IOException {
      return ProtoMessage.mergeFrom(new GmClearAllEquipmentInstance(), input).checkInitialized();
    }

    public static GmClearAllEquipmentInstance parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new GmClearAllEquipmentInstance(), input).checkInitialized();
    }

    /**
     * @return factory for creating GmClearAllEquipmentInstance messages
     */
    public static MessageFactory<GmClearAllEquipmentInstance> getFactory() {
      return GmClearAllEquipmentInstanceFactory.INSTANCE;
    }

    private enum GmClearAllEquipmentInstanceFactory implements MessageFactory<GmClearAllEquipmentInstance> {
      INSTANCE;

      @Override
      public GmClearAllEquipmentInstance create() {
        return GmClearAllEquipmentInstance.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName change = FieldName.forField("Change");

      static final FieldName nextPackage = FieldName.forField("NextPackage");

      static final FieldName equipmentInstances = FieldName.forField("EquipmentInstances");
    }
  }

  /**
   * Protobuf type {@code GmAllInfinityTowerInfos}
   */
  public static final class GmAllInfinityTowerInfos extends ProtoMessage<GmAllInfinityTowerInfos> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    /**
     * <code>repeated .InfinityTowerLevelInfo Infos = 1;</code>
     */
    private final RepeatedMessage<Public.InfinityTowerLevelInfo> infos = RepeatedMessage.newEmptyInstance(Public.InfinityTowerLevelInfo.getFactory());

    private GmAllInfinityTowerInfos() {
    }

    /**
     * @return a new empty instance of {@code GmAllInfinityTowerInfos}
     */
    public static GmAllInfinityTowerInfos newInstance() {
      return new GmAllInfinityTowerInfos();
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public GmAllInfinityTowerInfos clearNextPackage() {
      bitField0_ &= ~0x00000001;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000001;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public GmAllInfinityTowerInfos addNextPackage(final byte value) {
      bitField0_ |= 0x00000001;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public GmAllInfinityTowerInfos addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000001;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public GmAllInfinityTowerInfos setNextPackage(final byte... values) {
      bitField0_ |= 0x00000001;
      nextPackage.copyFrom(values);
      return this;
    }

    /**
     * <code>repeated .InfinityTowerLevelInfo Infos = 1;</code>
     * @return whether the infos field is set
     */
    public boolean hasInfos() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>repeated .InfinityTowerLevelInfo Infos = 1;</code>
     * @return this
     */
    public GmAllInfinityTowerInfos clearInfos() {
      bitField0_ &= ~0x00000002;
      infos.clear();
      return this;
    }

    /**
     * <code>repeated .InfinityTowerLevelInfo Infos = 1;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableInfos()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<Public.InfinityTowerLevelInfo> getInfos() {
      return infos;
    }

    /**
     * <code>repeated .InfinityTowerLevelInfo Infos = 1;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<Public.InfinityTowerLevelInfo> getMutableInfos() {
      bitField0_ |= 0x00000002;
      return infos;
    }

    /**
     * <code>repeated .InfinityTowerLevelInfo Infos = 1;</code>
     * @param value the infos to add
     * @return this
     */
    public GmAllInfinityTowerInfos addInfos(final Public.InfinityTowerLevelInfo value) {
      bitField0_ |= 0x00000002;
      infos.add(value);
      return this;
    }

    /**
     * <code>repeated .InfinityTowerLevelInfo Infos = 1;</code>
     * @param values the infos to add
     * @return this
     */
    public GmAllInfinityTowerInfos addAllInfos(final Public.InfinityTowerLevelInfo... values) {
      bitField0_ |= 0x00000002;
      infos.addAll(values);
      return this;
    }

    @Override
    public GmAllInfinityTowerInfos copyFrom(final GmAllInfinityTowerInfos other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        nextPackage.copyFrom(other.nextPackage);
        infos.copyFrom(other.infos);
      }
      return this;
    }

    @Override
    public GmAllInfinityTowerInfos mergeFrom(final GmAllInfinityTowerInfos other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      if (other.hasInfos()) {
        getMutableInfos().addAll(other.infos);
      }
      return this;
    }

    @Override
    public GmAllInfinityTowerInfos clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      infos.clear();
      return this;
    }

    @Override
    public GmAllInfinityTowerInfos clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      infos.clearQuick();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof GmAllInfinityTowerInfos)) {
        return false;
      }
      GmAllInfinityTowerInfos other = (GmAllInfinityTowerInfos) o;
      return bitField0_ == other.bitField0_
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage))
        && (!hasInfos() || infos.equals(other.infos));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        for (int i = 0; i < infos.length(); i++) {
          output.writeRawByte((byte) 10);
          output.writeMessageNoTag(infos.get(i));
        }
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += (1 * infos.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(infos);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public GmAllInfinityTowerInfos mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 10) {
              break;
            }
          }
          case 10: {
            // infos
            tag = input.readRepeatedMessage(infos, tag);
            bitField0_ |= 0x00000002;
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRepeatedMessage(FieldNames.infos, infos);
      }
      output.endObject();
    }

    @Override
    public GmAllInfinityTowerInfos mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 70795621: {
            if (input.isAtField(FieldNames.infos)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedMessage(infos);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public GmAllInfinityTowerInfos clone() {
      return new GmAllInfinityTowerInfos().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static GmAllInfinityTowerInfos parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new GmAllInfinityTowerInfos(), data).checkInitialized();
    }

    public static GmAllInfinityTowerInfos parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new GmAllInfinityTowerInfos(), input).checkInitialized();
    }

    public static GmAllInfinityTowerInfos parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new GmAllInfinityTowerInfos(), input).checkInitialized();
    }

    /**
     * @return factory for creating GmAllInfinityTowerInfos messages
     */
    public static MessageFactory<GmAllInfinityTowerInfos> getFactory() {
      return GmAllInfinityTowerInfosFactory.INSTANCE;
    }

    private enum GmAllInfinityTowerInfosFactory implements MessageFactory<GmAllInfinityTowerInfos> {
      INSTANCE;

      @Override
      public GmAllInfinityTowerInfos create() {
        return GmAllInfinityTowerInfos.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName nextPackage = FieldName.forField("NextPackage");

      static final FieldName infos = FieldName.forField("Infos");
    }
  }

  /**
   * Protobuf type {@code GmStory}
   */
  public static final class GmStory extends ProtoMessage<GmStory> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional .ChangeInfo Change = 3;</code>
     */
    private final Public.ChangeInfo change = Public.ChangeInfo.newInstance();

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    /**
     * <code>repeated uint32 Evidences = 1;</code>
     */
    private final RepeatedInt evidences = RepeatedInt.newEmptyInstance();

    /**
     * <code>repeated .Story Stories = 2;</code>
     */
    private final RepeatedMessage<Public.Story> stories = RepeatedMessage.newEmptyInstance(Public.Story.getFactory());

    private GmStory() {
    }

    /**
     * @return a new empty instance of {@code GmStory}
     */
    public static GmStory newInstance() {
      return new GmStory();
    }

    /**
     * <code>optional .ChangeInfo Change = 3;</code>
     * @return whether the change field is set
     */
    public boolean hasChange() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional .ChangeInfo Change = 3;</code>
     * @return this
     */
    public GmStory clearChange() {
      bitField0_ &= ~0x00000001;
      change.clear();
      return this;
    }

    /**
     * <code>optional .ChangeInfo Change = 3;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableChange()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public Public.ChangeInfo getChange() {
      return change;
    }

    /**
     * <code>optional .ChangeInfo Change = 3;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public Public.ChangeInfo getMutableChange() {
      bitField0_ |= 0x00000001;
      return change;
    }

    /**
     * <code>optional .ChangeInfo Change = 3;</code>
     * @param value the change to set
     * @return this
     */
    public GmStory setChange(final Public.ChangeInfo value) {
      bitField0_ |= 0x00000001;
      change.copyFrom(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public GmStory clearNextPackage() {
      bitField0_ &= ~0x00000002;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000002;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public GmStory addNextPackage(final byte value) {
      bitField0_ |= 0x00000002;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public GmStory addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000002;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public GmStory setNextPackage(final byte... values) {
      bitField0_ |= 0x00000002;
      nextPackage.copyFrom(values);
      return this;
    }

    /**
     * <code>repeated uint32 Evidences = 1;</code>
     * @return whether the evidences field is set
     */
    public boolean hasEvidences() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>repeated uint32 Evidences = 1;</code>
     * @return this
     */
    public GmStory clearEvidences() {
      bitField0_ &= ~0x00000004;
      evidences.clear();
      return this;
    }

    /**
     * <code>repeated uint32 Evidences = 1;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableEvidences()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedInt getEvidences() {
      return evidences;
    }

    /**
     * <code>repeated uint32 Evidences = 1;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedInt getMutableEvidences() {
      bitField0_ |= 0x00000004;
      return evidences;
    }

    /**
     * <code>repeated uint32 Evidences = 1;</code>
     * @param value the evidences to add
     * @return this
     */
    public GmStory addEvidences(final int value) {
      bitField0_ |= 0x00000004;
      evidences.add(value);
      return this;
    }

    /**
     * <code>repeated uint32 Evidences = 1;</code>
     * @param values the evidences to add
     * @return this
     */
    public GmStory addAllEvidences(final int... values) {
      bitField0_ |= 0x00000004;
      evidences.addAll(values);
      return this;
    }

    /**
     * <code>repeated .Story Stories = 2;</code>
     * @return whether the stories field is set
     */
    public boolean hasStories() {
      return (bitField0_ & 0x00000008) != 0;
    }

    /**
     * <code>repeated .Story Stories = 2;</code>
     * @return this
     */
    public GmStory clearStories() {
      bitField0_ &= ~0x00000008;
      stories.clear();
      return this;
    }

    /**
     * <code>repeated .Story Stories = 2;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableStories()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<Public.Story> getStories() {
      return stories;
    }

    /**
     * <code>repeated .Story Stories = 2;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<Public.Story> getMutableStories() {
      bitField0_ |= 0x00000008;
      return stories;
    }

    /**
     * <code>repeated .Story Stories = 2;</code>
     * @param value the stories to add
     * @return this
     */
    public GmStory addStories(final Public.Story value) {
      bitField0_ |= 0x00000008;
      stories.add(value);
      return this;
    }

    /**
     * <code>repeated .Story Stories = 2;</code>
     * @param values the stories to add
     * @return this
     */
    public GmStory addAllStories(final Public.Story... values) {
      bitField0_ |= 0x00000008;
      stories.addAll(values);
      return this;
    }

    @Override
    public GmStory copyFrom(final GmStory other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        change.copyFrom(other.change);
        nextPackage.copyFrom(other.nextPackage);
        evidences.copyFrom(other.evidences);
        stories.copyFrom(other.stories);
      }
      return this;
    }

    @Override
    public GmStory mergeFrom(final GmStory other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasChange()) {
        getMutableChange().mergeFrom(other.change);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      if (other.hasEvidences()) {
        getMutableEvidences().addAll(other.evidences);
      }
      if (other.hasStories()) {
        getMutableStories().addAll(other.stories);
      }
      return this;
    }

    @Override
    public GmStory clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      change.clear();
      nextPackage.clear();
      evidences.clear();
      stories.clear();
      return this;
    }

    @Override
    public GmStory clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      change.clearQuick();
      nextPackage.clear();
      evidences.clear();
      stories.clearQuick();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof GmStory)) {
        return false;
      }
      GmStory other = (GmStory) o;
      return bitField0_ == other.bitField0_
        && (!hasChange() || change.equals(other.change))
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage))
        && (!hasEvidences() || evidences.equals(other.evidences))
        && (!hasStories() || stories.equals(other.stories));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 26);
        output.writeMessageNoTag(change);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        for (int i = 0; i < evidences.length(); i++) {
          output.writeRawByte((byte) 8);
          output.writeUInt32NoTag(evidences.array()[i]);
        }
      }
      if ((bitField0_ & 0x00000008) != 0) {
        for (int i = 0; i < stories.length(); i++) {
          output.writeRawByte((byte) 18);
          output.writeMessageNoTag(stories.get(i));
        }
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeMessageSizeNoTag(change);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += (1 * evidences.length()) + ProtoSink.computeRepeatedUInt32SizeNoTag(evidences);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        size += (1 * stories.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(stories);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public GmStory mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 26: {
            // change
            input.readMessage(change);
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 10) {
              break;
            }
          }
          case 10: {
            // evidences [packed=true]
            input.readPackedUInt32(evidences, tag);
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 18) {
              break;
            }
          }
          case 18: {
            // stories
            tag = input.readRepeatedMessage(stories, tag);
            bitField0_ |= 0x00000008;
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
          case 8: {
            // evidences [packed=false]
            tag = input.readRepeatedUInt32(evidences, tag);
            bitField0_ |= 0x00000004;
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeMessage(FieldNames.change, change);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRepeatedUInt32(FieldNames.evidences, evidences);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeRepeatedMessage(FieldNames.stories, stories);
      }
      output.endObject();
    }

    @Override
    public GmStory mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 2017198032: {
            if (input.isAtField(FieldNames.change)) {
              if (!input.trySkipNullValue()) {
                input.readMessage(change);
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 991055068: {
            if (input.isAtField(FieldNames.evidences)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedUInt32(evidences);
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -219613133: {
            if (input.isAtField(FieldNames.stories)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedMessage(stories);
                bitField0_ |= 0x00000008;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public GmStory clone() {
      return new GmStory().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static GmStory parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new GmStory(), data).checkInitialized();
    }

    public static GmStory parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new GmStory(), input).checkInitialized();
    }

    public static GmStory parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new GmStory(), input).checkInitialized();
    }

    /**
     * @return factory for creating GmStory messages
     */
    public static MessageFactory<GmStory> getFactory() {
      return GmStoryFactory.INSTANCE;
    }

    private enum GmStoryFactory implements MessageFactory<GmStory> {
      INSTANCE;

      @Override
      public GmStory create() {
        return GmStory.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName change = FieldName.forField("Change");

      static final FieldName nextPackage = FieldName.forField("NextPackage");

      static final FieldName evidences = FieldName.forField("Evidences");

      static final FieldName stories = FieldName.forField("Stories");
    }
  }

  /**
   * Protobuf type {@code GmHarmonySkillNotify}
   */
  public static final class GmHarmonySkillNotify extends ProtoMessage<GmHarmonySkillNotify> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    /**
     * <code>repeated uint32 List = 1;</code>
     */
    private final RepeatedInt list = RepeatedInt.newEmptyInstance();

    private GmHarmonySkillNotify() {
    }

    /**
     * @return a new empty instance of {@code GmHarmonySkillNotify}
     */
    public static GmHarmonySkillNotify newInstance() {
      return new GmHarmonySkillNotify();
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public GmHarmonySkillNotify clearNextPackage() {
      bitField0_ &= ~0x00000001;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000001;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public GmHarmonySkillNotify addNextPackage(final byte value) {
      bitField0_ |= 0x00000001;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public GmHarmonySkillNotify addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000001;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public GmHarmonySkillNotify setNextPackage(final byte... values) {
      bitField0_ |= 0x00000001;
      nextPackage.copyFrom(values);
      return this;
    }

    /**
     * <code>repeated uint32 List = 1;</code>
     * @return whether the list field is set
     */
    public boolean hasList() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>repeated uint32 List = 1;</code>
     * @return this
     */
    public GmHarmonySkillNotify clearList() {
      bitField0_ &= ~0x00000002;
      list.clear();
      return this;
    }

    /**
     * <code>repeated uint32 List = 1;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableList()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedInt getList() {
      return list;
    }

    /**
     * <code>repeated uint32 List = 1;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedInt getMutableList() {
      bitField0_ |= 0x00000002;
      return list;
    }

    /**
     * <code>repeated uint32 List = 1;</code>
     * @param value the list to add
     * @return this
     */
    public GmHarmonySkillNotify addList(final int value) {
      bitField0_ |= 0x00000002;
      list.add(value);
      return this;
    }

    /**
     * <code>repeated uint32 List = 1;</code>
     * @param values the list to add
     * @return this
     */
    public GmHarmonySkillNotify addAllList(final int... values) {
      bitField0_ |= 0x00000002;
      list.addAll(values);
      return this;
    }

    @Override
    public GmHarmonySkillNotify copyFrom(final GmHarmonySkillNotify other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        nextPackage.copyFrom(other.nextPackage);
        list.copyFrom(other.list);
      }
      return this;
    }

    @Override
    public GmHarmonySkillNotify mergeFrom(final GmHarmonySkillNotify other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      if (other.hasList()) {
        getMutableList().addAll(other.list);
      }
      return this;
    }

    @Override
    public GmHarmonySkillNotify clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      list.clear();
      return this;
    }

    @Override
    public GmHarmonySkillNotify clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      list.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof GmHarmonySkillNotify)) {
        return false;
      }
      GmHarmonySkillNotify other = (GmHarmonySkillNotify) o;
      return bitField0_ == other.bitField0_
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage))
        && (!hasList() || list.equals(other.list));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        for (int i = 0; i < list.length(); i++) {
          output.writeRawByte((byte) 8);
          output.writeUInt32NoTag(list.array()[i]);
        }
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += (1 * list.length()) + ProtoSink.computeRepeatedUInt32SizeNoTag(list);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public GmHarmonySkillNotify mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 10) {
              break;
            }
          }
          case 10: {
            // list [packed=true]
            input.readPackedUInt32(list, tag);
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
          case 8: {
            // list [packed=false]
            tag = input.readRepeatedUInt32(list, tag);
            bitField0_ |= 0x00000002;
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRepeatedUInt32(FieldNames.list, list);
      }
      output.endObject();
    }

    @Override
    public GmHarmonySkillNotify mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 2368702: {
            if (input.isAtField(FieldNames.list)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedUInt32(list);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public GmHarmonySkillNotify clone() {
      return new GmHarmonySkillNotify().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static GmHarmonySkillNotify parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new GmHarmonySkillNotify(), data).checkInitialized();
    }

    public static GmHarmonySkillNotify parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new GmHarmonySkillNotify(), input).checkInitialized();
    }

    public static GmHarmonySkillNotify parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new GmHarmonySkillNotify(), input).checkInitialized();
    }

    /**
     * @return factory for creating GmHarmonySkillNotify messages
     */
    public static MessageFactory<GmHarmonySkillNotify> getFactory() {
      return GmHarmonySkillNotifyFactory.INSTANCE;
    }

    private enum GmHarmonySkillNotifyFactory implements MessageFactory<GmHarmonySkillNotify> {
      INSTANCE;

      @Override
      public GmHarmonySkillNotify create() {
        return GmHarmonySkillNotify.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName nextPackage = FieldName.forField("NextPackage");

      static final FieldName list = FieldName.forField("List");
    }
  }

  /**
   * Protobuf type {@code GmTowerGrowthNodesNotify}
   */
  public static final class GmTowerGrowthNodesNotify extends ProtoMessage<GmTowerGrowthNodesNotify> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    /**
     * <code>repeated uint32 Detail = 1;</code>
     */
    private final RepeatedInt detail = RepeatedInt.newEmptyInstance();

    private GmTowerGrowthNodesNotify() {
    }

    /**
     * @return a new empty instance of {@code GmTowerGrowthNodesNotify}
     */
    public static GmTowerGrowthNodesNotify newInstance() {
      return new GmTowerGrowthNodesNotify();
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public GmTowerGrowthNodesNotify clearNextPackage() {
      bitField0_ &= ~0x00000001;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000001;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public GmTowerGrowthNodesNotify addNextPackage(final byte value) {
      bitField0_ |= 0x00000001;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public GmTowerGrowthNodesNotify addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000001;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public GmTowerGrowthNodesNotify setNextPackage(final byte... values) {
      bitField0_ |= 0x00000001;
      nextPackage.copyFrom(values);
      return this;
    }

    /**
     * <code>repeated uint32 Detail = 1;</code>
     * @return whether the detail field is set
     */
    public boolean hasDetail() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>repeated uint32 Detail = 1;</code>
     * @return this
     */
    public GmTowerGrowthNodesNotify clearDetail() {
      bitField0_ &= ~0x00000002;
      detail.clear();
      return this;
    }

    /**
     * <code>repeated uint32 Detail = 1;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableDetail()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedInt getDetail() {
      return detail;
    }

    /**
     * <code>repeated uint32 Detail = 1;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedInt getMutableDetail() {
      bitField0_ |= 0x00000002;
      return detail;
    }

    /**
     * <code>repeated uint32 Detail = 1;</code>
     * @param value the detail to add
     * @return this
     */
    public GmTowerGrowthNodesNotify addDetail(final int value) {
      bitField0_ |= 0x00000002;
      detail.add(value);
      return this;
    }

    /**
     * <code>repeated uint32 Detail = 1;</code>
     * @param values the detail to add
     * @return this
     */
    public GmTowerGrowthNodesNotify addAllDetail(final int... values) {
      bitField0_ |= 0x00000002;
      detail.addAll(values);
      return this;
    }

    @Override
    public GmTowerGrowthNodesNotify copyFrom(final GmTowerGrowthNodesNotify other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        nextPackage.copyFrom(other.nextPackage);
        detail.copyFrom(other.detail);
      }
      return this;
    }

    @Override
    public GmTowerGrowthNodesNotify mergeFrom(final GmTowerGrowthNodesNotify other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      if (other.hasDetail()) {
        getMutableDetail().addAll(other.detail);
      }
      return this;
    }

    @Override
    public GmTowerGrowthNodesNotify clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      detail.clear();
      return this;
    }

    @Override
    public GmTowerGrowthNodesNotify clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      detail.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof GmTowerGrowthNodesNotify)) {
        return false;
      }
      GmTowerGrowthNodesNotify other = (GmTowerGrowthNodesNotify) o;
      return bitField0_ == other.bitField0_
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage))
        && (!hasDetail() || detail.equals(other.detail));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        for (int i = 0; i < detail.length(); i++) {
          output.writeRawByte((byte) 8);
          output.writeUInt32NoTag(detail.array()[i]);
        }
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += (1 * detail.length()) + ProtoSink.computeRepeatedUInt32SizeNoTag(detail);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public GmTowerGrowthNodesNotify mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 10) {
              break;
            }
          }
          case 10: {
            // detail [packed=true]
            input.readPackedUInt32(detail, tag);
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
          case 8: {
            // detail [packed=false]
            tag = input.readRepeatedUInt32(detail, tag);
            bitField0_ |= 0x00000002;
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRepeatedUInt32(FieldNames.detail, detail);
      }
      output.endObject();
    }

    @Override
    public GmTowerGrowthNodesNotify mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 2043610225: {
            if (input.isAtField(FieldNames.detail)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedUInt32(detail);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public GmTowerGrowthNodesNotify clone() {
      return new GmTowerGrowthNodesNotify().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static GmTowerGrowthNodesNotify parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new GmTowerGrowthNodesNotify(), data).checkInitialized();
    }

    public static GmTowerGrowthNodesNotify parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new GmTowerGrowthNodesNotify(), input).checkInitialized();
    }

    public static GmTowerGrowthNodesNotify parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new GmTowerGrowthNodesNotify(), input).checkInitialized();
    }

    /**
     * @return factory for creating GmTowerGrowthNodesNotify messages
     */
    public static MessageFactory<GmTowerGrowthNodesNotify> getFactory() {
      return GmTowerGrowthNodesNotifyFactory.INSTANCE;
    }

    private enum GmTowerGrowthNodesNotifyFactory implements MessageFactory<GmTowerGrowthNodesNotify> {
      INSTANCE;

      @Override
      public GmTowerGrowthNodesNotify create() {
        return GmTowerGrowthNodesNotify.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName nextPackage = FieldName.forField("NextPackage");

      static final FieldName detail = FieldName.forField("Detail");
    }
  }

  /**
   * Protobuf type {@code GmCharUpNotify}
   */
  public static final class GmCharUpNotify extends ProtoMessage<GmCharUpNotify> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional .Char Char = 1;</code>
     */
    private final Public.Char char_ = Public.Char.newInstance();

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    /**
     * <code>repeated .HandbookInfo Handbook = 2;</code>
     */
    private final RepeatedMessage<Public.HandbookInfo> handbook = RepeatedMessage.newEmptyInstance(Public.HandbookInfo.getFactory());

    private GmCharUpNotify() {
    }

    /**
     * @return a new empty instance of {@code GmCharUpNotify}
     */
    public static GmCharUpNotify newInstance() {
      return new GmCharUpNotify();
    }

    /**
     * <code>optional .Char Char = 1;</code>
     * @return whether the char_ field is set
     */
    public boolean hasChar() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional .Char Char = 1;</code>
     * @return this
     */
    public GmCharUpNotify clearChar() {
      bitField0_ &= ~0x00000001;
      char_.clear();
      return this;
    }

    /**
     * <code>optional .Char Char = 1;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableChar()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public Public.Char getChar() {
      return char_;
    }

    /**
     * <code>optional .Char Char = 1;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public Public.Char getMutableChar() {
      bitField0_ |= 0x00000001;
      return char_;
    }

    /**
     * <code>optional .Char Char = 1;</code>
     * @param value the char_ to set
     * @return this
     */
    public GmCharUpNotify setChar(final Public.Char value) {
      bitField0_ |= 0x00000001;
      char_.copyFrom(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public GmCharUpNotify clearNextPackage() {
      bitField0_ &= ~0x00000002;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000002;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public GmCharUpNotify addNextPackage(final byte value) {
      bitField0_ |= 0x00000002;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public GmCharUpNotify addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000002;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public GmCharUpNotify setNextPackage(final byte... values) {
      bitField0_ |= 0x00000002;
      nextPackage.copyFrom(values);
      return this;
    }

    /**
     * <code>repeated .HandbookInfo Handbook = 2;</code>
     * @return whether the handbook field is set
     */
    public boolean hasHandbook() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>repeated .HandbookInfo Handbook = 2;</code>
     * @return this
     */
    public GmCharUpNotify clearHandbook() {
      bitField0_ &= ~0x00000004;
      handbook.clear();
      return this;
    }

    /**
     * <code>repeated .HandbookInfo Handbook = 2;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableHandbook()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<Public.HandbookInfo> getHandbook() {
      return handbook;
    }

    /**
     * <code>repeated .HandbookInfo Handbook = 2;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<Public.HandbookInfo> getMutableHandbook() {
      bitField0_ |= 0x00000004;
      return handbook;
    }

    /**
     * <code>repeated .HandbookInfo Handbook = 2;</code>
     * @param value the handbook to add
     * @return this
     */
    public GmCharUpNotify addHandbook(final Public.HandbookInfo value) {
      bitField0_ |= 0x00000004;
      handbook.add(value);
      return this;
    }

    /**
     * <code>repeated .HandbookInfo Handbook = 2;</code>
     * @param values the handbook to add
     * @return this
     */
    public GmCharUpNotify addAllHandbook(final Public.HandbookInfo... values) {
      bitField0_ |= 0x00000004;
      handbook.addAll(values);
      return this;
    }

    @Override
    public GmCharUpNotify copyFrom(final GmCharUpNotify other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        char_.copyFrom(other.char_);
        nextPackage.copyFrom(other.nextPackage);
        handbook.copyFrom(other.handbook);
      }
      return this;
    }

    @Override
    public GmCharUpNotify mergeFrom(final GmCharUpNotify other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasChar()) {
        getMutableChar().mergeFrom(other.char_);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      if (other.hasHandbook()) {
        getMutableHandbook().addAll(other.handbook);
      }
      return this;
    }

    @Override
    public GmCharUpNotify clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      char_.clear();
      nextPackage.clear();
      handbook.clear();
      return this;
    }

    @Override
    public GmCharUpNotify clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      char_.clearQuick();
      nextPackage.clear();
      handbook.clearQuick();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof GmCharUpNotify)) {
        return false;
      }
      GmCharUpNotify other = (GmCharUpNotify) o;
      return bitField0_ == other.bitField0_
        && (!hasChar() || char_.equals(other.char_))
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage))
        && (!hasHandbook() || handbook.equals(other.handbook));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 10);
        output.writeMessageNoTag(char_);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        for (int i = 0; i < handbook.length(); i++) {
          output.writeRawByte((byte) 18);
          output.writeMessageNoTag(handbook.get(i));
        }
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeMessageSizeNoTag(char_);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += (1 * handbook.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(handbook);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public GmCharUpNotify mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 10: {
            // char_
            input.readMessage(char_);
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 18) {
              break;
            }
          }
          case 18: {
            // handbook
            tag = input.readRepeatedMessage(handbook, tag);
            bitField0_ |= 0x00000004;
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeMessage(FieldNames.char_, char_);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRepeatedMessage(FieldNames.handbook, handbook);
      }
      output.endObject();
    }

    @Override
    public GmCharUpNotify mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 2099062: {
            if (input.isAtField(FieldNames.char_)) {
              if (!input.trySkipNullValue()) {
                input.readMessage(char_);
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 66424824: {
            if (input.isAtField(FieldNames.handbook)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedMessage(handbook);
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public GmCharUpNotify clone() {
      return new GmCharUpNotify().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static GmCharUpNotify parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new GmCharUpNotify(), data).checkInitialized();
    }

    public static GmCharUpNotify parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new GmCharUpNotify(), input).checkInitialized();
    }

    public static GmCharUpNotify parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new GmCharUpNotify(), input).checkInitialized();
    }

    /**
     * @return factory for creating GmCharUpNotify messages
     */
    public static MessageFactory<GmCharUpNotify> getFactory() {
      return GmCharUpNotifyFactory.INSTANCE;
    }

    private enum GmCharUpNotifyFactory implements MessageFactory<GmCharUpNotify> {
      INSTANCE;

      @Override
      public GmCharUpNotify create() {
        return GmCharUpNotify.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName char_ = FieldName.forField("Char");

      static final FieldName nextPackage = FieldName.forField("NextPackage");

      static final FieldName handbook = FieldName.forField("Handbook");
    }
  }

  /**
   * Protobuf type {@code GmClearAllCharGemInstance}
   */
  public static final class GmClearAllCharGemInstance extends ProtoMessage<GmClearAllCharGemInstance> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    /**
     * <code>repeated .CharGemInstance CharGemInstances = 1;</code>
     */
    private final RepeatedMessage<Public.CharGemInstance> charGemInstances = RepeatedMessage.newEmptyInstance(Public.CharGemInstance.getFactory());

    private GmClearAllCharGemInstance() {
    }

    /**
     * @return a new empty instance of {@code GmClearAllCharGemInstance}
     */
    public static GmClearAllCharGemInstance newInstance() {
      return new GmClearAllCharGemInstance();
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public GmClearAllCharGemInstance clearNextPackage() {
      bitField0_ &= ~0x00000001;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000001;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public GmClearAllCharGemInstance addNextPackage(final byte value) {
      bitField0_ |= 0x00000001;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public GmClearAllCharGemInstance addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000001;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public GmClearAllCharGemInstance setNextPackage(final byte... values) {
      bitField0_ |= 0x00000001;
      nextPackage.copyFrom(values);
      return this;
    }

    /**
     * <code>repeated .CharGemInstance CharGemInstances = 1;</code>
     * @return whether the charGemInstances field is set
     */
    public boolean hasCharGemInstances() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>repeated .CharGemInstance CharGemInstances = 1;</code>
     * @return this
     */
    public GmClearAllCharGemInstance clearCharGemInstances() {
      bitField0_ &= ~0x00000002;
      charGemInstances.clear();
      return this;
    }

    /**
     * <code>repeated .CharGemInstance CharGemInstances = 1;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableCharGemInstances()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<Public.CharGemInstance> getCharGemInstances() {
      return charGemInstances;
    }

    /**
     * <code>repeated .CharGemInstance CharGemInstances = 1;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<Public.CharGemInstance> getMutableCharGemInstances() {
      bitField0_ |= 0x00000002;
      return charGemInstances;
    }

    /**
     * <code>repeated .CharGemInstance CharGemInstances = 1;</code>
     * @param value the charGemInstances to add
     * @return this
     */
    public GmClearAllCharGemInstance addCharGemInstances(final Public.CharGemInstance value) {
      bitField0_ |= 0x00000002;
      charGemInstances.add(value);
      return this;
    }

    /**
     * <code>repeated .CharGemInstance CharGemInstances = 1;</code>
     * @param values the charGemInstances to add
     * @return this
     */
    public GmClearAllCharGemInstance addAllCharGemInstances(
        final Public.CharGemInstance... values) {
      bitField0_ |= 0x00000002;
      charGemInstances.addAll(values);
      return this;
    }

    @Override
    public GmClearAllCharGemInstance copyFrom(final GmClearAllCharGemInstance other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        nextPackage.copyFrom(other.nextPackage);
        charGemInstances.copyFrom(other.charGemInstances);
      }
      return this;
    }

    @Override
    public GmClearAllCharGemInstance mergeFrom(final GmClearAllCharGemInstance other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      if (other.hasCharGemInstances()) {
        getMutableCharGemInstances().addAll(other.charGemInstances);
      }
      return this;
    }

    @Override
    public GmClearAllCharGemInstance clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      charGemInstances.clear();
      return this;
    }

    @Override
    public GmClearAllCharGemInstance clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      charGemInstances.clearQuick();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof GmClearAllCharGemInstance)) {
        return false;
      }
      GmClearAllCharGemInstance other = (GmClearAllCharGemInstance) o;
      return bitField0_ == other.bitField0_
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage))
        && (!hasCharGemInstances() || charGemInstances.equals(other.charGemInstances));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        for (int i = 0; i < charGemInstances.length(); i++) {
          output.writeRawByte((byte) 10);
          output.writeMessageNoTag(charGemInstances.get(i));
        }
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += (1 * charGemInstances.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(charGemInstances);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public GmClearAllCharGemInstance mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 10) {
              break;
            }
          }
          case 10: {
            // charGemInstances
            tag = input.readRepeatedMessage(charGemInstances, tag);
            bitField0_ |= 0x00000002;
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRepeatedMessage(FieldNames.charGemInstances, charGemInstances);
      }
      output.endObject();
    }

    @Override
    public GmClearAllCharGemInstance mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1297796475: {
            if (input.isAtField(FieldNames.charGemInstances)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedMessage(charGemInstances);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public GmClearAllCharGemInstance clone() {
      return new GmClearAllCharGemInstance().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static GmClearAllCharGemInstance parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new GmClearAllCharGemInstance(), data).checkInitialized();
    }

    public static GmClearAllCharGemInstance parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new GmClearAllCharGemInstance(), input).checkInitialized();
    }

    public static GmClearAllCharGemInstance parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new GmClearAllCharGemInstance(), input).checkInitialized();
    }

    /**
     * @return factory for creating GmClearAllCharGemInstance messages
     */
    public static MessageFactory<GmClearAllCharGemInstance> getFactory() {
      return GmClearAllCharGemInstanceFactory.INSTANCE;
    }

    private enum GmClearAllCharGemInstanceFactory implements MessageFactory<GmClearAllCharGemInstance> {
      INSTANCE;

      @Override
      public GmClearAllCharGemInstance create() {
        return GmClearAllCharGemInstance.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName nextPackage = FieldName.forField("NextPackage");

      static final FieldName charGemInstances = FieldName.forField("CharGemInstances");
    }
  }

  /**
   * Protobuf type {@code GmImportCharGemsNotify}
   */
  public static final class GmImportCharGemsNotify extends ProtoMessage<GmImportCharGemsNotify> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional uint32 CharId = 1;</code>
     */
    private int charId;

    /**
     * <code>optional .CharGemPresets CharGemPresets = 3;</code>
     */
    private final Public.CharGemPresets charGemPresets = Public.CharGemPresets.newInstance();

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    /**
     * <code>repeated .CharGemSlot CharGemSlots = 2;</code>
     */
    private final RepeatedMessage<Public.CharGemSlot> charGemSlots = RepeatedMessage.newEmptyInstance(Public.CharGemSlot.getFactory());

    private GmImportCharGemsNotify() {
    }

    /**
     * @return a new empty instance of {@code GmImportCharGemsNotify}
     */
    public static GmImportCharGemsNotify newInstance() {
      return new GmImportCharGemsNotify();
    }

    /**
     * <code>optional uint32 CharId = 1;</code>
     * @return whether the charId field is set
     */
    public boolean hasCharId() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional uint32 CharId = 1;</code>
     * @return this
     */
    public GmImportCharGemsNotify clearCharId() {
      bitField0_ &= ~0x00000001;
      charId = 0;
      return this;
    }

    /**
     * <code>optional uint32 CharId = 1;</code>
     * @return the charId
     */
    public int getCharId() {
      return charId;
    }

    /**
     * <code>optional uint32 CharId = 1;</code>
     * @param value the charId to set
     * @return this
     */
    public GmImportCharGemsNotify setCharId(final int value) {
      bitField0_ |= 0x00000001;
      charId = value;
      return this;
    }

    /**
     * <code>optional .CharGemPresets CharGemPresets = 3;</code>
     * @return whether the charGemPresets field is set
     */
    public boolean hasCharGemPresets() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional .CharGemPresets CharGemPresets = 3;</code>
     * @return this
     */
    public GmImportCharGemsNotify clearCharGemPresets() {
      bitField0_ &= ~0x00000002;
      charGemPresets.clear();
      return this;
    }

    /**
     * <code>optional .CharGemPresets CharGemPresets = 3;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableCharGemPresets()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public Public.CharGemPresets getCharGemPresets() {
      return charGemPresets;
    }

    /**
     * <code>optional .CharGemPresets CharGemPresets = 3;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public Public.CharGemPresets getMutableCharGemPresets() {
      bitField0_ |= 0x00000002;
      return charGemPresets;
    }

    /**
     * <code>optional .CharGemPresets CharGemPresets = 3;</code>
     * @param value the charGemPresets to set
     * @return this
     */
    public GmImportCharGemsNotify setCharGemPresets(final Public.CharGemPresets value) {
      bitField0_ |= 0x00000002;
      charGemPresets.copyFrom(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public GmImportCharGemsNotify clearNextPackage() {
      bitField0_ &= ~0x00000004;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000004;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public GmImportCharGemsNotify addNextPackage(final byte value) {
      bitField0_ |= 0x00000004;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public GmImportCharGemsNotify addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000004;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public GmImportCharGemsNotify setNextPackage(final byte... values) {
      bitField0_ |= 0x00000004;
      nextPackage.copyFrom(values);
      return this;
    }

    /**
     * <code>repeated .CharGemSlot CharGemSlots = 2;</code>
     * @return whether the charGemSlots field is set
     */
    public boolean hasCharGemSlots() {
      return (bitField0_ & 0x00000008) != 0;
    }

    /**
     * <code>repeated .CharGemSlot CharGemSlots = 2;</code>
     * @return this
     */
    public GmImportCharGemsNotify clearCharGemSlots() {
      bitField0_ &= ~0x00000008;
      charGemSlots.clear();
      return this;
    }

    /**
     * <code>repeated .CharGemSlot CharGemSlots = 2;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableCharGemSlots()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<Public.CharGemSlot> getCharGemSlots() {
      return charGemSlots;
    }

    /**
     * <code>repeated .CharGemSlot CharGemSlots = 2;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<Public.CharGemSlot> getMutableCharGemSlots() {
      bitField0_ |= 0x00000008;
      return charGemSlots;
    }

    /**
     * <code>repeated .CharGemSlot CharGemSlots = 2;</code>
     * @param value the charGemSlots to add
     * @return this
     */
    public GmImportCharGemsNotify addCharGemSlots(final Public.CharGemSlot value) {
      bitField0_ |= 0x00000008;
      charGemSlots.add(value);
      return this;
    }

    /**
     * <code>repeated .CharGemSlot CharGemSlots = 2;</code>
     * @param values the charGemSlots to add
     * @return this
     */
    public GmImportCharGemsNotify addAllCharGemSlots(final Public.CharGemSlot... values) {
      bitField0_ |= 0x00000008;
      charGemSlots.addAll(values);
      return this;
    }

    @Override
    public GmImportCharGemsNotify copyFrom(final GmImportCharGemsNotify other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        charId = other.charId;
        charGemPresets.copyFrom(other.charGemPresets);
        nextPackage.copyFrom(other.nextPackage);
        charGemSlots.copyFrom(other.charGemSlots);
      }
      return this;
    }

    @Override
    public GmImportCharGemsNotify mergeFrom(final GmImportCharGemsNotify other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasCharId()) {
        setCharId(other.charId);
      }
      if (other.hasCharGemPresets()) {
        getMutableCharGemPresets().mergeFrom(other.charGemPresets);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      if (other.hasCharGemSlots()) {
        getMutableCharGemSlots().addAll(other.charGemSlots);
      }
      return this;
    }

    @Override
    public GmImportCharGemsNotify clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      charId = 0;
      charGemPresets.clear();
      nextPackage.clear();
      charGemSlots.clear();
      return this;
    }

    @Override
    public GmImportCharGemsNotify clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      charGemPresets.clearQuick();
      nextPackage.clear();
      charGemSlots.clearQuick();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof GmImportCharGemsNotify)) {
        return false;
      }
      GmImportCharGemsNotify other = (GmImportCharGemsNotify) o;
      return bitField0_ == other.bitField0_
        && (!hasCharId() || charId == other.charId)
        && (!hasCharGemPresets() || charGemPresets.equals(other.charGemPresets))
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage))
        && (!hasCharGemSlots() || charGemSlots.equals(other.charGemSlots));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt32NoTag(charId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 26);
        output.writeMessageNoTag(charGemPresets);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        for (int i = 0; i < charGemSlots.length(); i++) {
          output.writeRawByte((byte) 18);
          output.writeMessageNoTag(charGemSlots.get(i));
        }
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(charId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeMessageSizeNoTag(charGemPresets);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        size += (1 * charGemSlots.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(charGemSlots);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public GmImportCharGemsNotify mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            // charId
            charId = input.readUInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 26) {
              break;
            }
          }
          case 26: {
            // charGemPresets
            input.readMessage(charGemPresets);
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 18) {
              break;
            }
          }
          case 18: {
            // charGemSlots
            tag = input.readRepeatedMessage(charGemSlots, tag);
            bitField0_ |= 0x00000008;
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeUInt32(FieldNames.charId, charId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeMessage(FieldNames.charGemPresets, charGemPresets);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeRepeatedMessage(FieldNames.charGemSlots, charGemSlots);
      }
      output.endObject();
    }

    @Override
    public GmImportCharGemsNotify mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 2017200945: {
            if (input.isAtField(FieldNames.charId)) {
              if (!input.trySkipNullValue()) {
                charId = input.readUInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 82576187: {
            if (input.isAtField(FieldNames.charGemPresets)) {
              if (!input.trySkipNullValue()) {
                input.readMessage(charGemPresets);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2084461124: {
            if (input.isAtField(FieldNames.charGemSlots)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedMessage(charGemSlots);
                bitField0_ |= 0x00000008;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public GmImportCharGemsNotify clone() {
      return new GmImportCharGemsNotify().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static GmImportCharGemsNotify parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new GmImportCharGemsNotify(), data).checkInitialized();
    }

    public static GmImportCharGemsNotify parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new GmImportCharGemsNotify(), input).checkInitialized();
    }

    public static GmImportCharGemsNotify parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new GmImportCharGemsNotify(), input).checkInitialized();
    }

    /**
     * @return factory for creating GmImportCharGemsNotify messages
     */
    public static MessageFactory<GmImportCharGemsNotify> getFactory() {
      return GmImportCharGemsNotifyFactory.INSTANCE;
    }

    private enum GmImportCharGemsNotifyFactory implements MessageFactory<GmImportCharGemsNotify> {
      INSTANCE;

      @Override
      public GmImportCharGemsNotify create() {
        return GmImportCharGemsNotify.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName charId = FieldName.forField("CharId");

      static final FieldName charGemPresets = FieldName.forField("CharGemPresets");

      static final FieldName nextPackage = FieldName.forField("NextPackage");

      static final FieldName charGemSlots = FieldName.forField("CharGemSlots");
    }
  }

  /**
   * Protobuf type {@code GmClearAllActivityAvgNotify}
   */
  public static final class GmClearAllActivityAvgNotify extends ProtoMessage<GmClearAllActivityAvgNotify> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    /**
     * <code>repeated .ActivityAvg Avgs = 1;</code>
     */
    private final RepeatedMessage<Public.ActivityAvg> avgs = RepeatedMessage.newEmptyInstance(Public.ActivityAvg.getFactory());

    private GmClearAllActivityAvgNotify() {
    }

    /**
     * @return a new empty instance of {@code GmClearAllActivityAvgNotify}
     */
    public static GmClearAllActivityAvgNotify newInstance() {
      return new GmClearAllActivityAvgNotify();
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public GmClearAllActivityAvgNotify clearNextPackage() {
      bitField0_ &= ~0x00000001;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000001;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public GmClearAllActivityAvgNotify addNextPackage(final byte value) {
      bitField0_ |= 0x00000001;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public GmClearAllActivityAvgNotify addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000001;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public GmClearAllActivityAvgNotify setNextPackage(final byte... values) {
      bitField0_ |= 0x00000001;
      nextPackage.copyFrom(values);
      return this;
    }

    /**
     * <code>repeated .ActivityAvg Avgs = 1;</code>
     * @return whether the avgs field is set
     */
    public boolean hasAvgs() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>repeated .ActivityAvg Avgs = 1;</code>
     * @return this
     */
    public GmClearAllActivityAvgNotify clearAvgs() {
      bitField0_ &= ~0x00000002;
      avgs.clear();
      return this;
    }

    /**
     * <code>repeated .ActivityAvg Avgs = 1;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableAvgs()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<Public.ActivityAvg> getAvgs() {
      return avgs;
    }

    /**
     * <code>repeated .ActivityAvg Avgs = 1;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<Public.ActivityAvg> getMutableAvgs() {
      bitField0_ |= 0x00000002;
      return avgs;
    }

    /**
     * <code>repeated .ActivityAvg Avgs = 1;</code>
     * @param value the avgs to add
     * @return this
     */
    public GmClearAllActivityAvgNotify addAvgs(final Public.ActivityAvg value) {
      bitField0_ |= 0x00000002;
      avgs.add(value);
      return this;
    }

    /**
     * <code>repeated .ActivityAvg Avgs = 1;</code>
     * @param values the avgs to add
     * @return this
     */
    public GmClearAllActivityAvgNotify addAllAvgs(final Public.ActivityAvg... values) {
      bitField0_ |= 0x00000002;
      avgs.addAll(values);
      return this;
    }

    @Override
    public GmClearAllActivityAvgNotify copyFrom(final GmClearAllActivityAvgNotify other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        nextPackage.copyFrom(other.nextPackage);
        avgs.copyFrom(other.avgs);
      }
      return this;
    }

    @Override
    public GmClearAllActivityAvgNotify mergeFrom(final GmClearAllActivityAvgNotify other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      if (other.hasAvgs()) {
        getMutableAvgs().addAll(other.avgs);
      }
      return this;
    }

    @Override
    public GmClearAllActivityAvgNotify clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      avgs.clear();
      return this;
    }

    @Override
    public GmClearAllActivityAvgNotify clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      avgs.clearQuick();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof GmClearAllActivityAvgNotify)) {
        return false;
      }
      GmClearAllActivityAvgNotify other = (GmClearAllActivityAvgNotify) o;
      return bitField0_ == other.bitField0_
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage))
        && (!hasAvgs() || avgs.equals(other.avgs));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        for (int i = 0; i < avgs.length(); i++) {
          output.writeRawByte((byte) 10);
          output.writeMessageNoTag(avgs.get(i));
        }
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += (1 * avgs.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(avgs);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public GmClearAllActivityAvgNotify mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 10) {
              break;
            }
          }
          case 10: {
            // avgs
            tag = input.readRepeatedMessage(avgs, tag);
            bitField0_ |= 0x00000002;
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRepeatedMessage(FieldNames.avgs, avgs);
      }
      output.endObject();
    }

    @Override
    public GmClearAllActivityAvgNotify mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 2053121: {
            if (input.isAtField(FieldNames.avgs)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedMessage(avgs);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public GmClearAllActivityAvgNotify clone() {
      return new GmClearAllActivityAvgNotify().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static GmClearAllActivityAvgNotify parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new GmClearAllActivityAvgNotify(), data).checkInitialized();
    }

    public static GmClearAllActivityAvgNotify parseFrom(final ProtoSource input) throws
        IOException {
      return ProtoMessage.mergeFrom(new GmClearAllActivityAvgNotify(), input).checkInitialized();
    }

    public static GmClearAllActivityAvgNotify parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new GmClearAllActivityAvgNotify(), input).checkInitialized();
    }

    /**
     * @return factory for creating GmClearAllActivityAvgNotify messages
     */
    public static MessageFactory<GmClearAllActivityAvgNotify> getFactory() {
      return GmClearAllActivityAvgNotifyFactory.INSTANCE;
    }

    private enum GmClearAllActivityAvgNotifyFactory implements MessageFactory<GmClearAllActivityAvgNotify> {
      INSTANCE;

      @Override
      public GmClearAllActivityAvgNotify create() {
        return GmClearAllActivityAvgNotify.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName nextPackage = FieldName.forField("NextPackage");

      static final FieldName avgs = FieldName.forField("Avgs");
    }
  }

  /**
   * Protobuf type {@code GmClearAllActivityLevelsNotify}
   */
  public static final class GmClearAllActivityLevelsNotify extends ProtoMessage<GmClearAllActivityLevelsNotify> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    /**
     * <code>repeated .ActivityLevels levels = 1;</code>
     */
    private final RepeatedMessage<Public.ActivityLevels> levels = RepeatedMessage.newEmptyInstance(Public.ActivityLevels.getFactory());

    private GmClearAllActivityLevelsNotify() {
    }

    /**
     * @return a new empty instance of {@code GmClearAllActivityLevelsNotify}
     */
    public static GmClearAllActivityLevelsNotify newInstance() {
      return new GmClearAllActivityLevelsNotify();
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public GmClearAllActivityLevelsNotify clearNextPackage() {
      bitField0_ &= ~0x00000001;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000001;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public GmClearAllActivityLevelsNotify addNextPackage(final byte value) {
      bitField0_ |= 0x00000001;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public GmClearAllActivityLevelsNotify addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000001;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public GmClearAllActivityLevelsNotify setNextPackage(final byte... values) {
      bitField0_ |= 0x00000001;
      nextPackage.copyFrom(values);
      return this;
    }

    /**
     * <code>repeated .ActivityLevels levels = 1;</code>
     * @return whether the levels field is set
     */
    public boolean hasLevels() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>repeated .ActivityLevels levels = 1;</code>
     * @return this
     */
    public GmClearAllActivityLevelsNotify clearLevels() {
      bitField0_ &= ~0x00000002;
      levels.clear();
      return this;
    }

    /**
     * <code>repeated .ActivityLevels levels = 1;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableLevels()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<Public.ActivityLevels> getLevels() {
      return levels;
    }

    /**
     * <code>repeated .ActivityLevels levels = 1;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<Public.ActivityLevels> getMutableLevels() {
      bitField0_ |= 0x00000002;
      return levels;
    }

    /**
     * <code>repeated .ActivityLevels levels = 1;</code>
     * @param value the levels to add
     * @return this
     */
    public GmClearAllActivityLevelsNotify addLevels(final Public.ActivityLevels value) {
      bitField0_ |= 0x00000002;
      levels.add(value);
      return this;
    }

    /**
     * <code>repeated .ActivityLevels levels = 1;</code>
     * @param values the levels to add
     * @return this
     */
    public GmClearAllActivityLevelsNotify addAllLevels(final Public.ActivityLevels... values) {
      bitField0_ |= 0x00000002;
      levels.addAll(values);
      return this;
    }

    @Override
    public GmClearAllActivityLevelsNotify copyFrom(final GmClearAllActivityLevelsNotify other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        nextPackage.copyFrom(other.nextPackage);
        levels.copyFrom(other.levels);
      }
      return this;
    }

    @Override
    public GmClearAllActivityLevelsNotify mergeFrom(final GmClearAllActivityLevelsNotify other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      if (other.hasLevels()) {
        getMutableLevels().addAll(other.levels);
      }
      return this;
    }

    @Override
    public GmClearAllActivityLevelsNotify clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      levels.clear();
      return this;
    }

    @Override
    public GmClearAllActivityLevelsNotify clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      levels.clearQuick();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof GmClearAllActivityLevelsNotify)) {
        return false;
      }
      GmClearAllActivityLevelsNotify other = (GmClearAllActivityLevelsNotify) o;
      return bitField0_ == other.bitField0_
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage))
        && (!hasLevels() || levels.equals(other.levels));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        for (int i = 0; i < levels.length(); i++) {
          output.writeRawByte((byte) 10);
          output.writeMessageNoTag(levels.get(i));
        }
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += (1 * levels.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(levels);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public GmClearAllActivityLevelsNotify mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 10) {
              break;
            }
          }
          case 10: {
            // levels
            tag = input.readRepeatedMessage(levels, tag);
            bitField0_ |= 0x00000002;
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRepeatedMessage(FieldNames.levels, levels);
      }
      output.endObject();
    }

    @Override
    public GmClearAllActivityLevelsNotify mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1106127505: {
            if (input.isAtField(FieldNames.levels)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedMessage(levels);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public GmClearAllActivityLevelsNotify clone() {
      return new GmClearAllActivityLevelsNotify().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static GmClearAllActivityLevelsNotify parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new GmClearAllActivityLevelsNotify(), data).checkInitialized();
    }

    public static GmClearAllActivityLevelsNotify parseFrom(final ProtoSource input) throws
        IOException {
      return ProtoMessage.mergeFrom(new GmClearAllActivityLevelsNotify(), input).checkInitialized();
    }

    public static GmClearAllActivityLevelsNotify parseFrom(final JsonSource input) throws
        IOException {
      return ProtoMessage.mergeFrom(new GmClearAllActivityLevelsNotify(), input).checkInitialized();
    }

    /**
     * @return factory for creating GmClearAllActivityLevelsNotify messages
     */
    public static MessageFactory<GmClearAllActivityLevelsNotify> getFactory() {
      return GmClearAllActivityLevelsNotifyFactory.INSTANCE;
    }

    private enum GmClearAllActivityLevelsNotifyFactory implements MessageFactory<GmClearAllActivityLevelsNotify> {
      INSTANCE;

      @Override
      public GmClearAllActivityLevelsNotify create() {
        return GmClearAllActivityLevelsNotify.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName nextPackage = FieldName.forField("NextPackage");

      static final FieldName levels = FieldName.forField("levels");
    }
  }
}
