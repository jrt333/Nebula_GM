// Code generated by protocol buffer compiler. Do not edit!
package emu.nebula.proto;

import java.io.IOException;
import us.hebi.quickbuf.FieldName;
import us.hebi.quickbuf.InvalidProtocolBufferException;
import us.hebi.quickbuf.JsonSink;
import us.hebi.quickbuf.JsonSource;
import us.hebi.quickbuf.MessageFactory;
import us.hebi.quickbuf.ProtoEnum;
import us.hebi.quickbuf.ProtoMessage;
import us.hebi.quickbuf.ProtoSink;
import us.hebi.quickbuf.ProtoSource;
import us.hebi.quickbuf.ProtoUtil;
import us.hebi.quickbuf.RepeatedByte;
import us.hebi.quickbuf.Utf8String;

public final class PlayerLogin {
  /**
   * Protobuf enum {@code Platform}
   */
  public enum Platform implements ProtoEnum<Platform> {
    /**
     * <code>Unknown = 0;</code>
     */
    Unknown("Unknown", 0),

    /**
     * <code>Ios = 1;</code>
     */
    Ios("Ios", 1),

    /**
     * <code>Android = 2;</code>
     */
    Android("Android", 2),

    /**
     * <code>PC = 3;</code>
     */
    PC("PC", 3),

    /**
     * <code>Harmonyos = 4;</code>
     */
    Harmonyos("Harmonyos", 4);

    /**
     * <code>Unknown = 0;</code>
     */
    public static final int Unknown_VALUE = 0;

    /**
     * <code>Ios = 1;</code>
     */
    public static final int Ios_VALUE = 1;

    /**
     * <code>Android = 2;</code>
     */
    public static final int Android_VALUE = 2;

    /**
     * <code>PC = 3;</code>
     */
    public static final int PC_VALUE = 3;

    /**
     * <code>Harmonyos = 4;</code>
     */
    public static final int Harmonyos_VALUE = 4;

    private final String name;

    private final int number;

    private Platform(String name, int number) {
      this.name = name;
      this.number = number;
    }

    /**
     * @return the string representation of enum entry
     */
    @Override
    public String getName() {
      return name;
    }

    /**
     * @return the numeric wire value of this enum entry
     */
    @Override
    public int getNumber() {
      return number;
    }

    /**
     * @return a converter that maps between this enum's numeric and text representations
     */
    public static ProtoEnum.EnumConverter<Platform> converter() {
      return PlatformConverter.INSTANCE;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value, or null if unknown.
     */
    public static Platform forNumber(int value) {
      return PlatformConverter.INSTANCE.forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @param other Fallback value in case the value is not known.
     * @return The enum associated with the given numeric wire value, or the fallback value if unknown.
     */
    public static Platform forNumberOr(int number, Platform other) {
      Platform value = forNumber(number);
      return value == null ? other : value;
    }

    enum PlatformConverter implements ProtoEnum.EnumConverter<Platform> {
      INSTANCE;

      private static final Platform[] lookup = new Platform[5];

      static {
        lookup[0] = Unknown;
        lookup[1] = Ios;
        lookup[2] = Android;
        lookup[3] = PC;
        lookup[4] = Harmonyos;
      }

      @Override
      public final Platform forNumber(final int value) {
        if (value >= 0 && value < lookup.length) {
          return lookup[value];
        }
        return null;
      }

      @Override
      public final Platform forName(final CharSequence value) {
        switch (value.length()) {
          case 2: {
            if (ProtoUtil.isEqual("PC", value)) {
              return PC;
            }
            break;
          }
          case 3: {
            if (ProtoUtil.isEqual("Ios", value)) {
              return Ios;
            }
            break;
          }
          case 7: {
            if (ProtoUtil.isEqual("Unknown", value)) {
              return Unknown;
            }
            if (ProtoUtil.isEqual("Android", value)) {
              return Android;
            }
            break;
          }
          case 9: {
            if (ProtoUtil.isEqual("Harmonyos", value)) {
              return Harmonyos;
            }
            break;
          }
        }
        return null;
      }
    }
  }

  /**
   * Protobuf type {@code LoginReq}
   */
  public static final class LoginReq extends ProtoMessage<LoginReq> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional .Platform Platform = 11;</code>
     */
    private int platform;

    /**
     * <code>optional .Regular Account = 1;</code>
     */
    private final Regular account = Regular.newInstance();

    /**
     * <code>optional .Official Official = 2;</code>
     */
    private final Official official = Official.newInstance();

    /**
     * <code>optional .OfficialOverseas OfficialOverseas = 3;</code>
     */
    private final OfficialOverseas officialOverseas = OfficialOverseas.newInstance();

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    /**
     * <code>optional string Token = 4;</code>
     */
    private final Utf8String token = Utf8String.newEmptyInstance();

    /**
     * <code>optional string Language = 12;</code>
     */
    private final Utf8String language = Utf8String.newEmptyInstance();

    /**
     * <code>optional string Channel = 13;</code>
     */
    private final Utf8String channel = Utf8String.newEmptyInstance();

    /**
     * <code>optional string Device = 14;</code>
     */
    private final Utf8String device = Utf8String.newEmptyInstance();

    /**
     * <code>optional string Version = 15;</code>
     */
    private final Utf8String version = Utf8String.newEmptyInstance();

    private LoginReq() {
    }

    /**
     * @return a new empty instance of {@code LoginReq}
     */
    public static LoginReq newInstance() {
      return new LoginReq();
    }

    /**
     * <code>optional .Platform Platform = 11;</code>
     * @return whether the platform field is set
     */
    public boolean hasPlatform() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional .Platform Platform = 11;</code>
     * @return this
     */
    public LoginReq clearPlatform() {
      bitField0_ &= ~0x00000001;
      platform = 0;
      return this;
    }

    /**
     * <code>optional .Platform Platform = 11;</code>
     * @return the platform
     */
    public Platform getPlatform() {
      return Platform.forNumber(platform);
    }

    /**
     * Gets the value of the internal enum store. The result is
     * equivalent to {@link LoginReq#getPlatform()}.getNumber().
     *
     * @return numeric wire representation
     */
    public int getPlatformValue() {
      return platform;
    }

    /**
     * Sets the value of the internal enum store. This does not
     * do any validity checks, so be sure to use appropriate value
     * constants from {@link Platform}. Setting an invalid value
     * can cause {@link LoginReq#getPlatform()} to return null
     *
     * @param value the numeric wire value to set
     * @return this
     */
    public LoginReq setPlatformValue(final int value) {
      bitField0_ |= 0x00000001;
      platform = value;
      return this;
    }

    /**
     * <code>optional .Platform Platform = 11;</code>
     * @param value the platform to set
     * @return this
     */
    public LoginReq setPlatform(final Platform value) {
      bitField0_ |= 0x00000001;
      platform = value.getNumber();
      return this;
    }

    /**
     * <code>optional .Regular Account = 1;</code>
     * @return whether the account field is set
     */
    public boolean hasAccount() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional .Regular Account = 1;</code>
     * @return this
     */
    public LoginReq clearAccount() {
      bitField0_ &= ~0x00000002;
      account.clear();
      return this;
    }

    /**
     * <code>optional .Regular Account = 1;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableAccount()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public Regular getAccount() {
      return account;
    }

    /**
     * <code>optional .Regular Account = 1;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public Regular getMutableAccount() {
      bitField0_ |= 0x00000002;
      return account;
    }

    /**
     * <code>optional .Regular Account = 1;</code>
     * @param value the account to set
     * @return this
     */
    public LoginReq setAccount(final Regular value) {
      bitField0_ |= 0x00000002;
      account.copyFrom(value);
      return this;
    }

    /**
     * <code>optional .Official Official = 2;</code>
     * @return whether the official field is set
     */
    public boolean hasOfficial() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional .Official Official = 2;</code>
     * @return this
     */
    public LoginReq clearOfficial() {
      bitField0_ &= ~0x00000004;
      official.clear();
      return this;
    }

    /**
     * <code>optional .Official Official = 2;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableOfficial()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public Official getOfficial() {
      return official;
    }

    /**
     * <code>optional .Official Official = 2;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public Official getMutableOfficial() {
      bitField0_ |= 0x00000004;
      return official;
    }

    /**
     * <code>optional .Official Official = 2;</code>
     * @param value the official to set
     * @return this
     */
    public LoginReq setOfficial(final Official value) {
      bitField0_ |= 0x00000004;
      official.copyFrom(value);
      return this;
    }

    /**
     * <code>optional .OfficialOverseas OfficialOverseas = 3;</code>
     * @return whether the officialOverseas field is set
     */
    public boolean hasOfficialOverseas() {
      return (bitField0_ & 0x00000008) != 0;
    }

    /**
     * <code>optional .OfficialOverseas OfficialOverseas = 3;</code>
     * @return this
     */
    public LoginReq clearOfficialOverseas() {
      bitField0_ &= ~0x00000008;
      officialOverseas.clear();
      return this;
    }

    /**
     * <code>optional .OfficialOverseas OfficialOverseas = 3;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableOfficialOverseas()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public OfficialOverseas getOfficialOverseas() {
      return officialOverseas;
    }

    /**
     * <code>optional .OfficialOverseas OfficialOverseas = 3;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public OfficialOverseas getMutableOfficialOverseas() {
      bitField0_ |= 0x00000008;
      return officialOverseas;
    }

    /**
     * <code>optional .OfficialOverseas OfficialOverseas = 3;</code>
     * @param value the officialOverseas to set
     * @return this
     */
    public LoginReq setOfficialOverseas(final OfficialOverseas value) {
      bitField0_ |= 0x00000008;
      officialOverseas.copyFrom(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000010) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public LoginReq clearNextPackage() {
      bitField0_ &= ~0x00000010;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000010;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public LoginReq addNextPackage(final byte value) {
      bitField0_ |= 0x00000010;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public LoginReq addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000010;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public LoginReq setNextPackage(final byte... values) {
      bitField0_ |= 0x00000010;
      nextPackage.copyFrom(values);
      return this;
    }

    /**
     * <code>optional string Token = 4;</code>
     * @return whether the token field is set
     */
    public boolean hasToken() {
      return (bitField0_ & 0x00000020) != 0;
    }

    /**
     * <code>optional string Token = 4;</code>
     * @return this
     */
    public LoginReq clearToken() {
      bitField0_ &= ~0x00000020;
      token.clear();
      return this;
    }

    /**
     * <code>optional string Token = 4;</code>
     * @return the token
     */
    public String getToken() {
      return token.getString();
    }

    /**
     * <code>optional string Token = 4;</code>
     * @return internal {@code Utf8String} representation of token for reading
     */
    public Utf8String getTokenBytes() {
      return this.token;
    }

    /**
     * <code>optional string Token = 4;</code>
     * @return internal {@code Utf8String} representation of token for modifications
     */
    public Utf8String getMutableTokenBytes() {
      bitField0_ |= 0x00000020;
      return this.token;
    }

    /**
     * <code>optional string Token = 4;</code>
     * @param value the token to set
     * @return this
     */
    public LoginReq setToken(final CharSequence value) {
      bitField0_ |= 0x00000020;
      token.copyFrom(value);
      return this;
    }

    /**
     * <code>optional string Token = 4;</code>
     * @param value the token to set
     * @return this
     */
    public LoginReq setToken(final Utf8String value) {
      bitField0_ |= 0x00000020;
      token.copyFrom(value);
      return this;
    }

    /**
     * <code>optional string Language = 12;</code>
     * @return whether the language field is set
     */
    public boolean hasLanguage() {
      return (bitField0_ & 0x00000040) != 0;
    }

    /**
     * <code>optional string Language = 12;</code>
     * @return this
     */
    public LoginReq clearLanguage() {
      bitField0_ &= ~0x00000040;
      language.clear();
      return this;
    }

    /**
     * <code>optional string Language = 12;</code>
     * @return the language
     */
    public String getLanguage() {
      return language.getString();
    }

    /**
     * <code>optional string Language = 12;</code>
     * @return internal {@code Utf8String} representation of language for reading
     */
    public Utf8String getLanguageBytes() {
      return this.language;
    }

    /**
     * <code>optional string Language = 12;</code>
     * @return internal {@code Utf8String} representation of language for modifications
     */
    public Utf8String getMutableLanguageBytes() {
      bitField0_ |= 0x00000040;
      return this.language;
    }

    /**
     * <code>optional string Language = 12;</code>
     * @param value the language to set
     * @return this
     */
    public LoginReq setLanguage(final CharSequence value) {
      bitField0_ |= 0x00000040;
      language.copyFrom(value);
      return this;
    }

    /**
     * <code>optional string Language = 12;</code>
     * @param value the language to set
     * @return this
     */
    public LoginReq setLanguage(final Utf8String value) {
      bitField0_ |= 0x00000040;
      language.copyFrom(value);
      return this;
    }

    /**
     * <code>optional string Channel = 13;</code>
     * @return whether the channel field is set
     */
    public boolean hasChannel() {
      return (bitField0_ & 0x00000080) != 0;
    }

    /**
     * <code>optional string Channel = 13;</code>
     * @return this
     */
    public LoginReq clearChannel() {
      bitField0_ &= ~0x00000080;
      channel.clear();
      return this;
    }

    /**
     * <code>optional string Channel = 13;</code>
     * @return the channel
     */
    public String getChannel() {
      return channel.getString();
    }

    /**
     * <code>optional string Channel = 13;</code>
     * @return internal {@code Utf8String} representation of channel for reading
     */
    public Utf8String getChannelBytes() {
      return this.channel;
    }

    /**
     * <code>optional string Channel = 13;</code>
     * @return internal {@code Utf8String} representation of channel for modifications
     */
    public Utf8String getMutableChannelBytes() {
      bitField0_ |= 0x00000080;
      return this.channel;
    }

    /**
     * <code>optional string Channel = 13;</code>
     * @param value the channel to set
     * @return this
     */
    public LoginReq setChannel(final CharSequence value) {
      bitField0_ |= 0x00000080;
      channel.copyFrom(value);
      return this;
    }

    /**
     * <code>optional string Channel = 13;</code>
     * @param value the channel to set
     * @return this
     */
    public LoginReq setChannel(final Utf8String value) {
      bitField0_ |= 0x00000080;
      channel.copyFrom(value);
      return this;
    }

    /**
     * <code>optional string Device = 14;</code>
     * @return whether the device field is set
     */
    public boolean hasDevice() {
      return (bitField0_ & 0x00000100) != 0;
    }

    /**
     * <code>optional string Device = 14;</code>
     * @return this
     */
    public LoginReq clearDevice() {
      bitField0_ &= ~0x00000100;
      device.clear();
      return this;
    }

    /**
     * <code>optional string Device = 14;</code>
     * @return the device
     */
    public String getDevice() {
      return device.getString();
    }

    /**
     * <code>optional string Device = 14;</code>
     * @return internal {@code Utf8String} representation of device for reading
     */
    public Utf8String getDeviceBytes() {
      return this.device;
    }

    /**
     * <code>optional string Device = 14;</code>
     * @return internal {@code Utf8String} representation of device for modifications
     */
    public Utf8String getMutableDeviceBytes() {
      bitField0_ |= 0x00000100;
      return this.device;
    }

    /**
     * <code>optional string Device = 14;</code>
     * @param value the device to set
     * @return this
     */
    public LoginReq setDevice(final CharSequence value) {
      bitField0_ |= 0x00000100;
      device.copyFrom(value);
      return this;
    }

    /**
     * <code>optional string Device = 14;</code>
     * @param value the device to set
     * @return this
     */
    public LoginReq setDevice(final Utf8String value) {
      bitField0_ |= 0x00000100;
      device.copyFrom(value);
      return this;
    }

    /**
     * <code>optional string Version = 15;</code>
     * @return whether the version field is set
     */
    public boolean hasVersion() {
      return (bitField0_ & 0x00000200) != 0;
    }

    /**
     * <code>optional string Version = 15;</code>
     * @return this
     */
    public LoginReq clearVersion() {
      bitField0_ &= ~0x00000200;
      version.clear();
      return this;
    }

    /**
     * <code>optional string Version = 15;</code>
     * @return the version
     */
    public String getVersion() {
      return version.getString();
    }

    /**
     * <code>optional string Version = 15;</code>
     * @return internal {@code Utf8String} representation of version for reading
     */
    public Utf8String getVersionBytes() {
      return this.version;
    }

    /**
     * <code>optional string Version = 15;</code>
     * @return internal {@code Utf8String} representation of version for modifications
     */
    public Utf8String getMutableVersionBytes() {
      bitField0_ |= 0x00000200;
      return this.version;
    }

    /**
     * <code>optional string Version = 15;</code>
     * @param value the version to set
     * @return this
     */
    public LoginReq setVersion(final CharSequence value) {
      bitField0_ |= 0x00000200;
      version.copyFrom(value);
      return this;
    }

    /**
     * <code>optional string Version = 15;</code>
     * @param value the version to set
     * @return this
     */
    public LoginReq setVersion(final Utf8String value) {
      bitField0_ |= 0x00000200;
      version.copyFrom(value);
      return this;
    }

    @Override
    public LoginReq copyFrom(final LoginReq other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        platform = other.platform;
        account.copyFrom(other.account);
        official.copyFrom(other.official);
        officialOverseas.copyFrom(other.officialOverseas);
        nextPackage.copyFrom(other.nextPackage);
        token.copyFrom(other.token);
        language.copyFrom(other.language);
        channel.copyFrom(other.channel);
        device.copyFrom(other.device);
        version.copyFrom(other.version);
      }
      return this;
    }

    @Override
    public LoginReq mergeFrom(final LoginReq other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasPlatform()) {
        setPlatformValue(other.platform);
      }
      if (other.hasAccount()) {
        getMutableAccount().mergeFrom(other.account);
      }
      if (other.hasOfficial()) {
        getMutableOfficial().mergeFrom(other.official);
      }
      if (other.hasOfficialOverseas()) {
        getMutableOfficialOverseas().mergeFrom(other.officialOverseas);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      if (other.hasToken()) {
        getMutableTokenBytes().copyFrom(other.token);
      }
      if (other.hasLanguage()) {
        getMutableLanguageBytes().copyFrom(other.language);
      }
      if (other.hasChannel()) {
        getMutableChannelBytes().copyFrom(other.channel);
      }
      if (other.hasDevice()) {
        getMutableDeviceBytes().copyFrom(other.device);
      }
      if (other.hasVersion()) {
        getMutableVersionBytes().copyFrom(other.version);
      }
      return this;
    }

    @Override
    public LoginReq clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      platform = 0;
      account.clear();
      official.clear();
      officialOverseas.clear();
      nextPackage.clear();
      token.clear();
      language.clear();
      channel.clear();
      device.clear();
      version.clear();
      return this;
    }

    @Override
    public LoginReq clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      account.clearQuick();
      official.clearQuick();
      officialOverseas.clearQuick();
      nextPackage.clear();
      token.clear();
      language.clear();
      channel.clear();
      device.clear();
      version.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof LoginReq)) {
        return false;
      }
      LoginReq other = (LoginReq) o;
      return bitField0_ == other.bitField0_
        && (!hasPlatform() || platform == other.platform)
        && (!hasAccount() || account.equals(other.account))
        && (!hasOfficial() || official.equals(other.official))
        && (!hasOfficialOverseas() || officialOverseas.equals(other.officialOverseas))
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage))
        && (!hasToken() || token.equals(other.token))
        && (!hasLanguage() || language.equals(other.language))
        && (!hasChannel() || channel.equals(other.channel))
        && (!hasDevice() || device.equals(other.device))
        && (!hasVersion() || version.equals(other.version));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 88);
        output.writeEnumNoTag(platform);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 10);
        output.writeMessageNoTag(account);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawByte((byte) 18);
        output.writeMessageNoTag(official);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeRawByte((byte) 26);
        output.writeMessageNoTag(officialOverseas);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        output.writeRawByte((byte) 34);
        output.writeStringNoTag(token);
      }
      if ((bitField0_ & 0x00000040) != 0) {
        output.writeRawByte((byte) 98);
        output.writeStringNoTag(language);
      }
      if ((bitField0_ & 0x00000080) != 0) {
        output.writeRawByte((byte) 106);
        output.writeStringNoTag(channel);
      }
      if ((bitField0_ & 0x00000100) != 0) {
        output.writeRawByte((byte) 114);
        output.writeStringNoTag(device);
      }
      if ((bitField0_ & 0x00000200) != 0) {
        output.writeRawByte((byte) 122);
        output.writeStringNoTag(version);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeEnumSizeNoTag(platform);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeMessageSizeNoTag(account);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 1 + ProtoSink.computeMessageSizeNoTag(official);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        size += 1 + ProtoSink.computeMessageSizeNoTag(officialOverseas);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        size += 1 + ProtoSink.computeStringSizeNoTag(token);
      }
      if ((bitField0_ & 0x00000040) != 0) {
        size += 1 + ProtoSink.computeStringSizeNoTag(language);
      }
      if ((bitField0_ & 0x00000080) != 0) {
        size += 1 + ProtoSink.computeStringSizeNoTag(channel);
      }
      if ((bitField0_ & 0x00000100) != 0) {
        size += 1 + ProtoSink.computeStringSizeNoTag(device);
      }
      if ((bitField0_ & 0x00000200) != 0) {
        size += 1 + ProtoSink.computeStringSizeNoTag(version);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public LoginReq mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 88: {
            // platform
            final int value = input.readInt32();
            if (Platform.forNumber(value) != null) {
              platform = value;
              bitField0_ |= 0x00000001;
            }
            tag = input.readTag();
            if (tag != 10) {
              break;
            }
          }
          case 10: {
            // account
            input.readMessage(account);
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 18) {
              break;
            }
          }
          case 18: {
            // official
            input.readMessage(official);
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 26) {
              break;
            }
          }
          case 26: {
            // officialOverseas
            input.readMessage(officialOverseas);
            bitField0_ |= 0x00000008;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000010;
            tag = input.readTag();
            if (tag != 34) {
              break;
            }
          }
          case 34: {
            // token
            input.readString(token);
            bitField0_ |= 0x00000020;
            tag = input.readTag();
            if (tag != 98) {
              break;
            }
          }
          case 98: {
            // language
            input.readString(language);
            bitField0_ |= 0x00000040;
            tag = input.readTag();
            if (tag != 106) {
              break;
            }
          }
          case 106: {
            // channel
            input.readString(channel);
            bitField0_ |= 0x00000080;
            tag = input.readTag();
            if (tag != 114) {
              break;
            }
          }
          case 114: {
            // device
            input.readString(device);
            bitField0_ |= 0x00000100;
            tag = input.readTag();
            if (tag != 122) {
              break;
            }
          }
          case 122: {
            // version
            input.readString(version);
            bitField0_ |= 0x00000200;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeEnum(FieldNames.platform, platform, Platform.converter());
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeMessage(FieldNames.account, account);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeMessage(FieldNames.official, official);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeMessage(FieldNames.officialOverseas, officialOverseas);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        output.writeString(FieldNames.token, token);
      }
      if ((bitField0_ & 0x00000040) != 0) {
        output.writeString(FieldNames.language, language);
      }
      if ((bitField0_ & 0x00000080) != 0) {
        output.writeString(FieldNames.channel, channel);
      }
      if ((bitField0_ & 0x00000100) != 0) {
        output.writeString(FieldNames.device, device);
      }
      if ((bitField0_ & 0x00000200) != 0) {
        output.writeString(FieldNames.version, version);
      }
      output.endObject();
    }

    @Override
    public LoginReq mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 1939328147: {
            if (input.isAtField(FieldNames.platform)) {
              if (!input.trySkipNullValue()) {
                final Platform value = input.readEnum(Platform.converter());
                if (value != null) {
                  platform = value.getNumber();
                  bitField0_ |= 0x00000001;
                } else {
                  input.skipUnknownEnumValue();
                }
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 487334413: {
            if (input.isAtField(FieldNames.account)) {
              if (!input.trySkipNullValue()) {
                input.readMessage(account);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -700645621: {
            if (input.isAtField(FieldNames.official)) {
              if (!input.trySkipNullValue()) {
                input.readMessage(official);
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2026854141: {
            if (input.isAtField(FieldNames.officialOverseas)) {
              if (!input.trySkipNullValue()) {
                input.readMessage(officialOverseas);
                bitField0_ |= 0x00000008;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000010;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 80988633: {
            if (input.isAtField(FieldNames.token)) {
              if (!input.trySkipNullValue()) {
                input.readString(token);
                bitField0_ |= 0x00000020;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1548945544: {
            if (input.isAtField(FieldNames.language)) {
              if (!input.trySkipNullValue()) {
                input.readString(language);
                bitField0_ |= 0x00000040;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1891363613: {
            if (input.isAtField(FieldNames.channel)) {
              if (!input.trySkipNullValue()) {
                input.readString(channel);
                bitField0_ |= 0x00000080;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 2043677302: {
            if (input.isAtField(FieldNames.device)) {
              if (!input.trySkipNullValue()) {
                input.readString(device);
                bitField0_ |= 0x00000100;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 2016261304: {
            if (input.isAtField(FieldNames.version)) {
              if (!input.trySkipNullValue()) {
                input.readString(version);
                bitField0_ |= 0x00000200;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public LoginReq clone() {
      return new LoginReq().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static LoginReq parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new LoginReq(), data).checkInitialized();
    }

    public static LoginReq parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new LoginReq(), input).checkInitialized();
    }

    public static LoginReq parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new LoginReq(), input).checkInitialized();
    }

    /**
     * @return factory for creating LoginReq messages
     */
    public static MessageFactory<LoginReq> getFactory() {
      return LoginReqFactory.INSTANCE;
    }

    private enum LoginReqFactory implements MessageFactory<LoginReq> {
      INSTANCE;

      @Override
      public LoginReq create() {
        return LoginReq.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName platform = FieldName.forField("Platform");

      static final FieldName account = FieldName.forField("Account");

      static final FieldName official = FieldName.forField("Official");

      static final FieldName officialOverseas = FieldName.forField("OfficialOverseas");

      static final FieldName nextPackage = FieldName.forField("NextPackage");

      static final FieldName token = FieldName.forField("Token");

      static final FieldName language = FieldName.forField("Language");

      static final FieldName channel = FieldName.forField("Channel");

      static final FieldName device = FieldName.forField("Device");

      static final FieldName version = FieldName.forField("Version");
    }
  }

  /**
   * Protobuf type {@code Official}
   */
  public static final class Official extends ProtoMessage<Official> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional uint64 Uid = 1;</code>
     */
    private long uid;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    /**
     * <code>optional string Token = 2;</code>
     */
    private final Utf8String token = Utf8String.newEmptyInstance();

    private Official() {
    }

    /**
     * @return a new empty instance of {@code Official}
     */
    public static Official newInstance() {
      return new Official();
    }

    /**
     * <code>optional uint64 Uid = 1;</code>
     * @return whether the uid field is set
     */
    public boolean hasUid() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional uint64 Uid = 1;</code>
     * @return this
     */
    public Official clearUid() {
      bitField0_ &= ~0x00000001;
      uid = 0L;
      return this;
    }

    /**
     * <code>optional uint64 Uid = 1;</code>
     * @return the uid
     */
    public long getUid() {
      return uid;
    }

    /**
     * <code>optional uint64 Uid = 1;</code>
     * @param value the uid to set
     * @return this
     */
    public Official setUid(final long value) {
      bitField0_ |= 0x00000001;
      uid = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public Official clearNextPackage() {
      bitField0_ &= ~0x00000002;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000002;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public Official addNextPackage(final byte value) {
      bitField0_ |= 0x00000002;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public Official addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000002;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public Official setNextPackage(final byte... values) {
      bitField0_ |= 0x00000002;
      nextPackage.copyFrom(values);
      return this;
    }

    /**
     * <code>optional string Token = 2;</code>
     * @return whether the token field is set
     */
    public boolean hasToken() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional string Token = 2;</code>
     * @return this
     */
    public Official clearToken() {
      bitField0_ &= ~0x00000004;
      token.clear();
      return this;
    }

    /**
     * <code>optional string Token = 2;</code>
     * @return the token
     */
    public String getToken() {
      return token.getString();
    }

    /**
     * <code>optional string Token = 2;</code>
     * @return internal {@code Utf8String} representation of token for reading
     */
    public Utf8String getTokenBytes() {
      return this.token;
    }

    /**
     * <code>optional string Token = 2;</code>
     * @return internal {@code Utf8String} representation of token for modifications
     */
    public Utf8String getMutableTokenBytes() {
      bitField0_ |= 0x00000004;
      return this.token;
    }

    /**
     * <code>optional string Token = 2;</code>
     * @param value the token to set
     * @return this
     */
    public Official setToken(final CharSequence value) {
      bitField0_ |= 0x00000004;
      token.copyFrom(value);
      return this;
    }

    /**
     * <code>optional string Token = 2;</code>
     * @param value the token to set
     * @return this
     */
    public Official setToken(final Utf8String value) {
      bitField0_ |= 0x00000004;
      token.copyFrom(value);
      return this;
    }

    @Override
    public Official copyFrom(final Official other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        uid = other.uid;
        nextPackage.copyFrom(other.nextPackage);
        token.copyFrom(other.token);
      }
      return this;
    }

    @Override
    public Official mergeFrom(final Official other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasUid()) {
        setUid(other.uid);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      if (other.hasToken()) {
        getMutableTokenBytes().copyFrom(other.token);
      }
      return this;
    }

    @Override
    public Official clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      uid = 0L;
      nextPackage.clear();
      token.clear();
      return this;
    }

    @Override
    public Official clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      token.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof Official)) {
        return false;
      }
      Official other = (Official) o;
      return bitField0_ == other.bitField0_
        && (!hasUid() || uid == other.uid)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage))
        && (!hasToken() || token.equals(other.token));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt64NoTag(uid);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawByte((byte) 18);
        output.writeStringNoTag(token);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeUInt64SizeNoTag(uid);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 1 + ProtoSink.computeStringSizeNoTag(token);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public Official mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            // uid
            uid = input.readUInt64();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 18) {
              break;
            }
          }
          case 18: {
            // token
            input.readString(token);
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeUInt64(FieldNames.uid, uid);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeString(FieldNames.token, token);
      }
      output.endObject();
    }

    @Override
    public Official mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 85040: {
            if (input.isAtField(FieldNames.uid)) {
              if (!input.trySkipNullValue()) {
                uid = input.readUInt64();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 80988633: {
            if (input.isAtField(FieldNames.token)) {
              if (!input.trySkipNullValue()) {
                input.readString(token);
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public Official clone() {
      return new Official().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static Official parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new Official(), data).checkInitialized();
    }

    public static Official parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new Official(), input).checkInitialized();
    }

    public static Official parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new Official(), input).checkInitialized();
    }

    /**
     * @return factory for creating Official messages
     */
    public static MessageFactory<Official> getFactory() {
      return OfficialFactory.INSTANCE;
    }

    private enum OfficialFactory implements MessageFactory<Official> {
      INSTANCE;

      @Override
      public Official create() {
        return Official.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName uid = FieldName.forField("Uid");

      static final FieldName nextPackage = FieldName.forField("NextPackage");

      static final FieldName token = FieldName.forField("Token");
    }
  }

  /**
   * Protobuf type {@code OfficialOverseas}
   */
  public static final class OfficialOverseas extends ProtoMessage<OfficialOverseas> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    /**
     * <code>optional string Uid = 1;</code>
     */
    private final Utf8String uid = Utf8String.newEmptyInstance();

    /**
     * <code>optional string Token = 2;</code>
     */
    private final Utf8String token = Utf8String.newEmptyInstance();

    private OfficialOverseas() {
    }

    /**
     * @return a new empty instance of {@code OfficialOverseas}
     */
    public static OfficialOverseas newInstance() {
      return new OfficialOverseas();
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public OfficialOverseas clearNextPackage() {
      bitField0_ &= ~0x00000001;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000001;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public OfficialOverseas addNextPackage(final byte value) {
      bitField0_ |= 0x00000001;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public OfficialOverseas addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000001;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public OfficialOverseas setNextPackage(final byte... values) {
      bitField0_ |= 0x00000001;
      nextPackage.copyFrom(values);
      return this;
    }

    /**
     * <code>optional string Uid = 1;</code>
     * @return whether the uid field is set
     */
    public boolean hasUid() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional string Uid = 1;</code>
     * @return this
     */
    public OfficialOverseas clearUid() {
      bitField0_ &= ~0x00000002;
      uid.clear();
      return this;
    }

    /**
     * <code>optional string Uid = 1;</code>
     * @return the uid
     */
    public String getUid() {
      return uid.getString();
    }

    /**
     * <code>optional string Uid = 1;</code>
     * @return internal {@code Utf8String} representation of uid for reading
     */
    public Utf8String getUidBytes() {
      return this.uid;
    }

    /**
     * <code>optional string Uid = 1;</code>
     * @return internal {@code Utf8String} representation of uid for modifications
     */
    public Utf8String getMutableUidBytes() {
      bitField0_ |= 0x00000002;
      return this.uid;
    }

    /**
     * <code>optional string Uid = 1;</code>
     * @param value the uid to set
     * @return this
     */
    public OfficialOverseas setUid(final CharSequence value) {
      bitField0_ |= 0x00000002;
      uid.copyFrom(value);
      return this;
    }

    /**
     * <code>optional string Uid = 1;</code>
     * @param value the uid to set
     * @return this
     */
    public OfficialOverseas setUid(final Utf8String value) {
      bitField0_ |= 0x00000002;
      uid.copyFrom(value);
      return this;
    }

    /**
     * <code>optional string Token = 2;</code>
     * @return whether the token field is set
     */
    public boolean hasToken() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional string Token = 2;</code>
     * @return this
     */
    public OfficialOverseas clearToken() {
      bitField0_ &= ~0x00000004;
      token.clear();
      return this;
    }

    /**
     * <code>optional string Token = 2;</code>
     * @return the token
     */
    public String getToken() {
      return token.getString();
    }

    /**
     * <code>optional string Token = 2;</code>
     * @return internal {@code Utf8String} representation of token for reading
     */
    public Utf8String getTokenBytes() {
      return this.token;
    }

    /**
     * <code>optional string Token = 2;</code>
     * @return internal {@code Utf8String} representation of token for modifications
     */
    public Utf8String getMutableTokenBytes() {
      bitField0_ |= 0x00000004;
      return this.token;
    }

    /**
     * <code>optional string Token = 2;</code>
     * @param value the token to set
     * @return this
     */
    public OfficialOverseas setToken(final CharSequence value) {
      bitField0_ |= 0x00000004;
      token.copyFrom(value);
      return this;
    }

    /**
     * <code>optional string Token = 2;</code>
     * @param value the token to set
     * @return this
     */
    public OfficialOverseas setToken(final Utf8String value) {
      bitField0_ |= 0x00000004;
      token.copyFrom(value);
      return this;
    }

    @Override
    public OfficialOverseas copyFrom(final OfficialOverseas other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        nextPackage.copyFrom(other.nextPackage);
        uid.copyFrom(other.uid);
        token.copyFrom(other.token);
      }
      return this;
    }

    @Override
    public OfficialOverseas mergeFrom(final OfficialOverseas other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      if (other.hasUid()) {
        getMutableUidBytes().copyFrom(other.uid);
      }
      if (other.hasToken()) {
        getMutableTokenBytes().copyFrom(other.token);
      }
      return this;
    }

    @Override
    public OfficialOverseas clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      uid.clear();
      token.clear();
      return this;
    }

    @Override
    public OfficialOverseas clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      uid.clear();
      token.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof OfficialOverseas)) {
        return false;
      }
      OfficialOverseas other = (OfficialOverseas) o;
      return bitField0_ == other.bitField0_
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage))
        && (!hasUid() || uid.equals(other.uid))
        && (!hasToken() || token.equals(other.token));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 10);
        output.writeStringNoTag(uid);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawByte((byte) 18);
        output.writeStringNoTag(token);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeStringSizeNoTag(uid);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 1 + ProtoSink.computeStringSizeNoTag(token);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public OfficialOverseas mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 10) {
              break;
            }
          }
          case 10: {
            // uid
            input.readString(uid);
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 18) {
              break;
            }
          }
          case 18: {
            // token
            input.readString(token);
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeString(FieldNames.uid, uid);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeString(FieldNames.token, token);
      }
      output.endObject();
    }

    @Override
    public OfficialOverseas mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 85040: {
            if (input.isAtField(FieldNames.uid)) {
              if (!input.trySkipNullValue()) {
                input.readString(uid);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 80988633: {
            if (input.isAtField(FieldNames.token)) {
              if (!input.trySkipNullValue()) {
                input.readString(token);
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public OfficialOverseas clone() {
      return new OfficialOverseas().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static OfficialOverseas parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new OfficialOverseas(), data).checkInitialized();
    }

    public static OfficialOverseas parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new OfficialOverseas(), input).checkInitialized();
    }

    public static OfficialOverseas parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new OfficialOverseas(), input).checkInitialized();
    }

    /**
     * @return factory for creating OfficialOverseas messages
     */
    public static MessageFactory<OfficialOverseas> getFactory() {
      return OfficialOverseasFactory.INSTANCE;
    }

    private enum OfficialOverseasFactory implements MessageFactory<OfficialOverseas> {
      INSTANCE;

      @Override
      public OfficialOverseas create() {
        return OfficialOverseas.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName nextPackage = FieldName.forField("NextPackage");

      static final FieldName uid = FieldName.forField("Uid");

      static final FieldName token = FieldName.forField("Token");
    }
  }

  /**
   * Protobuf type {@code Regular}
   */
  public static final class Regular extends ProtoMessage<Regular> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    /**
     * <code>optional string Name = 1;</code>
     */
    private final Utf8String name = Utf8String.newEmptyInstance();

    /**
     * <code>optional string Pass = 2;</code>
     */
    private final Utf8String pass = Utf8String.newEmptyInstance();

    private Regular() {
    }

    /**
     * @return a new empty instance of {@code Regular}
     */
    public static Regular newInstance() {
      return new Regular();
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public Regular clearNextPackage() {
      bitField0_ &= ~0x00000001;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000001;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public Regular addNextPackage(final byte value) {
      bitField0_ |= 0x00000001;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public Regular addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000001;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public Regular setNextPackage(final byte... values) {
      bitField0_ |= 0x00000001;
      nextPackage.copyFrom(values);
      return this;
    }

    /**
     * <code>optional string Name = 1;</code>
     * @return whether the name field is set
     */
    public boolean hasName() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional string Name = 1;</code>
     * @return this
     */
    public Regular clearName() {
      bitField0_ &= ~0x00000002;
      name.clear();
      return this;
    }

    /**
     * <code>optional string Name = 1;</code>
     * @return the name
     */
    public String getName() {
      return name.getString();
    }

    /**
     * <code>optional string Name = 1;</code>
     * @return internal {@code Utf8String} representation of name for reading
     */
    public Utf8String getNameBytes() {
      return this.name;
    }

    /**
     * <code>optional string Name = 1;</code>
     * @return internal {@code Utf8String} representation of name for modifications
     */
    public Utf8String getMutableNameBytes() {
      bitField0_ |= 0x00000002;
      return this.name;
    }

    /**
     * <code>optional string Name = 1;</code>
     * @param value the name to set
     * @return this
     */
    public Regular setName(final CharSequence value) {
      bitField0_ |= 0x00000002;
      name.copyFrom(value);
      return this;
    }

    /**
     * <code>optional string Name = 1;</code>
     * @param value the name to set
     * @return this
     */
    public Regular setName(final Utf8String value) {
      bitField0_ |= 0x00000002;
      name.copyFrom(value);
      return this;
    }

    /**
     * <code>optional string Pass = 2;</code>
     * @return whether the pass field is set
     */
    public boolean hasPass() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional string Pass = 2;</code>
     * @return this
     */
    public Regular clearPass() {
      bitField0_ &= ~0x00000004;
      pass.clear();
      return this;
    }

    /**
     * <code>optional string Pass = 2;</code>
     * @return the pass
     */
    public String getPass() {
      return pass.getString();
    }

    /**
     * <code>optional string Pass = 2;</code>
     * @return internal {@code Utf8String} representation of pass for reading
     */
    public Utf8String getPassBytes() {
      return this.pass;
    }

    /**
     * <code>optional string Pass = 2;</code>
     * @return internal {@code Utf8String} representation of pass for modifications
     */
    public Utf8String getMutablePassBytes() {
      bitField0_ |= 0x00000004;
      return this.pass;
    }

    /**
     * <code>optional string Pass = 2;</code>
     * @param value the pass to set
     * @return this
     */
    public Regular setPass(final CharSequence value) {
      bitField0_ |= 0x00000004;
      pass.copyFrom(value);
      return this;
    }

    /**
     * <code>optional string Pass = 2;</code>
     * @param value the pass to set
     * @return this
     */
    public Regular setPass(final Utf8String value) {
      bitField0_ |= 0x00000004;
      pass.copyFrom(value);
      return this;
    }

    @Override
    public Regular copyFrom(final Regular other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        nextPackage.copyFrom(other.nextPackage);
        name.copyFrom(other.name);
        pass.copyFrom(other.pass);
      }
      return this;
    }

    @Override
    public Regular mergeFrom(final Regular other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      if (other.hasName()) {
        getMutableNameBytes().copyFrom(other.name);
      }
      if (other.hasPass()) {
        getMutablePassBytes().copyFrom(other.pass);
      }
      return this;
    }

    @Override
    public Regular clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      name.clear();
      pass.clear();
      return this;
    }

    @Override
    public Regular clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      name.clear();
      pass.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof Regular)) {
        return false;
      }
      Regular other = (Regular) o;
      return bitField0_ == other.bitField0_
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage))
        && (!hasName() || name.equals(other.name))
        && (!hasPass() || pass.equals(other.pass));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 10);
        output.writeStringNoTag(name);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawByte((byte) 18);
        output.writeStringNoTag(pass);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeStringSizeNoTag(name);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 1 + ProtoSink.computeStringSizeNoTag(pass);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public Regular mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 10) {
              break;
            }
          }
          case 10: {
            // name
            input.readString(name);
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 18) {
              break;
            }
          }
          case 18: {
            // pass
            input.readString(pass);
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeString(FieldNames.name, name);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeString(FieldNames.pass, pass);
      }
      output.endObject();
    }

    @Override
    public Regular mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 2420395: {
            if (input.isAtField(FieldNames.name)) {
              if (!input.trySkipNullValue()) {
                input.readString(name);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 2480177: {
            if (input.isAtField(FieldNames.pass)) {
              if (!input.trySkipNullValue()) {
                input.readString(pass);
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public Regular clone() {
      return new Regular().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static Regular parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new Regular(), data).checkInitialized();
    }

    public static Regular parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new Regular(), input).checkInitialized();
    }

    public static Regular parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new Regular(), input).checkInitialized();
    }

    /**
     * @return factory for creating Regular messages
     */
    public static MessageFactory<Regular> getFactory() {
      return RegularFactory.INSTANCE;
    }

    private enum RegularFactory implements MessageFactory<Regular> {
      INSTANCE;

      @Override
      public Regular create() {
        return Regular.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName nextPackage = FieldName.forField("NextPackage");

      static final FieldName name = FieldName.forField("Name");

      static final FieldName pass = FieldName.forField("Pass");
    }
  }

  /**
   * Protobuf type {@code LoginResp}
   */
  public static final class LoginResp extends ProtoMessage<LoginResp> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    /**
     * <code>optional string Token = 1;</code>
     */
    private final Utf8String token = Utf8String.newEmptyInstance();

    private LoginResp() {
    }

    /**
     * @return a new empty instance of {@code LoginResp}
     */
    public static LoginResp newInstance() {
      return new LoginResp();
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public LoginResp clearNextPackage() {
      bitField0_ &= ~0x00000001;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000001;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public LoginResp addNextPackage(final byte value) {
      bitField0_ |= 0x00000001;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public LoginResp addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000001;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public LoginResp setNextPackage(final byte... values) {
      bitField0_ |= 0x00000001;
      nextPackage.copyFrom(values);
      return this;
    }

    /**
     * <code>optional string Token = 1;</code>
     * @return whether the token field is set
     */
    public boolean hasToken() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional string Token = 1;</code>
     * @return this
     */
    public LoginResp clearToken() {
      bitField0_ &= ~0x00000002;
      token.clear();
      return this;
    }

    /**
     * <code>optional string Token = 1;</code>
     * @return the token
     */
    public String getToken() {
      return token.getString();
    }

    /**
     * <code>optional string Token = 1;</code>
     * @return internal {@code Utf8String} representation of token for reading
     */
    public Utf8String getTokenBytes() {
      return this.token;
    }

    /**
     * <code>optional string Token = 1;</code>
     * @return internal {@code Utf8String} representation of token for modifications
     */
    public Utf8String getMutableTokenBytes() {
      bitField0_ |= 0x00000002;
      return this.token;
    }

    /**
     * <code>optional string Token = 1;</code>
     * @param value the token to set
     * @return this
     */
    public LoginResp setToken(final CharSequence value) {
      bitField0_ |= 0x00000002;
      token.copyFrom(value);
      return this;
    }

    /**
     * <code>optional string Token = 1;</code>
     * @param value the token to set
     * @return this
     */
    public LoginResp setToken(final Utf8String value) {
      bitField0_ |= 0x00000002;
      token.copyFrom(value);
      return this;
    }

    @Override
    public LoginResp copyFrom(final LoginResp other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        nextPackage.copyFrom(other.nextPackage);
        token.copyFrom(other.token);
      }
      return this;
    }

    @Override
    public LoginResp mergeFrom(final LoginResp other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      if (other.hasToken()) {
        getMutableTokenBytes().copyFrom(other.token);
      }
      return this;
    }

    @Override
    public LoginResp clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      token.clear();
      return this;
    }

    @Override
    public LoginResp clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      token.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof LoginResp)) {
        return false;
      }
      LoginResp other = (LoginResp) o;
      return bitField0_ == other.bitField0_
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage))
        && (!hasToken() || token.equals(other.token));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 10);
        output.writeStringNoTag(token);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeStringSizeNoTag(token);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public LoginResp mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 10) {
              break;
            }
          }
          case 10: {
            // token
            input.readString(token);
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeString(FieldNames.token, token);
      }
      output.endObject();
    }

    @Override
    public LoginResp mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 80988633: {
            if (input.isAtField(FieldNames.token)) {
              if (!input.trySkipNullValue()) {
                input.readString(token);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public LoginResp clone() {
      return new LoginResp().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static LoginResp parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new LoginResp(), data).checkInitialized();
    }

    public static LoginResp parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new LoginResp(), input).checkInitialized();
    }

    public static LoginResp parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new LoginResp(), input).checkInitialized();
    }

    /**
     * @return factory for creating LoginResp messages
     */
    public static MessageFactory<LoginResp> getFactory() {
      return LoginRespFactory.INSTANCE;
    }

    private enum LoginRespFactory implements MessageFactory<LoginResp> {
      INSTANCE;

      @Override
      public LoginResp create() {
        return LoginResp.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName nextPackage = FieldName.forField("NextPackage");

      static final FieldName token = FieldName.forField("Token");
    }
  }
}
