// Code generated by protocol buffer compiler. Do not edit!
package emu.nebula.proto;

import java.io.IOException;
import us.hebi.quickbuf.FieldName;
import us.hebi.quickbuf.InvalidProtocolBufferException;
import us.hebi.quickbuf.JsonSink;
import us.hebi.quickbuf.JsonSource;
import us.hebi.quickbuf.MessageFactory;
import us.hebi.quickbuf.ProtoMessage;
import us.hebi.quickbuf.ProtoSink;
import us.hebi.quickbuf.ProtoSource;
import us.hebi.quickbuf.RepeatedByte;
import us.hebi.quickbuf.RepeatedInt;
import us.hebi.quickbuf.RepeatedMessage;

public final class PlayerData {
  /**
   * Protobuf type {@code PlayerInfo}
   */
  public static final class PlayerInfo extends ProtoMessage<PlayerInfo> implements Cloneable {
    private static final long serialVersionUID = 0L;

    private int bitField1_;

    /**
     * <code>optional int64 TalentResetTime = 26;</code>
     */
    private long talentResetTime;

    /**
     * <code>optional int64 NicknameResetTime = 121;</code>
     */
    private long nicknameResetTime;

    /**
     * <code>optional int64 MusicInfo = 122;</code>
     */
    private long musicInfo;

    /**
     * <code>optional int64 ServerTs = 127;</code>
     */
    private long serverTs;

    /**
     * <code>optional uint32 SendGiftCnt = 15;</code>
     */
    private int sendGiftCnt;

    /**
     * <code>optional uint32 SigninIndex = 20;</code>
     */
    private int signinIndex;

    /**
     * <code>optional uint32 EquipmentDoubleCount = 27;</code>
     */
    private int equipmentDoubleCount;

    /**
     * <code>optional uint32 TourGuideQuestGroup = 33;</code>
     */
    private int tourGuideQuestGroup;

    /**
     * <code>optional uint32 TowerTicket = 126;</code>
     */
    private int towerTicket;

    /**
     * <code>optional bool DailyShopRewardStatus = 125;</code>
     */
    private boolean dailyShopRewardStatus;

    /**
     * <code>optional .AccInfo Acc = 1;</code>
     */
    private final Public.AccInfo acc = Public.AccInfo.newInstance();

    /**
     * <code>optional .TowerFormation Formation = 5;</code>
     */
    private final Public.TowerFormation formation = Public.TowerFormation.newInstance();

    /**
     * <code>optional .EnergyInfo Energy = 7;</code>
     */
    private final EnergyInfo energy = EnergyInfo.newInstance();

    /**
     * <code>optional .WorldClassInfo WorldClass = 8;</code>
     */
    private final WorldClassInfo worldClass = WorldClassInfo.newInstance();

    /**
     * <code>optional .AgentData Agent = 9;</code>
     */
    private final Public.AgentData agent = Public.AgentData.newInstance();

    /**
     * <code>optional .Quests Quests = 13;</code>
     */
    private final Public.Quests quests = Public.Quests.newInstance();

    /**
     * <code>optional .StateInfo State = 14;</code>
     */
    private final Public.StateInfo state = Public.StateInfo.newInstance();

    /**
     * <code>optional .PhoneInfo Phone = 25;</code>
     */
    private final PhoneInfo phone = PhoneInfo.newInstance();

    /**
     * <code>optional .StoryInfo Story = 30;</code>
     */
    private final Public.StoryInfo story = Public.StoryInfo.newInstance();

    /**
     * <code>optional .VampireSurvivorRecordInfo VampireSurvivorRecord = 31;</code>
     */
    private final Public.VampireSurvivorRecordInfo vampireSurvivorRecord = Public.VampireSurvivorRecordInfo.newInstance();

    /**
     * <code>optional bytes Achievements = 18;</code>
     */
    private final RepeatedByte achievements = RepeatedByte.newEmptyInstance();

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    /**
     * <code>repeated uint32 RglPassedIds = 10;</code>
     */
    private final RepeatedInt rglPassedIds = RepeatedInt.newEmptyInstance();

    /**
     * <code>repeated uint32 Board = 16;</code>
     */
    private final RepeatedInt board = RepeatedInt.newEmptyInstance();

    /**
     * <code>repeated uint32 DatingCharIds = 17;</code>
     */
    private final RepeatedInt datingCharIds = RepeatedInt.newEmptyInstance();

    /**
     * <code>repeated uint32 DailyActiveIds = 32;</code>
     */
    private final RepeatedInt dailyActiveIds = RepeatedInt.newEmptyInstance();

    /**
     * <code>repeated uint32 HonorList = 123;</code>
     */
    private final RepeatedInt honorList = RepeatedInt.newEmptyInstance();

    /**
     * <code>repeated .Res Res = 2;</code>
     */
    private final RepeatedMessage<Public.Res> res = RepeatedMessage.newEmptyInstance(Public.Res.getFactory());

    /**
     * <code>repeated .Item Items = 3;</code>
     */
    private final RepeatedMessage<Public.Item> items = RepeatedMessage.newEmptyInstance(Public.Item.getFactory());

    /**
     * <code>repeated .Char Chars = 4;</code>
     */
    private final RepeatedMessage<Public.Char> chars = RepeatedMessage.newEmptyInstance(Public.Char.getFactory());

    /**
     * <code>repeated .EquipmentInfo Equipments = 11;</code>
     */
    private final RepeatedMessage<Public.EquipmentInfo> equipments = RepeatedMessage.newEmptyInstance(Public.EquipmentInfo.getFactory());

    /**
     * <code>repeated .RegionBossLevel RegionBossLevels = 12;</code>
     */
    private final RepeatedMessage<Public.RegionBossLevel> regionBossLevels = RepeatedMessage.newEmptyInstance(Public.RegionBossLevel.getFactory());

    /**
     * <code>repeated .HandbookInfo Handbook = 19;</code>
     */
    private final RepeatedMessage<Public.HandbookInfo> handbook = RepeatedMessage.newEmptyInstance(Public.HandbookInfo.getFactory());

    /**
     * <code>repeated .Title Titles = 21;</code>
     */
    private final RepeatedMessage<Public.Title> titles = RepeatedMessage.newEmptyInstance(Public.Title.getFactory());

    /**
     * <code>repeated .DailyInstance DailyInstances = 22;</code>
     */
    private final RepeatedMessage<Public.DailyInstance> dailyInstances = RepeatedMessage.newEmptyInstance(Public.DailyInstance.getFactory());

    /**
     * <code>repeated .DictionaryTab Dictionaries = 23;</code>
     */
    private final RepeatedMessage<DictionaryTab> dictionaries = RepeatedMessage.newEmptyInstance(DictionaryTab.getFactory());

    /**
     * <code>repeated .Activity Activities = 24;</code>
     */
    private final RepeatedMessage<Public.Activity> activities = RepeatedMessage.newEmptyInstance(Public.Activity.getFactory());

    /**
     * <code>repeated .Disc Discs = 28;</code>
     */
    private final RepeatedMessage<Public.Disc> discs = RepeatedMessage.newEmptyInstance(Public.Disc.getFactory());

    /**
     * <code>repeated .EquipmentInstance EquipmentInstances = 29;</code>
     */
    private final RepeatedMessage<Public.EquipmentInstance> equipmentInstances = RepeatedMessage.newEmptyInstance(Public.EquipmentInstance.getFactory());

    /**
     * <code>repeated .SkillInstance SkillInstances = 34;</code>
     */
    private final RepeatedMessage<Public.SkillInstance> skillInstances = RepeatedMessage.newEmptyInstance(Public.SkillInstance.getFactory());

    /**
     * <code>repeated .WeekBossLevel WeekBossLevels = 35;</code>
     */
    private final RepeatedMessage<Public.WeekBossLevel> weekBossLevels = RepeatedMessage.newEmptyInstance(Public.WeekBossLevel.getFactory());

    /**
     * <code>repeated .CharGemInstance CharGemInstances = 36;</code>
     */
    private final RepeatedMessage<Public.CharGemInstance> charGemInstances = RepeatedMessage.newEmptyInstance(Public.CharGemInstance.getFactory());

    /**
     * <code>repeated .TutorialLevel TutorialLevels = 37;</code>
     */
    private final RepeatedMessage<Public.TutorialLevel> tutorialLevels = RepeatedMessage.newEmptyInstance(Public.TutorialLevel.getFactory());

    /**
     * <code>repeated .HonorInfo Honors = 124;</code>
     */
    private final RepeatedMessage<Public.HonorInfo> honors = RepeatedMessage.newEmptyInstance(Public.HonorInfo.getFactory());

    private PlayerInfo() {
    }

    /**
     * @return a new empty instance of {@code PlayerInfo}
     */
    public static PlayerInfo newInstance() {
      return new PlayerInfo();
    }

    /**
     * <code>optional int64 TalentResetTime = 26;</code>
     * @return whether the talentResetTime field is set
     */
    public boolean hasTalentResetTime() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional int64 TalentResetTime = 26;</code>
     * @return this
     */
    public PlayerInfo clearTalentResetTime() {
      bitField0_ &= ~0x00000001;
      talentResetTime = 0L;
      return this;
    }

    /**
     * <code>optional int64 TalentResetTime = 26;</code>
     * @return the talentResetTime
     */
    public long getTalentResetTime() {
      return talentResetTime;
    }

    /**
     * <code>optional int64 TalentResetTime = 26;</code>
     * @param value the talentResetTime to set
     * @return this
     */
    public PlayerInfo setTalentResetTime(final long value) {
      bitField0_ |= 0x00000001;
      talentResetTime = value;
      return this;
    }

    /**
     * <code>optional int64 NicknameResetTime = 121;</code>
     * @return whether the nicknameResetTime field is set
     */
    public boolean hasNicknameResetTime() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional int64 NicknameResetTime = 121;</code>
     * @return this
     */
    public PlayerInfo clearNicknameResetTime() {
      bitField0_ &= ~0x00000002;
      nicknameResetTime = 0L;
      return this;
    }

    /**
     * <code>optional int64 NicknameResetTime = 121;</code>
     * @return the nicknameResetTime
     */
    public long getNicknameResetTime() {
      return nicknameResetTime;
    }

    /**
     * <code>optional int64 NicknameResetTime = 121;</code>
     * @param value the nicknameResetTime to set
     * @return this
     */
    public PlayerInfo setNicknameResetTime(final long value) {
      bitField0_ |= 0x00000002;
      nicknameResetTime = value;
      return this;
    }

    /**
     * <code>optional int64 MusicInfo = 122;</code>
     * @return whether the musicInfo field is set
     */
    public boolean hasMusicInfo() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional int64 MusicInfo = 122;</code>
     * @return this
     */
    public PlayerInfo clearMusicInfo() {
      bitField0_ &= ~0x00000004;
      musicInfo = 0L;
      return this;
    }

    /**
     * <code>optional int64 MusicInfo = 122;</code>
     * @return the musicInfo
     */
    public long getMusicInfo() {
      return musicInfo;
    }

    /**
     * <code>optional int64 MusicInfo = 122;</code>
     * @param value the musicInfo to set
     * @return this
     */
    public PlayerInfo setMusicInfo(final long value) {
      bitField0_ |= 0x00000004;
      musicInfo = value;
      return this;
    }

    /**
     * <code>optional int64 ServerTs = 127;</code>
     * @return whether the serverTs field is set
     */
    public boolean hasServerTs() {
      return (bitField0_ & 0x00000008) != 0;
    }

    /**
     * <code>optional int64 ServerTs = 127;</code>
     * @return this
     */
    public PlayerInfo clearServerTs() {
      bitField0_ &= ~0x00000008;
      serverTs = 0L;
      return this;
    }

    /**
     * <code>optional int64 ServerTs = 127;</code>
     * @return the serverTs
     */
    public long getServerTs() {
      return serverTs;
    }

    /**
     * <code>optional int64 ServerTs = 127;</code>
     * @param value the serverTs to set
     * @return this
     */
    public PlayerInfo setServerTs(final long value) {
      bitField0_ |= 0x00000008;
      serverTs = value;
      return this;
    }

    /**
     * <code>optional uint32 SendGiftCnt = 15;</code>
     * @return whether the sendGiftCnt field is set
     */
    public boolean hasSendGiftCnt() {
      return (bitField0_ & 0x00000010) != 0;
    }

    /**
     * <code>optional uint32 SendGiftCnt = 15;</code>
     * @return this
     */
    public PlayerInfo clearSendGiftCnt() {
      bitField0_ &= ~0x00000010;
      sendGiftCnt = 0;
      return this;
    }

    /**
     * <code>optional uint32 SendGiftCnt = 15;</code>
     * @return the sendGiftCnt
     */
    public int getSendGiftCnt() {
      return sendGiftCnt;
    }

    /**
     * <code>optional uint32 SendGiftCnt = 15;</code>
     * @param value the sendGiftCnt to set
     * @return this
     */
    public PlayerInfo setSendGiftCnt(final int value) {
      bitField0_ |= 0x00000010;
      sendGiftCnt = value;
      return this;
    }

    /**
     * <code>optional uint32 SigninIndex = 20;</code>
     * @return whether the signinIndex field is set
     */
    public boolean hasSigninIndex() {
      return (bitField0_ & 0x00000020) != 0;
    }

    /**
     * <code>optional uint32 SigninIndex = 20;</code>
     * @return this
     */
    public PlayerInfo clearSigninIndex() {
      bitField0_ &= ~0x00000020;
      signinIndex = 0;
      return this;
    }

    /**
     * <code>optional uint32 SigninIndex = 20;</code>
     * @return the signinIndex
     */
    public int getSigninIndex() {
      return signinIndex;
    }

    /**
     * <code>optional uint32 SigninIndex = 20;</code>
     * @param value the signinIndex to set
     * @return this
     */
    public PlayerInfo setSigninIndex(final int value) {
      bitField0_ |= 0x00000020;
      signinIndex = value;
      return this;
    }

    /**
     * <code>optional uint32 EquipmentDoubleCount = 27;</code>
     * @return whether the equipmentDoubleCount field is set
     */
    public boolean hasEquipmentDoubleCount() {
      return (bitField0_ & 0x00000040) != 0;
    }

    /**
     * <code>optional uint32 EquipmentDoubleCount = 27;</code>
     * @return this
     */
    public PlayerInfo clearEquipmentDoubleCount() {
      bitField0_ &= ~0x00000040;
      equipmentDoubleCount = 0;
      return this;
    }

    /**
     * <code>optional uint32 EquipmentDoubleCount = 27;</code>
     * @return the equipmentDoubleCount
     */
    public int getEquipmentDoubleCount() {
      return equipmentDoubleCount;
    }

    /**
     * <code>optional uint32 EquipmentDoubleCount = 27;</code>
     * @param value the equipmentDoubleCount to set
     * @return this
     */
    public PlayerInfo setEquipmentDoubleCount(final int value) {
      bitField0_ |= 0x00000040;
      equipmentDoubleCount = value;
      return this;
    }

    /**
     * <code>optional uint32 TourGuideQuestGroup = 33;</code>
     * @return whether the tourGuideQuestGroup field is set
     */
    public boolean hasTourGuideQuestGroup() {
      return (bitField0_ & 0x00000080) != 0;
    }

    /**
     * <code>optional uint32 TourGuideQuestGroup = 33;</code>
     * @return this
     */
    public PlayerInfo clearTourGuideQuestGroup() {
      bitField0_ &= ~0x00000080;
      tourGuideQuestGroup = 0;
      return this;
    }

    /**
     * <code>optional uint32 TourGuideQuestGroup = 33;</code>
     * @return the tourGuideQuestGroup
     */
    public int getTourGuideQuestGroup() {
      return tourGuideQuestGroup;
    }

    /**
     * <code>optional uint32 TourGuideQuestGroup = 33;</code>
     * @param value the tourGuideQuestGroup to set
     * @return this
     */
    public PlayerInfo setTourGuideQuestGroup(final int value) {
      bitField0_ |= 0x00000080;
      tourGuideQuestGroup = value;
      return this;
    }

    /**
     * <code>optional uint32 TowerTicket = 126;</code>
     * @return whether the towerTicket field is set
     */
    public boolean hasTowerTicket() {
      return (bitField0_ & 0x00000100) != 0;
    }

    /**
     * <code>optional uint32 TowerTicket = 126;</code>
     * @return this
     */
    public PlayerInfo clearTowerTicket() {
      bitField0_ &= ~0x00000100;
      towerTicket = 0;
      return this;
    }

    /**
     * <code>optional uint32 TowerTicket = 126;</code>
     * @return the towerTicket
     */
    public int getTowerTicket() {
      return towerTicket;
    }

    /**
     * <code>optional uint32 TowerTicket = 126;</code>
     * @param value the towerTicket to set
     * @return this
     */
    public PlayerInfo setTowerTicket(final int value) {
      bitField0_ |= 0x00000100;
      towerTicket = value;
      return this;
    }

    /**
     * <code>optional bool DailyShopRewardStatus = 125;</code>
     * @return whether the dailyShopRewardStatus field is set
     */
    public boolean hasDailyShopRewardStatus() {
      return (bitField0_ & 0x00000200) != 0;
    }

    /**
     * <code>optional bool DailyShopRewardStatus = 125;</code>
     * @return this
     */
    public PlayerInfo clearDailyShopRewardStatus() {
      bitField0_ &= ~0x00000200;
      dailyShopRewardStatus = false;
      return this;
    }

    /**
     * <code>optional bool DailyShopRewardStatus = 125;</code>
     * @return the dailyShopRewardStatus
     */
    public boolean getDailyShopRewardStatus() {
      return dailyShopRewardStatus;
    }

    /**
     * <code>optional bool DailyShopRewardStatus = 125;</code>
     * @param value the dailyShopRewardStatus to set
     * @return this
     */
    public PlayerInfo setDailyShopRewardStatus(final boolean value) {
      bitField0_ |= 0x00000200;
      dailyShopRewardStatus = value;
      return this;
    }

    /**
     * <code>optional .AccInfo Acc = 1;</code>
     * @return whether the acc field is set
     */
    public boolean hasAcc() {
      return (bitField0_ & 0x00000400) != 0;
    }

    /**
     * <code>optional .AccInfo Acc = 1;</code>
     * @return this
     */
    public PlayerInfo clearAcc() {
      bitField0_ &= ~0x00000400;
      acc.clear();
      return this;
    }

    /**
     * <code>optional .AccInfo Acc = 1;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableAcc()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public Public.AccInfo getAcc() {
      return acc;
    }

    /**
     * <code>optional .AccInfo Acc = 1;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public Public.AccInfo getMutableAcc() {
      bitField0_ |= 0x00000400;
      return acc;
    }

    /**
     * <code>optional .AccInfo Acc = 1;</code>
     * @param value the acc to set
     * @return this
     */
    public PlayerInfo setAcc(final Public.AccInfo value) {
      bitField0_ |= 0x00000400;
      acc.copyFrom(value);
      return this;
    }

    /**
     * <code>optional .TowerFormation Formation = 5;</code>
     * @return whether the formation field is set
     */
    public boolean hasFormation() {
      return (bitField0_ & 0x00000800) != 0;
    }

    /**
     * <code>optional .TowerFormation Formation = 5;</code>
     * @return this
     */
    public PlayerInfo clearFormation() {
      bitField0_ &= ~0x00000800;
      formation.clear();
      return this;
    }

    /**
     * <code>optional .TowerFormation Formation = 5;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableFormation()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public Public.TowerFormation getFormation() {
      return formation;
    }

    /**
     * <code>optional .TowerFormation Formation = 5;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public Public.TowerFormation getMutableFormation() {
      bitField0_ |= 0x00000800;
      return formation;
    }

    /**
     * <code>optional .TowerFormation Formation = 5;</code>
     * @param value the formation to set
     * @return this
     */
    public PlayerInfo setFormation(final Public.TowerFormation value) {
      bitField0_ |= 0x00000800;
      formation.copyFrom(value);
      return this;
    }

    /**
     * <code>optional .EnergyInfo Energy = 7;</code>
     * @return whether the energy field is set
     */
    public boolean hasEnergy() {
      return (bitField0_ & 0x00001000) != 0;
    }

    /**
     * <code>optional .EnergyInfo Energy = 7;</code>
     * @return this
     */
    public PlayerInfo clearEnergy() {
      bitField0_ &= ~0x00001000;
      energy.clear();
      return this;
    }

    /**
     * <code>optional .EnergyInfo Energy = 7;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableEnergy()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public EnergyInfo getEnergy() {
      return energy;
    }

    /**
     * <code>optional .EnergyInfo Energy = 7;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public EnergyInfo getMutableEnergy() {
      bitField0_ |= 0x00001000;
      return energy;
    }

    /**
     * <code>optional .EnergyInfo Energy = 7;</code>
     * @param value the energy to set
     * @return this
     */
    public PlayerInfo setEnergy(final EnergyInfo value) {
      bitField0_ |= 0x00001000;
      energy.copyFrom(value);
      return this;
    }

    /**
     * <code>optional .WorldClassInfo WorldClass = 8;</code>
     * @return whether the worldClass field is set
     */
    public boolean hasWorldClass() {
      return (bitField0_ & 0x00002000) != 0;
    }

    /**
     * <code>optional .WorldClassInfo WorldClass = 8;</code>
     * @return this
     */
    public PlayerInfo clearWorldClass() {
      bitField0_ &= ~0x00002000;
      worldClass.clear();
      return this;
    }

    /**
     * <code>optional .WorldClassInfo WorldClass = 8;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableWorldClass()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public WorldClassInfo getWorldClass() {
      return worldClass;
    }

    /**
     * <code>optional .WorldClassInfo WorldClass = 8;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public WorldClassInfo getMutableWorldClass() {
      bitField0_ |= 0x00002000;
      return worldClass;
    }

    /**
     * <code>optional .WorldClassInfo WorldClass = 8;</code>
     * @param value the worldClass to set
     * @return this
     */
    public PlayerInfo setWorldClass(final WorldClassInfo value) {
      bitField0_ |= 0x00002000;
      worldClass.copyFrom(value);
      return this;
    }

    /**
     * <code>optional .AgentData Agent = 9;</code>
     * @return whether the agent field is set
     */
    public boolean hasAgent() {
      return (bitField0_ & 0x00004000) != 0;
    }

    /**
     * <code>optional .AgentData Agent = 9;</code>
     * @return this
     */
    public PlayerInfo clearAgent() {
      bitField0_ &= ~0x00004000;
      agent.clear();
      return this;
    }

    /**
     * <code>optional .AgentData Agent = 9;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableAgent()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public Public.AgentData getAgent() {
      return agent;
    }

    /**
     * <code>optional .AgentData Agent = 9;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public Public.AgentData getMutableAgent() {
      bitField0_ |= 0x00004000;
      return agent;
    }

    /**
     * <code>optional .AgentData Agent = 9;</code>
     * @param value the agent to set
     * @return this
     */
    public PlayerInfo setAgent(final Public.AgentData value) {
      bitField0_ |= 0x00004000;
      agent.copyFrom(value);
      return this;
    }

    /**
     * <code>optional .Quests Quests = 13;</code>
     * @return whether the quests field is set
     */
    public boolean hasQuests() {
      return (bitField0_ & 0x00008000) != 0;
    }

    /**
     * <code>optional .Quests Quests = 13;</code>
     * @return this
     */
    public PlayerInfo clearQuests() {
      bitField0_ &= ~0x00008000;
      quests.clear();
      return this;
    }

    /**
     * <code>optional .Quests Quests = 13;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableQuests()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public Public.Quests getQuests() {
      return quests;
    }

    /**
     * <code>optional .Quests Quests = 13;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public Public.Quests getMutableQuests() {
      bitField0_ |= 0x00008000;
      return quests;
    }

    /**
     * <code>optional .Quests Quests = 13;</code>
     * @param value the quests to set
     * @return this
     */
    public PlayerInfo setQuests(final Public.Quests value) {
      bitField0_ |= 0x00008000;
      quests.copyFrom(value);
      return this;
    }

    /**
     * <code>optional .StateInfo State = 14;</code>
     * @return whether the state field is set
     */
    public boolean hasState() {
      return (bitField0_ & 0x00010000) != 0;
    }

    /**
     * <code>optional .StateInfo State = 14;</code>
     * @return this
     */
    public PlayerInfo clearState() {
      bitField0_ &= ~0x00010000;
      state.clear();
      return this;
    }

    /**
     * <code>optional .StateInfo State = 14;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableState()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public Public.StateInfo getState() {
      return state;
    }

    /**
     * <code>optional .StateInfo State = 14;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public Public.StateInfo getMutableState() {
      bitField0_ |= 0x00010000;
      return state;
    }

    /**
     * <code>optional .StateInfo State = 14;</code>
     * @param value the state to set
     * @return this
     */
    public PlayerInfo setState(final Public.StateInfo value) {
      bitField0_ |= 0x00010000;
      state.copyFrom(value);
      return this;
    }

    /**
     * <code>optional .PhoneInfo Phone = 25;</code>
     * @return whether the phone field is set
     */
    public boolean hasPhone() {
      return (bitField0_ & 0x00020000) != 0;
    }

    /**
     * <code>optional .PhoneInfo Phone = 25;</code>
     * @return this
     */
    public PlayerInfo clearPhone() {
      bitField0_ &= ~0x00020000;
      phone.clear();
      return this;
    }

    /**
     * <code>optional .PhoneInfo Phone = 25;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutablePhone()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public PhoneInfo getPhone() {
      return phone;
    }

    /**
     * <code>optional .PhoneInfo Phone = 25;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public PhoneInfo getMutablePhone() {
      bitField0_ |= 0x00020000;
      return phone;
    }

    /**
     * <code>optional .PhoneInfo Phone = 25;</code>
     * @param value the phone to set
     * @return this
     */
    public PlayerInfo setPhone(final PhoneInfo value) {
      bitField0_ |= 0x00020000;
      phone.copyFrom(value);
      return this;
    }

    /**
     * <code>optional .StoryInfo Story = 30;</code>
     * @return whether the story field is set
     */
    public boolean hasStory() {
      return (bitField0_ & 0x00040000) != 0;
    }

    /**
     * <code>optional .StoryInfo Story = 30;</code>
     * @return this
     */
    public PlayerInfo clearStory() {
      bitField0_ &= ~0x00040000;
      story.clear();
      return this;
    }

    /**
     * <code>optional .StoryInfo Story = 30;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableStory()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public Public.StoryInfo getStory() {
      return story;
    }

    /**
     * <code>optional .StoryInfo Story = 30;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public Public.StoryInfo getMutableStory() {
      bitField0_ |= 0x00040000;
      return story;
    }

    /**
     * <code>optional .StoryInfo Story = 30;</code>
     * @param value the story to set
     * @return this
     */
    public PlayerInfo setStory(final Public.StoryInfo value) {
      bitField0_ |= 0x00040000;
      story.copyFrom(value);
      return this;
    }

    /**
     * <code>optional .VampireSurvivorRecordInfo VampireSurvivorRecord = 31;</code>
     * @return whether the vampireSurvivorRecord field is set
     */
    public boolean hasVampireSurvivorRecord() {
      return (bitField0_ & 0x00080000) != 0;
    }

    /**
     * <code>optional .VampireSurvivorRecordInfo VampireSurvivorRecord = 31;</code>
     * @return this
     */
    public PlayerInfo clearVampireSurvivorRecord() {
      bitField0_ &= ~0x00080000;
      vampireSurvivorRecord.clear();
      return this;
    }

    /**
     * <code>optional .VampireSurvivorRecordInfo VampireSurvivorRecord = 31;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableVampireSurvivorRecord()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public Public.VampireSurvivorRecordInfo getVampireSurvivorRecord() {
      return vampireSurvivorRecord;
    }

    /**
     * <code>optional .VampireSurvivorRecordInfo VampireSurvivorRecord = 31;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public Public.VampireSurvivorRecordInfo getMutableVampireSurvivorRecord() {
      bitField0_ |= 0x00080000;
      return vampireSurvivorRecord;
    }

    /**
     * <code>optional .VampireSurvivorRecordInfo VampireSurvivorRecord = 31;</code>
     * @param value the vampireSurvivorRecord to set
     * @return this
     */
    public PlayerInfo setVampireSurvivorRecord(final Public.VampireSurvivorRecordInfo value) {
      bitField0_ |= 0x00080000;
      vampireSurvivorRecord.copyFrom(value);
      return this;
    }

    /**
     * <code>optional bytes Achievements = 18;</code>
     * @return whether the achievements field is set
     */
    public boolean hasAchievements() {
      return (bitField0_ & 0x00100000) != 0;
    }

    /**
     * <code>optional bytes Achievements = 18;</code>
     * @return this
     */
    public PlayerInfo clearAchievements() {
      bitField0_ &= ~0x00100000;
      achievements.clear();
      return this;
    }

    /**
     * <code>optional bytes Achievements = 18;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableAchievements()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getAchievements() {
      return achievements;
    }

    /**
     * <code>optional bytes Achievements = 18;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableAchievements() {
      bitField0_ |= 0x00100000;
      return achievements;
    }

    /**
     * <code>optional bytes Achievements = 18;</code>
     * @param value the achievements to add
     * @return this
     */
    public PlayerInfo addAchievements(final byte value) {
      bitField0_ |= 0x00100000;
      achievements.add(value);
      return this;
    }

    /**
     * <code>optional bytes Achievements = 18;</code>
     * @param values the achievements to add
     * @return this
     */
    public PlayerInfo addAllAchievements(final byte... values) {
      bitField0_ |= 0x00100000;
      achievements.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes Achievements = 18;</code>
     * @param values the achievements to set
     * @return this
     */
    public PlayerInfo setAchievements(final byte... values) {
      bitField0_ |= 0x00100000;
      achievements.copyFrom(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00200000) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public PlayerInfo clearNextPackage() {
      bitField0_ &= ~0x00200000;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00200000;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public PlayerInfo addNextPackage(final byte value) {
      bitField0_ |= 0x00200000;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public PlayerInfo addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00200000;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public PlayerInfo setNextPackage(final byte... values) {
      bitField0_ |= 0x00200000;
      nextPackage.copyFrom(values);
      return this;
    }

    /**
     * <code>repeated uint32 RglPassedIds = 10;</code>
     * @return whether the rglPassedIds field is set
     */
    public boolean hasRglPassedIds() {
      return (bitField0_ & 0x00400000) != 0;
    }

    /**
     * <code>repeated uint32 RglPassedIds = 10;</code>
     * @return this
     */
    public PlayerInfo clearRglPassedIds() {
      bitField0_ &= ~0x00400000;
      rglPassedIds.clear();
      return this;
    }

    /**
     * <code>repeated uint32 RglPassedIds = 10;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableRglPassedIds()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedInt getRglPassedIds() {
      return rglPassedIds;
    }

    /**
     * <code>repeated uint32 RglPassedIds = 10;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedInt getMutableRglPassedIds() {
      bitField0_ |= 0x00400000;
      return rglPassedIds;
    }

    /**
     * <code>repeated uint32 RglPassedIds = 10;</code>
     * @param value the rglPassedIds to add
     * @return this
     */
    public PlayerInfo addRglPassedIds(final int value) {
      bitField0_ |= 0x00400000;
      rglPassedIds.add(value);
      return this;
    }

    /**
     * <code>repeated uint32 RglPassedIds = 10;</code>
     * @param values the rglPassedIds to add
     * @return this
     */
    public PlayerInfo addAllRglPassedIds(final int... values) {
      bitField0_ |= 0x00400000;
      rglPassedIds.addAll(values);
      return this;
    }

    /**
     * <code>repeated uint32 Board = 16;</code>
     * @return whether the board field is set
     */
    public boolean hasBoard() {
      return (bitField0_ & 0x00800000) != 0;
    }

    /**
     * <code>repeated uint32 Board = 16;</code>
     * @return this
     */
    public PlayerInfo clearBoard() {
      bitField0_ &= ~0x00800000;
      board.clear();
      return this;
    }

    /**
     * <code>repeated uint32 Board = 16;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableBoard()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedInt getBoard() {
      return board;
    }

    /**
     * <code>repeated uint32 Board = 16;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedInt getMutableBoard() {
      bitField0_ |= 0x00800000;
      return board;
    }

    /**
     * <code>repeated uint32 Board = 16;</code>
     * @param value the board to add
     * @return this
     */
    public PlayerInfo addBoard(final int value) {
      bitField0_ |= 0x00800000;
      board.add(value);
      return this;
    }

    /**
     * <code>repeated uint32 Board = 16;</code>
     * @param values the board to add
     * @return this
     */
    public PlayerInfo addAllBoard(final int... values) {
      bitField0_ |= 0x00800000;
      board.addAll(values);
      return this;
    }

    /**
     * <code>repeated uint32 DatingCharIds = 17;</code>
     * @return whether the datingCharIds field is set
     */
    public boolean hasDatingCharIds() {
      return (bitField0_ & 0x01000000) != 0;
    }

    /**
     * <code>repeated uint32 DatingCharIds = 17;</code>
     * @return this
     */
    public PlayerInfo clearDatingCharIds() {
      bitField0_ &= ~0x01000000;
      datingCharIds.clear();
      return this;
    }

    /**
     * <code>repeated uint32 DatingCharIds = 17;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableDatingCharIds()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedInt getDatingCharIds() {
      return datingCharIds;
    }

    /**
     * <code>repeated uint32 DatingCharIds = 17;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedInt getMutableDatingCharIds() {
      bitField0_ |= 0x01000000;
      return datingCharIds;
    }

    /**
     * <code>repeated uint32 DatingCharIds = 17;</code>
     * @param value the datingCharIds to add
     * @return this
     */
    public PlayerInfo addDatingCharIds(final int value) {
      bitField0_ |= 0x01000000;
      datingCharIds.add(value);
      return this;
    }

    /**
     * <code>repeated uint32 DatingCharIds = 17;</code>
     * @param values the datingCharIds to add
     * @return this
     */
    public PlayerInfo addAllDatingCharIds(final int... values) {
      bitField0_ |= 0x01000000;
      datingCharIds.addAll(values);
      return this;
    }

    /**
     * <code>repeated uint32 DailyActiveIds = 32;</code>
     * @return whether the dailyActiveIds field is set
     */
    public boolean hasDailyActiveIds() {
      return (bitField0_ & 0x02000000) != 0;
    }

    /**
     * <code>repeated uint32 DailyActiveIds = 32;</code>
     * @return this
     */
    public PlayerInfo clearDailyActiveIds() {
      bitField0_ &= ~0x02000000;
      dailyActiveIds.clear();
      return this;
    }

    /**
     * <code>repeated uint32 DailyActiveIds = 32;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableDailyActiveIds()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedInt getDailyActiveIds() {
      return dailyActiveIds;
    }

    /**
     * <code>repeated uint32 DailyActiveIds = 32;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedInt getMutableDailyActiveIds() {
      bitField0_ |= 0x02000000;
      return dailyActiveIds;
    }

    /**
     * <code>repeated uint32 DailyActiveIds = 32;</code>
     * @param value the dailyActiveIds to add
     * @return this
     */
    public PlayerInfo addDailyActiveIds(final int value) {
      bitField0_ |= 0x02000000;
      dailyActiveIds.add(value);
      return this;
    }

    /**
     * <code>repeated uint32 DailyActiveIds = 32;</code>
     * @param values the dailyActiveIds to add
     * @return this
     */
    public PlayerInfo addAllDailyActiveIds(final int... values) {
      bitField0_ |= 0x02000000;
      dailyActiveIds.addAll(values);
      return this;
    }

    /**
     * <code>repeated uint32 HonorList = 123;</code>
     * @return whether the honorList field is set
     */
    public boolean hasHonorList() {
      return (bitField0_ & 0x04000000) != 0;
    }

    /**
     * <code>repeated uint32 HonorList = 123;</code>
     * @return this
     */
    public PlayerInfo clearHonorList() {
      bitField0_ &= ~0x04000000;
      honorList.clear();
      return this;
    }

    /**
     * <code>repeated uint32 HonorList = 123;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableHonorList()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedInt getHonorList() {
      return honorList;
    }

    /**
     * <code>repeated uint32 HonorList = 123;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedInt getMutableHonorList() {
      bitField0_ |= 0x04000000;
      return honorList;
    }

    /**
     * <code>repeated uint32 HonorList = 123;</code>
     * @param value the honorList to add
     * @return this
     */
    public PlayerInfo addHonorList(final int value) {
      bitField0_ |= 0x04000000;
      honorList.add(value);
      return this;
    }

    /**
     * <code>repeated uint32 HonorList = 123;</code>
     * @param values the honorList to add
     * @return this
     */
    public PlayerInfo addAllHonorList(final int... values) {
      bitField0_ |= 0x04000000;
      honorList.addAll(values);
      return this;
    }

    /**
     * <code>repeated .Res Res = 2;</code>
     * @return whether the res field is set
     */
    public boolean hasRes() {
      return (bitField0_ & 0x08000000) != 0;
    }

    /**
     * <code>repeated .Res Res = 2;</code>
     * @return this
     */
    public PlayerInfo clearRes() {
      bitField0_ &= ~0x08000000;
      res.clear();
      return this;
    }

    /**
     * <code>repeated .Res Res = 2;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableRes()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<Public.Res> getRes() {
      return res;
    }

    /**
     * <code>repeated .Res Res = 2;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<Public.Res> getMutableRes() {
      bitField0_ |= 0x08000000;
      return res;
    }

    /**
     * <code>repeated .Res Res = 2;</code>
     * @param value the res to add
     * @return this
     */
    public PlayerInfo addRes(final Public.Res value) {
      bitField0_ |= 0x08000000;
      res.add(value);
      return this;
    }

    /**
     * <code>repeated .Res Res = 2;</code>
     * @param values the res to add
     * @return this
     */
    public PlayerInfo addAllRes(final Public.Res... values) {
      bitField0_ |= 0x08000000;
      res.addAll(values);
      return this;
    }

    /**
     * <code>repeated .Item Items = 3;</code>
     * @return whether the items field is set
     */
    public boolean hasItems() {
      return (bitField0_ & 0x10000000) != 0;
    }

    /**
     * <code>repeated .Item Items = 3;</code>
     * @return this
     */
    public PlayerInfo clearItems() {
      bitField0_ &= ~0x10000000;
      items.clear();
      return this;
    }

    /**
     * <code>repeated .Item Items = 3;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableItems()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<Public.Item> getItems() {
      return items;
    }

    /**
     * <code>repeated .Item Items = 3;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<Public.Item> getMutableItems() {
      bitField0_ |= 0x10000000;
      return items;
    }

    /**
     * <code>repeated .Item Items = 3;</code>
     * @param value the items to add
     * @return this
     */
    public PlayerInfo addItems(final Public.Item value) {
      bitField0_ |= 0x10000000;
      items.add(value);
      return this;
    }

    /**
     * <code>repeated .Item Items = 3;</code>
     * @param values the items to add
     * @return this
     */
    public PlayerInfo addAllItems(final Public.Item... values) {
      bitField0_ |= 0x10000000;
      items.addAll(values);
      return this;
    }

    /**
     * <code>repeated .Char Chars = 4;</code>
     * @return whether the chars field is set
     */
    public boolean hasChars() {
      return (bitField0_ & 0x20000000) != 0;
    }

    /**
     * <code>repeated .Char Chars = 4;</code>
     * @return this
     */
    public PlayerInfo clearChars() {
      bitField0_ &= ~0x20000000;
      chars.clear();
      return this;
    }

    /**
     * <code>repeated .Char Chars = 4;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableChars()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<Public.Char> getChars() {
      return chars;
    }

    /**
     * <code>repeated .Char Chars = 4;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<Public.Char> getMutableChars() {
      bitField0_ |= 0x20000000;
      return chars;
    }

    /**
     * <code>repeated .Char Chars = 4;</code>
     * @param value the chars to add
     * @return this
     */
    public PlayerInfo addChars(final Public.Char value) {
      bitField0_ |= 0x20000000;
      chars.add(value);
      return this;
    }

    /**
     * <code>repeated .Char Chars = 4;</code>
     * @param values the chars to add
     * @return this
     */
    public PlayerInfo addAllChars(final Public.Char... values) {
      bitField0_ |= 0x20000000;
      chars.addAll(values);
      return this;
    }

    /**
     * <code>repeated .EquipmentInfo Equipments = 11;</code>
     * @return whether the equipments field is set
     */
    public boolean hasEquipments() {
      return (bitField0_ & 0x40000000) != 0;
    }

    /**
     * <code>repeated .EquipmentInfo Equipments = 11;</code>
     * @return this
     */
    public PlayerInfo clearEquipments() {
      bitField0_ &= ~0x40000000;
      equipments.clear();
      return this;
    }

    /**
     * <code>repeated .EquipmentInfo Equipments = 11;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableEquipments()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<Public.EquipmentInfo> getEquipments() {
      return equipments;
    }

    /**
     * <code>repeated .EquipmentInfo Equipments = 11;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<Public.EquipmentInfo> getMutableEquipments() {
      bitField0_ |= 0x40000000;
      return equipments;
    }

    /**
     * <code>repeated .EquipmentInfo Equipments = 11;</code>
     * @param value the equipments to add
     * @return this
     */
    public PlayerInfo addEquipments(final Public.EquipmentInfo value) {
      bitField0_ |= 0x40000000;
      equipments.add(value);
      return this;
    }

    /**
     * <code>repeated .EquipmentInfo Equipments = 11;</code>
     * @param values the equipments to add
     * @return this
     */
    public PlayerInfo addAllEquipments(final Public.EquipmentInfo... values) {
      bitField0_ |= 0x40000000;
      equipments.addAll(values);
      return this;
    }

    /**
     * <code>repeated .RegionBossLevel RegionBossLevels = 12;</code>
     * @return whether the regionBossLevels field is set
     */
    public boolean hasRegionBossLevels() {
      return (bitField0_ & 0x80000000) != 0;
    }

    /**
     * <code>repeated .RegionBossLevel RegionBossLevels = 12;</code>
     * @return this
     */
    public PlayerInfo clearRegionBossLevels() {
      bitField0_ &= ~0x80000000;
      regionBossLevels.clear();
      return this;
    }

    /**
     * <code>repeated .RegionBossLevel RegionBossLevels = 12;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableRegionBossLevels()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<Public.RegionBossLevel> getRegionBossLevels() {
      return regionBossLevels;
    }

    /**
     * <code>repeated .RegionBossLevel RegionBossLevels = 12;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<Public.RegionBossLevel> getMutableRegionBossLevels() {
      bitField0_ |= 0x80000000;
      return regionBossLevels;
    }

    /**
     * <code>repeated .RegionBossLevel RegionBossLevels = 12;</code>
     * @param value the regionBossLevels to add
     * @return this
     */
    public PlayerInfo addRegionBossLevels(final Public.RegionBossLevel value) {
      bitField0_ |= 0x80000000;
      regionBossLevels.add(value);
      return this;
    }

    /**
     * <code>repeated .RegionBossLevel RegionBossLevels = 12;</code>
     * @param values the regionBossLevels to add
     * @return this
     */
    public PlayerInfo addAllRegionBossLevels(final Public.RegionBossLevel... values) {
      bitField0_ |= 0x80000000;
      regionBossLevels.addAll(values);
      return this;
    }

    /**
     * <code>repeated .HandbookInfo Handbook = 19;</code>
     * @return whether the handbook field is set
     */
    public boolean hasHandbook() {
      return (bitField1_ & 0x00000001) != 0;
    }

    /**
     * <code>repeated .HandbookInfo Handbook = 19;</code>
     * @return this
     */
    public PlayerInfo clearHandbook() {
      bitField1_ &= ~0x00000001;
      handbook.clear();
      return this;
    }

    /**
     * <code>repeated .HandbookInfo Handbook = 19;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableHandbook()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<Public.HandbookInfo> getHandbook() {
      return handbook;
    }

    /**
     * <code>repeated .HandbookInfo Handbook = 19;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<Public.HandbookInfo> getMutableHandbook() {
      bitField1_ |= 0x00000001;
      return handbook;
    }

    /**
     * <code>repeated .HandbookInfo Handbook = 19;</code>
     * @param value the handbook to add
     * @return this
     */
    public PlayerInfo addHandbook(final Public.HandbookInfo value) {
      bitField1_ |= 0x00000001;
      handbook.add(value);
      return this;
    }

    /**
     * <code>repeated .HandbookInfo Handbook = 19;</code>
     * @param values the handbook to add
     * @return this
     */
    public PlayerInfo addAllHandbook(final Public.HandbookInfo... values) {
      bitField1_ |= 0x00000001;
      handbook.addAll(values);
      return this;
    }

    /**
     * <code>repeated .Title Titles = 21;</code>
     * @return whether the titles field is set
     */
    public boolean hasTitles() {
      return (bitField1_ & 0x00000002) != 0;
    }

    /**
     * <code>repeated .Title Titles = 21;</code>
     * @return this
     */
    public PlayerInfo clearTitles() {
      bitField1_ &= ~0x00000002;
      titles.clear();
      return this;
    }

    /**
     * <code>repeated .Title Titles = 21;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableTitles()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<Public.Title> getTitles() {
      return titles;
    }

    /**
     * <code>repeated .Title Titles = 21;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<Public.Title> getMutableTitles() {
      bitField1_ |= 0x00000002;
      return titles;
    }

    /**
     * <code>repeated .Title Titles = 21;</code>
     * @param value the titles to add
     * @return this
     */
    public PlayerInfo addTitles(final Public.Title value) {
      bitField1_ |= 0x00000002;
      titles.add(value);
      return this;
    }

    /**
     * <code>repeated .Title Titles = 21;</code>
     * @param values the titles to add
     * @return this
     */
    public PlayerInfo addAllTitles(final Public.Title... values) {
      bitField1_ |= 0x00000002;
      titles.addAll(values);
      return this;
    }

    /**
     * <code>repeated .DailyInstance DailyInstances = 22;</code>
     * @return whether the dailyInstances field is set
     */
    public boolean hasDailyInstances() {
      return (bitField1_ & 0x00000004) != 0;
    }

    /**
     * <code>repeated .DailyInstance DailyInstances = 22;</code>
     * @return this
     */
    public PlayerInfo clearDailyInstances() {
      bitField1_ &= ~0x00000004;
      dailyInstances.clear();
      return this;
    }

    /**
     * <code>repeated .DailyInstance DailyInstances = 22;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableDailyInstances()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<Public.DailyInstance> getDailyInstances() {
      return dailyInstances;
    }

    /**
     * <code>repeated .DailyInstance DailyInstances = 22;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<Public.DailyInstance> getMutableDailyInstances() {
      bitField1_ |= 0x00000004;
      return dailyInstances;
    }

    /**
     * <code>repeated .DailyInstance DailyInstances = 22;</code>
     * @param value the dailyInstances to add
     * @return this
     */
    public PlayerInfo addDailyInstances(final Public.DailyInstance value) {
      bitField1_ |= 0x00000004;
      dailyInstances.add(value);
      return this;
    }

    /**
     * <code>repeated .DailyInstance DailyInstances = 22;</code>
     * @param values the dailyInstances to add
     * @return this
     */
    public PlayerInfo addAllDailyInstances(final Public.DailyInstance... values) {
      bitField1_ |= 0x00000004;
      dailyInstances.addAll(values);
      return this;
    }

    /**
     * <code>repeated .DictionaryTab Dictionaries = 23;</code>
     * @return whether the dictionaries field is set
     */
    public boolean hasDictionaries() {
      return (bitField1_ & 0x00000008) != 0;
    }

    /**
     * <code>repeated .DictionaryTab Dictionaries = 23;</code>
     * @return this
     */
    public PlayerInfo clearDictionaries() {
      bitField1_ &= ~0x00000008;
      dictionaries.clear();
      return this;
    }

    /**
     * <code>repeated .DictionaryTab Dictionaries = 23;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableDictionaries()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<DictionaryTab> getDictionaries() {
      return dictionaries;
    }

    /**
     * <code>repeated .DictionaryTab Dictionaries = 23;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<DictionaryTab> getMutableDictionaries() {
      bitField1_ |= 0x00000008;
      return dictionaries;
    }

    /**
     * <code>repeated .DictionaryTab Dictionaries = 23;</code>
     * @param value the dictionaries to add
     * @return this
     */
    public PlayerInfo addDictionaries(final DictionaryTab value) {
      bitField1_ |= 0x00000008;
      dictionaries.add(value);
      return this;
    }

    /**
     * <code>repeated .DictionaryTab Dictionaries = 23;</code>
     * @param values the dictionaries to add
     * @return this
     */
    public PlayerInfo addAllDictionaries(final DictionaryTab... values) {
      bitField1_ |= 0x00000008;
      dictionaries.addAll(values);
      return this;
    }

    /**
     * <code>repeated .Activity Activities = 24;</code>
     * @return whether the activities field is set
     */
    public boolean hasActivities() {
      return (bitField1_ & 0x00000010) != 0;
    }

    /**
     * <code>repeated .Activity Activities = 24;</code>
     * @return this
     */
    public PlayerInfo clearActivities() {
      bitField1_ &= ~0x00000010;
      activities.clear();
      return this;
    }

    /**
     * <code>repeated .Activity Activities = 24;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableActivities()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<Public.Activity> getActivities() {
      return activities;
    }

    /**
     * <code>repeated .Activity Activities = 24;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<Public.Activity> getMutableActivities() {
      bitField1_ |= 0x00000010;
      return activities;
    }

    /**
     * <code>repeated .Activity Activities = 24;</code>
     * @param value the activities to add
     * @return this
     */
    public PlayerInfo addActivities(final Public.Activity value) {
      bitField1_ |= 0x00000010;
      activities.add(value);
      return this;
    }

    /**
     * <code>repeated .Activity Activities = 24;</code>
     * @param values the activities to add
     * @return this
     */
    public PlayerInfo addAllActivities(final Public.Activity... values) {
      bitField1_ |= 0x00000010;
      activities.addAll(values);
      return this;
    }

    /**
     * <code>repeated .Disc Discs = 28;</code>
     * @return whether the discs field is set
     */
    public boolean hasDiscs() {
      return (bitField1_ & 0x00000020) != 0;
    }

    /**
     * <code>repeated .Disc Discs = 28;</code>
     * @return this
     */
    public PlayerInfo clearDiscs() {
      bitField1_ &= ~0x00000020;
      discs.clear();
      return this;
    }

    /**
     * <code>repeated .Disc Discs = 28;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableDiscs()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<Public.Disc> getDiscs() {
      return discs;
    }

    /**
     * <code>repeated .Disc Discs = 28;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<Public.Disc> getMutableDiscs() {
      bitField1_ |= 0x00000020;
      return discs;
    }

    /**
     * <code>repeated .Disc Discs = 28;</code>
     * @param value the discs to add
     * @return this
     */
    public PlayerInfo addDiscs(final Public.Disc value) {
      bitField1_ |= 0x00000020;
      discs.add(value);
      return this;
    }

    /**
     * <code>repeated .Disc Discs = 28;</code>
     * @param values the discs to add
     * @return this
     */
    public PlayerInfo addAllDiscs(final Public.Disc... values) {
      bitField1_ |= 0x00000020;
      discs.addAll(values);
      return this;
    }

    /**
     * <code>repeated .EquipmentInstance EquipmentInstances = 29;</code>
     * @return whether the equipmentInstances field is set
     */
    public boolean hasEquipmentInstances() {
      return (bitField1_ & 0x00000040) != 0;
    }

    /**
     * <code>repeated .EquipmentInstance EquipmentInstances = 29;</code>
     * @return this
     */
    public PlayerInfo clearEquipmentInstances() {
      bitField1_ &= ~0x00000040;
      equipmentInstances.clear();
      return this;
    }

    /**
     * <code>repeated .EquipmentInstance EquipmentInstances = 29;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableEquipmentInstances()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<Public.EquipmentInstance> getEquipmentInstances() {
      return equipmentInstances;
    }

    /**
     * <code>repeated .EquipmentInstance EquipmentInstances = 29;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<Public.EquipmentInstance> getMutableEquipmentInstances() {
      bitField1_ |= 0x00000040;
      return equipmentInstances;
    }

    /**
     * <code>repeated .EquipmentInstance EquipmentInstances = 29;</code>
     * @param value the equipmentInstances to add
     * @return this
     */
    public PlayerInfo addEquipmentInstances(final Public.EquipmentInstance value) {
      bitField1_ |= 0x00000040;
      equipmentInstances.add(value);
      return this;
    }

    /**
     * <code>repeated .EquipmentInstance EquipmentInstances = 29;</code>
     * @param values the equipmentInstances to add
     * @return this
     */
    public PlayerInfo addAllEquipmentInstances(final Public.EquipmentInstance... values) {
      bitField1_ |= 0x00000040;
      equipmentInstances.addAll(values);
      return this;
    }

    /**
     * <code>repeated .SkillInstance SkillInstances = 34;</code>
     * @return whether the skillInstances field is set
     */
    public boolean hasSkillInstances() {
      return (bitField1_ & 0x00000080) != 0;
    }

    /**
     * <code>repeated .SkillInstance SkillInstances = 34;</code>
     * @return this
     */
    public PlayerInfo clearSkillInstances() {
      bitField1_ &= ~0x00000080;
      skillInstances.clear();
      return this;
    }

    /**
     * <code>repeated .SkillInstance SkillInstances = 34;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableSkillInstances()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<Public.SkillInstance> getSkillInstances() {
      return skillInstances;
    }

    /**
     * <code>repeated .SkillInstance SkillInstances = 34;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<Public.SkillInstance> getMutableSkillInstances() {
      bitField1_ |= 0x00000080;
      return skillInstances;
    }

    /**
     * <code>repeated .SkillInstance SkillInstances = 34;</code>
     * @param value the skillInstances to add
     * @return this
     */
    public PlayerInfo addSkillInstances(final Public.SkillInstance value) {
      bitField1_ |= 0x00000080;
      skillInstances.add(value);
      return this;
    }

    /**
     * <code>repeated .SkillInstance SkillInstances = 34;</code>
     * @param values the skillInstances to add
     * @return this
     */
    public PlayerInfo addAllSkillInstances(final Public.SkillInstance... values) {
      bitField1_ |= 0x00000080;
      skillInstances.addAll(values);
      return this;
    }

    /**
     * <code>repeated .WeekBossLevel WeekBossLevels = 35;</code>
     * @return whether the weekBossLevels field is set
     */
    public boolean hasWeekBossLevels() {
      return (bitField1_ & 0x00000100) != 0;
    }

    /**
     * <code>repeated .WeekBossLevel WeekBossLevels = 35;</code>
     * @return this
     */
    public PlayerInfo clearWeekBossLevels() {
      bitField1_ &= ~0x00000100;
      weekBossLevels.clear();
      return this;
    }

    /**
     * <code>repeated .WeekBossLevel WeekBossLevels = 35;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableWeekBossLevels()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<Public.WeekBossLevel> getWeekBossLevels() {
      return weekBossLevels;
    }

    /**
     * <code>repeated .WeekBossLevel WeekBossLevels = 35;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<Public.WeekBossLevel> getMutableWeekBossLevels() {
      bitField1_ |= 0x00000100;
      return weekBossLevels;
    }

    /**
     * <code>repeated .WeekBossLevel WeekBossLevels = 35;</code>
     * @param value the weekBossLevels to add
     * @return this
     */
    public PlayerInfo addWeekBossLevels(final Public.WeekBossLevel value) {
      bitField1_ |= 0x00000100;
      weekBossLevels.add(value);
      return this;
    }

    /**
     * <code>repeated .WeekBossLevel WeekBossLevels = 35;</code>
     * @param values the weekBossLevels to add
     * @return this
     */
    public PlayerInfo addAllWeekBossLevels(final Public.WeekBossLevel... values) {
      bitField1_ |= 0x00000100;
      weekBossLevels.addAll(values);
      return this;
    }

    /**
     * <code>repeated .CharGemInstance CharGemInstances = 36;</code>
     * @return whether the charGemInstances field is set
     */
    public boolean hasCharGemInstances() {
      return (bitField1_ & 0x00000200) != 0;
    }

    /**
     * <code>repeated .CharGemInstance CharGemInstances = 36;</code>
     * @return this
     */
    public PlayerInfo clearCharGemInstances() {
      bitField1_ &= ~0x00000200;
      charGemInstances.clear();
      return this;
    }

    /**
     * <code>repeated .CharGemInstance CharGemInstances = 36;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableCharGemInstances()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<Public.CharGemInstance> getCharGemInstances() {
      return charGemInstances;
    }

    /**
     * <code>repeated .CharGemInstance CharGemInstances = 36;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<Public.CharGemInstance> getMutableCharGemInstances() {
      bitField1_ |= 0x00000200;
      return charGemInstances;
    }

    /**
     * <code>repeated .CharGemInstance CharGemInstances = 36;</code>
     * @param value the charGemInstances to add
     * @return this
     */
    public PlayerInfo addCharGemInstances(final Public.CharGemInstance value) {
      bitField1_ |= 0x00000200;
      charGemInstances.add(value);
      return this;
    }

    /**
     * <code>repeated .CharGemInstance CharGemInstances = 36;</code>
     * @param values the charGemInstances to add
     * @return this
     */
    public PlayerInfo addAllCharGemInstances(final Public.CharGemInstance... values) {
      bitField1_ |= 0x00000200;
      charGemInstances.addAll(values);
      return this;
    }

    /**
     * <code>repeated .TutorialLevel TutorialLevels = 37;</code>
     * @return whether the tutorialLevels field is set
     */
    public boolean hasTutorialLevels() {
      return (bitField1_ & 0x00000400) != 0;
    }

    /**
     * <code>repeated .TutorialLevel TutorialLevels = 37;</code>
     * @return this
     */
    public PlayerInfo clearTutorialLevels() {
      bitField1_ &= ~0x00000400;
      tutorialLevels.clear();
      return this;
    }

    /**
     * <code>repeated .TutorialLevel TutorialLevels = 37;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableTutorialLevels()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<Public.TutorialLevel> getTutorialLevels() {
      return tutorialLevels;
    }

    /**
     * <code>repeated .TutorialLevel TutorialLevels = 37;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<Public.TutorialLevel> getMutableTutorialLevels() {
      bitField1_ |= 0x00000400;
      return tutorialLevels;
    }

    /**
     * <code>repeated .TutorialLevel TutorialLevels = 37;</code>
     * @param value the tutorialLevels to add
     * @return this
     */
    public PlayerInfo addTutorialLevels(final Public.TutorialLevel value) {
      bitField1_ |= 0x00000400;
      tutorialLevels.add(value);
      return this;
    }

    /**
     * <code>repeated .TutorialLevel TutorialLevels = 37;</code>
     * @param values the tutorialLevels to add
     * @return this
     */
    public PlayerInfo addAllTutorialLevels(final Public.TutorialLevel... values) {
      bitField1_ |= 0x00000400;
      tutorialLevels.addAll(values);
      return this;
    }

    /**
     * <code>repeated .HonorInfo Honors = 124;</code>
     * @return whether the honors field is set
     */
    public boolean hasHonors() {
      return (bitField1_ & 0x00000800) != 0;
    }

    /**
     * <code>repeated .HonorInfo Honors = 124;</code>
     * @return this
     */
    public PlayerInfo clearHonors() {
      bitField1_ &= ~0x00000800;
      honors.clear();
      return this;
    }

    /**
     * <code>repeated .HonorInfo Honors = 124;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableHonors()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<Public.HonorInfo> getHonors() {
      return honors;
    }

    /**
     * <code>repeated .HonorInfo Honors = 124;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<Public.HonorInfo> getMutableHonors() {
      bitField1_ |= 0x00000800;
      return honors;
    }

    /**
     * <code>repeated .HonorInfo Honors = 124;</code>
     * @param value the honors to add
     * @return this
     */
    public PlayerInfo addHonors(final Public.HonorInfo value) {
      bitField1_ |= 0x00000800;
      honors.add(value);
      return this;
    }

    /**
     * <code>repeated .HonorInfo Honors = 124;</code>
     * @param values the honors to add
     * @return this
     */
    public PlayerInfo addAllHonors(final Public.HonorInfo... values) {
      bitField1_ |= 0x00000800;
      honors.addAll(values);
      return this;
    }

    @Override
    public PlayerInfo copyFrom(final PlayerInfo other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        talentResetTime = other.talentResetTime;
        nicknameResetTime = other.nicknameResetTime;
        musicInfo = other.musicInfo;
        serverTs = other.serverTs;
        sendGiftCnt = other.sendGiftCnt;
        signinIndex = other.signinIndex;
        equipmentDoubleCount = other.equipmentDoubleCount;
        tourGuideQuestGroup = other.tourGuideQuestGroup;
        towerTicket = other.towerTicket;
        dailyShopRewardStatus = other.dailyShopRewardStatus;
        acc.copyFrom(other.acc);
        formation.copyFrom(other.formation);
        energy.copyFrom(other.energy);
        worldClass.copyFrom(other.worldClass);
        agent.copyFrom(other.agent);
        quests.copyFrom(other.quests);
        state.copyFrom(other.state);
        phone.copyFrom(other.phone);
        story.copyFrom(other.story);
        vampireSurvivorRecord.copyFrom(other.vampireSurvivorRecord);
        achievements.copyFrom(other.achievements);
        nextPackage.copyFrom(other.nextPackage);
        rglPassedIds.copyFrom(other.rglPassedIds);
        board.copyFrom(other.board);
        datingCharIds.copyFrom(other.datingCharIds);
        dailyActiveIds.copyFrom(other.dailyActiveIds);
        honorList.copyFrom(other.honorList);
        res.copyFrom(other.res);
        items.copyFrom(other.items);
        chars.copyFrom(other.chars);
        equipments.copyFrom(other.equipments);
        regionBossLevels.copyFrom(other.regionBossLevels);
      }
      if ((bitField1_ | other.bitField1_) != 0) {
        bitField1_ = other.bitField1_;
        handbook.copyFrom(other.handbook);
        titles.copyFrom(other.titles);
        dailyInstances.copyFrom(other.dailyInstances);
        dictionaries.copyFrom(other.dictionaries);
        activities.copyFrom(other.activities);
        discs.copyFrom(other.discs);
        equipmentInstances.copyFrom(other.equipmentInstances);
        skillInstances.copyFrom(other.skillInstances);
        weekBossLevels.copyFrom(other.weekBossLevels);
        charGemInstances.copyFrom(other.charGemInstances);
        tutorialLevels.copyFrom(other.tutorialLevels);
        honors.copyFrom(other.honors);
      }
      return this;
    }

    @Override
    public PlayerInfo mergeFrom(final PlayerInfo other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasTalentResetTime()) {
        setTalentResetTime(other.talentResetTime);
      }
      if (other.hasNicknameResetTime()) {
        setNicknameResetTime(other.nicknameResetTime);
      }
      if (other.hasMusicInfo()) {
        setMusicInfo(other.musicInfo);
      }
      if (other.hasServerTs()) {
        setServerTs(other.serverTs);
      }
      if (other.hasSendGiftCnt()) {
        setSendGiftCnt(other.sendGiftCnt);
      }
      if (other.hasSigninIndex()) {
        setSigninIndex(other.signinIndex);
      }
      if (other.hasEquipmentDoubleCount()) {
        setEquipmentDoubleCount(other.equipmentDoubleCount);
      }
      if (other.hasTourGuideQuestGroup()) {
        setTourGuideQuestGroup(other.tourGuideQuestGroup);
      }
      if (other.hasTowerTicket()) {
        setTowerTicket(other.towerTicket);
      }
      if (other.hasDailyShopRewardStatus()) {
        setDailyShopRewardStatus(other.dailyShopRewardStatus);
      }
      if (other.hasAcc()) {
        getMutableAcc().mergeFrom(other.acc);
      }
      if (other.hasFormation()) {
        getMutableFormation().mergeFrom(other.formation);
      }
      if (other.hasEnergy()) {
        getMutableEnergy().mergeFrom(other.energy);
      }
      if (other.hasWorldClass()) {
        getMutableWorldClass().mergeFrom(other.worldClass);
      }
      if (other.hasAgent()) {
        getMutableAgent().mergeFrom(other.agent);
      }
      if (other.hasQuests()) {
        getMutableQuests().mergeFrom(other.quests);
      }
      if (other.hasState()) {
        getMutableState().mergeFrom(other.state);
      }
      if (other.hasPhone()) {
        getMutablePhone().mergeFrom(other.phone);
      }
      if (other.hasStory()) {
        getMutableStory().mergeFrom(other.story);
      }
      if (other.hasVampireSurvivorRecord()) {
        getMutableVampireSurvivorRecord().mergeFrom(other.vampireSurvivorRecord);
      }
      if (other.hasAchievements()) {
        getMutableAchievements().copyFrom(other.achievements);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      if (other.hasRglPassedIds()) {
        getMutableRglPassedIds().addAll(other.rglPassedIds);
      }
      if (other.hasBoard()) {
        getMutableBoard().addAll(other.board);
      }
      if (other.hasDatingCharIds()) {
        getMutableDatingCharIds().addAll(other.datingCharIds);
      }
      if (other.hasDailyActiveIds()) {
        getMutableDailyActiveIds().addAll(other.dailyActiveIds);
      }
      if (other.hasHonorList()) {
        getMutableHonorList().addAll(other.honorList);
      }
      if (other.hasRes()) {
        getMutableRes().addAll(other.res);
      }
      if (other.hasItems()) {
        getMutableItems().addAll(other.items);
      }
      if (other.hasChars()) {
        getMutableChars().addAll(other.chars);
      }
      if (other.hasEquipments()) {
        getMutableEquipments().addAll(other.equipments);
      }
      if (other.hasRegionBossLevels()) {
        getMutableRegionBossLevels().addAll(other.regionBossLevels);
      }
      if (other.hasHandbook()) {
        getMutableHandbook().addAll(other.handbook);
      }
      if (other.hasTitles()) {
        getMutableTitles().addAll(other.titles);
      }
      if (other.hasDailyInstances()) {
        getMutableDailyInstances().addAll(other.dailyInstances);
      }
      if (other.hasDictionaries()) {
        getMutableDictionaries().addAll(other.dictionaries);
      }
      if (other.hasActivities()) {
        getMutableActivities().addAll(other.activities);
      }
      if (other.hasDiscs()) {
        getMutableDiscs().addAll(other.discs);
      }
      if (other.hasEquipmentInstances()) {
        getMutableEquipmentInstances().addAll(other.equipmentInstances);
      }
      if (other.hasSkillInstances()) {
        getMutableSkillInstances().addAll(other.skillInstances);
      }
      if (other.hasWeekBossLevels()) {
        getMutableWeekBossLevels().addAll(other.weekBossLevels);
      }
      if (other.hasCharGemInstances()) {
        getMutableCharGemInstances().addAll(other.charGemInstances);
      }
      if (other.hasTutorialLevels()) {
        getMutableTutorialLevels().addAll(other.tutorialLevels);
      }
      if (other.hasHonors()) {
        getMutableHonors().addAll(other.honors);
      }
      return this;
    }

    @Override
    public PlayerInfo clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      bitField1_ = 0;
      talentResetTime = 0L;
      nicknameResetTime = 0L;
      musicInfo = 0L;
      serverTs = 0L;
      sendGiftCnt = 0;
      signinIndex = 0;
      equipmentDoubleCount = 0;
      tourGuideQuestGroup = 0;
      towerTicket = 0;
      dailyShopRewardStatus = false;
      acc.clear();
      formation.clear();
      energy.clear();
      worldClass.clear();
      agent.clear();
      quests.clear();
      state.clear();
      phone.clear();
      story.clear();
      vampireSurvivorRecord.clear();
      achievements.clear();
      nextPackage.clear();
      rglPassedIds.clear();
      board.clear();
      datingCharIds.clear();
      dailyActiveIds.clear();
      honorList.clear();
      res.clear();
      items.clear();
      chars.clear();
      equipments.clear();
      regionBossLevels.clear();
      handbook.clear();
      titles.clear();
      dailyInstances.clear();
      dictionaries.clear();
      activities.clear();
      discs.clear();
      equipmentInstances.clear();
      skillInstances.clear();
      weekBossLevels.clear();
      charGemInstances.clear();
      tutorialLevels.clear();
      honors.clear();
      return this;
    }

    @Override
    public PlayerInfo clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      bitField1_ = 0;
      acc.clearQuick();
      formation.clearQuick();
      energy.clearQuick();
      worldClass.clearQuick();
      agent.clearQuick();
      quests.clearQuick();
      state.clearQuick();
      phone.clearQuick();
      story.clearQuick();
      vampireSurvivorRecord.clearQuick();
      achievements.clear();
      nextPackage.clear();
      rglPassedIds.clear();
      board.clear();
      datingCharIds.clear();
      dailyActiveIds.clear();
      honorList.clear();
      res.clearQuick();
      items.clearQuick();
      chars.clearQuick();
      equipments.clearQuick();
      regionBossLevels.clearQuick();
      handbook.clearQuick();
      titles.clearQuick();
      dailyInstances.clearQuick();
      dictionaries.clearQuick();
      activities.clearQuick();
      discs.clearQuick();
      equipmentInstances.clearQuick();
      skillInstances.clearQuick();
      weekBossLevels.clearQuick();
      charGemInstances.clearQuick();
      tutorialLevels.clearQuick();
      honors.clearQuick();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof PlayerInfo)) {
        return false;
      }
      PlayerInfo other = (PlayerInfo) o;
      return bitField0_ == other.bitField0_
        && bitField1_ == other.bitField1_
        && (!hasTalentResetTime() || talentResetTime == other.talentResetTime)
        && (!hasNicknameResetTime() || nicknameResetTime == other.nicknameResetTime)
        && (!hasMusicInfo() || musicInfo == other.musicInfo)
        && (!hasServerTs() || serverTs == other.serverTs)
        && (!hasSendGiftCnt() || sendGiftCnt == other.sendGiftCnt)
        && (!hasSigninIndex() || signinIndex == other.signinIndex)
        && (!hasEquipmentDoubleCount() || equipmentDoubleCount == other.equipmentDoubleCount)
        && (!hasTourGuideQuestGroup() || tourGuideQuestGroup == other.tourGuideQuestGroup)
        && (!hasTowerTicket() || towerTicket == other.towerTicket)
        && (!hasDailyShopRewardStatus() || dailyShopRewardStatus == other.dailyShopRewardStatus)
        && (!hasAcc() || acc.equals(other.acc))
        && (!hasFormation() || formation.equals(other.formation))
        && (!hasEnergy() || energy.equals(other.energy))
        && (!hasWorldClass() || worldClass.equals(other.worldClass))
        && (!hasAgent() || agent.equals(other.agent))
        && (!hasQuests() || quests.equals(other.quests))
        && (!hasState() || state.equals(other.state))
        && (!hasPhone() || phone.equals(other.phone))
        && (!hasStory() || story.equals(other.story))
        && (!hasVampireSurvivorRecord() || vampireSurvivorRecord.equals(other.vampireSurvivorRecord))
        && (!hasAchievements() || achievements.equals(other.achievements))
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage))
        && (!hasRglPassedIds() || rglPassedIds.equals(other.rglPassedIds))
        && (!hasBoard() || board.equals(other.board))
        && (!hasDatingCharIds() || datingCharIds.equals(other.datingCharIds))
        && (!hasDailyActiveIds() || dailyActiveIds.equals(other.dailyActiveIds))
        && (!hasHonorList() || honorList.equals(other.honorList))
        && (!hasRes() || res.equals(other.res))
        && (!hasItems() || items.equals(other.items))
        && (!hasChars() || chars.equals(other.chars))
        && (!hasEquipments() || equipments.equals(other.equipments))
        && (!hasRegionBossLevels() || regionBossLevels.equals(other.regionBossLevels))
        && (!hasHandbook() || handbook.equals(other.handbook))
        && (!hasTitles() || titles.equals(other.titles))
        && (!hasDailyInstances() || dailyInstances.equals(other.dailyInstances))
        && (!hasDictionaries() || dictionaries.equals(other.dictionaries))
        && (!hasActivities() || activities.equals(other.activities))
        && (!hasDiscs() || discs.equals(other.discs))
        && (!hasEquipmentInstances() || equipmentInstances.equals(other.equipmentInstances))
        && (!hasSkillInstances() || skillInstances.equals(other.skillInstances))
        && (!hasWeekBossLevels() || weekBossLevels.equals(other.weekBossLevels))
        && (!hasCharGemInstances() || charGemInstances.equals(other.charGemInstances))
        && (!hasTutorialLevels() || tutorialLevels.equals(other.tutorialLevels))
        && (!hasHonors() || honors.equals(other.honors));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawLittleEndian16((short) 464);
        output.writeInt64NoTag(talentResetTime);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawLittleEndian16((short) 1992);
        output.writeInt64NoTag(nicknameResetTime);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawLittleEndian16((short) 2000);
        output.writeInt64NoTag(musicInfo);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeRawLittleEndian16((short) 2040);
        output.writeInt64NoTag(serverTs);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        output.writeRawByte((byte) 120);
        output.writeUInt32NoTag(sendGiftCnt);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        output.writeRawLittleEndian16((short) 416);
        output.writeUInt32NoTag(signinIndex);
      }
      if ((bitField0_ & 0x00000040) != 0) {
        output.writeRawLittleEndian16((short) 472);
        output.writeUInt32NoTag(equipmentDoubleCount);
      }
      if ((bitField0_ & 0x00000080) != 0) {
        output.writeRawLittleEndian16((short) 648);
        output.writeUInt32NoTag(tourGuideQuestGroup);
      }
      if ((bitField0_ & 0x00000100) != 0) {
        output.writeRawLittleEndian16((short) 2032);
        output.writeUInt32NoTag(towerTicket);
      }
      if ((bitField0_ & 0x00000200) != 0) {
        output.writeRawLittleEndian16((short) 2024);
        output.writeBoolNoTag(dailyShopRewardStatus);
      }
      if ((bitField0_ & 0x00000400) != 0) {
        output.writeRawByte((byte) 10);
        output.writeMessageNoTag(acc);
      }
      if ((bitField0_ & 0x00000800) != 0) {
        output.writeRawByte((byte) 42);
        output.writeMessageNoTag(formation);
      }
      if ((bitField0_ & 0x00001000) != 0) {
        output.writeRawByte((byte) 58);
        output.writeMessageNoTag(energy);
      }
      if ((bitField0_ & 0x00002000) != 0) {
        output.writeRawByte((byte) 66);
        output.writeMessageNoTag(worldClass);
      }
      if ((bitField0_ & 0x00004000) != 0) {
        output.writeRawByte((byte) 74);
        output.writeMessageNoTag(agent);
      }
      if ((bitField0_ & 0x00008000) != 0) {
        output.writeRawByte((byte) 106);
        output.writeMessageNoTag(quests);
      }
      if ((bitField0_ & 0x00010000) != 0) {
        output.writeRawByte((byte) 114);
        output.writeMessageNoTag(state);
      }
      if ((bitField0_ & 0x00020000) != 0) {
        output.writeRawLittleEndian16((short) 458);
        output.writeMessageNoTag(phone);
      }
      if ((bitField0_ & 0x00040000) != 0) {
        output.writeRawLittleEndian16((short) 498);
        output.writeMessageNoTag(story);
      }
      if ((bitField0_ & 0x00080000) != 0) {
        output.writeRawLittleEndian16((short) 506);
        output.writeMessageNoTag(vampireSurvivorRecord);
      }
      if ((bitField0_ & 0x00100000) != 0) {
        output.writeRawLittleEndian16((short) 402);
        output.writeBytesNoTag(achievements);
      }
      if ((bitField0_ & 0x00200000) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00400000) != 0) {
        for (int i = 0; i < rglPassedIds.length(); i++) {
          output.writeRawByte((byte) 80);
          output.writeUInt32NoTag(rglPassedIds.array()[i]);
        }
      }
      if ((bitField0_ & 0x00800000) != 0) {
        for (int i = 0; i < board.length(); i++) {
          output.writeRawLittleEndian16((short) 384);
          output.writeUInt32NoTag(board.array()[i]);
        }
      }
      if ((bitField0_ & 0x01000000) != 0) {
        for (int i = 0; i < datingCharIds.length(); i++) {
          output.writeRawLittleEndian16((short) 392);
          output.writeUInt32NoTag(datingCharIds.array()[i]);
        }
      }
      if ((bitField0_ & 0x02000000) != 0) {
        for (int i = 0; i < dailyActiveIds.length(); i++) {
          output.writeRawLittleEndian16((short) 640);
          output.writeUInt32NoTag(dailyActiveIds.array()[i]);
        }
      }
      if ((bitField0_ & 0x04000000) != 0) {
        for (int i = 0; i < honorList.length(); i++) {
          output.writeRawLittleEndian16((short) 2008);
          output.writeUInt32NoTag(honorList.array()[i]);
        }
      }
      if ((bitField0_ & 0x08000000) != 0) {
        for (int i = 0; i < res.length(); i++) {
          output.writeRawByte((byte) 18);
          output.writeMessageNoTag(res.get(i));
        }
      }
      if ((bitField0_ & 0x10000000) != 0) {
        for (int i = 0; i < items.length(); i++) {
          output.writeRawByte((byte) 26);
          output.writeMessageNoTag(items.get(i));
        }
      }
      if ((bitField0_ & 0x20000000) != 0) {
        for (int i = 0; i < chars.length(); i++) {
          output.writeRawByte((byte) 34);
          output.writeMessageNoTag(chars.get(i));
        }
      }
      if ((bitField0_ & 0x40000000) != 0) {
        for (int i = 0; i < equipments.length(); i++) {
          output.writeRawByte((byte) 90);
          output.writeMessageNoTag(equipments.get(i));
        }
      }
      if ((bitField0_ & 0x80000000) != 0) {
        for (int i = 0; i < regionBossLevels.length(); i++) {
          output.writeRawByte((byte) 98);
          output.writeMessageNoTag(regionBossLevels.get(i));
        }
      }
      if ((bitField1_ & 0x00000001) != 0) {
        for (int i = 0; i < handbook.length(); i++) {
          output.writeRawLittleEndian16((short) 410);
          output.writeMessageNoTag(handbook.get(i));
        }
      }
      if ((bitField1_ & 0x00000002) != 0) {
        for (int i = 0; i < titles.length(); i++) {
          output.writeRawLittleEndian16((short) 426);
          output.writeMessageNoTag(titles.get(i));
        }
      }
      if ((bitField1_ & 0x00000004) != 0) {
        for (int i = 0; i < dailyInstances.length(); i++) {
          output.writeRawLittleEndian16((short) 434);
          output.writeMessageNoTag(dailyInstances.get(i));
        }
      }
      if ((bitField1_ & 0x00000008) != 0) {
        for (int i = 0; i < dictionaries.length(); i++) {
          output.writeRawLittleEndian16((short) 442);
          output.writeMessageNoTag(dictionaries.get(i));
        }
      }
      if ((bitField1_ & 0x00000010) != 0) {
        for (int i = 0; i < activities.length(); i++) {
          output.writeRawLittleEndian16((short) 450);
          output.writeMessageNoTag(activities.get(i));
        }
      }
      if ((bitField1_ & 0x00000020) != 0) {
        for (int i = 0; i < discs.length(); i++) {
          output.writeRawLittleEndian16((short) 482);
          output.writeMessageNoTag(discs.get(i));
        }
      }
      if ((bitField1_ & 0x00000040) != 0) {
        for (int i = 0; i < equipmentInstances.length(); i++) {
          output.writeRawLittleEndian16((short) 490);
          output.writeMessageNoTag(equipmentInstances.get(i));
        }
      }
      if ((bitField1_ & 0x00000080) != 0) {
        for (int i = 0; i < skillInstances.length(); i++) {
          output.writeRawLittleEndian16((short) 658);
          output.writeMessageNoTag(skillInstances.get(i));
        }
      }
      if ((bitField1_ & 0x00000100) != 0) {
        for (int i = 0; i < weekBossLevels.length(); i++) {
          output.writeRawLittleEndian16((short) 666);
          output.writeMessageNoTag(weekBossLevels.get(i));
        }
      }
      if ((bitField1_ & 0x00000200) != 0) {
        for (int i = 0; i < charGemInstances.length(); i++) {
          output.writeRawLittleEndian16((short) 674);
          output.writeMessageNoTag(charGemInstances.get(i));
        }
      }
      if ((bitField1_ & 0x00000400) != 0) {
        for (int i = 0; i < tutorialLevels.length(); i++) {
          output.writeRawLittleEndian16((short) 682);
          output.writeMessageNoTag(tutorialLevels.get(i));
        }
      }
      if ((bitField1_ & 0x00000800) != 0) {
        for (int i = 0; i < honors.length(); i++) {
          output.writeRawLittleEndian16((short) 2018);
          output.writeMessageNoTag(honors.get(i));
        }
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 2 + ProtoSink.computeInt64SizeNoTag(talentResetTime);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 2 + ProtoSink.computeInt64SizeNoTag(nicknameResetTime);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 2 + ProtoSink.computeInt64SizeNoTag(musicInfo);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        size += 2 + ProtoSink.computeInt64SizeNoTag(serverTs);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(sendGiftCnt);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        size += 2 + ProtoSink.computeUInt32SizeNoTag(signinIndex);
      }
      if ((bitField0_ & 0x00000040) != 0) {
        size += 2 + ProtoSink.computeUInt32SizeNoTag(equipmentDoubleCount);
      }
      if ((bitField0_ & 0x00000080) != 0) {
        size += 2 + ProtoSink.computeUInt32SizeNoTag(tourGuideQuestGroup);
      }
      if ((bitField0_ & 0x00000100) != 0) {
        size += 2 + ProtoSink.computeUInt32SizeNoTag(towerTicket);
      }
      if ((bitField0_ & 0x00000200) != 0) {
        size += 3;
      }
      if ((bitField0_ & 0x00000400) != 0) {
        size += 1 + ProtoSink.computeMessageSizeNoTag(acc);
      }
      if ((bitField0_ & 0x00000800) != 0) {
        size += 1 + ProtoSink.computeMessageSizeNoTag(formation);
      }
      if ((bitField0_ & 0x00001000) != 0) {
        size += 1 + ProtoSink.computeMessageSizeNoTag(energy);
      }
      if ((bitField0_ & 0x00002000) != 0) {
        size += 1 + ProtoSink.computeMessageSizeNoTag(worldClass);
      }
      if ((bitField0_ & 0x00004000) != 0) {
        size += 1 + ProtoSink.computeMessageSizeNoTag(agent);
      }
      if ((bitField0_ & 0x00008000) != 0) {
        size += 1 + ProtoSink.computeMessageSizeNoTag(quests);
      }
      if ((bitField0_ & 0x00010000) != 0) {
        size += 1 + ProtoSink.computeMessageSizeNoTag(state);
      }
      if ((bitField0_ & 0x00020000) != 0) {
        size += 2 + ProtoSink.computeMessageSizeNoTag(phone);
      }
      if ((bitField0_ & 0x00040000) != 0) {
        size += 2 + ProtoSink.computeMessageSizeNoTag(story);
      }
      if ((bitField0_ & 0x00080000) != 0) {
        size += 2 + ProtoSink.computeMessageSizeNoTag(vampireSurvivorRecord);
      }
      if ((bitField0_ & 0x00100000) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(achievements);
      }
      if ((bitField0_ & 0x00200000) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00400000) != 0) {
        size += (1 * rglPassedIds.length()) + ProtoSink.computeRepeatedUInt32SizeNoTag(rglPassedIds);
      }
      if ((bitField0_ & 0x00800000) != 0) {
        size += (2 * board.length()) + ProtoSink.computeRepeatedUInt32SizeNoTag(board);
      }
      if ((bitField0_ & 0x01000000) != 0) {
        size += (2 * datingCharIds.length()) + ProtoSink.computeRepeatedUInt32SizeNoTag(datingCharIds);
      }
      if ((bitField0_ & 0x02000000) != 0) {
        size += (2 * dailyActiveIds.length()) + ProtoSink.computeRepeatedUInt32SizeNoTag(dailyActiveIds);
      }
      if ((bitField0_ & 0x04000000) != 0) {
        size += (2 * honorList.length()) + ProtoSink.computeRepeatedUInt32SizeNoTag(honorList);
      }
      if ((bitField0_ & 0x08000000) != 0) {
        size += (1 * res.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(res);
      }
      if ((bitField0_ & 0x10000000) != 0) {
        size += (1 * items.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(items);
      }
      if ((bitField0_ & 0x20000000) != 0) {
        size += (1 * chars.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(chars);
      }
      if ((bitField0_ & 0x40000000) != 0) {
        size += (1 * equipments.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(equipments);
      }
      if ((bitField0_ & 0x80000000) != 0) {
        size += (1 * regionBossLevels.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(regionBossLevels);
      }
      if ((bitField1_ & 0x00000001) != 0) {
        size += (2 * handbook.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(handbook);
      }
      if ((bitField1_ & 0x00000002) != 0) {
        size += (2 * titles.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(titles);
      }
      if ((bitField1_ & 0x00000004) != 0) {
        size += (2 * dailyInstances.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(dailyInstances);
      }
      if ((bitField1_ & 0x00000008) != 0) {
        size += (2 * dictionaries.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(dictionaries);
      }
      if ((bitField1_ & 0x00000010) != 0) {
        size += (2 * activities.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(activities);
      }
      if ((bitField1_ & 0x00000020) != 0) {
        size += (2 * discs.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(discs);
      }
      if ((bitField1_ & 0x00000040) != 0) {
        size += (2 * equipmentInstances.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(equipmentInstances);
      }
      if ((bitField1_ & 0x00000080) != 0) {
        size += (2 * skillInstances.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(skillInstances);
      }
      if ((bitField1_ & 0x00000100) != 0) {
        size += (2 * weekBossLevels.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(weekBossLevels);
      }
      if ((bitField1_ & 0x00000200) != 0) {
        size += (2 * charGemInstances.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(charGemInstances);
      }
      if ((bitField1_ & 0x00000400) != 0) {
        size += (2 * tutorialLevels.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(tutorialLevels);
      }
      if ((bitField1_ & 0x00000800) != 0) {
        size += (2 * honors.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(honors);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public PlayerInfo mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 208: {
            // talentResetTime
            talentResetTime = input.readInt64();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 968) {
              break;
            }
          }
          case 968: {
            // nicknameResetTime
            nicknameResetTime = input.readInt64();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 976) {
              break;
            }
          }
          case 976: {
            // musicInfo
            musicInfo = input.readInt64();
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 1016) {
              break;
            }
          }
          case 1016: {
            // serverTs
            serverTs = input.readInt64();
            bitField0_ |= 0x00000008;
            tag = input.readTag();
            if (tag != 120) {
              break;
            }
          }
          case 120: {
            // sendGiftCnt
            sendGiftCnt = input.readUInt32();
            bitField0_ |= 0x00000010;
            tag = input.readTag();
            if (tag != 160) {
              break;
            }
          }
          case 160: {
            // signinIndex
            signinIndex = input.readUInt32();
            bitField0_ |= 0x00000020;
            tag = input.readTag();
            if (tag != 216) {
              break;
            }
          }
          case 216: {
            // equipmentDoubleCount
            equipmentDoubleCount = input.readUInt32();
            bitField0_ |= 0x00000040;
            tag = input.readTag();
            if (tag != 264) {
              break;
            }
          }
          case 264: {
            // tourGuideQuestGroup
            tourGuideQuestGroup = input.readUInt32();
            bitField0_ |= 0x00000080;
            tag = input.readTag();
            if (tag != 1008) {
              break;
            }
          }
          case 1008: {
            // towerTicket
            towerTicket = input.readUInt32();
            bitField0_ |= 0x00000100;
            tag = input.readTag();
            if (tag != 1000) {
              break;
            }
          }
          case 1000: {
            // dailyShopRewardStatus
            dailyShopRewardStatus = input.readBool();
            bitField0_ |= 0x00000200;
            tag = input.readTag();
            if (tag != 10) {
              break;
            }
          }
          case 10: {
            // acc
            input.readMessage(acc);
            bitField0_ |= 0x00000400;
            tag = input.readTag();
            if (tag != 42) {
              break;
            }
          }
          case 42: {
            // formation
            input.readMessage(formation);
            bitField0_ |= 0x00000800;
            tag = input.readTag();
            if (tag != 58) {
              break;
            }
          }
          case 58: {
            // energy
            input.readMessage(energy);
            bitField0_ |= 0x00001000;
            tag = input.readTag();
            if (tag != 66) {
              break;
            }
          }
          case 66: {
            // worldClass
            input.readMessage(worldClass);
            bitField0_ |= 0x00002000;
            tag = input.readTag();
            if (tag != 74) {
              break;
            }
          }
          case 74: {
            // agent
            input.readMessage(agent);
            bitField0_ |= 0x00004000;
            tag = input.readTag();
            if (tag != 106) {
              break;
            }
          }
          case 106: {
            // quests
            input.readMessage(quests);
            bitField0_ |= 0x00008000;
            tag = input.readTag();
            if (tag != 114) {
              break;
            }
          }
          case 114: {
            // state
            input.readMessage(state);
            bitField0_ |= 0x00010000;
            tag = input.readTag();
            if (tag != 202) {
              break;
            }
          }
          case 202: {
            // phone
            input.readMessage(phone);
            bitField0_ |= 0x00020000;
            tag = input.readTag();
            if (tag != 242) {
              break;
            }
          }
          case 242: {
            // story
            input.readMessage(story);
            bitField0_ |= 0x00040000;
            tag = input.readTag();
            if (tag != 250) {
              break;
            }
          }
          case 250: {
            // vampireSurvivorRecord
            input.readMessage(vampireSurvivorRecord);
            bitField0_ |= 0x00080000;
            tag = input.readTag();
            if (tag != 146) {
              break;
            }
          }
          case 146: {
            // achievements
            input.readBytes(achievements);
            bitField0_ |= 0x00100000;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00200000;
            tag = input.readTag();
            if (tag != 82) {
              break;
            }
          }
          case 82: {
            // rglPassedIds [packed=true]
            input.readPackedUInt32(rglPassedIds, tag);
            bitField0_ |= 0x00400000;
            tag = input.readTag();
            if (tag != 130) {
              break;
            }
          }
          case 130: {
            // board [packed=true]
            input.readPackedUInt32(board, tag);
            bitField0_ |= 0x00800000;
            tag = input.readTag();
            if (tag != 138) {
              break;
            }
          }
          case 138: {
            // datingCharIds [packed=true]
            input.readPackedUInt32(datingCharIds, tag);
            bitField0_ |= 0x01000000;
            tag = input.readTag();
            if (tag != 258) {
              break;
            }
          }
          case 258: {
            // dailyActiveIds [packed=true]
            input.readPackedUInt32(dailyActiveIds, tag);
            bitField0_ |= 0x02000000;
            tag = input.readTag();
            if (tag != 986) {
              break;
            }
          }
          case 986: {
            // honorList [packed=true]
            input.readPackedUInt32(honorList, tag);
            bitField0_ |= 0x04000000;
            tag = input.readTag();
            if (tag != 18) {
              break;
            }
          }
          case 18: {
            // res
            tag = input.readRepeatedMessage(res, tag);
            bitField0_ |= 0x08000000;
            if (tag != 26) {
              break;
            }
          }
          case 26: {
            // items
            tag = input.readRepeatedMessage(items, tag);
            bitField0_ |= 0x10000000;
            if (tag != 34) {
              break;
            }
          }
          case 34: {
            // chars
            tag = input.readRepeatedMessage(chars, tag);
            bitField0_ |= 0x20000000;
            if (tag != 90) {
              break;
            }
          }
          case 90: {
            // equipments
            tag = input.readRepeatedMessage(equipments, tag);
            bitField0_ |= 0x40000000;
            if (tag != 98) {
              break;
            }
          }
          case 98: {
            // regionBossLevels
            tag = input.readRepeatedMessage(regionBossLevels, tag);
            bitField0_ |= 0x80000000;
            if (tag != 154) {
              break;
            }
          }
          case 154: {
            // handbook
            tag = input.readRepeatedMessage(handbook, tag);
            bitField1_ |= 0x00000001;
            if (tag != 170) {
              break;
            }
          }
          case 170: {
            // titles
            tag = input.readRepeatedMessage(titles, tag);
            bitField1_ |= 0x00000002;
            if (tag != 178) {
              break;
            }
          }
          case 178: {
            // dailyInstances
            tag = input.readRepeatedMessage(dailyInstances, tag);
            bitField1_ |= 0x00000004;
            if (tag != 186) {
              break;
            }
          }
          case 186: {
            // dictionaries
            tag = input.readRepeatedMessage(dictionaries, tag);
            bitField1_ |= 0x00000008;
            if (tag != 194) {
              break;
            }
          }
          case 194: {
            // activities
            tag = input.readRepeatedMessage(activities, tag);
            bitField1_ |= 0x00000010;
            if (tag != 226) {
              break;
            }
          }
          case 226: {
            // discs
            tag = input.readRepeatedMessage(discs, tag);
            bitField1_ |= 0x00000020;
            if (tag != 234) {
              break;
            }
          }
          case 234: {
            // equipmentInstances
            tag = input.readRepeatedMessage(equipmentInstances, tag);
            bitField1_ |= 0x00000040;
            if (tag != 274) {
              break;
            }
          }
          case 274: {
            // skillInstances
            tag = input.readRepeatedMessage(skillInstances, tag);
            bitField1_ |= 0x00000080;
            if (tag != 282) {
              break;
            }
          }
          case 282: {
            // weekBossLevels
            tag = input.readRepeatedMessage(weekBossLevels, tag);
            bitField1_ |= 0x00000100;
            if (tag != 290) {
              break;
            }
          }
          case 290: {
            // charGemInstances
            tag = input.readRepeatedMessage(charGemInstances, tag);
            bitField1_ |= 0x00000200;
            if (tag != 298) {
              break;
            }
          }
          case 298: {
            // tutorialLevels
            tag = input.readRepeatedMessage(tutorialLevels, tag);
            bitField1_ |= 0x00000400;
            if (tag != 994) {
              break;
            }
          }
          case 994: {
            // honors
            tag = input.readRepeatedMessage(honors, tag);
            bitField1_ |= 0x00000800;
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
          case 80: {
            // rglPassedIds [packed=false]
            tag = input.readRepeatedUInt32(rglPassedIds, tag);
            bitField0_ |= 0x00400000;
            break;
          }
          case 128: {
            // board [packed=false]
            tag = input.readRepeatedUInt32(board, tag);
            bitField0_ |= 0x00800000;
            break;
          }
          case 136: {
            // datingCharIds [packed=false]
            tag = input.readRepeatedUInt32(datingCharIds, tag);
            bitField0_ |= 0x01000000;
            break;
          }
          case 256: {
            // dailyActiveIds [packed=false]
            tag = input.readRepeatedUInt32(dailyActiveIds, tag);
            bitField0_ |= 0x02000000;
            break;
          }
          case 984: {
            // honorList [packed=false]
            tag = input.readRepeatedUInt32(honorList, tag);
            bitField0_ |= 0x04000000;
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeInt64(FieldNames.talentResetTime, talentResetTime);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeInt64(FieldNames.nicknameResetTime, nicknameResetTime);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeInt64(FieldNames.musicInfo, musicInfo);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeInt64(FieldNames.serverTs, serverTs);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        output.writeUInt32(FieldNames.sendGiftCnt, sendGiftCnt);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        output.writeUInt32(FieldNames.signinIndex, signinIndex);
      }
      if ((bitField0_ & 0x00000040) != 0) {
        output.writeUInt32(FieldNames.equipmentDoubleCount, equipmentDoubleCount);
      }
      if ((bitField0_ & 0x00000080) != 0) {
        output.writeUInt32(FieldNames.tourGuideQuestGroup, tourGuideQuestGroup);
      }
      if ((bitField0_ & 0x00000100) != 0) {
        output.writeUInt32(FieldNames.towerTicket, towerTicket);
      }
      if ((bitField0_ & 0x00000200) != 0) {
        output.writeBool(FieldNames.dailyShopRewardStatus, dailyShopRewardStatus);
      }
      if ((bitField0_ & 0x00000400) != 0) {
        output.writeMessage(FieldNames.acc, acc);
      }
      if ((bitField0_ & 0x00000800) != 0) {
        output.writeMessage(FieldNames.formation, formation);
      }
      if ((bitField0_ & 0x00001000) != 0) {
        output.writeMessage(FieldNames.energy, energy);
      }
      if ((bitField0_ & 0x00002000) != 0) {
        output.writeMessage(FieldNames.worldClass, worldClass);
      }
      if ((bitField0_ & 0x00004000) != 0) {
        output.writeMessage(FieldNames.agent, agent);
      }
      if ((bitField0_ & 0x00008000) != 0) {
        output.writeMessage(FieldNames.quests, quests);
      }
      if ((bitField0_ & 0x00010000) != 0) {
        output.writeMessage(FieldNames.state, state);
      }
      if ((bitField0_ & 0x00020000) != 0) {
        output.writeMessage(FieldNames.phone, phone);
      }
      if ((bitField0_ & 0x00040000) != 0) {
        output.writeMessage(FieldNames.story, story);
      }
      if ((bitField0_ & 0x00080000) != 0) {
        output.writeMessage(FieldNames.vampireSurvivorRecord, vampireSurvivorRecord);
      }
      if ((bitField0_ & 0x00100000) != 0) {
        output.writeBytes(FieldNames.achievements, achievements);
      }
      if ((bitField0_ & 0x00200000) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      if ((bitField0_ & 0x00400000) != 0) {
        output.writeRepeatedUInt32(FieldNames.rglPassedIds, rglPassedIds);
      }
      if ((bitField0_ & 0x00800000) != 0) {
        output.writeRepeatedUInt32(FieldNames.board, board);
      }
      if ((bitField0_ & 0x01000000) != 0) {
        output.writeRepeatedUInt32(FieldNames.datingCharIds, datingCharIds);
      }
      if ((bitField0_ & 0x02000000) != 0) {
        output.writeRepeatedUInt32(FieldNames.dailyActiveIds, dailyActiveIds);
      }
      if ((bitField0_ & 0x04000000) != 0) {
        output.writeRepeatedUInt32(FieldNames.honorList, honorList);
      }
      if ((bitField0_ & 0x08000000) != 0) {
        output.writeRepeatedMessage(FieldNames.res, res);
      }
      if ((bitField0_ & 0x10000000) != 0) {
        output.writeRepeatedMessage(FieldNames.items, items);
      }
      if ((bitField0_ & 0x20000000) != 0) {
        output.writeRepeatedMessage(FieldNames.chars, chars);
      }
      if ((bitField0_ & 0x40000000) != 0) {
        output.writeRepeatedMessage(FieldNames.equipments, equipments);
      }
      if ((bitField0_ & 0x80000000) != 0) {
        output.writeRepeatedMessage(FieldNames.regionBossLevels, regionBossLevels);
      }
      if ((bitField1_ & 0x00000001) != 0) {
        output.writeRepeatedMessage(FieldNames.handbook, handbook);
      }
      if ((bitField1_ & 0x00000002) != 0) {
        output.writeRepeatedMessage(FieldNames.titles, titles);
      }
      if ((bitField1_ & 0x00000004) != 0) {
        output.writeRepeatedMessage(FieldNames.dailyInstances, dailyInstances);
      }
      if ((bitField1_ & 0x00000008) != 0) {
        output.writeRepeatedMessage(FieldNames.dictionaries, dictionaries);
      }
      if ((bitField1_ & 0x00000010) != 0) {
        output.writeRepeatedMessage(FieldNames.activities, activities);
      }
      if ((bitField1_ & 0x00000020) != 0) {
        output.writeRepeatedMessage(FieldNames.discs, discs);
      }
      if ((bitField1_ & 0x00000040) != 0) {
        output.writeRepeatedMessage(FieldNames.equipmentInstances, equipmentInstances);
      }
      if ((bitField1_ & 0x00000080) != 0) {
        output.writeRepeatedMessage(FieldNames.skillInstances, skillInstances);
      }
      if ((bitField1_ & 0x00000100) != 0) {
        output.writeRepeatedMessage(FieldNames.weekBossLevels, weekBossLevels);
      }
      if ((bitField1_ & 0x00000200) != 0) {
        output.writeRepeatedMessage(FieldNames.charGemInstances, charGemInstances);
      }
      if ((bitField1_ & 0x00000400) != 0) {
        output.writeRepeatedMessage(FieldNames.tutorialLevels, tutorialLevels);
      }
      if ((bitField1_ & 0x00000800) != 0) {
        output.writeRepeatedMessage(FieldNames.honors, honors);
      }
      output.endObject();
    }

    @Override
    public PlayerInfo mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 1426330896: {
            if (input.isAtField(FieldNames.talentResetTime)) {
              if (!input.trySkipNullValue()) {
                talentResetTime = input.readInt64();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 1563162574: {
            if (input.isAtField(FieldNames.nicknameResetTime)) {
              if (!input.trySkipNullValue()) {
                nicknameResetTime = input.readInt64();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1901179821: {
            if (input.isAtField(FieldNames.musicInfo)) {
              if (!input.trySkipNullValue()) {
                musicInfo = input.readInt64();
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 1443748162: {
            if (input.isAtField(FieldNames.serverTs)) {
              if (!input.trySkipNullValue()) {
                serverTs = input.readInt64();
                bitField0_ |= 0x00000008;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 1431779665: {
            if (input.isAtField(FieldNames.sendGiftCnt)) {
              if (!input.trySkipNullValue()) {
                sendGiftCnt = input.readUInt32();
                bitField0_ |= 0x00000010;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 887809584: {
            if (input.isAtField(FieldNames.signinIndex)) {
              if (!input.trySkipNullValue()) {
                signinIndex = input.readUInt32();
                bitField0_ |= 0x00000020;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 740700528: {
            if (input.isAtField(FieldNames.equipmentDoubleCount)) {
              if (!input.trySkipNullValue()) {
                equipmentDoubleCount = input.readUInt32();
                bitField0_ |= 0x00000040;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 1496043841: {
            if (input.isAtField(FieldNames.tourGuideQuestGroup)) {
              if (!input.trySkipNullValue()) {
                tourGuideQuestGroup = input.readUInt32();
                bitField0_ |= 0x00000080;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -765674667: {
            if (input.isAtField(FieldNames.towerTicket)) {
              if (!input.trySkipNullValue()) {
                towerTicket = input.readUInt32();
                bitField0_ |= 0x00000100;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -483313104: {
            if (input.isAtField(FieldNames.dailyShopRewardStatus)) {
              if (!input.trySkipNullValue()) {
                dailyShopRewardStatus = input.readBool();
                bitField0_ |= 0x00000200;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 65633: {
            if (input.isAtField(FieldNames.acc)) {
              if (!input.trySkipNullValue()) {
                input.readMessage(acc);
                bitField0_ |= 0x00000400;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -479418223: {
            if (input.isAtField(FieldNames.formation)) {
              if (!input.trySkipNullValue()) {
                input.readMessage(formation);
                bitField0_ |= 0x00000800;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 2080120488: {
            if (input.isAtField(FieldNames.energy)) {
              if (!input.trySkipNullValue()) {
                input.readMessage(energy);
                bitField0_ |= 0x00001000;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1869617882: {
            if (input.isAtField(FieldNames.worldClass)) {
              if (!input.trySkipNullValue()) {
                input.readMessage(worldClass);
                bitField0_ |= 0x00002000;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 63197925: {
            if (input.isAtField(FieldNames.agent)) {
              if (!input.trySkipNullValue()) {
                input.readMessage(agent);
                bitField0_ |= 0x00004000;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1864830991: {
            if (input.isAtField(FieldNames.quests)) {
              if (!input.trySkipNullValue()) {
                input.readMessage(quests);
                bitField0_ |= 0x00008000;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 80204913: {
            if (input.isAtField(FieldNames.state)) {
              if (!input.trySkipNullValue()) {
                input.readMessage(state);
                bitField0_ |= 0x00010000;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 77090126: {
            if (input.isAtField(FieldNames.phone)) {
              if (!input.trySkipNullValue()) {
                input.readMessage(phone);
                bitField0_ |= 0x00020000;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 80218325: {
            if (input.isAtField(FieldNames.story)) {
              if (!input.trySkipNullValue()) {
                input.readMessage(story);
                bitField0_ |= 0x00040000;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1928058763: {
            if (input.isAtField(FieldNames.vampireSurvivorRecord)) {
              if (!input.trySkipNullValue()) {
                input.readMessage(vampireSurvivorRecord);
                bitField0_ |= 0x00080000;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1494045884: {
            if (input.isAtField(FieldNames.achievements)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(achievements);
                bitField0_ |= 0x00100000;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00200000;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1392306895: {
            if (input.isAtField(FieldNames.rglPassedIds)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedUInt32(rglPassedIds);
                bitField0_ |= 0x00400000;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 64356038: {
            if (input.isAtField(FieldNames.board)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedUInt32(board);
                bitField0_ |= 0x00800000;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -14425097: {
            if (input.isAtField(FieldNames.datingCharIds)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedUInt32(datingCharIds);
                bitField0_ |= 0x01000000;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 1363137497: {
            if (input.isAtField(FieldNames.dailyActiveIds)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedUInt32(dailyActiveIds);
                bitField0_ |= 0x02000000;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 1017359368: {
            if (input.isAtField(FieldNames.honorList)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedUInt32(honorList);
                bitField0_ |= 0x04000000;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 82048: {
            if (input.isAtField(FieldNames.res)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedMessage(res);
                bitField0_ |= 0x08000000;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 70973344: {
            if (input.isAtField(FieldNames.items)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedMessage(items);
                bitField0_ |= 0x10000000;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 65071037: {
            if (input.isAtField(FieldNames.chars)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedMessage(chars);
                bitField0_ |= 0x20000000;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 1000777925: {
            if (input.isAtField(FieldNames.equipments)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedMessage(equipments);
                bitField0_ |= 0x40000000;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -231400080: {
            if (input.isAtField(FieldNames.regionBossLevels)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedMessage(regionBossLevels);
                bitField0_ |= 0x80000000;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 66424824: {
            if (input.isAtField(FieldNames.handbook)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedMessage(handbook);
                bitField1_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1789586117: {
            if (input.isAtField(FieldNames.titles)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedMessage(titles);
                bitField1_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 1187764357: {
            if (input.isAtField(FieldNames.dailyInstances)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedMessage(dailyInstances);
                bitField1_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 282511316: {
            if (input.isAtField(FieldNames.dictionaries)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedMessage(dictionaries);
                bitField1_ |= 0x00000008;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -252897267: {
            if (input.isAtField(FieldNames.activities)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedMessage(activities);
                bitField1_ |= 0x00000010;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 66041182: {
            if (input.isAtField(FieldNames.discs)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedMessage(discs);
                bitField1_ |= 0x00000020;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 362304688: {
            if (input.isAtField(FieldNames.equipmentInstances)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedMessage(equipmentInstances);
                bitField1_ |= 0x00000040;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 1814965069: {
            if (input.isAtField(FieldNames.skillInstances)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedMessage(skillInstances);
                bitField1_ |= 0x00000080;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 1516494448: {
            if (input.isAtField(FieldNames.weekBossLevels)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedMessage(weekBossLevels);
                bitField1_ |= 0x00000100;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1297796475: {
            if (input.isAtField(FieldNames.charGemInstances)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedMessage(charGemInstances);
                bitField1_ |= 0x00000200;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -134202739: {
            if (input.isAtField(FieldNames.tutorialLevels)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedMessage(tutorialLevels);
                bitField1_ |= 0x00000400;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2127770263: {
            if (input.isAtField(FieldNames.honors)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedMessage(honors);
                bitField1_ |= 0x00000800;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public PlayerInfo clone() {
      return new PlayerInfo().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_ | bitField1_) == 0);
    }

    public static PlayerInfo parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new PlayerInfo(), data).checkInitialized();
    }

    public static PlayerInfo parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new PlayerInfo(), input).checkInitialized();
    }

    public static PlayerInfo parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new PlayerInfo(), input).checkInitialized();
    }

    /**
     * @return factory for creating PlayerInfo messages
     */
    public static MessageFactory<PlayerInfo> getFactory() {
      return PlayerInfoFactory.INSTANCE;
    }

    private enum PlayerInfoFactory implements MessageFactory<PlayerInfo> {
      INSTANCE;

      @Override
      public PlayerInfo create() {
        return PlayerInfo.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName talentResetTime = FieldName.forField("TalentResetTime");

      static final FieldName nicknameResetTime = FieldName.forField("NicknameResetTime");

      static final FieldName musicInfo = FieldName.forField("MusicInfo");

      static final FieldName serverTs = FieldName.forField("ServerTs");

      static final FieldName sendGiftCnt = FieldName.forField("SendGiftCnt");

      static final FieldName signinIndex = FieldName.forField("SigninIndex");

      static final FieldName equipmentDoubleCount = FieldName.forField("EquipmentDoubleCount");

      static final FieldName tourGuideQuestGroup = FieldName.forField("TourGuideQuestGroup");

      static final FieldName towerTicket = FieldName.forField("TowerTicket");

      static final FieldName dailyShopRewardStatus = FieldName.forField("DailyShopRewardStatus");

      static final FieldName acc = FieldName.forField("Acc");

      static final FieldName formation = FieldName.forField("Formation");

      static final FieldName energy = FieldName.forField("Energy");

      static final FieldName worldClass = FieldName.forField("WorldClass");

      static final FieldName agent = FieldName.forField("Agent");

      static final FieldName quests = FieldName.forField("Quests");

      static final FieldName state = FieldName.forField("State");

      static final FieldName phone = FieldName.forField("Phone");

      static final FieldName story = FieldName.forField("Story");

      static final FieldName vampireSurvivorRecord = FieldName.forField("VampireSurvivorRecord");

      static final FieldName achievements = FieldName.forField("Achievements");

      static final FieldName nextPackage = FieldName.forField("NextPackage");

      static final FieldName rglPassedIds = FieldName.forField("RglPassedIds");

      static final FieldName board = FieldName.forField("Board");

      static final FieldName datingCharIds = FieldName.forField("DatingCharIds");

      static final FieldName dailyActiveIds = FieldName.forField("DailyActiveIds");

      static final FieldName honorList = FieldName.forField("HonorList");

      static final FieldName res = FieldName.forField("Res");

      static final FieldName items = FieldName.forField("Items");

      static final FieldName chars = FieldName.forField("Chars");

      static final FieldName equipments = FieldName.forField("Equipments");

      static final FieldName regionBossLevels = FieldName.forField("RegionBossLevels");

      static final FieldName handbook = FieldName.forField("Handbook");

      static final FieldName titles = FieldName.forField("Titles");

      static final FieldName dailyInstances = FieldName.forField("DailyInstances");

      static final FieldName dictionaries = FieldName.forField("Dictionaries");

      static final FieldName activities = FieldName.forField("Activities");

      static final FieldName discs = FieldName.forField("Discs");

      static final FieldName equipmentInstances = FieldName.forField("EquipmentInstances");

      static final FieldName skillInstances = FieldName.forField("SkillInstances");

      static final FieldName weekBossLevels = FieldName.forField("WeekBossLevels");

      static final FieldName charGemInstances = FieldName.forField("CharGemInstances");

      static final FieldName tutorialLevels = FieldName.forField("TutorialLevels");

      static final FieldName honors = FieldName.forField("Honors");
    }
  }

  /**
   * Protobuf type {@code PhoneInfo}
   */
  public static final class PhoneInfo extends ProtoMessage<PhoneInfo> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional uint32 NewMessage = 1;</code>
     */
    private int newMessage;

    /**
     * <code>optional uint32 ProgressMessage = 2;</code>
     */
    private int progressMessage;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    private PhoneInfo() {
    }

    /**
     * @return a new empty instance of {@code PhoneInfo}
     */
    public static PhoneInfo newInstance() {
      return new PhoneInfo();
    }

    /**
     * <code>optional uint32 NewMessage = 1;</code>
     * @return whether the newMessage field is set
     */
    public boolean hasNewMessage() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional uint32 NewMessage = 1;</code>
     * @return this
     */
    public PhoneInfo clearNewMessage() {
      bitField0_ &= ~0x00000001;
      newMessage = 0;
      return this;
    }

    /**
     * <code>optional uint32 NewMessage = 1;</code>
     * @return the newMessage
     */
    public int getNewMessage() {
      return newMessage;
    }

    /**
     * <code>optional uint32 NewMessage = 1;</code>
     * @param value the newMessage to set
     * @return this
     */
    public PhoneInfo setNewMessage(final int value) {
      bitField0_ |= 0x00000001;
      newMessage = value;
      return this;
    }

    /**
     * <code>optional uint32 ProgressMessage = 2;</code>
     * @return whether the progressMessage field is set
     */
    public boolean hasProgressMessage() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional uint32 ProgressMessage = 2;</code>
     * @return this
     */
    public PhoneInfo clearProgressMessage() {
      bitField0_ &= ~0x00000002;
      progressMessage = 0;
      return this;
    }

    /**
     * <code>optional uint32 ProgressMessage = 2;</code>
     * @return the progressMessage
     */
    public int getProgressMessage() {
      return progressMessage;
    }

    /**
     * <code>optional uint32 ProgressMessage = 2;</code>
     * @param value the progressMessage to set
     * @return this
     */
    public PhoneInfo setProgressMessage(final int value) {
      bitField0_ |= 0x00000002;
      progressMessage = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public PhoneInfo clearNextPackage() {
      bitField0_ &= ~0x00000004;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000004;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public PhoneInfo addNextPackage(final byte value) {
      bitField0_ |= 0x00000004;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public PhoneInfo addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000004;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public PhoneInfo setNextPackage(final byte... values) {
      bitField0_ |= 0x00000004;
      nextPackage.copyFrom(values);
      return this;
    }

    @Override
    public PhoneInfo copyFrom(final PhoneInfo other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        newMessage = other.newMessage;
        progressMessage = other.progressMessage;
        nextPackage.copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public PhoneInfo mergeFrom(final PhoneInfo other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasNewMessage()) {
        setNewMessage(other.newMessage);
      }
      if (other.hasProgressMessage()) {
        setProgressMessage(other.progressMessage);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public PhoneInfo clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      newMessage = 0;
      progressMessage = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public PhoneInfo clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof PhoneInfo)) {
        return false;
      }
      PhoneInfo other = (PhoneInfo) o;
      return bitField0_ == other.bitField0_
        && (!hasNewMessage() || newMessage == other.newMessage)
        && (!hasProgressMessage() || progressMessage == other.progressMessage)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt32NoTag(newMessage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 16);
        output.writeUInt32NoTag(progressMessage);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(newMessage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(progressMessage);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public PhoneInfo mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            // newMessage
            newMessage = input.readUInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 16) {
              break;
            }
          }
          case 16: {
            // progressMessage
            progressMessage = input.readUInt32();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeUInt32(FieldNames.newMessage, newMessage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeUInt32(FieldNames.progressMessage, progressMessage);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      output.endObject();
    }

    @Override
    public PhoneInfo mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case -751847833: {
            if (input.isAtField(FieldNames.newMessage)) {
              if (!input.trySkipNullValue()) {
                newMessage = input.readUInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1132973830: {
            if (input.isAtField(FieldNames.progressMessage)) {
              if (!input.trySkipNullValue()) {
                progressMessage = input.readUInt32();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public PhoneInfo clone() {
      return new PhoneInfo().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static PhoneInfo parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new PhoneInfo(), data).checkInitialized();
    }

    public static PhoneInfo parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new PhoneInfo(), input).checkInitialized();
    }

    public static PhoneInfo parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new PhoneInfo(), input).checkInitialized();
    }

    /**
     * @return factory for creating PhoneInfo messages
     */
    public static MessageFactory<PhoneInfo> getFactory() {
      return PhoneInfoFactory.INSTANCE;
    }

    private enum PhoneInfoFactory implements MessageFactory<PhoneInfo> {
      INSTANCE;

      @Override
      public PhoneInfo create() {
        return PhoneInfo.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName newMessage = FieldName.forField("NewMessage");

      static final FieldName progressMessage = FieldName.forField("ProgressMessage");

      static final FieldName nextPackage = FieldName.forField("NextPackage");
    }
  }

  /**
   * Protobuf type {@code DictionaryEntry}
   */
  public static final class DictionaryEntry extends ProtoMessage<DictionaryEntry> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional uint32 Index = 1;</code>
     */
    private int index;

    /**
     * <code>optional uint32 Status = 2;</code>
     */
    private int status;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    private DictionaryEntry() {
    }

    /**
     * @return a new empty instance of {@code DictionaryEntry}
     */
    public static DictionaryEntry newInstance() {
      return new DictionaryEntry();
    }

    /**
     * <code>optional uint32 Index = 1;</code>
     * @return whether the index field is set
     */
    public boolean hasIndex() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional uint32 Index = 1;</code>
     * @return this
     */
    public DictionaryEntry clearIndex() {
      bitField0_ &= ~0x00000001;
      index = 0;
      return this;
    }

    /**
     * <code>optional uint32 Index = 1;</code>
     * @return the index
     */
    public int getIndex() {
      return index;
    }

    /**
     * <code>optional uint32 Index = 1;</code>
     * @param value the index to set
     * @return this
     */
    public DictionaryEntry setIndex(final int value) {
      bitField0_ |= 0x00000001;
      index = value;
      return this;
    }

    /**
     * <code>optional uint32 Status = 2;</code>
     * @return whether the status field is set
     */
    public boolean hasStatus() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional uint32 Status = 2;</code>
     * @return this
     */
    public DictionaryEntry clearStatus() {
      bitField0_ &= ~0x00000002;
      status = 0;
      return this;
    }

    /**
     * <code>optional uint32 Status = 2;</code>
     * @return the status
     */
    public int getStatus() {
      return status;
    }

    /**
     * <code>optional uint32 Status = 2;</code>
     * @param value the status to set
     * @return this
     */
    public DictionaryEntry setStatus(final int value) {
      bitField0_ |= 0x00000002;
      status = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public DictionaryEntry clearNextPackage() {
      bitField0_ &= ~0x00000004;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000004;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public DictionaryEntry addNextPackage(final byte value) {
      bitField0_ |= 0x00000004;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public DictionaryEntry addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000004;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public DictionaryEntry setNextPackage(final byte... values) {
      bitField0_ |= 0x00000004;
      nextPackage.copyFrom(values);
      return this;
    }

    @Override
    public DictionaryEntry copyFrom(final DictionaryEntry other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        index = other.index;
        status = other.status;
        nextPackage.copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public DictionaryEntry mergeFrom(final DictionaryEntry other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasIndex()) {
        setIndex(other.index);
      }
      if (other.hasStatus()) {
        setStatus(other.status);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public DictionaryEntry clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      index = 0;
      status = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public DictionaryEntry clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof DictionaryEntry)) {
        return false;
      }
      DictionaryEntry other = (DictionaryEntry) o;
      return bitField0_ == other.bitField0_
        && (!hasIndex() || index == other.index)
        && (!hasStatus() || status == other.status)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt32NoTag(index);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 16);
        output.writeUInt32NoTag(status);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(index);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(status);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public DictionaryEntry mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            // index
            index = input.readUInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 16) {
              break;
            }
          }
          case 16: {
            // status
            status = input.readUInt32();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeUInt32(FieldNames.index, index);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeUInt32(FieldNames.status, status);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      output.endObject();
    }

    @Override
    public DictionaryEntry mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 70793394: {
            if (input.isAtField(FieldNames.index)) {
              if (!input.trySkipNullValue()) {
                index = input.readUInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1808614382: {
            if (input.isAtField(FieldNames.status)) {
              if (!input.trySkipNullValue()) {
                status = input.readUInt32();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public DictionaryEntry clone() {
      return new DictionaryEntry().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static DictionaryEntry parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new DictionaryEntry(), data).checkInitialized();
    }

    public static DictionaryEntry parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new DictionaryEntry(), input).checkInitialized();
    }

    public static DictionaryEntry parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new DictionaryEntry(), input).checkInitialized();
    }

    /**
     * @return factory for creating DictionaryEntry messages
     */
    public static MessageFactory<DictionaryEntry> getFactory() {
      return DictionaryEntryFactory.INSTANCE;
    }

    private enum DictionaryEntryFactory implements MessageFactory<DictionaryEntry> {
      INSTANCE;

      @Override
      public DictionaryEntry create() {
        return DictionaryEntry.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName index = FieldName.forField("Index");

      static final FieldName status = FieldName.forField("Status");

      static final FieldName nextPackage = FieldName.forField("NextPackage");
    }
  }

  /**
   * Protobuf type {@code DictionaryTab}
   */
  public static final class DictionaryTab extends ProtoMessage<DictionaryTab> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional uint32 TabId = 1;</code>
     */
    private int tabId;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    /**
     * <code>repeated .DictionaryEntry Entries = 2;</code>
     */
    private final RepeatedMessage<DictionaryEntry> entries = RepeatedMessage.newEmptyInstance(DictionaryEntry.getFactory());

    private DictionaryTab() {
    }

    /**
     * @return a new empty instance of {@code DictionaryTab}
     */
    public static DictionaryTab newInstance() {
      return new DictionaryTab();
    }

    /**
     * <code>optional uint32 TabId = 1;</code>
     * @return whether the tabId field is set
     */
    public boolean hasTabId() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional uint32 TabId = 1;</code>
     * @return this
     */
    public DictionaryTab clearTabId() {
      bitField0_ &= ~0x00000001;
      tabId = 0;
      return this;
    }

    /**
     * <code>optional uint32 TabId = 1;</code>
     * @return the tabId
     */
    public int getTabId() {
      return tabId;
    }

    /**
     * <code>optional uint32 TabId = 1;</code>
     * @param value the tabId to set
     * @return this
     */
    public DictionaryTab setTabId(final int value) {
      bitField0_ |= 0x00000001;
      tabId = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public DictionaryTab clearNextPackage() {
      bitField0_ &= ~0x00000002;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000002;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public DictionaryTab addNextPackage(final byte value) {
      bitField0_ |= 0x00000002;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public DictionaryTab addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000002;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public DictionaryTab setNextPackage(final byte... values) {
      bitField0_ |= 0x00000002;
      nextPackage.copyFrom(values);
      return this;
    }

    /**
     * <code>repeated .DictionaryEntry Entries = 2;</code>
     * @return whether the entries field is set
     */
    public boolean hasEntries() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>repeated .DictionaryEntry Entries = 2;</code>
     * @return this
     */
    public DictionaryTab clearEntries() {
      bitField0_ &= ~0x00000004;
      entries.clear();
      return this;
    }

    /**
     * <code>repeated .DictionaryEntry Entries = 2;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableEntries()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<DictionaryEntry> getEntries() {
      return entries;
    }

    /**
     * <code>repeated .DictionaryEntry Entries = 2;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<DictionaryEntry> getMutableEntries() {
      bitField0_ |= 0x00000004;
      return entries;
    }

    /**
     * <code>repeated .DictionaryEntry Entries = 2;</code>
     * @param value the entries to add
     * @return this
     */
    public DictionaryTab addEntries(final DictionaryEntry value) {
      bitField0_ |= 0x00000004;
      entries.add(value);
      return this;
    }

    /**
     * <code>repeated .DictionaryEntry Entries = 2;</code>
     * @param values the entries to add
     * @return this
     */
    public DictionaryTab addAllEntries(final DictionaryEntry... values) {
      bitField0_ |= 0x00000004;
      entries.addAll(values);
      return this;
    }

    @Override
    public DictionaryTab copyFrom(final DictionaryTab other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        tabId = other.tabId;
        nextPackage.copyFrom(other.nextPackage);
        entries.copyFrom(other.entries);
      }
      return this;
    }

    @Override
    public DictionaryTab mergeFrom(final DictionaryTab other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasTabId()) {
        setTabId(other.tabId);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      if (other.hasEntries()) {
        getMutableEntries().addAll(other.entries);
      }
      return this;
    }

    @Override
    public DictionaryTab clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      tabId = 0;
      nextPackage.clear();
      entries.clear();
      return this;
    }

    @Override
    public DictionaryTab clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      entries.clearQuick();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof DictionaryTab)) {
        return false;
      }
      DictionaryTab other = (DictionaryTab) o;
      return bitField0_ == other.bitField0_
        && (!hasTabId() || tabId == other.tabId)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage))
        && (!hasEntries() || entries.equals(other.entries));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt32NoTag(tabId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        for (int i = 0; i < entries.length(); i++) {
          output.writeRawByte((byte) 18);
          output.writeMessageNoTag(entries.get(i));
        }
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(tabId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += (1 * entries.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(entries);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public DictionaryTab mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            // tabId
            tabId = input.readUInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 18) {
              break;
            }
          }
          case 18: {
            // entries
            tag = input.readRepeatedMessage(entries, tag);
            bitField0_ |= 0x00000004;
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeUInt32(FieldNames.tabId, tabId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRepeatedMessage(FieldNames.entries, entries);
      }
      output.endObject();
    }

    @Override
    public DictionaryTab mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 80562032: {
            if (input.isAtField(FieldNames.tabId)) {
              if (!input.trySkipNullValue()) {
                tabId = input.readUInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 73079920: {
            if (input.isAtField(FieldNames.entries)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedMessage(entries);
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public DictionaryTab clone() {
      return new DictionaryTab().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static DictionaryTab parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new DictionaryTab(), data).checkInitialized();
    }

    public static DictionaryTab parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new DictionaryTab(), input).checkInitialized();
    }

    public static DictionaryTab parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new DictionaryTab(), input).checkInitialized();
    }

    /**
     * @return factory for creating DictionaryTab messages
     */
    public static MessageFactory<DictionaryTab> getFactory() {
      return DictionaryTabFactory.INSTANCE;
    }

    private enum DictionaryTabFactory implements MessageFactory<DictionaryTab> {
      INSTANCE;

      @Override
      public DictionaryTab create() {
        return DictionaryTab.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName tabId = FieldName.forField("TabId");

      static final FieldName nextPackage = FieldName.forField("NextPackage");

      static final FieldName entries = FieldName.forField("Entries");
    }
  }

  /**
   * Protobuf type {@code EnergyInfo}
   */
  public static final class EnergyInfo extends ProtoMessage<EnergyInfo> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional uint32 Count = 2;</code>
     */
    private int count;

    /**
     * <code>optional .Energy Energy = 1;</code>
     */
    private final Public.Energy energy = Public.Energy.newInstance();

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    private EnergyInfo() {
    }

    /**
     * @return a new empty instance of {@code EnergyInfo}
     */
    public static EnergyInfo newInstance() {
      return new EnergyInfo();
    }

    /**
     * <code>optional uint32 Count = 2;</code>
     * @return whether the count field is set
     */
    public boolean hasCount() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional uint32 Count = 2;</code>
     * @return this
     */
    public EnergyInfo clearCount() {
      bitField0_ &= ~0x00000001;
      count = 0;
      return this;
    }

    /**
     * <code>optional uint32 Count = 2;</code>
     * @return the count
     */
    public int getCount() {
      return count;
    }

    /**
     * <code>optional uint32 Count = 2;</code>
     * @param value the count to set
     * @return this
     */
    public EnergyInfo setCount(final int value) {
      bitField0_ |= 0x00000001;
      count = value;
      return this;
    }

    /**
     * <code>optional .Energy Energy = 1;</code>
     * @return whether the energy field is set
     */
    public boolean hasEnergy() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional .Energy Energy = 1;</code>
     * @return this
     */
    public EnergyInfo clearEnergy() {
      bitField0_ &= ~0x00000002;
      energy.clear();
      return this;
    }

    /**
     * <code>optional .Energy Energy = 1;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableEnergy()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public Public.Energy getEnergy() {
      return energy;
    }

    /**
     * <code>optional .Energy Energy = 1;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public Public.Energy getMutableEnergy() {
      bitField0_ |= 0x00000002;
      return energy;
    }

    /**
     * <code>optional .Energy Energy = 1;</code>
     * @param value the energy to set
     * @return this
     */
    public EnergyInfo setEnergy(final Public.Energy value) {
      bitField0_ |= 0x00000002;
      energy.copyFrom(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public EnergyInfo clearNextPackage() {
      bitField0_ &= ~0x00000004;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000004;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public EnergyInfo addNextPackage(final byte value) {
      bitField0_ |= 0x00000004;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public EnergyInfo addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000004;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public EnergyInfo setNextPackage(final byte... values) {
      bitField0_ |= 0x00000004;
      nextPackage.copyFrom(values);
      return this;
    }

    @Override
    public EnergyInfo copyFrom(final EnergyInfo other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        count = other.count;
        energy.copyFrom(other.energy);
        nextPackage.copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public EnergyInfo mergeFrom(final EnergyInfo other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasCount()) {
        setCount(other.count);
      }
      if (other.hasEnergy()) {
        getMutableEnergy().mergeFrom(other.energy);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public EnergyInfo clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      count = 0;
      energy.clear();
      nextPackage.clear();
      return this;
    }

    @Override
    public EnergyInfo clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      energy.clearQuick();
      nextPackage.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof EnergyInfo)) {
        return false;
      }
      EnergyInfo other = (EnergyInfo) o;
      return bitField0_ == other.bitField0_
        && (!hasCount() || count == other.count)
        && (!hasEnergy() || energy.equals(other.energy))
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 16);
        output.writeUInt32NoTag(count);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 10);
        output.writeMessageNoTag(energy);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(count);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeMessageSizeNoTag(energy);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public EnergyInfo mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 16: {
            // count
            count = input.readUInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 10) {
              break;
            }
          }
          case 10: {
            // energy
            input.readMessage(energy);
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeUInt32(FieldNames.count, count);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeMessage(FieldNames.energy, energy);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      output.endObject();
    }

    @Override
    public EnergyInfo mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 65298671: {
            if (input.isAtField(FieldNames.count)) {
              if (!input.trySkipNullValue()) {
                count = input.readUInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 2080120488: {
            if (input.isAtField(FieldNames.energy)) {
              if (!input.trySkipNullValue()) {
                input.readMessage(energy);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public EnergyInfo clone() {
      return new EnergyInfo().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static EnergyInfo parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new EnergyInfo(), data).checkInitialized();
    }

    public static EnergyInfo parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new EnergyInfo(), input).checkInitialized();
    }

    public static EnergyInfo parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new EnergyInfo(), input).checkInitialized();
    }

    /**
     * @return factory for creating EnergyInfo messages
     */
    public static MessageFactory<EnergyInfo> getFactory() {
      return EnergyInfoFactory.INSTANCE;
    }

    private enum EnergyInfoFactory implements MessageFactory<EnergyInfo> {
      INSTANCE;

      @Override
      public EnergyInfo create() {
        return EnergyInfo.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName count = FieldName.forField("Count");

      static final FieldName energy = FieldName.forField("Energy");

      static final FieldName nextPackage = FieldName.forField("NextPackage");
    }
  }

  /**
   * Protobuf type {@code WorldClassInfo}
   */
  public static final class WorldClassInfo extends ProtoMessage<WorldClassInfo> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional int32 LastExp = 2;</code>
     */
    private int lastExp;

    /**
     * <code>optional uint32 Cur = 1;</code>
     */
    private int cur;

    /**
     * <code>optional uint32 Stage = 3;</code>
     */
    private int stage;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    private WorldClassInfo() {
    }

    /**
     * @return a new empty instance of {@code WorldClassInfo}
     */
    public static WorldClassInfo newInstance() {
      return new WorldClassInfo();
    }

    /**
     * <code>optional int32 LastExp = 2;</code>
     * @return whether the lastExp field is set
     */
    public boolean hasLastExp() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional int32 LastExp = 2;</code>
     * @return this
     */
    public WorldClassInfo clearLastExp() {
      bitField0_ &= ~0x00000001;
      lastExp = 0;
      return this;
    }

    /**
     * <code>optional int32 LastExp = 2;</code>
     * @return the lastExp
     */
    public int getLastExp() {
      return lastExp;
    }

    /**
     * <code>optional int32 LastExp = 2;</code>
     * @param value the lastExp to set
     * @return this
     */
    public WorldClassInfo setLastExp(final int value) {
      bitField0_ |= 0x00000001;
      lastExp = value;
      return this;
    }

    /**
     * <code>optional uint32 Cur = 1;</code>
     * @return whether the cur field is set
     */
    public boolean hasCur() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional uint32 Cur = 1;</code>
     * @return this
     */
    public WorldClassInfo clearCur() {
      bitField0_ &= ~0x00000002;
      cur = 0;
      return this;
    }

    /**
     * <code>optional uint32 Cur = 1;</code>
     * @return the cur
     */
    public int getCur() {
      return cur;
    }

    /**
     * <code>optional uint32 Cur = 1;</code>
     * @param value the cur to set
     * @return this
     */
    public WorldClassInfo setCur(final int value) {
      bitField0_ |= 0x00000002;
      cur = value;
      return this;
    }

    /**
     * <code>optional uint32 Stage = 3;</code>
     * @return whether the stage field is set
     */
    public boolean hasStage() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional uint32 Stage = 3;</code>
     * @return this
     */
    public WorldClassInfo clearStage() {
      bitField0_ &= ~0x00000004;
      stage = 0;
      return this;
    }

    /**
     * <code>optional uint32 Stage = 3;</code>
     * @return the stage
     */
    public int getStage() {
      return stage;
    }

    /**
     * <code>optional uint32 Stage = 3;</code>
     * @param value the stage to set
     * @return this
     */
    public WorldClassInfo setStage(final int value) {
      bitField0_ |= 0x00000004;
      stage = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000008) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public WorldClassInfo clearNextPackage() {
      bitField0_ &= ~0x00000008;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000008;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public WorldClassInfo addNextPackage(final byte value) {
      bitField0_ |= 0x00000008;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public WorldClassInfo addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000008;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public WorldClassInfo setNextPackage(final byte... values) {
      bitField0_ |= 0x00000008;
      nextPackage.copyFrom(values);
      return this;
    }

    @Override
    public WorldClassInfo copyFrom(final WorldClassInfo other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        lastExp = other.lastExp;
        cur = other.cur;
        stage = other.stage;
        nextPackage.copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public WorldClassInfo mergeFrom(final WorldClassInfo other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasLastExp()) {
        setLastExp(other.lastExp);
      }
      if (other.hasCur()) {
        setCur(other.cur);
      }
      if (other.hasStage()) {
        setStage(other.stage);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public WorldClassInfo clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      lastExp = 0;
      cur = 0;
      stage = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public WorldClassInfo clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof WorldClassInfo)) {
        return false;
      }
      WorldClassInfo other = (WorldClassInfo) o;
      return bitField0_ == other.bitField0_
        && (!hasLastExp() || lastExp == other.lastExp)
        && (!hasCur() || cur == other.cur)
        && (!hasStage() || stage == other.stage)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 16);
        output.writeInt32NoTag(lastExp);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt32NoTag(cur);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawByte((byte) 24);
        output.writeUInt32NoTag(stage);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeInt32SizeNoTag(lastExp);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(cur);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(stage);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public WorldClassInfo mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 16: {
            // lastExp
            lastExp = input.readInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 8) {
              break;
            }
          }
          case 8: {
            // cur
            cur = input.readUInt32();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 24) {
              break;
            }
          }
          case 24: {
            // stage
            stage = input.readUInt32();
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000008;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeInt32(FieldNames.lastExp, lastExp);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeUInt32(FieldNames.cur, cur);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeUInt32(FieldNames.stage, stage);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      output.endObject();
    }

    @Override
    public WorldClassInfo mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 1617561479: {
            if (input.isAtField(FieldNames.lastExp)) {
              if (!input.trySkipNullValue()) {
                lastExp = input.readInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 68128: {
            if (input.isAtField(FieldNames.cur)) {
              if (!input.trySkipNullValue()) {
                cur = input.readUInt32();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 80204510: {
            if (input.isAtField(FieldNames.stage)) {
              if (!input.trySkipNullValue()) {
                stage = input.readUInt32();
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000008;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public WorldClassInfo clone() {
      return new WorldClassInfo().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static WorldClassInfo parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new WorldClassInfo(), data).checkInitialized();
    }

    public static WorldClassInfo parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new WorldClassInfo(), input).checkInitialized();
    }

    public static WorldClassInfo parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new WorldClassInfo(), input).checkInitialized();
    }

    /**
     * @return factory for creating WorldClassInfo messages
     */
    public static MessageFactory<WorldClassInfo> getFactory() {
      return WorldClassInfoFactory.INSTANCE;
    }

    private enum WorldClassInfoFactory implements MessageFactory<WorldClassInfo> {
      INSTANCE;

      @Override
      public WorldClassInfo create() {
        return WorldClassInfo.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName lastExp = FieldName.forField("LastExp");

      static final FieldName cur = FieldName.forField("Cur");

      static final FieldName stage = FieldName.forField("Stage");

      static final FieldName nextPackage = FieldName.forField("NextPackage");
    }
  }
}
