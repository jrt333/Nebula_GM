// Code generated by protocol buffer compiler. Do not edit!
package emu.nebula.proto;

import java.io.IOException;
import us.hebi.quickbuf.FieldName;
import us.hebi.quickbuf.InvalidProtocolBufferException;
import us.hebi.quickbuf.JsonSink;
import us.hebi.quickbuf.JsonSource;
import us.hebi.quickbuf.MessageFactory;
import us.hebi.quickbuf.ProtoMessage;
import us.hebi.quickbuf.ProtoSink;
import us.hebi.quickbuf.ProtoSource;
import us.hebi.quickbuf.RepeatedByte;
import us.hebi.quickbuf.RepeatedInt;
import us.hebi.quickbuf.RepeatedLong;
import us.hebi.quickbuf.RepeatedMessage;
import us.hebi.quickbuf.Utf8String;

public final class PublicStarTower {
  /**
   * Protobuf type {@code StarTowerInfo}
   */
  public static final class StarTowerInfo extends ProtoMessage<StarTowerInfo> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional .StarTowerMeta Meta = 1;</code>
     */
    private final StarTowerMeta meta = StarTowerMeta.newInstance();

    /**
     * <code>optional .StarTowerRoom Room = 2;</code>
     */
    private final StarTowerRoom room = StarTowerRoom.newInstance();

    /**
     * <code>optional .StarTowerBag Bag = 3;</code>
     */
    private final StarTowerBag bag = StarTowerBag.newInstance();

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    private StarTowerInfo() {
    }

    /**
     * @return a new empty instance of {@code StarTowerInfo}
     */
    public static StarTowerInfo newInstance() {
      return new StarTowerInfo();
    }

    /**
     * <code>optional .StarTowerMeta Meta = 1;</code>
     * @return whether the meta field is set
     */
    public boolean hasMeta() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional .StarTowerMeta Meta = 1;</code>
     * @return this
     */
    public StarTowerInfo clearMeta() {
      bitField0_ &= ~0x00000001;
      meta.clear();
      return this;
    }

    /**
     * <code>optional .StarTowerMeta Meta = 1;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableMeta()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public StarTowerMeta getMeta() {
      return meta;
    }

    /**
     * <code>optional .StarTowerMeta Meta = 1;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public StarTowerMeta getMutableMeta() {
      bitField0_ |= 0x00000001;
      return meta;
    }

    /**
     * <code>optional .StarTowerMeta Meta = 1;</code>
     * @param value the meta to set
     * @return this
     */
    public StarTowerInfo setMeta(final StarTowerMeta value) {
      bitField0_ |= 0x00000001;
      meta.copyFrom(value);
      return this;
    }

    /**
     * <code>optional .StarTowerRoom Room = 2;</code>
     * @return whether the room field is set
     */
    public boolean hasRoom() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional .StarTowerRoom Room = 2;</code>
     * @return this
     */
    public StarTowerInfo clearRoom() {
      bitField0_ &= ~0x00000002;
      room.clear();
      return this;
    }

    /**
     * <code>optional .StarTowerRoom Room = 2;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableRoom()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public StarTowerRoom getRoom() {
      return room;
    }

    /**
     * <code>optional .StarTowerRoom Room = 2;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public StarTowerRoom getMutableRoom() {
      bitField0_ |= 0x00000002;
      return room;
    }

    /**
     * <code>optional .StarTowerRoom Room = 2;</code>
     * @param value the room to set
     * @return this
     */
    public StarTowerInfo setRoom(final StarTowerRoom value) {
      bitField0_ |= 0x00000002;
      room.copyFrom(value);
      return this;
    }

    /**
     * <code>optional .StarTowerBag Bag = 3;</code>
     * @return whether the bag field is set
     */
    public boolean hasBag() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional .StarTowerBag Bag = 3;</code>
     * @return this
     */
    public StarTowerInfo clearBag() {
      bitField0_ &= ~0x00000004;
      bag.clear();
      return this;
    }

    /**
     * <code>optional .StarTowerBag Bag = 3;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableBag()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public StarTowerBag getBag() {
      return bag;
    }

    /**
     * <code>optional .StarTowerBag Bag = 3;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public StarTowerBag getMutableBag() {
      bitField0_ |= 0x00000004;
      return bag;
    }

    /**
     * <code>optional .StarTowerBag Bag = 3;</code>
     * @param value the bag to set
     * @return this
     */
    public StarTowerInfo setBag(final StarTowerBag value) {
      bitField0_ |= 0x00000004;
      bag.copyFrom(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000008) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public StarTowerInfo clearNextPackage() {
      bitField0_ &= ~0x00000008;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000008;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public StarTowerInfo addNextPackage(final byte value) {
      bitField0_ |= 0x00000008;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public StarTowerInfo addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000008;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public StarTowerInfo setNextPackage(final byte... values) {
      bitField0_ |= 0x00000008;
      nextPackage.copyFrom(values);
      return this;
    }

    @Override
    public StarTowerInfo copyFrom(final StarTowerInfo other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        meta.copyFrom(other.meta);
        room.copyFrom(other.room);
        bag.copyFrom(other.bag);
        nextPackage.copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public StarTowerInfo mergeFrom(final StarTowerInfo other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasMeta()) {
        getMutableMeta().mergeFrom(other.meta);
      }
      if (other.hasRoom()) {
        getMutableRoom().mergeFrom(other.room);
      }
      if (other.hasBag()) {
        getMutableBag().mergeFrom(other.bag);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public StarTowerInfo clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      meta.clear();
      room.clear();
      bag.clear();
      nextPackage.clear();
      return this;
    }

    @Override
    public StarTowerInfo clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      meta.clearQuick();
      room.clearQuick();
      bag.clearQuick();
      nextPackage.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof StarTowerInfo)) {
        return false;
      }
      StarTowerInfo other = (StarTowerInfo) o;
      return bitField0_ == other.bitField0_
        && (!hasMeta() || meta.equals(other.meta))
        && (!hasRoom() || room.equals(other.room))
        && (!hasBag() || bag.equals(other.bag))
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 10);
        output.writeMessageNoTag(meta);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 18);
        output.writeMessageNoTag(room);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawByte((byte) 26);
        output.writeMessageNoTag(bag);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeMessageSizeNoTag(meta);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeMessageSizeNoTag(room);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 1 + ProtoSink.computeMessageSizeNoTag(bag);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public StarTowerInfo mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 10: {
            // meta
            input.readMessage(meta);
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 18) {
              break;
            }
          }
          case 18: {
            // room
            input.readMessage(room);
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 26) {
              break;
            }
          }
          case 26: {
            // bag
            input.readMessage(bag);
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000008;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeMessage(FieldNames.meta, meta);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeMessage(FieldNames.room, room);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeMessage(FieldNames.bag, bag);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      output.endObject();
    }

    @Override
    public StarTowerInfo mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 2394661: {
            if (input.isAtField(FieldNames.meta)) {
              if (!input.trySkipNullValue()) {
                input.readMessage(meta);
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 2553083: {
            if (input.isAtField(FieldNames.room)) {
              if (!input.trySkipNullValue()) {
                input.readMessage(room);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 66536: {
            if (input.isAtField(FieldNames.bag)) {
              if (!input.trySkipNullValue()) {
                input.readMessage(bag);
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000008;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public StarTowerInfo clone() {
      return new StarTowerInfo().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static StarTowerInfo parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new StarTowerInfo(), data).checkInitialized();
    }

    public static StarTowerInfo parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new StarTowerInfo(), input).checkInitialized();
    }

    public static StarTowerInfo parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new StarTowerInfo(), input).checkInitialized();
    }

    /**
     * @return factory for creating StarTowerInfo messages
     */
    public static MessageFactory<StarTowerInfo> getFactory() {
      return StarTowerInfoFactory.INSTANCE;
    }

    private enum StarTowerInfoFactory implements MessageFactory<StarTowerInfo> {
      INSTANCE;

      @Override
      public StarTowerInfo create() {
        return StarTowerInfo.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName meta = FieldName.forField("Meta");

      static final FieldName room = FieldName.forField("Room");

      static final FieldName bag = FieldName.forField("Bag");

      static final FieldName nextPackage = FieldName.forField("NextPackage");
    }
  }

  /**
   * Protobuf type {@code StarTowerMeta}
   */
  public static final class StarTowerMeta extends ProtoMessage<StarTowerMeta> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional uint64 BuildId = 16;</code>
     */
    private long buildId;

    /**
     * <code>optional uint32 Id = 1;</code>
     */
    private int id;

    /**
     * <code>optional uint32 CharHp = 2;</code>
     */
    private int charHp;

    /**
     * <code>optional uint32 TeamLevel = 3;</code>
     */
    private int teamLevel;

    /**
     * <code>optional uint32 TeamExp = 4;</code>
     */
    private int teamExp;

    /**
     * <code>optional uint32 DateLen = 7;</code>
     */
    private int dateLen;

    /**
     * <code>optional uint32 NPCInteractions = 10;</code>
     */
    private int nPCInteractions;

    /**
     * <code>optional uint32 ResurrectionCnt = 12;</code>
     */
    private int resurrectionCnt;

    /**
     * <code>optional uint32 TotalTime = 14;</code>
     */
    private int totalTime;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    /**
     * <code>optional string ClientData = 8;</code>
     */
    private final Utf8String clientData = Utf8String.newEmptyInstance();

    /**
     * <code>repeated uint64 TotalDamages = 15;</code>
     */
    private final RepeatedLong totalDamages = RepeatedLong.newEmptyInstance();

    /**
     * <code>repeated uint32 ActiveSecondaryIds = 9;</code>
     */
    private final RepeatedInt activeSecondaryIds = RepeatedInt.newEmptyInstance();

    /**
     * <code>repeated uint32 TowerGrowthNodes = 11;</code>
     */
    private final RepeatedInt towerGrowthNodes = RepeatedInt.newEmptyInstance();

    /**
     * <code>repeated .StarTowerChar Chars = 5;</code>
     */
    private final RepeatedMessage<StarTowerChar> chars = RepeatedMessage.newEmptyInstance(StarTowerChar.getFactory());

    /**
     * <code>repeated .StarTowerDisc Discs = 6;</code>
     */
    private final RepeatedMessage<StarTowerDisc> discs = RepeatedMessage.newEmptyInstance(StarTowerDisc.getFactory());

    private StarTowerMeta() {
    }

    /**
     * @return a new empty instance of {@code StarTowerMeta}
     */
    public static StarTowerMeta newInstance() {
      return new StarTowerMeta();
    }

    /**
     * <code>optional uint64 BuildId = 16;</code>
     * @return whether the buildId field is set
     */
    public boolean hasBuildId() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional uint64 BuildId = 16;</code>
     * @return this
     */
    public StarTowerMeta clearBuildId() {
      bitField0_ &= ~0x00000001;
      buildId = 0L;
      return this;
    }

    /**
     * <code>optional uint64 BuildId = 16;</code>
     * @return the buildId
     */
    public long getBuildId() {
      return buildId;
    }

    /**
     * <code>optional uint64 BuildId = 16;</code>
     * @param value the buildId to set
     * @return this
     */
    public StarTowerMeta setBuildId(final long value) {
      bitField0_ |= 0x00000001;
      buildId = value;
      return this;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @return whether the id field is set
     */
    public boolean hasId() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @return this
     */
    public StarTowerMeta clearId() {
      bitField0_ &= ~0x00000002;
      id = 0;
      return this;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @return the id
     */
    public int getId() {
      return id;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @param value the id to set
     * @return this
     */
    public StarTowerMeta setId(final int value) {
      bitField0_ |= 0x00000002;
      id = value;
      return this;
    }

    /**
     * <code>optional uint32 CharHp = 2;</code>
     * @return whether the charHp field is set
     */
    public boolean hasCharHp() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional uint32 CharHp = 2;</code>
     * @return this
     */
    public StarTowerMeta clearCharHp() {
      bitField0_ &= ~0x00000004;
      charHp = 0;
      return this;
    }

    /**
     * <code>optional uint32 CharHp = 2;</code>
     * @return the charHp
     */
    public int getCharHp() {
      return charHp;
    }

    /**
     * <code>optional uint32 CharHp = 2;</code>
     * @param value the charHp to set
     * @return this
     */
    public StarTowerMeta setCharHp(final int value) {
      bitField0_ |= 0x00000004;
      charHp = value;
      return this;
    }

    /**
     * <code>optional uint32 TeamLevel = 3;</code>
     * @return whether the teamLevel field is set
     */
    public boolean hasTeamLevel() {
      return (bitField0_ & 0x00000008) != 0;
    }

    /**
     * <code>optional uint32 TeamLevel = 3;</code>
     * @return this
     */
    public StarTowerMeta clearTeamLevel() {
      bitField0_ &= ~0x00000008;
      teamLevel = 0;
      return this;
    }

    /**
     * <code>optional uint32 TeamLevel = 3;</code>
     * @return the teamLevel
     */
    public int getTeamLevel() {
      return teamLevel;
    }

    /**
     * <code>optional uint32 TeamLevel = 3;</code>
     * @param value the teamLevel to set
     * @return this
     */
    public StarTowerMeta setTeamLevel(final int value) {
      bitField0_ |= 0x00000008;
      teamLevel = value;
      return this;
    }

    /**
     * <code>optional uint32 TeamExp = 4;</code>
     * @return whether the teamExp field is set
     */
    public boolean hasTeamExp() {
      return (bitField0_ & 0x00000010) != 0;
    }

    /**
     * <code>optional uint32 TeamExp = 4;</code>
     * @return this
     */
    public StarTowerMeta clearTeamExp() {
      bitField0_ &= ~0x00000010;
      teamExp = 0;
      return this;
    }

    /**
     * <code>optional uint32 TeamExp = 4;</code>
     * @return the teamExp
     */
    public int getTeamExp() {
      return teamExp;
    }

    /**
     * <code>optional uint32 TeamExp = 4;</code>
     * @param value the teamExp to set
     * @return this
     */
    public StarTowerMeta setTeamExp(final int value) {
      bitField0_ |= 0x00000010;
      teamExp = value;
      return this;
    }

    /**
     * <code>optional uint32 DateLen = 7;</code>
     * @return whether the dateLen field is set
     */
    public boolean hasDateLen() {
      return (bitField0_ & 0x00000020) != 0;
    }

    /**
     * <code>optional uint32 DateLen = 7;</code>
     * @return this
     */
    public StarTowerMeta clearDateLen() {
      bitField0_ &= ~0x00000020;
      dateLen = 0;
      return this;
    }

    /**
     * <code>optional uint32 DateLen = 7;</code>
     * @return the dateLen
     */
    public int getDateLen() {
      return dateLen;
    }

    /**
     * <code>optional uint32 DateLen = 7;</code>
     * @param value the dateLen to set
     * @return this
     */
    public StarTowerMeta setDateLen(final int value) {
      bitField0_ |= 0x00000020;
      dateLen = value;
      return this;
    }

    /**
     * <code>optional uint32 NPCInteractions = 10;</code>
     * @return whether the nPCInteractions field is set
     */
    public boolean hasNPCInteractions() {
      return (bitField0_ & 0x00000040) != 0;
    }

    /**
     * <code>optional uint32 NPCInteractions = 10;</code>
     * @return this
     */
    public StarTowerMeta clearNPCInteractions() {
      bitField0_ &= ~0x00000040;
      nPCInteractions = 0;
      return this;
    }

    /**
     * <code>optional uint32 NPCInteractions = 10;</code>
     * @return the nPCInteractions
     */
    public int getNPCInteractions() {
      return nPCInteractions;
    }

    /**
     * <code>optional uint32 NPCInteractions = 10;</code>
     * @param value the nPCInteractions to set
     * @return this
     */
    public StarTowerMeta setNPCInteractions(final int value) {
      bitField0_ |= 0x00000040;
      nPCInteractions = value;
      return this;
    }

    /**
     * <code>optional uint32 ResurrectionCnt = 12;</code>
     * @return whether the resurrectionCnt field is set
     */
    public boolean hasResurrectionCnt() {
      return (bitField0_ & 0x00000080) != 0;
    }

    /**
     * <code>optional uint32 ResurrectionCnt = 12;</code>
     * @return this
     */
    public StarTowerMeta clearResurrectionCnt() {
      bitField0_ &= ~0x00000080;
      resurrectionCnt = 0;
      return this;
    }

    /**
     * <code>optional uint32 ResurrectionCnt = 12;</code>
     * @return the resurrectionCnt
     */
    public int getResurrectionCnt() {
      return resurrectionCnt;
    }

    /**
     * <code>optional uint32 ResurrectionCnt = 12;</code>
     * @param value the resurrectionCnt to set
     * @return this
     */
    public StarTowerMeta setResurrectionCnt(final int value) {
      bitField0_ |= 0x00000080;
      resurrectionCnt = value;
      return this;
    }

    /**
     * <code>optional uint32 TotalTime = 14;</code>
     * @return whether the totalTime field is set
     */
    public boolean hasTotalTime() {
      return (bitField0_ & 0x00000100) != 0;
    }

    /**
     * <code>optional uint32 TotalTime = 14;</code>
     * @return this
     */
    public StarTowerMeta clearTotalTime() {
      bitField0_ &= ~0x00000100;
      totalTime = 0;
      return this;
    }

    /**
     * <code>optional uint32 TotalTime = 14;</code>
     * @return the totalTime
     */
    public int getTotalTime() {
      return totalTime;
    }

    /**
     * <code>optional uint32 TotalTime = 14;</code>
     * @param value the totalTime to set
     * @return this
     */
    public StarTowerMeta setTotalTime(final int value) {
      bitField0_ |= 0x00000100;
      totalTime = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000200) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public StarTowerMeta clearNextPackage() {
      bitField0_ &= ~0x00000200;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000200;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public StarTowerMeta addNextPackage(final byte value) {
      bitField0_ |= 0x00000200;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public StarTowerMeta addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000200;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public StarTowerMeta setNextPackage(final byte... values) {
      bitField0_ |= 0x00000200;
      nextPackage.copyFrom(values);
      return this;
    }

    /**
     * <code>optional string ClientData = 8;</code>
     * @return whether the clientData field is set
     */
    public boolean hasClientData() {
      return (bitField0_ & 0x00000400) != 0;
    }

    /**
     * <code>optional string ClientData = 8;</code>
     * @return this
     */
    public StarTowerMeta clearClientData() {
      bitField0_ &= ~0x00000400;
      clientData.clear();
      return this;
    }

    /**
     * <code>optional string ClientData = 8;</code>
     * @return the clientData
     */
    public String getClientData() {
      return clientData.getString();
    }

    /**
     * <code>optional string ClientData = 8;</code>
     * @return internal {@code Utf8String} representation of clientData for reading
     */
    public Utf8String getClientDataBytes() {
      return this.clientData;
    }

    /**
     * <code>optional string ClientData = 8;</code>
     * @return internal {@code Utf8String} representation of clientData for modifications
     */
    public Utf8String getMutableClientDataBytes() {
      bitField0_ |= 0x00000400;
      return this.clientData;
    }

    /**
     * <code>optional string ClientData = 8;</code>
     * @param value the clientData to set
     * @return this
     */
    public StarTowerMeta setClientData(final CharSequence value) {
      bitField0_ |= 0x00000400;
      clientData.copyFrom(value);
      return this;
    }

    /**
     * <code>optional string ClientData = 8;</code>
     * @param value the clientData to set
     * @return this
     */
    public StarTowerMeta setClientData(final Utf8String value) {
      bitField0_ |= 0x00000400;
      clientData.copyFrom(value);
      return this;
    }

    /**
     * <code>repeated uint64 TotalDamages = 15;</code>
     * @return whether the totalDamages field is set
     */
    public boolean hasTotalDamages() {
      return (bitField0_ & 0x00000800) != 0;
    }

    /**
     * <code>repeated uint64 TotalDamages = 15;</code>
     * @return this
     */
    public StarTowerMeta clearTotalDamages() {
      bitField0_ &= ~0x00000800;
      totalDamages.clear();
      return this;
    }

    /**
     * <code>repeated uint64 TotalDamages = 15;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableTotalDamages()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedLong getTotalDamages() {
      return totalDamages;
    }

    /**
     * <code>repeated uint64 TotalDamages = 15;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedLong getMutableTotalDamages() {
      bitField0_ |= 0x00000800;
      return totalDamages;
    }

    /**
     * <code>repeated uint64 TotalDamages = 15;</code>
     * @param value the totalDamages to add
     * @return this
     */
    public StarTowerMeta addTotalDamages(final long value) {
      bitField0_ |= 0x00000800;
      totalDamages.add(value);
      return this;
    }

    /**
     * <code>repeated uint64 TotalDamages = 15;</code>
     * @param values the totalDamages to add
     * @return this
     */
    public StarTowerMeta addAllTotalDamages(final long... values) {
      bitField0_ |= 0x00000800;
      totalDamages.addAll(values);
      return this;
    }

    /**
     * <code>repeated uint32 ActiveSecondaryIds = 9;</code>
     * @return whether the activeSecondaryIds field is set
     */
    public boolean hasActiveSecondaryIds() {
      return (bitField0_ & 0x00001000) != 0;
    }

    /**
     * <code>repeated uint32 ActiveSecondaryIds = 9;</code>
     * @return this
     */
    public StarTowerMeta clearActiveSecondaryIds() {
      bitField0_ &= ~0x00001000;
      activeSecondaryIds.clear();
      return this;
    }

    /**
     * <code>repeated uint32 ActiveSecondaryIds = 9;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableActiveSecondaryIds()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedInt getActiveSecondaryIds() {
      return activeSecondaryIds;
    }

    /**
     * <code>repeated uint32 ActiveSecondaryIds = 9;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedInt getMutableActiveSecondaryIds() {
      bitField0_ |= 0x00001000;
      return activeSecondaryIds;
    }

    /**
     * <code>repeated uint32 ActiveSecondaryIds = 9;</code>
     * @param value the activeSecondaryIds to add
     * @return this
     */
    public StarTowerMeta addActiveSecondaryIds(final int value) {
      bitField0_ |= 0x00001000;
      activeSecondaryIds.add(value);
      return this;
    }

    /**
     * <code>repeated uint32 ActiveSecondaryIds = 9;</code>
     * @param values the activeSecondaryIds to add
     * @return this
     */
    public StarTowerMeta addAllActiveSecondaryIds(final int... values) {
      bitField0_ |= 0x00001000;
      activeSecondaryIds.addAll(values);
      return this;
    }

    /**
     * <code>repeated uint32 TowerGrowthNodes = 11;</code>
     * @return whether the towerGrowthNodes field is set
     */
    public boolean hasTowerGrowthNodes() {
      return (bitField0_ & 0x00002000) != 0;
    }

    /**
     * <code>repeated uint32 TowerGrowthNodes = 11;</code>
     * @return this
     */
    public StarTowerMeta clearTowerGrowthNodes() {
      bitField0_ &= ~0x00002000;
      towerGrowthNodes.clear();
      return this;
    }

    /**
     * <code>repeated uint32 TowerGrowthNodes = 11;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableTowerGrowthNodes()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedInt getTowerGrowthNodes() {
      return towerGrowthNodes;
    }

    /**
     * <code>repeated uint32 TowerGrowthNodes = 11;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedInt getMutableTowerGrowthNodes() {
      bitField0_ |= 0x00002000;
      return towerGrowthNodes;
    }

    /**
     * <code>repeated uint32 TowerGrowthNodes = 11;</code>
     * @param value the towerGrowthNodes to add
     * @return this
     */
    public StarTowerMeta addTowerGrowthNodes(final int value) {
      bitField0_ |= 0x00002000;
      towerGrowthNodes.add(value);
      return this;
    }

    /**
     * <code>repeated uint32 TowerGrowthNodes = 11;</code>
     * @param values the towerGrowthNodes to add
     * @return this
     */
    public StarTowerMeta addAllTowerGrowthNodes(final int... values) {
      bitField0_ |= 0x00002000;
      towerGrowthNodes.addAll(values);
      return this;
    }

    /**
     * <code>repeated .StarTowerChar Chars = 5;</code>
     * @return whether the chars field is set
     */
    public boolean hasChars() {
      return (bitField0_ & 0x00004000) != 0;
    }

    /**
     * <code>repeated .StarTowerChar Chars = 5;</code>
     * @return this
     */
    public StarTowerMeta clearChars() {
      bitField0_ &= ~0x00004000;
      chars.clear();
      return this;
    }

    /**
     * <code>repeated .StarTowerChar Chars = 5;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableChars()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<StarTowerChar> getChars() {
      return chars;
    }

    /**
     * <code>repeated .StarTowerChar Chars = 5;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<StarTowerChar> getMutableChars() {
      bitField0_ |= 0x00004000;
      return chars;
    }

    /**
     * <code>repeated .StarTowerChar Chars = 5;</code>
     * @param value the chars to add
     * @return this
     */
    public StarTowerMeta addChars(final StarTowerChar value) {
      bitField0_ |= 0x00004000;
      chars.add(value);
      return this;
    }

    /**
     * <code>repeated .StarTowerChar Chars = 5;</code>
     * @param values the chars to add
     * @return this
     */
    public StarTowerMeta addAllChars(final StarTowerChar... values) {
      bitField0_ |= 0x00004000;
      chars.addAll(values);
      return this;
    }

    /**
     * <code>repeated .StarTowerDisc Discs = 6;</code>
     * @return whether the discs field is set
     */
    public boolean hasDiscs() {
      return (bitField0_ & 0x00008000) != 0;
    }

    /**
     * <code>repeated .StarTowerDisc Discs = 6;</code>
     * @return this
     */
    public StarTowerMeta clearDiscs() {
      bitField0_ &= ~0x00008000;
      discs.clear();
      return this;
    }

    /**
     * <code>repeated .StarTowerDisc Discs = 6;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableDiscs()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<StarTowerDisc> getDiscs() {
      return discs;
    }

    /**
     * <code>repeated .StarTowerDisc Discs = 6;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<StarTowerDisc> getMutableDiscs() {
      bitField0_ |= 0x00008000;
      return discs;
    }

    /**
     * <code>repeated .StarTowerDisc Discs = 6;</code>
     * @param value the discs to add
     * @return this
     */
    public StarTowerMeta addDiscs(final StarTowerDisc value) {
      bitField0_ |= 0x00008000;
      discs.add(value);
      return this;
    }

    /**
     * <code>repeated .StarTowerDisc Discs = 6;</code>
     * @param values the discs to add
     * @return this
     */
    public StarTowerMeta addAllDiscs(final StarTowerDisc... values) {
      bitField0_ |= 0x00008000;
      discs.addAll(values);
      return this;
    }

    @Override
    public StarTowerMeta copyFrom(final StarTowerMeta other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        buildId = other.buildId;
        id = other.id;
        charHp = other.charHp;
        teamLevel = other.teamLevel;
        teamExp = other.teamExp;
        dateLen = other.dateLen;
        nPCInteractions = other.nPCInteractions;
        resurrectionCnt = other.resurrectionCnt;
        totalTime = other.totalTime;
        nextPackage.copyFrom(other.nextPackage);
        clientData.copyFrom(other.clientData);
        totalDamages.copyFrom(other.totalDamages);
        activeSecondaryIds.copyFrom(other.activeSecondaryIds);
        towerGrowthNodes.copyFrom(other.towerGrowthNodes);
        chars.copyFrom(other.chars);
        discs.copyFrom(other.discs);
      }
      return this;
    }

    @Override
    public StarTowerMeta mergeFrom(final StarTowerMeta other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasBuildId()) {
        setBuildId(other.buildId);
      }
      if (other.hasId()) {
        setId(other.id);
      }
      if (other.hasCharHp()) {
        setCharHp(other.charHp);
      }
      if (other.hasTeamLevel()) {
        setTeamLevel(other.teamLevel);
      }
      if (other.hasTeamExp()) {
        setTeamExp(other.teamExp);
      }
      if (other.hasDateLen()) {
        setDateLen(other.dateLen);
      }
      if (other.hasNPCInteractions()) {
        setNPCInteractions(other.nPCInteractions);
      }
      if (other.hasResurrectionCnt()) {
        setResurrectionCnt(other.resurrectionCnt);
      }
      if (other.hasTotalTime()) {
        setTotalTime(other.totalTime);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      if (other.hasClientData()) {
        getMutableClientDataBytes().copyFrom(other.clientData);
      }
      if (other.hasTotalDamages()) {
        getMutableTotalDamages().addAll(other.totalDamages);
      }
      if (other.hasActiveSecondaryIds()) {
        getMutableActiveSecondaryIds().addAll(other.activeSecondaryIds);
      }
      if (other.hasTowerGrowthNodes()) {
        getMutableTowerGrowthNodes().addAll(other.towerGrowthNodes);
      }
      if (other.hasChars()) {
        getMutableChars().addAll(other.chars);
      }
      if (other.hasDiscs()) {
        getMutableDiscs().addAll(other.discs);
      }
      return this;
    }

    @Override
    public StarTowerMeta clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      buildId = 0L;
      id = 0;
      charHp = 0;
      teamLevel = 0;
      teamExp = 0;
      dateLen = 0;
      nPCInteractions = 0;
      resurrectionCnt = 0;
      totalTime = 0;
      nextPackage.clear();
      clientData.clear();
      totalDamages.clear();
      activeSecondaryIds.clear();
      towerGrowthNodes.clear();
      chars.clear();
      discs.clear();
      return this;
    }

    @Override
    public StarTowerMeta clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      clientData.clear();
      totalDamages.clear();
      activeSecondaryIds.clear();
      towerGrowthNodes.clear();
      chars.clearQuick();
      discs.clearQuick();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof StarTowerMeta)) {
        return false;
      }
      StarTowerMeta other = (StarTowerMeta) o;
      return bitField0_ == other.bitField0_
        && (!hasBuildId() || buildId == other.buildId)
        && (!hasId() || id == other.id)
        && (!hasCharHp() || charHp == other.charHp)
        && (!hasTeamLevel() || teamLevel == other.teamLevel)
        && (!hasTeamExp() || teamExp == other.teamExp)
        && (!hasDateLen() || dateLen == other.dateLen)
        && (!hasNPCInteractions() || nPCInteractions == other.nPCInteractions)
        && (!hasResurrectionCnt() || resurrectionCnt == other.resurrectionCnt)
        && (!hasTotalTime() || totalTime == other.totalTime)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage))
        && (!hasClientData() || clientData.equals(other.clientData))
        && (!hasTotalDamages() || totalDamages.equals(other.totalDamages))
        && (!hasActiveSecondaryIds() || activeSecondaryIds.equals(other.activeSecondaryIds))
        && (!hasTowerGrowthNodes() || towerGrowthNodes.equals(other.towerGrowthNodes))
        && (!hasChars() || chars.equals(other.chars))
        && (!hasDiscs() || discs.equals(other.discs));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawLittleEndian16((short) 384);
        output.writeUInt64NoTag(buildId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt32NoTag(id);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawByte((byte) 16);
        output.writeUInt32NoTag(charHp);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeRawByte((byte) 24);
        output.writeUInt32NoTag(teamLevel);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        output.writeRawByte((byte) 32);
        output.writeUInt32NoTag(teamExp);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        output.writeRawByte((byte) 56);
        output.writeUInt32NoTag(dateLen);
      }
      if ((bitField0_ & 0x00000040) != 0) {
        output.writeRawByte((byte) 80);
        output.writeUInt32NoTag(nPCInteractions);
      }
      if ((bitField0_ & 0x00000080) != 0) {
        output.writeRawByte((byte) 96);
        output.writeUInt32NoTag(resurrectionCnt);
      }
      if ((bitField0_ & 0x00000100) != 0) {
        output.writeRawByte((byte) 112);
        output.writeUInt32NoTag(totalTime);
      }
      if ((bitField0_ & 0x00000200) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000400) != 0) {
        output.writeRawByte((byte) 66);
        output.writeStringNoTag(clientData);
      }
      if ((bitField0_ & 0x00000800) != 0) {
        for (int i = 0; i < totalDamages.length(); i++) {
          output.writeRawByte((byte) 120);
          output.writeUInt64NoTag(totalDamages.array()[i]);
        }
      }
      if ((bitField0_ & 0x00001000) != 0) {
        for (int i = 0; i < activeSecondaryIds.length(); i++) {
          output.writeRawByte((byte) 72);
          output.writeUInt32NoTag(activeSecondaryIds.array()[i]);
        }
      }
      if ((bitField0_ & 0x00002000) != 0) {
        for (int i = 0; i < towerGrowthNodes.length(); i++) {
          output.writeRawByte((byte) 88);
          output.writeUInt32NoTag(towerGrowthNodes.array()[i]);
        }
      }
      if ((bitField0_ & 0x00004000) != 0) {
        for (int i = 0; i < chars.length(); i++) {
          output.writeRawByte((byte) 42);
          output.writeMessageNoTag(chars.get(i));
        }
      }
      if ((bitField0_ & 0x00008000) != 0) {
        for (int i = 0; i < discs.length(); i++) {
          output.writeRawByte((byte) 50);
          output.writeMessageNoTag(discs.get(i));
        }
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 2 + ProtoSink.computeUInt64SizeNoTag(buildId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(id);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(charHp);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(teamLevel);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(teamExp);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(dateLen);
      }
      if ((bitField0_ & 0x00000040) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(nPCInteractions);
      }
      if ((bitField0_ & 0x00000080) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(resurrectionCnt);
      }
      if ((bitField0_ & 0x00000100) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(totalTime);
      }
      if ((bitField0_ & 0x00000200) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000400) != 0) {
        size += 1 + ProtoSink.computeStringSizeNoTag(clientData);
      }
      if ((bitField0_ & 0x00000800) != 0) {
        size += (1 * totalDamages.length()) + ProtoSink.computeRepeatedUInt64SizeNoTag(totalDamages);
      }
      if ((bitField0_ & 0x00001000) != 0) {
        size += (1 * activeSecondaryIds.length()) + ProtoSink.computeRepeatedUInt32SizeNoTag(activeSecondaryIds);
      }
      if ((bitField0_ & 0x00002000) != 0) {
        size += (1 * towerGrowthNodes.length()) + ProtoSink.computeRepeatedUInt32SizeNoTag(towerGrowthNodes);
      }
      if ((bitField0_ & 0x00004000) != 0) {
        size += (1 * chars.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(chars);
      }
      if ((bitField0_ & 0x00008000) != 0) {
        size += (1 * discs.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(discs);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public StarTowerMeta mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 128: {
            // buildId
            buildId = input.readUInt64();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 8) {
              break;
            }
          }
          case 8: {
            // id
            id = input.readUInt32();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 16) {
              break;
            }
          }
          case 16: {
            // charHp
            charHp = input.readUInt32();
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 24) {
              break;
            }
          }
          case 24: {
            // teamLevel
            teamLevel = input.readUInt32();
            bitField0_ |= 0x00000008;
            tag = input.readTag();
            if (tag != 32) {
              break;
            }
          }
          case 32: {
            // teamExp
            teamExp = input.readUInt32();
            bitField0_ |= 0x00000010;
            tag = input.readTag();
            if (tag != 56) {
              break;
            }
          }
          case 56: {
            // dateLen
            dateLen = input.readUInt32();
            bitField0_ |= 0x00000020;
            tag = input.readTag();
            if (tag != 80) {
              break;
            }
          }
          case 80: {
            // nPCInteractions
            nPCInteractions = input.readUInt32();
            bitField0_ |= 0x00000040;
            tag = input.readTag();
            if (tag != 96) {
              break;
            }
          }
          case 96: {
            // resurrectionCnt
            resurrectionCnt = input.readUInt32();
            bitField0_ |= 0x00000080;
            tag = input.readTag();
            if (tag != 112) {
              break;
            }
          }
          case 112: {
            // totalTime
            totalTime = input.readUInt32();
            bitField0_ |= 0x00000100;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000200;
            tag = input.readTag();
            if (tag != 66) {
              break;
            }
          }
          case 66: {
            // clientData
            input.readString(clientData);
            bitField0_ |= 0x00000400;
            tag = input.readTag();
            if (tag != 122) {
              break;
            }
          }
          case 122: {
            // totalDamages [packed=true]
            input.readPackedUInt64(totalDamages, tag);
            bitField0_ |= 0x00000800;
            tag = input.readTag();
            if (tag != 74) {
              break;
            }
          }
          case 74: {
            // activeSecondaryIds [packed=true]
            input.readPackedUInt32(activeSecondaryIds, tag);
            bitField0_ |= 0x00001000;
            tag = input.readTag();
            if (tag != 90) {
              break;
            }
          }
          case 90: {
            // towerGrowthNodes [packed=true]
            input.readPackedUInt32(towerGrowthNodes, tag);
            bitField0_ |= 0x00002000;
            tag = input.readTag();
            if (tag != 42) {
              break;
            }
          }
          case 42: {
            // chars
            tag = input.readRepeatedMessage(chars, tag);
            bitField0_ |= 0x00004000;
            if (tag != 50) {
              break;
            }
          }
          case 50: {
            // discs
            tag = input.readRepeatedMessage(discs, tag);
            bitField0_ |= 0x00008000;
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
          case 120: {
            // totalDamages [packed=false]
            tag = input.readRepeatedUInt64(totalDamages, tag);
            bitField0_ |= 0x00000800;
            break;
          }
          case 72: {
            // activeSecondaryIds [packed=false]
            tag = input.readRepeatedUInt32(activeSecondaryIds, tag);
            bitField0_ |= 0x00001000;
            break;
          }
          case 88: {
            // towerGrowthNodes [packed=false]
            tag = input.readRepeatedUInt32(towerGrowthNodes, tag);
            bitField0_ |= 0x00002000;
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeUInt64(FieldNames.buildId, buildId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeUInt32(FieldNames.id, id);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeUInt32(FieldNames.charHp, charHp);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeUInt32(FieldNames.teamLevel, teamLevel);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        output.writeUInt32(FieldNames.teamExp, teamExp);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        output.writeUInt32(FieldNames.dateLen, dateLen);
      }
      if ((bitField0_ & 0x00000040) != 0) {
        output.writeUInt32(FieldNames.nPCInteractions, nPCInteractions);
      }
      if ((bitField0_ & 0x00000080) != 0) {
        output.writeUInt32(FieldNames.resurrectionCnt, resurrectionCnt);
      }
      if ((bitField0_ & 0x00000100) != 0) {
        output.writeUInt32(FieldNames.totalTime, totalTime);
      }
      if ((bitField0_ & 0x00000200) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      if ((bitField0_ & 0x00000400) != 0) {
        output.writeString(FieldNames.clientData, clientData);
      }
      if ((bitField0_ & 0x00000800) != 0) {
        output.writeRepeatedUInt64(FieldNames.totalDamages, totalDamages);
      }
      if ((bitField0_ & 0x00001000) != 0) {
        output.writeRepeatedUInt32(FieldNames.activeSecondaryIds, activeSecondaryIds);
      }
      if ((bitField0_ & 0x00002000) != 0) {
        output.writeRepeatedUInt32(FieldNames.towerGrowthNodes, towerGrowthNodes);
      }
      if ((bitField0_ & 0x00004000) != 0) {
        output.writeRepeatedMessage(FieldNames.chars, chars);
      }
      if ((bitField0_ & 0x00008000) != 0) {
        output.writeRepeatedMessage(FieldNames.discs, discs);
      }
      output.endObject();
    }

    @Override
    public StarTowerMeta mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 1895597065: {
            if (input.isAtField(FieldNames.buildId)) {
              if (!input.trySkipNullValue()) {
                buildId = input.readUInt64();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 2363: {
            if (input.isAtField(FieldNames.id)) {
              if (!input.trySkipNullValue()) {
                id = input.readUInt32();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 2017200926: {
            if (input.isAtField(FieldNames.charHp)) {
              if (!input.trySkipNullValue()) {
                charHp = input.readUInt32();
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 1810266887: {
            if (input.isAtField(FieldNames.teamLevel)) {
              if (!input.trySkipNullValue()) {
                teamLevel = input.readUInt32();
                bitField0_ |= 0x00000008;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 225341024: {
            if (input.isAtField(FieldNames.teamExp)) {
              if (!input.trySkipNullValue()) {
                teamExp = input.readUInt32();
                bitField0_ |= 0x00000010;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1187017881: {
            if (input.isAtField(FieldNames.dateLen)) {
              if (!input.trySkipNullValue()) {
                dateLen = input.readUInt32();
                bitField0_ |= 0x00000020;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1146200574: {
            if (input.isAtField(FieldNames.nPCInteractions)) {
              if (!input.trySkipNullValue()) {
                nPCInteractions = input.readUInt32();
                bitField0_ |= 0x00000040;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 21242370: {
            if (input.isAtField(FieldNames.resurrectionCnt)) {
              if (!input.trySkipNullValue()) {
                resurrectionCnt = input.readUInt32();
                bitField0_ |= 0x00000080;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 1426685969: {
            if (input.isAtField(FieldNames.totalTime)) {
              if (!input.trySkipNullValue()) {
                totalTime = input.readUInt32();
                bitField0_ |= 0x00000100;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000200;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1199548875: {
            if (input.isAtField(FieldNames.clientData)) {
              if (!input.trySkipNullValue()) {
                input.readString(clientData);
                bitField0_ |= 0x00000400;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2138865888: {
            if (input.isAtField(FieldNames.totalDamages)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedUInt64(totalDamages);
                bitField0_ |= 0x00000800;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 1499070186: {
            if (input.isAtField(FieldNames.activeSecondaryIds)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedUInt32(activeSecondaryIds);
                bitField0_ |= 0x00001000;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -727074175: {
            if (input.isAtField(FieldNames.towerGrowthNodes)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedUInt32(towerGrowthNodes);
                bitField0_ |= 0x00002000;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 65071037: {
            if (input.isAtField(FieldNames.chars)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedMessage(chars);
                bitField0_ |= 0x00004000;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 66041182: {
            if (input.isAtField(FieldNames.discs)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedMessage(discs);
                bitField0_ |= 0x00008000;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public StarTowerMeta clone() {
      return new StarTowerMeta().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static StarTowerMeta parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new StarTowerMeta(), data).checkInitialized();
    }

    public static StarTowerMeta parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new StarTowerMeta(), input).checkInitialized();
    }

    public static StarTowerMeta parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new StarTowerMeta(), input).checkInitialized();
    }

    /**
     * @return factory for creating StarTowerMeta messages
     */
    public static MessageFactory<StarTowerMeta> getFactory() {
      return StarTowerMetaFactory.INSTANCE;
    }

    private enum StarTowerMetaFactory implements MessageFactory<StarTowerMeta> {
      INSTANCE;

      @Override
      public StarTowerMeta create() {
        return StarTowerMeta.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName buildId = FieldName.forField("BuildId");

      static final FieldName id = FieldName.forField("Id");

      static final FieldName charHp = FieldName.forField("CharHp");

      static final FieldName teamLevel = FieldName.forField("TeamLevel");

      static final FieldName teamExp = FieldName.forField("TeamExp");

      static final FieldName dateLen = FieldName.forField("DateLen");

      static final FieldName nPCInteractions = FieldName.forField("NPCInteractions");

      static final FieldName resurrectionCnt = FieldName.forField("ResurrectionCnt");

      static final FieldName totalTime = FieldName.forField("TotalTime");

      static final FieldName nextPackage = FieldName.forField("NextPackage");

      static final FieldName clientData = FieldName.forField("ClientData");

      static final FieldName totalDamages = FieldName.forField("TotalDamages");

      static final FieldName activeSecondaryIds = FieldName.forField("ActiveSecondaryIds");

      static final FieldName towerGrowthNodes = FieldName.forField("TowerGrowthNodes");

      static final FieldName chars = FieldName.forField("Chars");

      static final FieldName discs = FieldName.forField("Discs");
    }
  }

  /**
   * Protobuf type {@code StarTowerDisc}
   */
  public static final class StarTowerDisc extends ProtoMessage<StarTowerDisc> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional uint32 Id = 1;</code>
     */
    private int id;

    /**
     * <code>optional uint32 Level = 2;</code>
     */
    private int level;

    /**
     * <code>optional uint32 Phase = 3;</code>
     */
    private int phase;

    /**
     * <code>optional uint32 Star = 4;</code>
     */
    private int star;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    private StarTowerDisc() {
    }

    /**
     * @return a new empty instance of {@code StarTowerDisc}
     */
    public static StarTowerDisc newInstance() {
      return new StarTowerDisc();
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @return whether the id field is set
     */
    public boolean hasId() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @return this
     */
    public StarTowerDisc clearId() {
      bitField0_ &= ~0x00000001;
      id = 0;
      return this;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @return the id
     */
    public int getId() {
      return id;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @param value the id to set
     * @return this
     */
    public StarTowerDisc setId(final int value) {
      bitField0_ |= 0x00000001;
      id = value;
      return this;
    }

    /**
     * <code>optional uint32 Level = 2;</code>
     * @return whether the level field is set
     */
    public boolean hasLevel() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional uint32 Level = 2;</code>
     * @return this
     */
    public StarTowerDisc clearLevel() {
      bitField0_ &= ~0x00000002;
      level = 0;
      return this;
    }

    /**
     * <code>optional uint32 Level = 2;</code>
     * @return the level
     */
    public int getLevel() {
      return level;
    }

    /**
     * <code>optional uint32 Level = 2;</code>
     * @param value the level to set
     * @return this
     */
    public StarTowerDisc setLevel(final int value) {
      bitField0_ |= 0x00000002;
      level = value;
      return this;
    }

    /**
     * <code>optional uint32 Phase = 3;</code>
     * @return whether the phase field is set
     */
    public boolean hasPhase() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional uint32 Phase = 3;</code>
     * @return this
     */
    public StarTowerDisc clearPhase() {
      bitField0_ &= ~0x00000004;
      phase = 0;
      return this;
    }

    /**
     * <code>optional uint32 Phase = 3;</code>
     * @return the phase
     */
    public int getPhase() {
      return phase;
    }

    /**
     * <code>optional uint32 Phase = 3;</code>
     * @param value the phase to set
     * @return this
     */
    public StarTowerDisc setPhase(final int value) {
      bitField0_ |= 0x00000004;
      phase = value;
      return this;
    }

    /**
     * <code>optional uint32 Star = 4;</code>
     * @return whether the star field is set
     */
    public boolean hasStar() {
      return (bitField0_ & 0x00000008) != 0;
    }

    /**
     * <code>optional uint32 Star = 4;</code>
     * @return this
     */
    public StarTowerDisc clearStar() {
      bitField0_ &= ~0x00000008;
      star = 0;
      return this;
    }

    /**
     * <code>optional uint32 Star = 4;</code>
     * @return the star
     */
    public int getStar() {
      return star;
    }

    /**
     * <code>optional uint32 Star = 4;</code>
     * @param value the star to set
     * @return this
     */
    public StarTowerDisc setStar(final int value) {
      bitField0_ |= 0x00000008;
      star = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000010) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public StarTowerDisc clearNextPackage() {
      bitField0_ &= ~0x00000010;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000010;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public StarTowerDisc addNextPackage(final byte value) {
      bitField0_ |= 0x00000010;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public StarTowerDisc addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000010;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public StarTowerDisc setNextPackage(final byte... values) {
      bitField0_ |= 0x00000010;
      nextPackage.copyFrom(values);
      return this;
    }

    @Override
    public StarTowerDisc copyFrom(final StarTowerDisc other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        id = other.id;
        level = other.level;
        phase = other.phase;
        star = other.star;
        nextPackage.copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public StarTowerDisc mergeFrom(final StarTowerDisc other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasId()) {
        setId(other.id);
      }
      if (other.hasLevel()) {
        setLevel(other.level);
      }
      if (other.hasPhase()) {
        setPhase(other.phase);
      }
      if (other.hasStar()) {
        setStar(other.star);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public StarTowerDisc clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      id = 0;
      level = 0;
      phase = 0;
      star = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public StarTowerDisc clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof StarTowerDisc)) {
        return false;
      }
      StarTowerDisc other = (StarTowerDisc) o;
      return bitField0_ == other.bitField0_
        && (!hasId() || id == other.id)
        && (!hasLevel() || level == other.level)
        && (!hasPhase() || phase == other.phase)
        && (!hasStar() || star == other.star)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt32NoTag(id);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 16);
        output.writeUInt32NoTag(level);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawByte((byte) 24);
        output.writeUInt32NoTag(phase);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeRawByte((byte) 32);
        output.writeUInt32NoTag(star);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(id);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(level);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(phase);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(star);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public StarTowerDisc mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            // id
            id = input.readUInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 16) {
              break;
            }
          }
          case 16: {
            // level
            level = input.readUInt32();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 24) {
              break;
            }
          }
          case 24: {
            // phase
            phase = input.readUInt32();
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 32) {
              break;
            }
          }
          case 32: {
            // star
            star = input.readUInt32();
            bitField0_ |= 0x00000008;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000010;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeUInt32(FieldNames.id, id);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeUInt32(FieldNames.level, level);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeUInt32(FieldNames.phase, phase);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeUInt32(FieldNames.star, star);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      output.endObject();
    }

    @Override
    public StarTowerDisc mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 2363: {
            if (input.isAtField(FieldNames.id)) {
              if (!input.trySkipNullValue()) {
                id = input.readUInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 73313124: {
            if (input.isAtField(FieldNames.level)) {
              if (!input.trySkipNullValue()) {
                level = input.readUInt32();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 77076827: {
            if (input.isAtField(FieldNames.phase)) {
              if (!input.trySkipNullValue()) {
                phase = input.readUInt32();
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 2587250: {
            if (input.isAtField(FieldNames.star)) {
              if (!input.trySkipNullValue()) {
                star = input.readUInt32();
                bitField0_ |= 0x00000008;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000010;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public StarTowerDisc clone() {
      return new StarTowerDisc().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static StarTowerDisc parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new StarTowerDisc(), data).checkInitialized();
    }

    public static StarTowerDisc parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new StarTowerDisc(), input).checkInitialized();
    }

    public static StarTowerDisc parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new StarTowerDisc(), input).checkInitialized();
    }

    /**
     * @return factory for creating StarTowerDisc messages
     */
    public static MessageFactory<StarTowerDisc> getFactory() {
      return StarTowerDiscFactory.INSTANCE;
    }

    private enum StarTowerDiscFactory implements MessageFactory<StarTowerDisc> {
      INSTANCE;

      @Override
      public StarTowerDisc create() {
        return StarTowerDisc.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName id = FieldName.forField("Id");

      static final FieldName level = FieldName.forField("Level");

      static final FieldName phase = FieldName.forField("Phase");

      static final FieldName star = FieldName.forField("Star");

      static final FieldName nextPackage = FieldName.forField("NextPackage");
    }
  }

  /**
   * Protobuf type {@code StarTowerChar}
   */
  public static final class StarTowerChar extends ProtoMessage<StarTowerChar> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional uint32 Id = 1;</code>
     */
    private int id;

    /**
     * <code>optional uint32 Level = 3;</code>
     */
    private int level;

    /**
     * <code>optional uint32 AffinityLevel = 5;</code>
     */
    private int affinityLevel;

    /**
     * <code>optional uint32 Advance = 6;</code>
     */
    private int advance;

    /**
     * <code>optional bytes TalentNodes = 7;</code>
     */
    private final RepeatedByte talentNodes = RepeatedByte.newEmptyInstance();

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    /**
     * <code>repeated uint32 SkillLvs = 4;</code>
     */
    private final RepeatedInt skillLvs = RepeatedInt.newEmptyInstance();

    /**
     * <code>repeated .StarTowerCharGem Gems = 2;</code>
     */
    private final RepeatedMessage<StarTowerCharGem> gems = RepeatedMessage.newEmptyInstance(StarTowerCharGem.getFactory());

    private StarTowerChar() {
    }

    /**
     * @return a new empty instance of {@code StarTowerChar}
     */
    public static StarTowerChar newInstance() {
      return new StarTowerChar();
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @return whether the id field is set
     */
    public boolean hasId() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @return this
     */
    public StarTowerChar clearId() {
      bitField0_ &= ~0x00000001;
      id = 0;
      return this;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @return the id
     */
    public int getId() {
      return id;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @param value the id to set
     * @return this
     */
    public StarTowerChar setId(final int value) {
      bitField0_ |= 0x00000001;
      id = value;
      return this;
    }

    /**
     * <code>optional uint32 Level = 3;</code>
     * @return whether the level field is set
     */
    public boolean hasLevel() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional uint32 Level = 3;</code>
     * @return this
     */
    public StarTowerChar clearLevel() {
      bitField0_ &= ~0x00000002;
      level = 0;
      return this;
    }

    /**
     * <code>optional uint32 Level = 3;</code>
     * @return the level
     */
    public int getLevel() {
      return level;
    }

    /**
     * <code>optional uint32 Level = 3;</code>
     * @param value the level to set
     * @return this
     */
    public StarTowerChar setLevel(final int value) {
      bitField0_ |= 0x00000002;
      level = value;
      return this;
    }

    /**
     * <code>optional uint32 AffinityLevel = 5;</code>
     * @return whether the affinityLevel field is set
     */
    public boolean hasAffinityLevel() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional uint32 AffinityLevel = 5;</code>
     * @return this
     */
    public StarTowerChar clearAffinityLevel() {
      bitField0_ &= ~0x00000004;
      affinityLevel = 0;
      return this;
    }

    /**
     * <code>optional uint32 AffinityLevel = 5;</code>
     * @return the affinityLevel
     */
    public int getAffinityLevel() {
      return affinityLevel;
    }

    /**
     * <code>optional uint32 AffinityLevel = 5;</code>
     * @param value the affinityLevel to set
     * @return this
     */
    public StarTowerChar setAffinityLevel(final int value) {
      bitField0_ |= 0x00000004;
      affinityLevel = value;
      return this;
    }

    /**
     * <code>optional uint32 Advance = 6;</code>
     * @return whether the advance field is set
     */
    public boolean hasAdvance() {
      return (bitField0_ & 0x00000008) != 0;
    }

    /**
     * <code>optional uint32 Advance = 6;</code>
     * @return this
     */
    public StarTowerChar clearAdvance() {
      bitField0_ &= ~0x00000008;
      advance = 0;
      return this;
    }

    /**
     * <code>optional uint32 Advance = 6;</code>
     * @return the advance
     */
    public int getAdvance() {
      return advance;
    }

    /**
     * <code>optional uint32 Advance = 6;</code>
     * @param value the advance to set
     * @return this
     */
    public StarTowerChar setAdvance(final int value) {
      bitField0_ |= 0x00000008;
      advance = value;
      return this;
    }

    /**
     * <code>optional bytes TalentNodes = 7;</code>
     * @return whether the talentNodes field is set
     */
    public boolean hasTalentNodes() {
      return (bitField0_ & 0x00000010) != 0;
    }

    /**
     * <code>optional bytes TalentNodes = 7;</code>
     * @return this
     */
    public StarTowerChar clearTalentNodes() {
      bitField0_ &= ~0x00000010;
      talentNodes.clear();
      return this;
    }

    /**
     * <code>optional bytes TalentNodes = 7;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableTalentNodes()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getTalentNodes() {
      return talentNodes;
    }

    /**
     * <code>optional bytes TalentNodes = 7;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableTalentNodes() {
      bitField0_ |= 0x00000010;
      return talentNodes;
    }

    /**
     * <code>optional bytes TalentNodes = 7;</code>
     * @param value the talentNodes to add
     * @return this
     */
    public StarTowerChar addTalentNodes(final byte value) {
      bitField0_ |= 0x00000010;
      talentNodes.add(value);
      return this;
    }

    /**
     * <code>optional bytes TalentNodes = 7;</code>
     * @param values the talentNodes to add
     * @return this
     */
    public StarTowerChar addAllTalentNodes(final byte... values) {
      bitField0_ |= 0x00000010;
      talentNodes.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes TalentNodes = 7;</code>
     * @param values the talentNodes to set
     * @return this
     */
    public StarTowerChar setTalentNodes(final byte... values) {
      bitField0_ |= 0x00000010;
      talentNodes.copyFrom(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000020) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public StarTowerChar clearNextPackage() {
      bitField0_ &= ~0x00000020;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000020;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public StarTowerChar addNextPackage(final byte value) {
      bitField0_ |= 0x00000020;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public StarTowerChar addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000020;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public StarTowerChar setNextPackage(final byte... values) {
      bitField0_ |= 0x00000020;
      nextPackage.copyFrom(values);
      return this;
    }

    /**
     * <code>repeated uint32 SkillLvs = 4;</code>
     * @return whether the skillLvs field is set
     */
    public boolean hasSkillLvs() {
      return (bitField0_ & 0x00000040) != 0;
    }

    /**
     * <code>repeated uint32 SkillLvs = 4;</code>
     * @return this
     */
    public StarTowerChar clearSkillLvs() {
      bitField0_ &= ~0x00000040;
      skillLvs.clear();
      return this;
    }

    /**
     * <code>repeated uint32 SkillLvs = 4;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableSkillLvs()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedInt getSkillLvs() {
      return skillLvs;
    }

    /**
     * <code>repeated uint32 SkillLvs = 4;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedInt getMutableSkillLvs() {
      bitField0_ |= 0x00000040;
      return skillLvs;
    }

    /**
     * <code>repeated uint32 SkillLvs = 4;</code>
     * @param value the skillLvs to add
     * @return this
     */
    public StarTowerChar addSkillLvs(final int value) {
      bitField0_ |= 0x00000040;
      skillLvs.add(value);
      return this;
    }

    /**
     * <code>repeated uint32 SkillLvs = 4;</code>
     * @param values the skillLvs to add
     * @return this
     */
    public StarTowerChar addAllSkillLvs(final int... values) {
      bitField0_ |= 0x00000040;
      skillLvs.addAll(values);
      return this;
    }

    /**
     * <code>repeated .StarTowerCharGem Gems = 2;</code>
     * @return whether the gems field is set
     */
    public boolean hasGems() {
      return (bitField0_ & 0x00000080) != 0;
    }

    /**
     * <code>repeated .StarTowerCharGem Gems = 2;</code>
     * @return this
     */
    public StarTowerChar clearGems() {
      bitField0_ &= ~0x00000080;
      gems.clear();
      return this;
    }

    /**
     * <code>repeated .StarTowerCharGem Gems = 2;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableGems()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<StarTowerCharGem> getGems() {
      return gems;
    }

    /**
     * <code>repeated .StarTowerCharGem Gems = 2;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<StarTowerCharGem> getMutableGems() {
      bitField0_ |= 0x00000080;
      return gems;
    }

    /**
     * <code>repeated .StarTowerCharGem Gems = 2;</code>
     * @param value the gems to add
     * @return this
     */
    public StarTowerChar addGems(final StarTowerCharGem value) {
      bitField0_ |= 0x00000080;
      gems.add(value);
      return this;
    }

    /**
     * <code>repeated .StarTowerCharGem Gems = 2;</code>
     * @param values the gems to add
     * @return this
     */
    public StarTowerChar addAllGems(final StarTowerCharGem... values) {
      bitField0_ |= 0x00000080;
      gems.addAll(values);
      return this;
    }

    @Override
    public StarTowerChar copyFrom(final StarTowerChar other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        id = other.id;
        level = other.level;
        affinityLevel = other.affinityLevel;
        advance = other.advance;
        talentNodes.copyFrom(other.talentNodes);
        nextPackage.copyFrom(other.nextPackage);
        skillLvs.copyFrom(other.skillLvs);
        gems.copyFrom(other.gems);
      }
      return this;
    }

    @Override
    public StarTowerChar mergeFrom(final StarTowerChar other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasId()) {
        setId(other.id);
      }
      if (other.hasLevel()) {
        setLevel(other.level);
      }
      if (other.hasAffinityLevel()) {
        setAffinityLevel(other.affinityLevel);
      }
      if (other.hasAdvance()) {
        setAdvance(other.advance);
      }
      if (other.hasTalentNodes()) {
        getMutableTalentNodes().copyFrom(other.talentNodes);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      if (other.hasSkillLvs()) {
        getMutableSkillLvs().addAll(other.skillLvs);
      }
      if (other.hasGems()) {
        getMutableGems().addAll(other.gems);
      }
      return this;
    }

    @Override
    public StarTowerChar clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      id = 0;
      level = 0;
      affinityLevel = 0;
      advance = 0;
      talentNodes.clear();
      nextPackage.clear();
      skillLvs.clear();
      gems.clear();
      return this;
    }

    @Override
    public StarTowerChar clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      talentNodes.clear();
      nextPackage.clear();
      skillLvs.clear();
      gems.clearQuick();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof StarTowerChar)) {
        return false;
      }
      StarTowerChar other = (StarTowerChar) o;
      return bitField0_ == other.bitField0_
        && (!hasId() || id == other.id)
        && (!hasLevel() || level == other.level)
        && (!hasAffinityLevel() || affinityLevel == other.affinityLevel)
        && (!hasAdvance() || advance == other.advance)
        && (!hasTalentNodes() || talentNodes.equals(other.talentNodes))
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage))
        && (!hasSkillLvs() || skillLvs.equals(other.skillLvs))
        && (!hasGems() || gems.equals(other.gems));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt32NoTag(id);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 24);
        output.writeUInt32NoTag(level);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawByte((byte) 40);
        output.writeUInt32NoTag(affinityLevel);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeRawByte((byte) 48);
        output.writeUInt32NoTag(advance);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        output.writeRawByte((byte) 58);
        output.writeBytesNoTag(talentNodes);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000040) != 0) {
        for (int i = 0; i < skillLvs.length(); i++) {
          output.writeRawByte((byte) 32);
          output.writeUInt32NoTag(skillLvs.array()[i]);
        }
      }
      if ((bitField0_ & 0x00000080) != 0) {
        for (int i = 0; i < gems.length(); i++) {
          output.writeRawByte((byte) 18);
          output.writeMessageNoTag(gems.get(i));
        }
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(id);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(level);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(affinityLevel);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(advance);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        size += 1 + ProtoSink.computeBytesSizeNoTag(talentNodes);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000040) != 0) {
        size += (1 * skillLvs.length()) + ProtoSink.computeRepeatedUInt32SizeNoTag(skillLvs);
      }
      if ((bitField0_ & 0x00000080) != 0) {
        size += (1 * gems.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(gems);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public StarTowerChar mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            // id
            id = input.readUInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 24) {
              break;
            }
          }
          case 24: {
            // level
            level = input.readUInt32();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 40) {
              break;
            }
          }
          case 40: {
            // affinityLevel
            affinityLevel = input.readUInt32();
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 48) {
              break;
            }
          }
          case 48: {
            // advance
            advance = input.readUInt32();
            bitField0_ |= 0x00000008;
            tag = input.readTag();
            if (tag != 58) {
              break;
            }
          }
          case 58: {
            // talentNodes
            input.readBytes(talentNodes);
            bitField0_ |= 0x00000010;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000020;
            tag = input.readTag();
            if (tag != 34) {
              break;
            }
          }
          case 34: {
            // skillLvs [packed=true]
            input.readPackedUInt32(skillLvs, tag);
            bitField0_ |= 0x00000040;
            tag = input.readTag();
            if (tag != 18) {
              break;
            }
          }
          case 18: {
            // gems
            tag = input.readRepeatedMessage(gems, tag);
            bitField0_ |= 0x00000080;
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
          case 32: {
            // skillLvs [packed=false]
            tag = input.readRepeatedUInt32(skillLvs, tag);
            bitField0_ |= 0x00000040;
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeUInt32(FieldNames.id, id);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeUInt32(FieldNames.level, level);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeUInt32(FieldNames.affinityLevel, affinityLevel);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeUInt32(FieldNames.advance, advance);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        output.writeBytes(FieldNames.talentNodes, talentNodes);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      if ((bitField0_ & 0x00000040) != 0) {
        output.writeRepeatedUInt32(FieldNames.skillLvs, skillLvs);
      }
      if ((bitField0_ & 0x00000080) != 0) {
        output.writeRepeatedMessage(FieldNames.gems, gems);
      }
      output.endObject();
    }

    @Override
    public StarTowerChar mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 2363: {
            if (input.isAtField(FieldNames.id)) {
              if (!input.trySkipNullValue()) {
                id = input.readUInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 73313124: {
            if (input.isAtField(FieldNames.level)) {
              if (!input.trySkipNullValue()) {
                level = input.readUInt32();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 1094331164: {
            if (input.isAtField(FieldNames.affinityLevel)) {
              if (!input.trySkipNullValue()) {
                affinityLevel = input.readUInt32();
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 533086306: {
            if (input.isAtField(FieldNames.advance)) {
              if (!input.trySkipNullValue()) {
                advance = input.readUInt32();
                bitField0_ |= 0x00000008;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 2029178117: {
            if (input.isAtField(FieldNames.talentNodes)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(talentNodes);
                bitField0_ |= 0x00000010;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000020;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2087888840: {
            if (input.isAtField(FieldNames.skillLvs)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedUInt32(skillLvs);
                bitField0_ |= 0x00000040;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 2215716: {
            if (input.isAtField(FieldNames.gems)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedMessage(gems);
                bitField0_ |= 0x00000080;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public StarTowerChar clone() {
      return new StarTowerChar().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static StarTowerChar parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new StarTowerChar(), data).checkInitialized();
    }

    public static StarTowerChar parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new StarTowerChar(), input).checkInitialized();
    }

    public static StarTowerChar parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new StarTowerChar(), input).checkInitialized();
    }

    /**
     * @return factory for creating StarTowerChar messages
     */
    public static MessageFactory<StarTowerChar> getFactory() {
      return StarTowerCharFactory.INSTANCE;
    }

    private enum StarTowerCharFactory implements MessageFactory<StarTowerChar> {
      INSTANCE;

      @Override
      public StarTowerChar create() {
        return StarTowerChar.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName id = FieldName.forField("Id");

      static final FieldName level = FieldName.forField("Level");

      static final FieldName affinityLevel = FieldName.forField("AffinityLevel");

      static final FieldName advance = FieldName.forField("Advance");

      static final FieldName talentNodes = FieldName.forField("TalentNodes");

      static final FieldName nextPackage = FieldName.forField("NextPackage");

      static final FieldName skillLvs = FieldName.forField("SkillLvs");

      static final FieldName gems = FieldName.forField("Gems");
    }
  }

  /**
   * Protobuf type {@code StarTowerCharGem}
   */
  public static final class StarTowerCharGem extends ProtoMessage<StarTowerCharGem> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional uint32 SlotId = 2;</code>
     */
    private int slotId;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    /**
     * <code>repeated uint32 Attributes = 1;</code>
     */
    private final RepeatedInt attributes = RepeatedInt.newEmptyInstance();

    private StarTowerCharGem() {
    }

    /**
     * @return a new empty instance of {@code StarTowerCharGem}
     */
    public static StarTowerCharGem newInstance() {
      return new StarTowerCharGem();
    }

    /**
     * <code>optional uint32 SlotId = 2;</code>
     * @return whether the slotId field is set
     */
    public boolean hasSlotId() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional uint32 SlotId = 2;</code>
     * @return this
     */
    public StarTowerCharGem clearSlotId() {
      bitField0_ &= ~0x00000001;
      slotId = 0;
      return this;
    }

    /**
     * <code>optional uint32 SlotId = 2;</code>
     * @return the slotId
     */
    public int getSlotId() {
      return slotId;
    }

    /**
     * <code>optional uint32 SlotId = 2;</code>
     * @param value the slotId to set
     * @return this
     */
    public StarTowerCharGem setSlotId(final int value) {
      bitField0_ |= 0x00000001;
      slotId = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public StarTowerCharGem clearNextPackage() {
      bitField0_ &= ~0x00000002;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000002;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public StarTowerCharGem addNextPackage(final byte value) {
      bitField0_ |= 0x00000002;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public StarTowerCharGem addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000002;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public StarTowerCharGem setNextPackage(final byte... values) {
      bitField0_ |= 0x00000002;
      nextPackage.copyFrom(values);
      return this;
    }

    /**
     * <code>repeated uint32 Attributes = 1;</code>
     * @return whether the attributes field is set
     */
    public boolean hasAttributes() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>repeated uint32 Attributes = 1;</code>
     * @return this
     */
    public StarTowerCharGem clearAttributes() {
      bitField0_ &= ~0x00000004;
      attributes.clear();
      return this;
    }

    /**
     * <code>repeated uint32 Attributes = 1;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableAttributes()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedInt getAttributes() {
      return attributes;
    }

    /**
     * <code>repeated uint32 Attributes = 1;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedInt getMutableAttributes() {
      bitField0_ |= 0x00000004;
      return attributes;
    }

    /**
     * <code>repeated uint32 Attributes = 1;</code>
     * @param value the attributes to add
     * @return this
     */
    public StarTowerCharGem addAttributes(final int value) {
      bitField0_ |= 0x00000004;
      attributes.add(value);
      return this;
    }

    /**
     * <code>repeated uint32 Attributes = 1;</code>
     * @param values the attributes to add
     * @return this
     */
    public StarTowerCharGem addAllAttributes(final int... values) {
      bitField0_ |= 0x00000004;
      attributes.addAll(values);
      return this;
    }

    @Override
    public StarTowerCharGem copyFrom(final StarTowerCharGem other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        slotId = other.slotId;
        nextPackage.copyFrom(other.nextPackage);
        attributes.copyFrom(other.attributes);
      }
      return this;
    }

    @Override
    public StarTowerCharGem mergeFrom(final StarTowerCharGem other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasSlotId()) {
        setSlotId(other.slotId);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      if (other.hasAttributes()) {
        getMutableAttributes().addAll(other.attributes);
      }
      return this;
    }

    @Override
    public StarTowerCharGem clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      slotId = 0;
      nextPackage.clear();
      attributes.clear();
      return this;
    }

    @Override
    public StarTowerCharGem clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      attributes.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof StarTowerCharGem)) {
        return false;
      }
      StarTowerCharGem other = (StarTowerCharGem) o;
      return bitField0_ == other.bitField0_
        && (!hasSlotId() || slotId == other.slotId)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage))
        && (!hasAttributes() || attributes.equals(other.attributes));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 16);
        output.writeUInt32NoTag(slotId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        for (int i = 0; i < attributes.length(); i++) {
          output.writeRawByte((byte) 8);
          output.writeUInt32NoTag(attributes.array()[i]);
        }
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(slotId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += (1 * attributes.length()) + ProtoSink.computeRepeatedUInt32SizeNoTag(attributes);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public StarTowerCharGem mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 16: {
            // slotId
            slotId = input.readUInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 10) {
              break;
            }
          }
          case 10: {
            // attributes [packed=true]
            input.readPackedUInt32(attributes, tag);
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
          case 8: {
            // attributes [packed=false]
            tag = input.readRepeatedUInt32(attributes, tag);
            bitField0_ |= 0x00000004;
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeUInt32(FieldNames.slotId, slotId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRepeatedUInt32(FieldNames.attributes, attributes);
      }
      output.endObject();
    }

    @Override
    public StarTowerCharGem mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case -1815586855: {
            if (input.isAtField(FieldNames.slotId)) {
              if (!input.trySkipNullValue()) {
                slotId = input.readUInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1895856777: {
            if (input.isAtField(FieldNames.attributes)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedUInt32(attributes);
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public StarTowerCharGem clone() {
      return new StarTowerCharGem().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static StarTowerCharGem parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new StarTowerCharGem(), data).checkInitialized();
    }

    public static StarTowerCharGem parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new StarTowerCharGem(), input).checkInitialized();
    }

    public static StarTowerCharGem parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new StarTowerCharGem(), input).checkInitialized();
    }

    /**
     * @return factory for creating StarTowerCharGem messages
     */
    public static MessageFactory<StarTowerCharGem> getFactory() {
      return StarTowerCharGemFactory.INSTANCE;
    }

    private enum StarTowerCharGemFactory implements MessageFactory<StarTowerCharGem> {
      INSTANCE;

      @Override
      public StarTowerCharGem create() {
        return StarTowerCharGem.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName slotId = FieldName.forField("SlotId");

      static final FieldName nextPackage = FieldName.forField("NextPackage");

      static final FieldName attributes = FieldName.forField("Attributes");
    }
  }

  /**
   * Protobuf type {@code StarTowerBag}
   */
  public static final class StarTowerBag extends ProtoMessage<StarTowerBag> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    /**
     * <code>repeated .FateCardInfo FateCard = 1;</code>
     */
    private final RepeatedMessage<FateCardInfo> fateCard = RepeatedMessage.newEmptyInstance(FateCardInfo.getFactory());

    /**
     * <code>repeated .PotentialInfo Potentials = 2;</code>
     */
    private final RepeatedMessage<PotentialInfo> potentials = RepeatedMessage.newEmptyInstance(PotentialInfo.getFactory());

    /**
     * <code>repeated .TowerItemInfo Items = 3;</code>
     */
    private final RepeatedMessage<TowerItemInfo> items = RepeatedMessage.newEmptyInstance(TowerItemInfo.getFactory());

    /**
     * <code>repeated .TowerResInfo Res = 4;</code>
     */
    private final RepeatedMessage<TowerResInfo> res = RepeatedMessage.newEmptyInstance(TowerResInfo.getFactory());

    private StarTowerBag() {
    }

    /**
     * @return a new empty instance of {@code StarTowerBag}
     */
    public static StarTowerBag newInstance() {
      return new StarTowerBag();
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public StarTowerBag clearNextPackage() {
      bitField0_ &= ~0x00000001;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000001;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public StarTowerBag addNextPackage(final byte value) {
      bitField0_ |= 0x00000001;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public StarTowerBag addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000001;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public StarTowerBag setNextPackage(final byte... values) {
      bitField0_ |= 0x00000001;
      nextPackage.copyFrom(values);
      return this;
    }

    /**
     * <code>repeated .FateCardInfo FateCard = 1;</code>
     * @return whether the fateCard field is set
     */
    public boolean hasFateCard() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>repeated .FateCardInfo FateCard = 1;</code>
     * @return this
     */
    public StarTowerBag clearFateCard() {
      bitField0_ &= ~0x00000002;
      fateCard.clear();
      return this;
    }

    /**
     * <code>repeated .FateCardInfo FateCard = 1;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableFateCard()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<FateCardInfo> getFateCard() {
      return fateCard;
    }

    /**
     * <code>repeated .FateCardInfo FateCard = 1;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<FateCardInfo> getMutableFateCard() {
      bitField0_ |= 0x00000002;
      return fateCard;
    }

    /**
     * <code>repeated .FateCardInfo FateCard = 1;</code>
     * @param value the fateCard to add
     * @return this
     */
    public StarTowerBag addFateCard(final FateCardInfo value) {
      bitField0_ |= 0x00000002;
      fateCard.add(value);
      return this;
    }

    /**
     * <code>repeated .FateCardInfo FateCard = 1;</code>
     * @param values the fateCard to add
     * @return this
     */
    public StarTowerBag addAllFateCard(final FateCardInfo... values) {
      bitField0_ |= 0x00000002;
      fateCard.addAll(values);
      return this;
    }

    /**
     * <code>repeated .PotentialInfo Potentials = 2;</code>
     * @return whether the potentials field is set
     */
    public boolean hasPotentials() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>repeated .PotentialInfo Potentials = 2;</code>
     * @return this
     */
    public StarTowerBag clearPotentials() {
      bitField0_ &= ~0x00000004;
      potentials.clear();
      return this;
    }

    /**
     * <code>repeated .PotentialInfo Potentials = 2;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutablePotentials()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<PotentialInfo> getPotentials() {
      return potentials;
    }

    /**
     * <code>repeated .PotentialInfo Potentials = 2;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<PotentialInfo> getMutablePotentials() {
      bitField0_ |= 0x00000004;
      return potentials;
    }

    /**
     * <code>repeated .PotentialInfo Potentials = 2;</code>
     * @param value the potentials to add
     * @return this
     */
    public StarTowerBag addPotentials(final PotentialInfo value) {
      bitField0_ |= 0x00000004;
      potentials.add(value);
      return this;
    }

    /**
     * <code>repeated .PotentialInfo Potentials = 2;</code>
     * @param values the potentials to add
     * @return this
     */
    public StarTowerBag addAllPotentials(final PotentialInfo... values) {
      bitField0_ |= 0x00000004;
      potentials.addAll(values);
      return this;
    }

    /**
     * <code>repeated .TowerItemInfo Items = 3;</code>
     * @return whether the items field is set
     */
    public boolean hasItems() {
      return (bitField0_ & 0x00000008) != 0;
    }

    /**
     * <code>repeated .TowerItemInfo Items = 3;</code>
     * @return this
     */
    public StarTowerBag clearItems() {
      bitField0_ &= ~0x00000008;
      items.clear();
      return this;
    }

    /**
     * <code>repeated .TowerItemInfo Items = 3;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableItems()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<TowerItemInfo> getItems() {
      return items;
    }

    /**
     * <code>repeated .TowerItemInfo Items = 3;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<TowerItemInfo> getMutableItems() {
      bitField0_ |= 0x00000008;
      return items;
    }

    /**
     * <code>repeated .TowerItemInfo Items = 3;</code>
     * @param value the items to add
     * @return this
     */
    public StarTowerBag addItems(final TowerItemInfo value) {
      bitField0_ |= 0x00000008;
      items.add(value);
      return this;
    }

    /**
     * <code>repeated .TowerItemInfo Items = 3;</code>
     * @param values the items to add
     * @return this
     */
    public StarTowerBag addAllItems(final TowerItemInfo... values) {
      bitField0_ |= 0x00000008;
      items.addAll(values);
      return this;
    }

    /**
     * <code>repeated .TowerResInfo Res = 4;</code>
     * @return whether the res field is set
     */
    public boolean hasRes() {
      return (bitField0_ & 0x00000010) != 0;
    }

    /**
     * <code>repeated .TowerResInfo Res = 4;</code>
     * @return this
     */
    public StarTowerBag clearRes() {
      bitField0_ &= ~0x00000010;
      res.clear();
      return this;
    }

    /**
     * <code>repeated .TowerResInfo Res = 4;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableRes()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<TowerResInfo> getRes() {
      return res;
    }

    /**
     * <code>repeated .TowerResInfo Res = 4;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<TowerResInfo> getMutableRes() {
      bitField0_ |= 0x00000010;
      return res;
    }

    /**
     * <code>repeated .TowerResInfo Res = 4;</code>
     * @param value the res to add
     * @return this
     */
    public StarTowerBag addRes(final TowerResInfo value) {
      bitField0_ |= 0x00000010;
      res.add(value);
      return this;
    }

    /**
     * <code>repeated .TowerResInfo Res = 4;</code>
     * @param values the res to add
     * @return this
     */
    public StarTowerBag addAllRes(final TowerResInfo... values) {
      bitField0_ |= 0x00000010;
      res.addAll(values);
      return this;
    }

    @Override
    public StarTowerBag copyFrom(final StarTowerBag other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        nextPackage.copyFrom(other.nextPackage);
        fateCard.copyFrom(other.fateCard);
        potentials.copyFrom(other.potentials);
        items.copyFrom(other.items);
        res.copyFrom(other.res);
      }
      return this;
    }

    @Override
    public StarTowerBag mergeFrom(final StarTowerBag other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      if (other.hasFateCard()) {
        getMutableFateCard().addAll(other.fateCard);
      }
      if (other.hasPotentials()) {
        getMutablePotentials().addAll(other.potentials);
      }
      if (other.hasItems()) {
        getMutableItems().addAll(other.items);
      }
      if (other.hasRes()) {
        getMutableRes().addAll(other.res);
      }
      return this;
    }

    @Override
    public StarTowerBag clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      fateCard.clear();
      potentials.clear();
      items.clear();
      res.clear();
      return this;
    }

    @Override
    public StarTowerBag clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      fateCard.clearQuick();
      potentials.clearQuick();
      items.clearQuick();
      res.clearQuick();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof StarTowerBag)) {
        return false;
      }
      StarTowerBag other = (StarTowerBag) o;
      return bitField0_ == other.bitField0_
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage))
        && (!hasFateCard() || fateCard.equals(other.fateCard))
        && (!hasPotentials() || potentials.equals(other.potentials))
        && (!hasItems() || items.equals(other.items))
        && (!hasRes() || res.equals(other.res));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        for (int i = 0; i < fateCard.length(); i++) {
          output.writeRawByte((byte) 10);
          output.writeMessageNoTag(fateCard.get(i));
        }
      }
      if ((bitField0_ & 0x00000004) != 0) {
        for (int i = 0; i < potentials.length(); i++) {
          output.writeRawByte((byte) 18);
          output.writeMessageNoTag(potentials.get(i));
        }
      }
      if ((bitField0_ & 0x00000008) != 0) {
        for (int i = 0; i < items.length(); i++) {
          output.writeRawByte((byte) 26);
          output.writeMessageNoTag(items.get(i));
        }
      }
      if ((bitField0_ & 0x00000010) != 0) {
        for (int i = 0; i < res.length(); i++) {
          output.writeRawByte((byte) 34);
          output.writeMessageNoTag(res.get(i));
        }
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += (1 * fateCard.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(fateCard);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += (1 * potentials.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(potentials);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        size += (1 * items.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(items);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        size += (1 * res.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(res);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public StarTowerBag mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 10) {
              break;
            }
          }
          case 10: {
            // fateCard
            tag = input.readRepeatedMessage(fateCard, tag);
            bitField0_ |= 0x00000002;
            if (tag != 18) {
              break;
            }
          }
          case 18: {
            // potentials
            tag = input.readRepeatedMessage(potentials, tag);
            bitField0_ |= 0x00000004;
            if (tag != 26) {
              break;
            }
          }
          case 26: {
            // items
            tag = input.readRepeatedMessage(items, tag);
            bitField0_ |= 0x00000008;
            if (tag != 34) {
              break;
            }
          }
          case 34: {
            // res
            tag = input.readRepeatedMessage(res, tag);
            bitField0_ |= 0x00000010;
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRepeatedMessage(FieldNames.fateCard, fateCard);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRepeatedMessage(FieldNames.potentials, potentials);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeRepeatedMessage(FieldNames.items, items);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        output.writeRepeatedMessage(FieldNames.res, res);
      }
      output.endObject();
    }

    @Override
    public StarTowerBag mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 1047532988: {
            if (input.isAtField(FieldNames.fateCard)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedMessage(fateCard);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 1405493301: {
            if (input.isAtField(FieldNames.potentials)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedMessage(potentials);
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 70973344: {
            if (input.isAtField(FieldNames.items)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedMessage(items);
                bitField0_ |= 0x00000008;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 82048: {
            if (input.isAtField(FieldNames.res)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedMessage(res);
                bitField0_ |= 0x00000010;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public StarTowerBag clone() {
      return new StarTowerBag().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static StarTowerBag parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new StarTowerBag(), data).checkInitialized();
    }

    public static StarTowerBag parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new StarTowerBag(), input).checkInitialized();
    }

    public static StarTowerBag parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new StarTowerBag(), input).checkInitialized();
    }

    /**
     * @return factory for creating StarTowerBag messages
     */
    public static MessageFactory<StarTowerBag> getFactory() {
      return StarTowerBagFactory.INSTANCE;
    }

    private enum StarTowerBagFactory implements MessageFactory<StarTowerBag> {
      INSTANCE;

      @Override
      public StarTowerBag create() {
        return StarTowerBag.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName nextPackage = FieldName.forField("NextPackage");

      static final FieldName fateCard = FieldName.forField("FateCard");

      static final FieldName potentials = FieldName.forField("Potentials");

      static final FieldName items = FieldName.forField("Items");

      static final FieldName res = FieldName.forField("Res");
    }
  }

  /**
   * Protobuf type {@code StarTowerRoom}
   */
  public static final class StarTowerRoom extends ProtoMessage<StarTowerRoom> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional .StarTowerRoomData Data = 1;</code>
     */
    private final StarTowerRoomData data = StarTowerRoomData.newInstance();

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    /**
     * <code>repeated .StarTowerRoomCase Cases = 2;</code>
     */
    private final RepeatedMessage<StarTowerRoomCase> cases = RepeatedMessage.newEmptyInstance(StarTowerRoomCase.getFactory());

    private StarTowerRoom() {
    }

    /**
     * @return a new empty instance of {@code StarTowerRoom}
     */
    public static StarTowerRoom newInstance() {
      return new StarTowerRoom();
    }

    /**
     * <code>optional .StarTowerRoomData Data = 1;</code>
     * @return whether the data field is set
     */
    public boolean hasData() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional .StarTowerRoomData Data = 1;</code>
     * @return this
     */
    public StarTowerRoom clearData() {
      bitField0_ &= ~0x00000001;
      data.clear();
      return this;
    }

    /**
     * <code>optional .StarTowerRoomData Data = 1;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableData()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public StarTowerRoomData getData() {
      return data;
    }

    /**
     * <code>optional .StarTowerRoomData Data = 1;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public StarTowerRoomData getMutableData() {
      bitField0_ |= 0x00000001;
      return data;
    }

    /**
     * <code>optional .StarTowerRoomData Data = 1;</code>
     * @param value the data to set
     * @return this
     */
    public StarTowerRoom setData(final StarTowerRoomData value) {
      bitField0_ |= 0x00000001;
      data.copyFrom(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public StarTowerRoom clearNextPackage() {
      bitField0_ &= ~0x00000002;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000002;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public StarTowerRoom addNextPackage(final byte value) {
      bitField0_ |= 0x00000002;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public StarTowerRoom addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000002;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public StarTowerRoom setNextPackage(final byte... values) {
      bitField0_ |= 0x00000002;
      nextPackage.copyFrom(values);
      return this;
    }

    /**
     * <code>repeated .StarTowerRoomCase Cases = 2;</code>
     * @return whether the cases field is set
     */
    public boolean hasCases() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>repeated .StarTowerRoomCase Cases = 2;</code>
     * @return this
     */
    public StarTowerRoom clearCases() {
      bitField0_ &= ~0x00000004;
      cases.clear();
      return this;
    }

    /**
     * <code>repeated .StarTowerRoomCase Cases = 2;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableCases()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<StarTowerRoomCase> getCases() {
      return cases;
    }

    /**
     * <code>repeated .StarTowerRoomCase Cases = 2;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<StarTowerRoomCase> getMutableCases() {
      bitField0_ |= 0x00000004;
      return cases;
    }

    /**
     * <code>repeated .StarTowerRoomCase Cases = 2;</code>
     * @param value the cases to add
     * @return this
     */
    public StarTowerRoom addCases(final StarTowerRoomCase value) {
      bitField0_ |= 0x00000004;
      cases.add(value);
      return this;
    }

    /**
     * <code>repeated .StarTowerRoomCase Cases = 2;</code>
     * @param values the cases to add
     * @return this
     */
    public StarTowerRoom addAllCases(final StarTowerRoomCase... values) {
      bitField0_ |= 0x00000004;
      cases.addAll(values);
      return this;
    }

    @Override
    public StarTowerRoom copyFrom(final StarTowerRoom other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        data.copyFrom(other.data);
        nextPackage.copyFrom(other.nextPackage);
        cases.copyFrom(other.cases);
      }
      return this;
    }

    @Override
    public StarTowerRoom mergeFrom(final StarTowerRoom other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasData()) {
        getMutableData().mergeFrom(other.data);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      if (other.hasCases()) {
        getMutableCases().addAll(other.cases);
      }
      return this;
    }

    @Override
    public StarTowerRoom clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      data.clear();
      nextPackage.clear();
      cases.clear();
      return this;
    }

    @Override
    public StarTowerRoom clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      data.clearQuick();
      nextPackage.clear();
      cases.clearQuick();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof StarTowerRoom)) {
        return false;
      }
      StarTowerRoom other = (StarTowerRoom) o;
      return bitField0_ == other.bitField0_
        && (!hasData() || data.equals(other.data))
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage))
        && (!hasCases() || cases.equals(other.cases));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 10);
        output.writeMessageNoTag(data);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        for (int i = 0; i < cases.length(); i++) {
          output.writeRawByte((byte) 18);
          output.writeMessageNoTag(cases.get(i));
        }
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeMessageSizeNoTag(data);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += (1 * cases.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(cases);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public StarTowerRoom mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 10: {
            // data
            input.readMessage(data);
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 18) {
              break;
            }
          }
          case 18: {
            // cases
            tag = input.readRepeatedMessage(cases, tag);
            bitField0_ |= 0x00000004;
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeMessage(FieldNames.data, data);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRepeatedMessage(FieldNames.cases, cases);
      }
      output.endObject();
    }

    @Override
    public StarTowerRoom mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 2122698: {
            if (input.isAtField(FieldNames.data)) {
              if (!input.trySkipNullValue()) {
                input.readMessage(data);
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 64879395: {
            if (input.isAtField(FieldNames.cases)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedMessage(cases);
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public StarTowerRoom clone() {
      return new StarTowerRoom().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static StarTowerRoom parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new StarTowerRoom(), data).checkInitialized();
    }

    public static StarTowerRoom parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new StarTowerRoom(), input).checkInitialized();
    }

    public static StarTowerRoom parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new StarTowerRoom(), input).checkInitialized();
    }

    /**
     * @return factory for creating StarTowerRoom messages
     */
    public static MessageFactory<StarTowerRoom> getFactory() {
      return StarTowerRoomFactory.INSTANCE;
    }

    private enum StarTowerRoomFactory implements MessageFactory<StarTowerRoom> {
      INSTANCE;

      @Override
      public StarTowerRoom create() {
        return StarTowerRoom.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName data = FieldName.forField("Data");

      static final FieldName nextPackage = FieldName.forField("NextPackage");

      static final FieldName cases = FieldName.forField("Cases");
    }
  }

  /**
   * Protobuf type {@code StarTowerRoomData}
   */
  public static final class StarTowerRoomData extends ProtoMessage<StarTowerRoomData> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional uint32 Floor = 1;</code>
     */
    private int floor;

    /**
     * <code>optional uint32 MapId = 2;</code>
     */
    private int mapId;

    /**
     * <code>optional uint32 ParamId = 3;</code>
     */
    private int paramId;

    /**
     * <code>optional uint32 RoomType = 4;</code>
     */
    private int roomType;

    /**
     * <code>optional uint32 MapTableId = 6;</code>
     */
    private int mapTableId;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    /**
     * <code>optional string MapParam = 5;</code>
     */
    private final Utf8String mapParam = Utf8String.newEmptyInstance();

    private StarTowerRoomData() {
    }

    /**
     * @return a new empty instance of {@code StarTowerRoomData}
     */
    public static StarTowerRoomData newInstance() {
      return new StarTowerRoomData();
    }

    /**
     * <code>optional uint32 Floor = 1;</code>
     * @return whether the floor field is set
     */
    public boolean hasFloor() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional uint32 Floor = 1;</code>
     * @return this
     */
    public StarTowerRoomData clearFloor() {
      bitField0_ &= ~0x00000001;
      floor = 0;
      return this;
    }

    /**
     * <code>optional uint32 Floor = 1;</code>
     * @return the floor
     */
    public int getFloor() {
      return floor;
    }

    /**
     * <code>optional uint32 Floor = 1;</code>
     * @param value the floor to set
     * @return this
     */
    public StarTowerRoomData setFloor(final int value) {
      bitField0_ |= 0x00000001;
      floor = value;
      return this;
    }

    /**
     * <code>optional uint32 MapId = 2;</code>
     * @return whether the mapId field is set
     */
    public boolean hasMapId() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional uint32 MapId = 2;</code>
     * @return this
     */
    public StarTowerRoomData clearMapId() {
      bitField0_ &= ~0x00000002;
      mapId = 0;
      return this;
    }

    /**
     * <code>optional uint32 MapId = 2;</code>
     * @return the mapId
     */
    public int getMapId() {
      return mapId;
    }

    /**
     * <code>optional uint32 MapId = 2;</code>
     * @param value the mapId to set
     * @return this
     */
    public StarTowerRoomData setMapId(final int value) {
      bitField0_ |= 0x00000002;
      mapId = value;
      return this;
    }

    /**
     * <code>optional uint32 ParamId = 3;</code>
     * @return whether the paramId field is set
     */
    public boolean hasParamId() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional uint32 ParamId = 3;</code>
     * @return this
     */
    public StarTowerRoomData clearParamId() {
      bitField0_ &= ~0x00000004;
      paramId = 0;
      return this;
    }

    /**
     * <code>optional uint32 ParamId = 3;</code>
     * @return the paramId
     */
    public int getParamId() {
      return paramId;
    }

    /**
     * <code>optional uint32 ParamId = 3;</code>
     * @param value the paramId to set
     * @return this
     */
    public StarTowerRoomData setParamId(final int value) {
      bitField0_ |= 0x00000004;
      paramId = value;
      return this;
    }

    /**
     * <code>optional uint32 RoomType = 4;</code>
     * @return whether the roomType field is set
     */
    public boolean hasRoomType() {
      return (bitField0_ & 0x00000008) != 0;
    }

    /**
     * <code>optional uint32 RoomType = 4;</code>
     * @return this
     */
    public StarTowerRoomData clearRoomType() {
      bitField0_ &= ~0x00000008;
      roomType = 0;
      return this;
    }

    /**
     * <code>optional uint32 RoomType = 4;</code>
     * @return the roomType
     */
    public int getRoomType() {
      return roomType;
    }

    /**
     * <code>optional uint32 RoomType = 4;</code>
     * @param value the roomType to set
     * @return this
     */
    public StarTowerRoomData setRoomType(final int value) {
      bitField0_ |= 0x00000008;
      roomType = value;
      return this;
    }

    /**
     * <code>optional uint32 MapTableId = 6;</code>
     * @return whether the mapTableId field is set
     */
    public boolean hasMapTableId() {
      return (bitField0_ & 0x00000010) != 0;
    }

    /**
     * <code>optional uint32 MapTableId = 6;</code>
     * @return this
     */
    public StarTowerRoomData clearMapTableId() {
      bitField0_ &= ~0x00000010;
      mapTableId = 0;
      return this;
    }

    /**
     * <code>optional uint32 MapTableId = 6;</code>
     * @return the mapTableId
     */
    public int getMapTableId() {
      return mapTableId;
    }

    /**
     * <code>optional uint32 MapTableId = 6;</code>
     * @param value the mapTableId to set
     * @return this
     */
    public StarTowerRoomData setMapTableId(final int value) {
      bitField0_ |= 0x00000010;
      mapTableId = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000020) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public StarTowerRoomData clearNextPackage() {
      bitField0_ &= ~0x00000020;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000020;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public StarTowerRoomData addNextPackage(final byte value) {
      bitField0_ |= 0x00000020;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public StarTowerRoomData addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000020;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public StarTowerRoomData setNextPackage(final byte... values) {
      bitField0_ |= 0x00000020;
      nextPackage.copyFrom(values);
      return this;
    }

    /**
     * <code>optional string MapParam = 5;</code>
     * @return whether the mapParam field is set
     */
    public boolean hasMapParam() {
      return (bitField0_ & 0x00000040) != 0;
    }

    /**
     * <code>optional string MapParam = 5;</code>
     * @return this
     */
    public StarTowerRoomData clearMapParam() {
      bitField0_ &= ~0x00000040;
      mapParam.clear();
      return this;
    }

    /**
     * <code>optional string MapParam = 5;</code>
     * @return the mapParam
     */
    public String getMapParam() {
      return mapParam.getString();
    }

    /**
     * <code>optional string MapParam = 5;</code>
     * @return internal {@code Utf8String} representation of mapParam for reading
     */
    public Utf8String getMapParamBytes() {
      return this.mapParam;
    }

    /**
     * <code>optional string MapParam = 5;</code>
     * @return internal {@code Utf8String} representation of mapParam for modifications
     */
    public Utf8String getMutableMapParamBytes() {
      bitField0_ |= 0x00000040;
      return this.mapParam;
    }

    /**
     * <code>optional string MapParam = 5;</code>
     * @param value the mapParam to set
     * @return this
     */
    public StarTowerRoomData setMapParam(final CharSequence value) {
      bitField0_ |= 0x00000040;
      mapParam.copyFrom(value);
      return this;
    }

    /**
     * <code>optional string MapParam = 5;</code>
     * @param value the mapParam to set
     * @return this
     */
    public StarTowerRoomData setMapParam(final Utf8String value) {
      bitField0_ |= 0x00000040;
      mapParam.copyFrom(value);
      return this;
    }

    @Override
    public StarTowerRoomData copyFrom(final StarTowerRoomData other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        floor = other.floor;
        mapId = other.mapId;
        paramId = other.paramId;
        roomType = other.roomType;
        mapTableId = other.mapTableId;
        nextPackage.copyFrom(other.nextPackage);
        mapParam.copyFrom(other.mapParam);
      }
      return this;
    }

    @Override
    public StarTowerRoomData mergeFrom(final StarTowerRoomData other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasFloor()) {
        setFloor(other.floor);
      }
      if (other.hasMapId()) {
        setMapId(other.mapId);
      }
      if (other.hasParamId()) {
        setParamId(other.paramId);
      }
      if (other.hasRoomType()) {
        setRoomType(other.roomType);
      }
      if (other.hasMapTableId()) {
        setMapTableId(other.mapTableId);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      if (other.hasMapParam()) {
        getMutableMapParamBytes().copyFrom(other.mapParam);
      }
      return this;
    }

    @Override
    public StarTowerRoomData clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      floor = 0;
      mapId = 0;
      paramId = 0;
      roomType = 0;
      mapTableId = 0;
      nextPackage.clear();
      mapParam.clear();
      return this;
    }

    @Override
    public StarTowerRoomData clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      mapParam.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof StarTowerRoomData)) {
        return false;
      }
      StarTowerRoomData other = (StarTowerRoomData) o;
      return bitField0_ == other.bitField0_
        && (!hasFloor() || floor == other.floor)
        && (!hasMapId() || mapId == other.mapId)
        && (!hasParamId() || paramId == other.paramId)
        && (!hasRoomType() || roomType == other.roomType)
        && (!hasMapTableId() || mapTableId == other.mapTableId)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage))
        && (!hasMapParam() || mapParam.equals(other.mapParam));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt32NoTag(floor);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 16);
        output.writeUInt32NoTag(mapId);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawByte((byte) 24);
        output.writeUInt32NoTag(paramId);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeRawByte((byte) 32);
        output.writeUInt32NoTag(roomType);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        output.writeRawByte((byte) 48);
        output.writeUInt32NoTag(mapTableId);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000040) != 0) {
        output.writeRawByte((byte) 42);
        output.writeStringNoTag(mapParam);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(floor);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(mapId);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(paramId);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(roomType);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(mapTableId);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000040) != 0) {
        size += 1 + ProtoSink.computeStringSizeNoTag(mapParam);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public StarTowerRoomData mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            // floor
            floor = input.readUInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 16) {
              break;
            }
          }
          case 16: {
            // mapId
            mapId = input.readUInt32();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 24) {
              break;
            }
          }
          case 24: {
            // paramId
            paramId = input.readUInt32();
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 32) {
              break;
            }
          }
          case 32: {
            // roomType
            roomType = input.readUInt32();
            bitField0_ |= 0x00000008;
            tag = input.readTag();
            if (tag != 48) {
              break;
            }
          }
          case 48: {
            // mapTableId
            mapTableId = input.readUInt32();
            bitField0_ |= 0x00000010;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000020;
            tag = input.readTag();
            if (tag != 42) {
              break;
            }
          }
          case 42: {
            // mapParam
            input.readString(mapParam);
            bitField0_ |= 0x00000040;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeUInt32(FieldNames.floor, floor);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeUInt32(FieldNames.mapId, mapId);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeUInt32(FieldNames.paramId, paramId);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeUInt32(FieldNames.roomType, roomType);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        output.writeUInt32(FieldNames.mapTableId, mapTableId);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      if ((bitField0_ & 0x00000040) != 0) {
        output.writeString(FieldNames.mapParam, mapParam);
      }
      output.endObject();
    }

    @Override
    public StarTowerRoomData mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 67974124: {
            if (input.isAtField(FieldNames.floor)) {
              if (!input.trySkipNullValue()) {
                floor = input.readUInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 74110839: {
            if (input.isAtField(FieldNames.mapId)) {
              if (!input.trySkipNullValue()) {
                mapId = input.readUInt32();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 871156328: {
            if (input.isAtField(FieldNames.paramId)) {
              if (!input.trySkipNullValue()) {
                paramId = input.readUInt32();
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -108657963: {
            if (input.isAtField(FieldNames.roomType)) {
              if (!input.trySkipNullValue()) {
                roomType = input.readUInt32();
                bitField0_ |= 0x00000008;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 556914861: {
            if (input.isAtField(FieldNames.mapTableId)) {
              if (!input.trySkipNullValue()) {
                mapTableId = input.readUInt32();
                bitField0_ |= 0x00000010;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000020;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 229302449: {
            if (input.isAtField(FieldNames.mapParam)) {
              if (!input.trySkipNullValue()) {
                input.readString(mapParam);
                bitField0_ |= 0x00000040;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public StarTowerRoomData clone() {
      return new StarTowerRoomData().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static StarTowerRoomData parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new StarTowerRoomData(), data).checkInitialized();
    }

    public static StarTowerRoomData parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new StarTowerRoomData(), input).checkInitialized();
    }

    public static StarTowerRoomData parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new StarTowerRoomData(), input).checkInitialized();
    }

    /**
     * @return factory for creating StarTowerRoomData messages
     */
    public static MessageFactory<StarTowerRoomData> getFactory() {
      return StarTowerRoomDataFactory.INSTANCE;
    }

    private enum StarTowerRoomDataFactory implements MessageFactory<StarTowerRoomData> {
      INSTANCE;

      @Override
      public StarTowerRoomData create() {
        return StarTowerRoomData.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName floor = FieldName.forField("Floor");

      static final FieldName mapId = FieldName.forField("MapId");

      static final FieldName paramId = FieldName.forField("ParamId");

      static final FieldName roomType = FieldName.forField("RoomType");

      static final FieldName mapTableId = FieldName.forField("MapTableId");

      static final FieldName nextPackage = FieldName.forField("NextPackage");

      static final FieldName mapParam = FieldName.forField("MapParam");
    }
  }

  /**
   * Protobuf type {@code StarTowerRoomCase}
   */
  public static final class StarTowerRoomCase extends ProtoMessage<StarTowerRoomCase> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional uint32 Id = 1;</code>
     */
    private int id;

    /**
     * <code>optional .BattleCaseData BattleCase = 2;</code>
     */
    private final BattleCaseData battleCase = BattleCaseData.newInstance();

    /**
     * <code>optional .DoorCaseData DoorCase = 3;</code>
     */
    private final DoorCaseData doorCase = DoorCaseData.newInstance();

    /**
     * <code>optional .SelectSpecialPotentialCaseData SelectSpecialPotentialCase = 4;</code>
     */
    private final SelectSpecialPotentialCaseData selectSpecialPotentialCase = SelectSpecialPotentialCaseData.newInstance();

    /**
     * <code>optional .SelectPotentialCaseData SelectPotentialCase = 5;</code>
     */
    private final SelectPotentialCaseData selectPotentialCase = SelectPotentialCaseData.newInstance();

    /**
     * <code>optional .SelectFateCardCaseData SelectFateCardCase = 6;</code>
     */
    private final SelectFateCardCaseData selectFateCardCase = SelectFateCardCaseData.newInstance();

    /**
     * <code>optional .SelectOptionsEventCaseData SelectOptionsEventCase = 8;</code>
     */
    private final SelectOptionsEventCaseData selectOptionsEventCase = SelectOptionsEventCaseData.newInstance();

    /**
     * <code>optional .RecoveryHPCaseData RecoveryHPCase = 9;</code>
     */
    private final RecoveryHPCaseData recoveryHPCase = RecoveryHPCaseData.newInstance();

    /**
     * <code>optional .NpcRecoveryHPCaseData NpcRecoveryHPCase = 10;</code>
     */
    private final NpcRecoveryHPCaseData npcRecoveryHPCase = NpcRecoveryHPCaseData.newInstance();

    /**
     * <code>optional .HawkerCaseData HawkerCase = 11;</code>
     */
    private final HawkerCaseData hawkerCase = HawkerCaseData.newInstance();

    /**
     * <code>optional .StrengthenMachineCaseData StrengthenMachineCase = 12;</code>
     */
    private final StrengthenMachineCaseData strengthenMachineCase = StrengthenMachineCaseData.newInstance();

    /**
     * <code>optional .SyncHPCaseData SyncHPCase = 15;</code>
     */
    private final SyncHPCaseData syncHPCase = SyncHPCaseData.newInstance();

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    private StarTowerRoomCase() {
    }

    /**
     * @return a new empty instance of {@code StarTowerRoomCase}
     */
    public static StarTowerRoomCase newInstance() {
      return new StarTowerRoomCase();
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @return whether the id field is set
     */
    public boolean hasId() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @return this
     */
    public StarTowerRoomCase clearId() {
      bitField0_ &= ~0x00000001;
      id = 0;
      return this;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @return the id
     */
    public int getId() {
      return id;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @param value the id to set
     * @return this
     */
    public StarTowerRoomCase setId(final int value) {
      bitField0_ |= 0x00000001;
      id = value;
      return this;
    }

    /**
     * <code>optional .BattleCaseData BattleCase = 2;</code>
     * @return whether the battleCase field is set
     */
    public boolean hasBattleCase() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional .BattleCaseData BattleCase = 2;</code>
     * @return this
     */
    public StarTowerRoomCase clearBattleCase() {
      bitField0_ &= ~0x00000002;
      battleCase.clear();
      return this;
    }

    /**
     * <code>optional .BattleCaseData BattleCase = 2;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableBattleCase()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public BattleCaseData getBattleCase() {
      return battleCase;
    }

    /**
     * <code>optional .BattleCaseData BattleCase = 2;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public BattleCaseData getMutableBattleCase() {
      bitField0_ |= 0x00000002;
      return battleCase;
    }

    /**
     * <code>optional .BattleCaseData BattleCase = 2;</code>
     * @param value the battleCase to set
     * @return this
     */
    public StarTowerRoomCase setBattleCase(final BattleCaseData value) {
      bitField0_ |= 0x00000002;
      battleCase.copyFrom(value);
      return this;
    }

    /**
     * <code>optional .DoorCaseData DoorCase = 3;</code>
     * @return whether the doorCase field is set
     */
    public boolean hasDoorCase() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional .DoorCaseData DoorCase = 3;</code>
     * @return this
     */
    public StarTowerRoomCase clearDoorCase() {
      bitField0_ &= ~0x00000004;
      doorCase.clear();
      return this;
    }

    /**
     * <code>optional .DoorCaseData DoorCase = 3;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableDoorCase()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public DoorCaseData getDoorCase() {
      return doorCase;
    }

    /**
     * <code>optional .DoorCaseData DoorCase = 3;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public DoorCaseData getMutableDoorCase() {
      bitField0_ |= 0x00000004;
      return doorCase;
    }

    /**
     * <code>optional .DoorCaseData DoorCase = 3;</code>
     * @param value the doorCase to set
     * @return this
     */
    public StarTowerRoomCase setDoorCase(final DoorCaseData value) {
      bitField0_ |= 0x00000004;
      doorCase.copyFrom(value);
      return this;
    }

    /**
     * <code>optional .SelectSpecialPotentialCaseData SelectSpecialPotentialCase = 4;</code>
     * @return whether the selectSpecialPotentialCase field is set
     */
    public boolean hasSelectSpecialPotentialCase() {
      return (bitField0_ & 0x00000008) != 0;
    }

    /**
     * <code>optional .SelectSpecialPotentialCaseData SelectSpecialPotentialCase = 4;</code>
     * @return this
     */
    public StarTowerRoomCase clearSelectSpecialPotentialCase() {
      bitField0_ &= ~0x00000008;
      selectSpecialPotentialCase.clear();
      return this;
    }

    /**
     * <code>optional .SelectSpecialPotentialCaseData SelectSpecialPotentialCase = 4;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableSelectSpecialPotentialCase()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public SelectSpecialPotentialCaseData getSelectSpecialPotentialCase() {
      return selectSpecialPotentialCase;
    }

    /**
     * <code>optional .SelectSpecialPotentialCaseData SelectSpecialPotentialCase = 4;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public SelectSpecialPotentialCaseData getMutableSelectSpecialPotentialCase() {
      bitField0_ |= 0x00000008;
      return selectSpecialPotentialCase;
    }

    /**
     * <code>optional .SelectSpecialPotentialCaseData SelectSpecialPotentialCase = 4;</code>
     * @param value the selectSpecialPotentialCase to set
     * @return this
     */
    public StarTowerRoomCase setSelectSpecialPotentialCase(
        final SelectSpecialPotentialCaseData value) {
      bitField0_ |= 0x00000008;
      selectSpecialPotentialCase.copyFrom(value);
      return this;
    }

    /**
     * <code>optional .SelectPotentialCaseData SelectPotentialCase = 5;</code>
     * @return whether the selectPotentialCase field is set
     */
    public boolean hasSelectPotentialCase() {
      return (bitField0_ & 0x00000010) != 0;
    }

    /**
     * <code>optional .SelectPotentialCaseData SelectPotentialCase = 5;</code>
     * @return this
     */
    public StarTowerRoomCase clearSelectPotentialCase() {
      bitField0_ &= ~0x00000010;
      selectPotentialCase.clear();
      return this;
    }

    /**
     * <code>optional .SelectPotentialCaseData SelectPotentialCase = 5;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableSelectPotentialCase()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public SelectPotentialCaseData getSelectPotentialCase() {
      return selectPotentialCase;
    }

    /**
     * <code>optional .SelectPotentialCaseData SelectPotentialCase = 5;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public SelectPotentialCaseData getMutableSelectPotentialCase() {
      bitField0_ |= 0x00000010;
      return selectPotentialCase;
    }

    /**
     * <code>optional .SelectPotentialCaseData SelectPotentialCase = 5;</code>
     * @param value the selectPotentialCase to set
     * @return this
     */
    public StarTowerRoomCase setSelectPotentialCase(final SelectPotentialCaseData value) {
      bitField0_ |= 0x00000010;
      selectPotentialCase.copyFrom(value);
      return this;
    }

    /**
     * <code>optional .SelectFateCardCaseData SelectFateCardCase = 6;</code>
     * @return whether the selectFateCardCase field is set
     */
    public boolean hasSelectFateCardCase() {
      return (bitField0_ & 0x00000020) != 0;
    }

    /**
     * <code>optional .SelectFateCardCaseData SelectFateCardCase = 6;</code>
     * @return this
     */
    public StarTowerRoomCase clearSelectFateCardCase() {
      bitField0_ &= ~0x00000020;
      selectFateCardCase.clear();
      return this;
    }

    /**
     * <code>optional .SelectFateCardCaseData SelectFateCardCase = 6;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableSelectFateCardCase()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public SelectFateCardCaseData getSelectFateCardCase() {
      return selectFateCardCase;
    }

    /**
     * <code>optional .SelectFateCardCaseData SelectFateCardCase = 6;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public SelectFateCardCaseData getMutableSelectFateCardCase() {
      bitField0_ |= 0x00000020;
      return selectFateCardCase;
    }

    /**
     * <code>optional .SelectFateCardCaseData SelectFateCardCase = 6;</code>
     * @param value the selectFateCardCase to set
     * @return this
     */
    public StarTowerRoomCase setSelectFateCardCase(final SelectFateCardCaseData value) {
      bitField0_ |= 0x00000020;
      selectFateCardCase.copyFrom(value);
      return this;
    }

    /**
     * <code>optional .SelectOptionsEventCaseData SelectOptionsEventCase = 8;</code>
     * @return whether the selectOptionsEventCase field is set
     */
    public boolean hasSelectOptionsEventCase() {
      return (bitField0_ & 0x00000040) != 0;
    }

    /**
     * <code>optional .SelectOptionsEventCaseData SelectOptionsEventCase = 8;</code>
     * @return this
     */
    public StarTowerRoomCase clearSelectOptionsEventCase() {
      bitField0_ &= ~0x00000040;
      selectOptionsEventCase.clear();
      return this;
    }

    /**
     * <code>optional .SelectOptionsEventCaseData SelectOptionsEventCase = 8;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableSelectOptionsEventCase()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public SelectOptionsEventCaseData getSelectOptionsEventCase() {
      return selectOptionsEventCase;
    }

    /**
     * <code>optional .SelectOptionsEventCaseData SelectOptionsEventCase = 8;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public SelectOptionsEventCaseData getMutableSelectOptionsEventCase() {
      bitField0_ |= 0x00000040;
      return selectOptionsEventCase;
    }

    /**
     * <code>optional .SelectOptionsEventCaseData SelectOptionsEventCase = 8;</code>
     * @param value the selectOptionsEventCase to set
     * @return this
     */
    public StarTowerRoomCase setSelectOptionsEventCase(final SelectOptionsEventCaseData value) {
      bitField0_ |= 0x00000040;
      selectOptionsEventCase.copyFrom(value);
      return this;
    }

    /**
     * <code>optional .RecoveryHPCaseData RecoveryHPCase = 9;</code>
     * @return whether the recoveryHPCase field is set
     */
    public boolean hasRecoveryHPCase() {
      return (bitField0_ & 0x00000080) != 0;
    }

    /**
     * <code>optional .RecoveryHPCaseData RecoveryHPCase = 9;</code>
     * @return this
     */
    public StarTowerRoomCase clearRecoveryHPCase() {
      bitField0_ &= ~0x00000080;
      recoveryHPCase.clear();
      return this;
    }

    /**
     * <code>optional .RecoveryHPCaseData RecoveryHPCase = 9;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableRecoveryHPCase()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RecoveryHPCaseData getRecoveryHPCase() {
      return recoveryHPCase;
    }

    /**
     * <code>optional .RecoveryHPCaseData RecoveryHPCase = 9;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RecoveryHPCaseData getMutableRecoveryHPCase() {
      bitField0_ |= 0x00000080;
      return recoveryHPCase;
    }

    /**
     * <code>optional .RecoveryHPCaseData RecoveryHPCase = 9;</code>
     * @param value the recoveryHPCase to set
     * @return this
     */
    public StarTowerRoomCase setRecoveryHPCase(final RecoveryHPCaseData value) {
      bitField0_ |= 0x00000080;
      recoveryHPCase.copyFrom(value);
      return this;
    }

    /**
     * <code>optional .NpcRecoveryHPCaseData NpcRecoveryHPCase = 10;</code>
     * @return whether the npcRecoveryHPCase field is set
     */
    public boolean hasNpcRecoveryHPCase() {
      return (bitField0_ & 0x00000100) != 0;
    }

    /**
     * <code>optional .NpcRecoveryHPCaseData NpcRecoveryHPCase = 10;</code>
     * @return this
     */
    public StarTowerRoomCase clearNpcRecoveryHPCase() {
      bitField0_ &= ~0x00000100;
      npcRecoveryHPCase.clear();
      return this;
    }

    /**
     * <code>optional .NpcRecoveryHPCaseData NpcRecoveryHPCase = 10;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNpcRecoveryHPCase()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public NpcRecoveryHPCaseData getNpcRecoveryHPCase() {
      return npcRecoveryHPCase;
    }

    /**
     * <code>optional .NpcRecoveryHPCaseData NpcRecoveryHPCase = 10;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public NpcRecoveryHPCaseData getMutableNpcRecoveryHPCase() {
      bitField0_ |= 0x00000100;
      return npcRecoveryHPCase;
    }

    /**
     * <code>optional .NpcRecoveryHPCaseData NpcRecoveryHPCase = 10;</code>
     * @param value the npcRecoveryHPCase to set
     * @return this
     */
    public StarTowerRoomCase setNpcRecoveryHPCase(final NpcRecoveryHPCaseData value) {
      bitField0_ |= 0x00000100;
      npcRecoveryHPCase.copyFrom(value);
      return this;
    }

    /**
     * <code>optional .HawkerCaseData HawkerCase = 11;</code>
     * @return whether the hawkerCase field is set
     */
    public boolean hasHawkerCase() {
      return (bitField0_ & 0x00000200) != 0;
    }

    /**
     * <code>optional .HawkerCaseData HawkerCase = 11;</code>
     * @return this
     */
    public StarTowerRoomCase clearHawkerCase() {
      bitField0_ &= ~0x00000200;
      hawkerCase.clear();
      return this;
    }

    /**
     * <code>optional .HawkerCaseData HawkerCase = 11;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableHawkerCase()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public HawkerCaseData getHawkerCase() {
      return hawkerCase;
    }

    /**
     * <code>optional .HawkerCaseData HawkerCase = 11;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public HawkerCaseData getMutableHawkerCase() {
      bitField0_ |= 0x00000200;
      return hawkerCase;
    }

    /**
     * <code>optional .HawkerCaseData HawkerCase = 11;</code>
     * @param value the hawkerCase to set
     * @return this
     */
    public StarTowerRoomCase setHawkerCase(final HawkerCaseData value) {
      bitField0_ |= 0x00000200;
      hawkerCase.copyFrom(value);
      return this;
    }

    /**
     * <code>optional .StrengthenMachineCaseData StrengthenMachineCase = 12;</code>
     * @return whether the strengthenMachineCase field is set
     */
    public boolean hasStrengthenMachineCase() {
      return (bitField0_ & 0x00000400) != 0;
    }

    /**
     * <code>optional .StrengthenMachineCaseData StrengthenMachineCase = 12;</code>
     * @return this
     */
    public StarTowerRoomCase clearStrengthenMachineCase() {
      bitField0_ &= ~0x00000400;
      strengthenMachineCase.clear();
      return this;
    }

    /**
     * <code>optional .StrengthenMachineCaseData StrengthenMachineCase = 12;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableStrengthenMachineCase()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public StrengthenMachineCaseData getStrengthenMachineCase() {
      return strengthenMachineCase;
    }

    /**
     * <code>optional .StrengthenMachineCaseData StrengthenMachineCase = 12;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public StrengthenMachineCaseData getMutableStrengthenMachineCase() {
      bitField0_ |= 0x00000400;
      return strengthenMachineCase;
    }

    /**
     * <code>optional .StrengthenMachineCaseData StrengthenMachineCase = 12;</code>
     * @param value the strengthenMachineCase to set
     * @return this
     */
    public StarTowerRoomCase setStrengthenMachineCase(final StrengthenMachineCaseData value) {
      bitField0_ |= 0x00000400;
      strengthenMachineCase.copyFrom(value);
      return this;
    }

    /**
     * <code>optional .SyncHPCaseData SyncHPCase = 15;</code>
     * @return whether the syncHPCase field is set
     */
    public boolean hasSyncHPCase() {
      return (bitField0_ & 0x00000800) != 0;
    }

    /**
     * <code>optional .SyncHPCaseData SyncHPCase = 15;</code>
     * @return this
     */
    public StarTowerRoomCase clearSyncHPCase() {
      bitField0_ &= ~0x00000800;
      syncHPCase.clear();
      return this;
    }

    /**
     * <code>optional .SyncHPCaseData SyncHPCase = 15;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableSyncHPCase()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public SyncHPCaseData getSyncHPCase() {
      return syncHPCase;
    }

    /**
     * <code>optional .SyncHPCaseData SyncHPCase = 15;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public SyncHPCaseData getMutableSyncHPCase() {
      bitField0_ |= 0x00000800;
      return syncHPCase;
    }

    /**
     * <code>optional .SyncHPCaseData SyncHPCase = 15;</code>
     * @param value the syncHPCase to set
     * @return this
     */
    public StarTowerRoomCase setSyncHPCase(final SyncHPCaseData value) {
      bitField0_ |= 0x00000800;
      syncHPCase.copyFrom(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00001000) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public StarTowerRoomCase clearNextPackage() {
      bitField0_ &= ~0x00001000;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00001000;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public StarTowerRoomCase addNextPackage(final byte value) {
      bitField0_ |= 0x00001000;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public StarTowerRoomCase addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00001000;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public StarTowerRoomCase setNextPackage(final byte... values) {
      bitField0_ |= 0x00001000;
      nextPackage.copyFrom(values);
      return this;
    }

    @Override
    public StarTowerRoomCase copyFrom(final StarTowerRoomCase other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        id = other.id;
        battleCase.copyFrom(other.battleCase);
        doorCase.copyFrom(other.doorCase);
        selectSpecialPotentialCase.copyFrom(other.selectSpecialPotentialCase);
        selectPotentialCase.copyFrom(other.selectPotentialCase);
        selectFateCardCase.copyFrom(other.selectFateCardCase);
        selectOptionsEventCase.copyFrom(other.selectOptionsEventCase);
        recoveryHPCase.copyFrom(other.recoveryHPCase);
        npcRecoveryHPCase.copyFrom(other.npcRecoveryHPCase);
        hawkerCase.copyFrom(other.hawkerCase);
        strengthenMachineCase.copyFrom(other.strengthenMachineCase);
        syncHPCase.copyFrom(other.syncHPCase);
        nextPackage.copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public StarTowerRoomCase mergeFrom(final StarTowerRoomCase other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasId()) {
        setId(other.id);
      }
      if (other.hasBattleCase()) {
        getMutableBattleCase().mergeFrom(other.battleCase);
      }
      if (other.hasDoorCase()) {
        getMutableDoorCase().mergeFrom(other.doorCase);
      }
      if (other.hasSelectSpecialPotentialCase()) {
        getMutableSelectSpecialPotentialCase().mergeFrom(other.selectSpecialPotentialCase);
      }
      if (other.hasSelectPotentialCase()) {
        getMutableSelectPotentialCase().mergeFrom(other.selectPotentialCase);
      }
      if (other.hasSelectFateCardCase()) {
        getMutableSelectFateCardCase().mergeFrom(other.selectFateCardCase);
      }
      if (other.hasSelectOptionsEventCase()) {
        getMutableSelectOptionsEventCase().mergeFrom(other.selectOptionsEventCase);
      }
      if (other.hasRecoveryHPCase()) {
        getMutableRecoveryHPCase().mergeFrom(other.recoveryHPCase);
      }
      if (other.hasNpcRecoveryHPCase()) {
        getMutableNpcRecoveryHPCase().mergeFrom(other.npcRecoveryHPCase);
      }
      if (other.hasHawkerCase()) {
        getMutableHawkerCase().mergeFrom(other.hawkerCase);
      }
      if (other.hasStrengthenMachineCase()) {
        getMutableStrengthenMachineCase().mergeFrom(other.strengthenMachineCase);
      }
      if (other.hasSyncHPCase()) {
        getMutableSyncHPCase().mergeFrom(other.syncHPCase);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public StarTowerRoomCase clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      id = 0;
      battleCase.clear();
      doorCase.clear();
      selectSpecialPotentialCase.clear();
      selectPotentialCase.clear();
      selectFateCardCase.clear();
      selectOptionsEventCase.clear();
      recoveryHPCase.clear();
      npcRecoveryHPCase.clear();
      hawkerCase.clear();
      strengthenMachineCase.clear();
      syncHPCase.clear();
      nextPackage.clear();
      return this;
    }

    @Override
    public StarTowerRoomCase clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      battleCase.clearQuick();
      doorCase.clearQuick();
      selectSpecialPotentialCase.clearQuick();
      selectPotentialCase.clearQuick();
      selectFateCardCase.clearQuick();
      selectOptionsEventCase.clearQuick();
      recoveryHPCase.clearQuick();
      npcRecoveryHPCase.clearQuick();
      hawkerCase.clearQuick();
      strengthenMachineCase.clearQuick();
      syncHPCase.clearQuick();
      nextPackage.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof StarTowerRoomCase)) {
        return false;
      }
      StarTowerRoomCase other = (StarTowerRoomCase) o;
      return bitField0_ == other.bitField0_
        && (!hasId() || id == other.id)
        && (!hasBattleCase() || battleCase.equals(other.battleCase))
        && (!hasDoorCase() || doorCase.equals(other.doorCase))
        && (!hasSelectSpecialPotentialCase() || selectSpecialPotentialCase.equals(other.selectSpecialPotentialCase))
        && (!hasSelectPotentialCase() || selectPotentialCase.equals(other.selectPotentialCase))
        && (!hasSelectFateCardCase() || selectFateCardCase.equals(other.selectFateCardCase))
        && (!hasSelectOptionsEventCase() || selectOptionsEventCase.equals(other.selectOptionsEventCase))
        && (!hasRecoveryHPCase() || recoveryHPCase.equals(other.recoveryHPCase))
        && (!hasNpcRecoveryHPCase() || npcRecoveryHPCase.equals(other.npcRecoveryHPCase))
        && (!hasHawkerCase() || hawkerCase.equals(other.hawkerCase))
        && (!hasStrengthenMachineCase() || strengthenMachineCase.equals(other.strengthenMachineCase))
        && (!hasSyncHPCase() || syncHPCase.equals(other.syncHPCase))
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt32NoTag(id);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 18);
        output.writeMessageNoTag(battleCase);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawByte((byte) 26);
        output.writeMessageNoTag(doorCase);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeRawByte((byte) 34);
        output.writeMessageNoTag(selectSpecialPotentialCase);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        output.writeRawByte((byte) 42);
        output.writeMessageNoTag(selectPotentialCase);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        output.writeRawByte((byte) 50);
        output.writeMessageNoTag(selectFateCardCase);
      }
      if ((bitField0_ & 0x00000040) != 0) {
        output.writeRawByte((byte) 66);
        output.writeMessageNoTag(selectOptionsEventCase);
      }
      if ((bitField0_ & 0x00000080) != 0) {
        output.writeRawByte((byte) 74);
        output.writeMessageNoTag(recoveryHPCase);
      }
      if ((bitField0_ & 0x00000100) != 0) {
        output.writeRawByte((byte) 82);
        output.writeMessageNoTag(npcRecoveryHPCase);
      }
      if ((bitField0_ & 0x00000200) != 0) {
        output.writeRawByte((byte) 90);
        output.writeMessageNoTag(hawkerCase);
      }
      if ((bitField0_ & 0x00000400) != 0) {
        output.writeRawByte((byte) 98);
        output.writeMessageNoTag(strengthenMachineCase);
      }
      if ((bitField0_ & 0x00000800) != 0) {
        output.writeRawByte((byte) 122);
        output.writeMessageNoTag(syncHPCase);
      }
      if ((bitField0_ & 0x00001000) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(id);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeMessageSizeNoTag(battleCase);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 1 + ProtoSink.computeMessageSizeNoTag(doorCase);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        size += 1 + ProtoSink.computeMessageSizeNoTag(selectSpecialPotentialCase);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        size += 1 + ProtoSink.computeMessageSizeNoTag(selectPotentialCase);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        size += 1 + ProtoSink.computeMessageSizeNoTag(selectFateCardCase);
      }
      if ((bitField0_ & 0x00000040) != 0) {
        size += 1 + ProtoSink.computeMessageSizeNoTag(selectOptionsEventCase);
      }
      if ((bitField0_ & 0x00000080) != 0) {
        size += 1 + ProtoSink.computeMessageSizeNoTag(recoveryHPCase);
      }
      if ((bitField0_ & 0x00000100) != 0) {
        size += 1 + ProtoSink.computeMessageSizeNoTag(npcRecoveryHPCase);
      }
      if ((bitField0_ & 0x00000200) != 0) {
        size += 1 + ProtoSink.computeMessageSizeNoTag(hawkerCase);
      }
      if ((bitField0_ & 0x00000400) != 0) {
        size += 1 + ProtoSink.computeMessageSizeNoTag(strengthenMachineCase);
      }
      if ((bitField0_ & 0x00000800) != 0) {
        size += 1 + ProtoSink.computeMessageSizeNoTag(syncHPCase);
      }
      if ((bitField0_ & 0x00001000) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public StarTowerRoomCase mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            // id
            id = input.readUInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 18) {
              break;
            }
          }
          case 18: {
            // battleCase
            input.readMessage(battleCase);
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 26) {
              break;
            }
          }
          case 26: {
            // doorCase
            input.readMessage(doorCase);
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 34) {
              break;
            }
          }
          case 34: {
            // selectSpecialPotentialCase
            input.readMessage(selectSpecialPotentialCase);
            bitField0_ |= 0x00000008;
            tag = input.readTag();
            if (tag != 42) {
              break;
            }
          }
          case 42: {
            // selectPotentialCase
            input.readMessage(selectPotentialCase);
            bitField0_ |= 0x00000010;
            tag = input.readTag();
            if (tag != 50) {
              break;
            }
          }
          case 50: {
            // selectFateCardCase
            input.readMessage(selectFateCardCase);
            bitField0_ |= 0x00000020;
            tag = input.readTag();
            if (tag != 66) {
              break;
            }
          }
          case 66: {
            // selectOptionsEventCase
            input.readMessage(selectOptionsEventCase);
            bitField0_ |= 0x00000040;
            tag = input.readTag();
            if (tag != 74) {
              break;
            }
          }
          case 74: {
            // recoveryHPCase
            input.readMessage(recoveryHPCase);
            bitField0_ |= 0x00000080;
            tag = input.readTag();
            if (tag != 82) {
              break;
            }
          }
          case 82: {
            // npcRecoveryHPCase
            input.readMessage(npcRecoveryHPCase);
            bitField0_ |= 0x00000100;
            tag = input.readTag();
            if (tag != 90) {
              break;
            }
          }
          case 90: {
            // hawkerCase
            input.readMessage(hawkerCase);
            bitField0_ |= 0x00000200;
            tag = input.readTag();
            if (tag != 98) {
              break;
            }
          }
          case 98: {
            // strengthenMachineCase
            input.readMessage(strengthenMachineCase);
            bitField0_ |= 0x00000400;
            tag = input.readTag();
            if (tag != 122) {
              break;
            }
          }
          case 122: {
            // syncHPCase
            input.readMessage(syncHPCase);
            bitField0_ |= 0x00000800;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00001000;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeUInt32(FieldNames.id, id);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeMessage(FieldNames.battleCase, battleCase);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeMessage(FieldNames.doorCase, doorCase);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeMessage(FieldNames.selectSpecialPotentialCase, selectSpecialPotentialCase);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        output.writeMessage(FieldNames.selectPotentialCase, selectPotentialCase);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        output.writeMessage(FieldNames.selectFateCardCase, selectFateCardCase);
      }
      if ((bitField0_ & 0x00000040) != 0) {
        output.writeMessage(FieldNames.selectOptionsEventCase, selectOptionsEventCase);
      }
      if ((bitField0_ & 0x00000080) != 0) {
        output.writeMessage(FieldNames.recoveryHPCase, recoveryHPCase);
      }
      if ((bitField0_ & 0x00000100) != 0) {
        output.writeMessage(FieldNames.npcRecoveryHPCase, npcRecoveryHPCase);
      }
      if ((bitField0_ & 0x00000200) != 0) {
        output.writeMessage(FieldNames.hawkerCase, hawkerCase);
      }
      if ((bitField0_ & 0x00000400) != 0) {
        output.writeMessage(FieldNames.strengthenMachineCase, strengthenMachineCase);
      }
      if ((bitField0_ & 0x00000800) != 0) {
        output.writeMessage(FieldNames.syncHPCase, syncHPCase);
      }
      if ((bitField0_ & 0x00001000) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      output.endObject();
    }

    @Override
    public StarTowerRoomCase mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 2363: {
            if (input.isAtField(FieldNames.id)) {
              if (!input.trySkipNullValue()) {
                id = input.readUInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -248315864: {
            if (input.isAtField(FieldNames.battleCase)) {
              if (!input.trySkipNullValue()) {
                input.readMessage(battleCase);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 1265889310: {
            if (input.isAtField(FieldNames.doorCase)) {
              if (!input.trySkipNullValue()) {
                input.readMessage(doorCase);
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1667710095: {
            if (input.isAtField(FieldNames.selectSpecialPotentialCase)) {
              if (!input.trySkipNullValue()) {
                input.readMessage(selectSpecialPotentialCase);
                bitField0_ |= 0x00000008;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 929377458: {
            if (input.isAtField(FieldNames.selectPotentialCase)) {
              if (!input.trySkipNullValue()) {
                input.readMessage(selectPotentialCase);
                bitField0_ |= 0x00000010;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 1348869672: {
            if (input.isAtField(FieldNames.selectFateCardCase)) {
              if (!input.trySkipNullValue()) {
                input.readMessage(selectFateCardCase);
                bitField0_ |= 0x00000020;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1570218712: {
            if (input.isAtField(FieldNames.selectOptionsEventCase)) {
              if (!input.trySkipNullValue()) {
                input.readMessage(selectOptionsEventCase);
                bitField0_ |= 0x00000040;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -688997299: {
            if (input.isAtField(FieldNames.recoveryHPCase)) {
              if (!input.trySkipNullValue()) {
                input.readMessage(recoveryHPCase);
                bitField0_ |= 0x00000080;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -631535282: {
            if (input.isAtField(FieldNames.npcRecoveryHPCase)) {
              if (!input.trySkipNullValue()) {
                input.readMessage(npcRecoveryHPCase);
                bitField0_ |= 0x00000100;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -79930006: {
            if (input.isAtField(FieldNames.hawkerCase)) {
              if (!input.trySkipNullValue()) {
                input.readMessage(hawkerCase);
                bitField0_ |= 0x00000200;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -789171987: {
            if (input.isAtField(FieldNames.strengthenMachineCase)) {
              if (!input.trySkipNullValue()) {
                input.readMessage(strengthenMachineCase);
                bitField0_ |= 0x00000400;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -547976493: {
            if (input.isAtField(FieldNames.syncHPCase)) {
              if (!input.trySkipNullValue()) {
                input.readMessage(syncHPCase);
                bitField0_ |= 0x00000800;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00001000;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public StarTowerRoomCase clone() {
      return new StarTowerRoomCase().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static StarTowerRoomCase parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new StarTowerRoomCase(), data).checkInitialized();
    }

    public static StarTowerRoomCase parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new StarTowerRoomCase(), input).checkInitialized();
    }

    public static StarTowerRoomCase parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new StarTowerRoomCase(), input).checkInitialized();
    }

    /**
     * @return factory for creating StarTowerRoomCase messages
     */
    public static MessageFactory<StarTowerRoomCase> getFactory() {
      return StarTowerRoomCaseFactory.INSTANCE;
    }

    private enum StarTowerRoomCaseFactory implements MessageFactory<StarTowerRoomCase> {
      INSTANCE;

      @Override
      public StarTowerRoomCase create() {
        return StarTowerRoomCase.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName id = FieldName.forField("Id");

      static final FieldName battleCase = FieldName.forField("BattleCase");

      static final FieldName doorCase = FieldName.forField("DoorCase");

      static final FieldName selectSpecialPotentialCase = FieldName.forField("SelectSpecialPotentialCase");

      static final FieldName selectPotentialCase = FieldName.forField("SelectPotentialCase");

      static final FieldName selectFateCardCase = FieldName.forField("SelectFateCardCase");

      static final FieldName selectOptionsEventCase = FieldName.forField("SelectOptionsEventCase");

      static final FieldName recoveryHPCase = FieldName.forField("RecoveryHPCase");

      static final FieldName npcRecoveryHPCase = FieldName.forField("NpcRecoveryHPCase");

      static final FieldName hawkerCase = FieldName.forField("HawkerCase");

      static final FieldName strengthenMachineCase = FieldName.forField("StrengthenMachineCase");

      static final FieldName syncHPCase = FieldName.forField("SyncHPCase");

      static final FieldName nextPackage = FieldName.forField("NextPackage");
    }
  }

  /**
   * Protobuf type {@code BattleCaseData}
   */
  public static final class BattleCaseData extends ProtoMessage<BattleCaseData> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional uint32 SubNoteSkillNum = 3;</code>
     */
    private int subNoteSkillNum;

    /**
     * <code>optional bool TimeLimit = 1;</code>
     */
    private boolean timeLimit;

    /**
     * <code>optional bool FateCard = 2;</code>
     */
    private boolean fateCard;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    private BattleCaseData() {
    }

    /**
     * @return a new empty instance of {@code BattleCaseData}
     */
    public static BattleCaseData newInstance() {
      return new BattleCaseData();
    }

    /**
     * <code>optional uint32 SubNoteSkillNum = 3;</code>
     * @return whether the subNoteSkillNum field is set
     */
    public boolean hasSubNoteSkillNum() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional uint32 SubNoteSkillNum = 3;</code>
     * @return this
     */
    public BattleCaseData clearSubNoteSkillNum() {
      bitField0_ &= ~0x00000001;
      subNoteSkillNum = 0;
      return this;
    }

    /**
     * <code>optional uint32 SubNoteSkillNum = 3;</code>
     * @return the subNoteSkillNum
     */
    public int getSubNoteSkillNum() {
      return subNoteSkillNum;
    }

    /**
     * <code>optional uint32 SubNoteSkillNum = 3;</code>
     * @param value the subNoteSkillNum to set
     * @return this
     */
    public BattleCaseData setSubNoteSkillNum(final int value) {
      bitField0_ |= 0x00000001;
      subNoteSkillNum = value;
      return this;
    }

    /**
     * <code>optional bool TimeLimit = 1;</code>
     * @return whether the timeLimit field is set
     */
    public boolean hasTimeLimit() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional bool TimeLimit = 1;</code>
     * @return this
     */
    public BattleCaseData clearTimeLimit() {
      bitField0_ &= ~0x00000002;
      timeLimit = false;
      return this;
    }

    /**
     * <code>optional bool TimeLimit = 1;</code>
     * @return the timeLimit
     */
    public boolean getTimeLimit() {
      return timeLimit;
    }

    /**
     * <code>optional bool TimeLimit = 1;</code>
     * @param value the timeLimit to set
     * @return this
     */
    public BattleCaseData setTimeLimit(final boolean value) {
      bitField0_ |= 0x00000002;
      timeLimit = value;
      return this;
    }

    /**
     * <code>optional bool FateCard = 2;</code>
     * @return whether the fateCard field is set
     */
    public boolean hasFateCard() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional bool FateCard = 2;</code>
     * @return this
     */
    public BattleCaseData clearFateCard() {
      bitField0_ &= ~0x00000004;
      fateCard = false;
      return this;
    }

    /**
     * <code>optional bool FateCard = 2;</code>
     * @return the fateCard
     */
    public boolean getFateCard() {
      return fateCard;
    }

    /**
     * <code>optional bool FateCard = 2;</code>
     * @param value the fateCard to set
     * @return this
     */
    public BattleCaseData setFateCard(final boolean value) {
      bitField0_ |= 0x00000004;
      fateCard = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000008) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public BattleCaseData clearNextPackage() {
      bitField0_ &= ~0x00000008;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000008;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public BattleCaseData addNextPackage(final byte value) {
      bitField0_ |= 0x00000008;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public BattleCaseData addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000008;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public BattleCaseData setNextPackage(final byte... values) {
      bitField0_ |= 0x00000008;
      nextPackage.copyFrom(values);
      return this;
    }

    @Override
    public BattleCaseData copyFrom(final BattleCaseData other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        subNoteSkillNum = other.subNoteSkillNum;
        timeLimit = other.timeLimit;
        fateCard = other.fateCard;
        nextPackage.copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public BattleCaseData mergeFrom(final BattleCaseData other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasSubNoteSkillNum()) {
        setSubNoteSkillNum(other.subNoteSkillNum);
      }
      if (other.hasTimeLimit()) {
        setTimeLimit(other.timeLimit);
      }
      if (other.hasFateCard()) {
        setFateCard(other.fateCard);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public BattleCaseData clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      subNoteSkillNum = 0;
      timeLimit = false;
      fateCard = false;
      nextPackage.clear();
      return this;
    }

    @Override
    public BattleCaseData clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof BattleCaseData)) {
        return false;
      }
      BattleCaseData other = (BattleCaseData) o;
      return bitField0_ == other.bitField0_
        && (!hasSubNoteSkillNum() || subNoteSkillNum == other.subNoteSkillNum)
        && (!hasTimeLimit() || timeLimit == other.timeLimit)
        && (!hasFateCard() || fateCard == other.fateCard)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 24);
        output.writeUInt32NoTag(subNoteSkillNum);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 8);
        output.writeBoolNoTag(timeLimit);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawByte((byte) 16);
        output.writeBoolNoTag(fateCard);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(subNoteSkillNum);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 2;
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 2;
      }
      if ((bitField0_ & 0x00000008) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public BattleCaseData mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 24: {
            // subNoteSkillNum
            subNoteSkillNum = input.readUInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 8) {
              break;
            }
          }
          case 8: {
            // timeLimit
            timeLimit = input.readBool();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 16) {
              break;
            }
          }
          case 16: {
            // fateCard
            fateCard = input.readBool();
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000008;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeUInt32(FieldNames.subNoteSkillNum, subNoteSkillNum);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeBool(FieldNames.timeLimit, timeLimit);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeBool(FieldNames.fateCard, fateCard);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      output.endObject();
    }

    @Override
    public BattleCaseData mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 1170696135: {
            if (input.isAtField(FieldNames.subNoteSkillNum)) {
              if (!input.trySkipNullValue()) {
                subNoteSkillNum = input.readUInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 2022760654: {
            if (input.isAtField(FieldNames.timeLimit)) {
              if (!input.trySkipNullValue()) {
                timeLimit = input.readBool();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 1047532988: {
            if (input.isAtField(FieldNames.fateCard)) {
              if (!input.trySkipNullValue()) {
                fateCard = input.readBool();
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000008;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public BattleCaseData clone() {
      return new BattleCaseData().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static BattleCaseData parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new BattleCaseData(), data).checkInitialized();
    }

    public static BattleCaseData parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new BattleCaseData(), input).checkInitialized();
    }

    public static BattleCaseData parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new BattleCaseData(), input).checkInitialized();
    }

    /**
     * @return factory for creating BattleCaseData messages
     */
    public static MessageFactory<BattleCaseData> getFactory() {
      return BattleCaseDataFactory.INSTANCE;
    }

    private enum BattleCaseDataFactory implements MessageFactory<BattleCaseData> {
      INSTANCE;

      @Override
      public BattleCaseData create() {
        return BattleCaseData.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName subNoteSkillNum = FieldName.forField("SubNoteSkillNum");

      static final FieldName timeLimit = FieldName.forField("TimeLimit");

      static final FieldName fateCard = FieldName.forField("FateCard");

      static final FieldName nextPackage = FieldName.forField("NextPackage");
    }
  }

  /**
   * Protobuf type {@code DoorCaseData}
   */
  public static final class DoorCaseData extends ProtoMessage<DoorCaseData> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional uint32 Floor = 1;</code>
     */
    private int floor;

    /**
     * <code>optional uint32 Type = 2;</code>
     */
    private int type;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    private DoorCaseData() {
    }

    /**
     * @return a new empty instance of {@code DoorCaseData}
     */
    public static DoorCaseData newInstance() {
      return new DoorCaseData();
    }

    /**
     * <code>optional uint32 Floor = 1;</code>
     * @return whether the floor field is set
     */
    public boolean hasFloor() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional uint32 Floor = 1;</code>
     * @return this
     */
    public DoorCaseData clearFloor() {
      bitField0_ &= ~0x00000001;
      floor = 0;
      return this;
    }

    /**
     * <code>optional uint32 Floor = 1;</code>
     * @return the floor
     */
    public int getFloor() {
      return floor;
    }

    /**
     * <code>optional uint32 Floor = 1;</code>
     * @param value the floor to set
     * @return this
     */
    public DoorCaseData setFloor(final int value) {
      bitField0_ |= 0x00000001;
      floor = value;
      return this;
    }

    /**
     * <code>optional uint32 Type = 2;</code>
     * @return whether the type field is set
     */
    public boolean hasType() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional uint32 Type = 2;</code>
     * @return this
     */
    public DoorCaseData clearType() {
      bitField0_ &= ~0x00000002;
      type = 0;
      return this;
    }

    /**
     * <code>optional uint32 Type = 2;</code>
     * @return the type
     */
    public int getType() {
      return type;
    }

    /**
     * <code>optional uint32 Type = 2;</code>
     * @param value the type to set
     * @return this
     */
    public DoorCaseData setType(final int value) {
      bitField0_ |= 0x00000002;
      type = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public DoorCaseData clearNextPackage() {
      bitField0_ &= ~0x00000004;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000004;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public DoorCaseData addNextPackage(final byte value) {
      bitField0_ |= 0x00000004;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public DoorCaseData addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000004;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public DoorCaseData setNextPackage(final byte... values) {
      bitField0_ |= 0x00000004;
      nextPackage.copyFrom(values);
      return this;
    }

    @Override
    public DoorCaseData copyFrom(final DoorCaseData other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        floor = other.floor;
        type = other.type;
        nextPackage.copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public DoorCaseData mergeFrom(final DoorCaseData other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasFloor()) {
        setFloor(other.floor);
      }
      if (other.hasType()) {
        setType(other.type);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public DoorCaseData clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      floor = 0;
      type = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public DoorCaseData clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof DoorCaseData)) {
        return false;
      }
      DoorCaseData other = (DoorCaseData) o;
      return bitField0_ == other.bitField0_
        && (!hasFloor() || floor == other.floor)
        && (!hasType() || type == other.type)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt32NoTag(floor);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 16);
        output.writeUInt32NoTag(type);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(floor);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(type);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public DoorCaseData mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            // floor
            floor = input.readUInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 16) {
              break;
            }
          }
          case 16: {
            // type
            type = input.readUInt32();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeUInt32(FieldNames.floor, floor);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeUInt32(FieldNames.type, type);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      output.endObject();
    }

    @Override
    public DoorCaseData mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 67974124: {
            if (input.isAtField(FieldNames.floor)) {
              if (!input.trySkipNullValue()) {
                floor = input.readUInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 2622298: {
            if (input.isAtField(FieldNames.type)) {
              if (!input.trySkipNullValue()) {
                type = input.readUInt32();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public DoorCaseData clone() {
      return new DoorCaseData().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static DoorCaseData parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new DoorCaseData(), data).checkInitialized();
    }

    public static DoorCaseData parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new DoorCaseData(), input).checkInitialized();
    }

    public static DoorCaseData parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new DoorCaseData(), input).checkInitialized();
    }

    /**
     * @return factory for creating DoorCaseData messages
     */
    public static MessageFactory<DoorCaseData> getFactory() {
      return DoorCaseDataFactory.INSTANCE;
    }

    private enum DoorCaseDataFactory implements MessageFactory<DoorCaseData> {
      INSTANCE;

      @Override
      public DoorCaseData create() {
        return DoorCaseData.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName floor = FieldName.forField("Floor");

      static final FieldName type = FieldName.forField("Type");

      static final FieldName nextPackage = FieldName.forField("NextPackage");
    }
  }

  /**
   * Protobuf type {@code SelectSpecialPotentialCaseData}
   */
  public static final class SelectSpecialPotentialCaseData extends ProtoMessage<SelectSpecialPotentialCaseData> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional uint32 TeamLevel = 2;</code>
     */
    private int teamLevel;

    /**
     * <code>optional uint32 ReRollPrice = 8;</code>
     */
    private int reRollPrice;

    /**
     * <code>optional bool CanReRoll = 7;</code>
     */
    private boolean canReRoll;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    /**
     * <code>repeated uint32 Ids = 1;</code>
     */
    private final RepeatedInt ids = RepeatedInt.newEmptyInstance();

    /**
     * <code>repeated uint32 NewIds = 3;</code>
     */
    private final RepeatedInt newIds = RepeatedInt.newEmptyInstance();

    private SelectSpecialPotentialCaseData() {
    }

    /**
     * @return a new empty instance of {@code SelectSpecialPotentialCaseData}
     */
    public static SelectSpecialPotentialCaseData newInstance() {
      return new SelectSpecialPotentialCaseData();
    }

    /**
     * <code>optional uint32 TeamLevel = 2;</code>
     * @return whether the teamLevel field is set
     */
    public boolean hasTeamLevel() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional uint32 TeamLevel = 2;</code>
     * @return this
     */
    public SelectSpecialPotentialCaseData clearTeamLevel() {
      bitField0_ &= ~0x00000001;
      teamLevel = 0;
      return this;
    }

    /**
     * <code>optional uint32 TeamLevel = 2;</code>
     * @return the teamLevel
     */
    public int getTeamLevel() {
      return teamLevel;
    }

    /**
     * <code>optional uint32 TeamLevel = 2;</code>
     * @param value the teamLevel to set
     * @return this
     */
    public SelectSpecialPotentialCaseData setTeamLevel(final int value) {
      bitField0_ |= 0x00000001;
      teamLevel = value;
      return this;
    }

    /**
     * <code>optional uint32 ReRollPrice = 8;</code>
     * @return whether the reRollPrice field is set
     */
    public boolean hasReRollPrice() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional uint32 ReRollPrice = 8;</code>
     * @return this
     */
    public SelectSpecialPotentialCaseData clearReRollPrice() {
      bitField0_ &= ~0x00000002;
      reRollPrice = 0;
      return this;
    }

    /**
     * <code>optional uint32 ReRollPrice = 8;</code>
     * @return the reRollPrice
     */
    public int getReRollPrice() {
      return reRollPrice;
    }

    /**
     * <code>optional uint32 ReRollPrice = 8;</code>
     * @param value the reRollPrice to set
     * @return this
     */
    public SelectSpecialPotentialCaseData setReRollPrice(final int value) {
      bitField0_ |= 0x00000002;
      reRollPrice = value;
      return this;
    }

    /**
     * <code>optional bool CanReRoll = 7;</code>
     * @return whether the canReRoll field is set
     */
    public boolean hasCanReRoll() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional bool CanReRoll = 7;</code>
     * @return this
     */
    public SelectSpecialPotentialCaseData clearCanReRoll() {
      bitField0_ &= ~0x00000004;
      canReRoll = false;
      return this;
    }

    /**
     * <code>optional bool CanReRoll = 7;</code>
     * @return the canReRoll
     */
    public boolean getCanReRoll() {
      return canReRoll;
    }

    /**
     * <code>optional bool CanReRoll = 7;</code>
     * @param value the canReRoll to set
     * @return this
     */
    public SelectSpecialPotentialCaseData setCanReRoll(final boolean value) {
      bitField0_ |= 0x00000004;
      canReRoll = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000008) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public SelectSpecialPotentialCaseData clearNextPackage() {
      bitField0_ &= ~0x00000008;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000008;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public SelectSpecialPotentialCaseData addNextPackage(final byte value) {
      bitField0_ |= 0x00000008;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public SelectSpecialPotentialCaseData addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000008;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public SelectSpecialPotentialCaseData setNextPackage(final byte... values) {
      bitField0_ |= 0x00000008;
      nextPackage.copyFrom(values);
      return this;
    }

    /**
     * <code>repeated uint32 Ids = 1;</code>
     * @return whether the ids field is set
     */
    public boolean hasIds() {
      return (bitField0_ & 0x00000010) != 0;
    }

    /**
     * <code>repeated uint32 Ids = 1;</code>
     * @return this
     */
    public SelectSpecialPotentialCaseData clearIds() {
      bitField0_ &= ~0x00000010;
      ids.clear();
      return this;
    }

    /**
     * <code>repeated uint32 Ids = 1;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableIds()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedInt getIds() {
      return ids;
    }

    /**
     * <code>repeated uint32 Ids = 1;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedInt getMutableIds() {
      bitField0_ |= 0x00000010;
      return ids;
    }

    /**
     * <code>repeated uint32 Ids = 1;</code>
     * @param value the ids to add
     * @return this
     */
    public SelectSpecialPotentialCaseData addIds(final int value) {
      bitField0_ |= 0x00000010;
      ids.add(value);
      return this;
    }

    /**
     * <code>repeated uint32 Ids = 1;</code>
     * @param values the ids to add
     * @return this
     */
    public SelectSpecialPotentialCaseData addAllIds(final int... values) {
      bitField0_ |= 0x00000010;
      ids.addAll(values);
      return this;
    }

    /**
     * <code>repeated uint32 NewIds = 3;</code>
     * @return whether the newIds field is set
     */
    public boolean hasNewIds() {
      return (bitField0_ & 0x00000020) != 0;
    }

    /**
     * <code>repeated uint32 NewIds = 3;</code>
     * @return this
     */
    public SelectSpecialPotentialCaseData clearNewIds() {
      bitField0_ &= ~0x00000020;
      newIds.clear();
      return this;
    }

    /**
     * <code>repeated uint32 NewIds = 3;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNewIds()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedInt getNewIds() {
      return newIds;
    }

    /**
     * <code>repeated uint32 NewIds = 3;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedInt getMutableNewIds() {
      bitField0_ |= 0x00000020;
      return newIds;
    }

    /**
     * <code>repeated uint32 NewIds = 3;</code>
     * @param value the newIds to add
     * @return this
     */
    public SelectSpecialPotentialCaseData addNewIds(final int value) {
      bitField0_ |= 0x00000020;
      newIds.add(value);
      return this;
    }

    /**
     * <code>repeated uint32 NewIds = 3;</code>
     * @param values the newIds to add
     * @return this
     */
    public SelectSpecialPotentialCaseData addAllNewIds(final int... values) {
      bitField0_ |= 0x00000020;
      newIds.addAll(values);
      return this;
    }

    @Override
    public SelectSpecialPotentialCaseData copyFrom(final SelectSpecialPotentialCaseData other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        teamLevel = other.teamLevel;
        reRollPrice = other.reRollPrice;
        canReRoll = other.canReRoll;
        nextPackage.copyFrom(other.nextPackage);
        ids.copyFrom(other.ids);
        newIds.copyFrom(other.newIds);
      }
      return this;
    }

    @Override
    public SelectSpecialPotentialCaseData mergeFrom(final SelectSpecialPotentialCaseData other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasTeamLevel()) {
        setTeamLevel(other.teamLevel);
      }
      if (other.hasReRollPrice()) {
        setReRollPrice(other.reRollPrice);
      }
      if (other.hasCanReRoll()) {
        setCanReRoll(other.canReRoll);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      if (other.hasIds()) {
        getMutableIds().addAll(other.ids);
      }
      if (other.hasNewIds()) {
        getMutableNewIds().addAll(other.newIds);
      }
      return this;
    }

    @Override
    public SelectSpecialPotentialCaseData clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      teamLevel = 0;
      reRollPrice = 0;
      canReRoll = false;
      nextPackage.clear();
      ids.clear();
      newIds.clear();
      return this;
    }

    @Override
    public SelectSpecialPotentialCaseData clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      ids.clear();
      newIds.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof SelectSpecialPotentialCaseData)) {
        return false;
      }
      SelectSpecialPotentialCaseData other = (SelectSpecialPotentialCaseData) o;
      return bitField0_ == other.bitField0_
        && (!hasTeamLevel() || teamLevel == other.teamLevel)
        && (!hasReRollPrice() || reRollPrice == other.reRollPrice)
        && (!hasCanReRoll() || canReRoll == other.canReRoll)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage))
        && (!hasIds() || ids.equals(other.ids))
        && (!hasNewIds() || newIds.equals(other.newIds));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 16);
        output.writeUInt32NoTag(teamLevel);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 64);
        output.writeUInt32NoTag(reRollPrice);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawByte((byte) 56);
        output.writeBoolNoTag(canReRoll);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        for (int i = 0; i < ids.length(); i++) {
          output.writeRawByte((byte) 8);
          output.writeUInt32NoTag(ids.array()[i]);
        }
      }
      if ((bitField0_ & 0x00000020) != 0) {
        for (int i = 0; i < newIds.length(); i++) {
          output.writeRawByte((byte) 24);
          output.writeUInt32NoTag(newIds.array()[i]);
        }
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(teamLevel);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(reRollPrice);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 2;
      }
      if ((bitField0_ & 0x00000008) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        size += (1 * ids.length()) + ProtoSink.computeRepeatedUInt32SizeNoTag(ids);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        size += (1 * newIds.length()) + ProtoSink.computeRepeatedUInt32SizeNoTag(newIds);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public SelectSpecialPotentialCaseData mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 16: {
            // teamLevel
            teamLevel = input.readUInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 64) {
              break;
            }
          }
          case 64: {
            // reRollPrice
            reRollPrice = input.readUInt32();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 56) {
              break;
            }
          }
          case 56: {
            // canReRoll
            canReRoll = input.readBool();
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000008;
            tag = input.readTag();
            if (tag != 10) {
              break;
            }
          }
          case 10: {
            // ids [packed=true]
            input.readPackedUInt32(ids, tag);
            bitField0_ |= 0x00000010;
            tag = input.readTag();
            if (tag != 26) {
              break;
            }
          }
          case 26: {
            // newIds [packed=true]
            input.readPackedUInt32(newIds, tag);
            bitField0_ |= 0x00000020;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
          case 8: {
            // ids [packed=false]
            tag = input.readRepeatedUInt32(ids, tag);
            bitField0_ |= 0x00000010;
            break;
          }
          case 24: {
            // newIds [packed=false]
            tag = input.readRepeatedUInt32(newIds, tag);
            bitField0_ |= 0x00000020;
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeUInt32(FieldNames.teamLevel, teamLevel);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeUInt32(FieldNames.reRollPrice, reRollPrice);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeBool(FieldNames.canReRoll, canReRoll);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        output.writeRepeatedUInt32(FieldNames.ids, ids);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        output.writeRepeatedUInt32(FieldNames.newIds, newIds);
      }
      output.endObject();
    }

    @Override
    public SelectSpecialPotentialCaseData mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 1810266887: {
            if (input.isAtField(FieldNames.teamLevel)) {
              if (!input.trySkipNullValue()) {
                teamLevel = input.readUInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1462629959: {
            if (input.isAtField(FieldNames.reRollPrice)) {
              if (!input.trySkipNullValue()) {
                reRollPrice = input.readUInt32();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 1993089312: {
            if (input.isAtField(FieldNames.canReRoll)) {
              if (!input.trySkipNullValue()) {
                canReRoll = input.readBool();
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000008;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 73368: {
            if (input.isAtField(FieldNames.ids)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedUInt32(ids);
                bitField0_ |= 0x00000010;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1964999400: {
            if (input.isAtField(FieldNames.newIds)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedUInt32(newIds);
                bitField0_ |= 0x00000020;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public SelectSpecialPotentialCaseData clone() {
      return new SelectSpecialPotentialCaseData().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static SelectSpecialPotentialCaseData parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new SelectSpecialPotentialCaseData(), data).checkInitialized();
    }

    public static SelectSpecialPotentialCaseData parseFrom(final ProtoSource input) throws
        IOException {
      return ProtoMessage.mergeFrom(new SelectSpecialPotentialCaseData(), input).checkInitialized();
    }

    public static SelectSpecialPotentialCaseData parseFrom(final JsonSource input) throws
        IOException {
      return ProtoMessage.mergeFrom(new SelectSpecialPotentialCaseData(), input).checkInitialized();
    }

    /**
     * @return factory for creating SelectSpecialPotentialCaseData messages
     */
    public static MessageFactory<SelectSpecialPotentialCaseData> getFactory() {
      return SelectSpecialPotentialCaseDataFactory.INSTANCE;
    }

    private enum SelectSpecialPotentialCaseDataFactory implements MessageFactory<SelectSpecialPotentialCaseData> {
      INSTANCE;

      @Override
      public SelectSpecialPotentialCaseData create() {
        return SelectSpecialPotentialCaseData.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName teamLevel = FieldName.forField("TeamLevel");

      static final FieldName reRollPrice = FieldName.forField("ReRollPrice");

      static final FieldName canReRoll = FieldName.forField("CanReRoll");

      static final FieldName nextPackage = FieldName.forField("NextPackage");

      static final FieldName ids = FieldName.forField("Ids");

      static final FieldName newIds = FieldName.forField("NewIds");
    }
  }

  /**
   * Protobuf type {@code SelectPotentialCaseData}
   */
  public static final class SelectPotentialCaseData extends ProtoMessage<SelectPotentialCaseData> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional uint32 TeamLevel = 2;</code>
     */
    private int teamLevel;

    /**
     * <code>optional uint32 ReRollPrice = 14;</code>
     */
    private int reRollPrice;

    /**
     * <code>optional uint32 Type = 15;</code>
     */
    private int type;

    /**
     * <code>optional bool CanReRoll = 13;</code>
     */
    private boolean canReRoll;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    /**
     * <code>repeated uint32 NewIds = 3;</code>
     */
    private final RepeatedInt newIds = RepeatedInt.newEmptyInstance();

    /**
     * <code>repeated uint32 LuckyIds = 12;</code>
     */
    private final RepeatedInt luckyIds = RepeatedInt.newEmptyInstance();

    /**
     * <code>repeated .PotentialInfo Infos = 1;</code>
     */
    private final RepeatedMessage<PotentialInfo> infos = RepeatedMessage.newEmptyInstance(PotentialInfo.getFactory());

    private SelectPotentialCaseData() {
    }

    /**
     * @return a new empty instance of {@code SelectPotentialCaseData}
     */
    public static SelectPotentialCaseData newInstance() {
      return new SelectPotentialCaseData();
    }

    /**
     * <code>optional uint32 TeamLevel = 2;</code>
     * @return whether the teamLevel field is set
     */
    public boolean hasTeamLevel() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional uint32 TeamLevel = 2;</code>
     * @return this
     */
    public SelectPotentialCaseData clearTeamLevel() {
      bitField0_ &= ~0x00000001;
      teamLevel = 0;
      return this;
    }

    /**
     * <code>optional uint32 TeamLevel = 2;</code>
     * @return the teamLevel
     */
    public int getTeamLevel() {
      return teamLevel;
    }

    /**
     * <code>optional uint32 TeamLevel = 2;</code>
     * @param value the teamLevel to set
     * @return this
     */
    public SelectPotentialCaseData setTeamLevel(final int value) {
      bitField0_ |= 0x00000001;
      teamLevel = value;
      return this;
    }

    /**
     * <code>optional uint32 ReRollPrice = 14;</code>
     * @return whether the reRollPrice field is set
     */
    public boolean hasReRollPrice() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional uint32 ReRollPrice = 14;</code>
     * @return this
     */
    public SelectPotentialCaseData clearReRollPrice() {
      bitField0_ &= ~0x00000002;
      reRollPrice = 0;
      return this;
    }

    /**
     * <code>optional uint32 ReRollPrice = 14;</code>
     * @return the reRollPrice
     */
    public int getReRollPrice() {
      return reRollPrice;
    }

    /**
     * <code>optional uint32 ReRollPrice = 14;</code>
     * @param value the reRollPrice to set
     * @return this
     */
    public SelectPotentialCaseData setReRollPrice(final int value) {
      bitField0_ |= 0x00000002;
      reRollPrice = value;
      return this;
    }

    /**
     * <code>optional uint32 Type = 15;</code>
     * @return whether the type field is set
     */
    public boolean hasType() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional uint32 Type = 15;</code>
     * @return this
     */
    public SelectPotentialCaseData clearType() {
      bitField0_ &= ~0x00000004;
      type = 0;
      return this;
    }

    /**
     * <code>optional uint32 Type = 15;</code>
     * @return the type
     */
    public int getType() {
      return type;
    }

    /**
     * <code>optional uint32 Type = 15;</code>
     * @param value the type to set
     * @return this
     */
    public SelectPotentialCaseData setType(final int value) {
      bitField0_ |= 0x00000004;
      type = value;
      return this;
    }

    /**
     * <code>optional bool CanReRoll = 13;</code>
     * @return whether the canReRoll field is set
     */
    public boolean hasCanReRoll() {
      return (bitField0_ & 0x00000008) != 0;
    }

    /**
     * <code>optional bool CanReRoll = 13;</code>
     * @return this
     */
    public SelectPotentialCaseData clearCanReRoll() {
      bitField0_ &= ~0x00000008;
      canReRoll = false;
      return this;
    }

    /**
     * <code>optional bool CanReRoll = 13;</code>
     * @return the canReRoll
     */
    public boolean getCanReRoll() {
      return canReRoll;
    }

    /**
     * <code>optional bool CanReRoll = 13;</code>
     * @param value the canReRoll to set
     * @return this
     */
    public SelectPotentialCaseData setCanReRoll(final boolean value) {
      bitField0_ |= 0x00000008;
      canReRoll = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000010) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public SelectPotentialCaseData clearNextPackage() {
      bitField0_ &= ~0x00000010;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000010;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public SelectPotentialCaseData addNextPackage(final byte value) {
      bitField0_ |= 0x00000010;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public SelectPotentialCaseData addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000010;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public SelectPotentialCaseData setNextPackage(final byte... values) {
      bitField0_ |= 0x00000010;
      nextPackage.copyFrom(values);
      return this;
    }

    /**
     * <code>repeated uint32 NewIds = 3;</code>
     * @return whether the newIds field is set
     */
    public boolean hasNewIds() {
      return (bitField0_ & 0x00000020) != 0;
    }

    /**
     * <code>repeated uint32 NewIds = 3;</code>
     * @return this
     */
    public SelectPotentialCaseData clearNewIds() {
      bitField0_ &= ~0x00000020;
      newIds.clear();
      return this;
    }

    /**
     * <code>repeated uint32 NewIds = 3;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNewIds()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedInt getNewIds() {
      return newIds;
    }

    /**
     * <code>repeated uint32 NewIds = 3;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedInt getMutableNewIds() {
      bitField0_ |= 0x00000020;
      return newIds;
    }

    /**
     * <code>repeated uint32 NewIds = 3;</code>
     * @param value the newIds to add
     * @return this
     */
    public SelectPotentialCaseData addNewIds(final int value) {
      bitField0_ |= 0x00000020;
      newIds.add(value);
      return this;
    }

    /**
     * <code>repeated uint32 NewIds = 3;</code>
     * @param values the newIds to add
     * @return this
     */
    public SelectPotentialCaseData addAllNewIds(final int... values) {
      bitField0_ |= 0x00000020;
      newIds.addAll(values);
      return this;
    }

    /**
     * <code>repeated uint32 LuckyIds = 12;</code>
     * @return whether the luckyIds field is set
     */
    public boolean hasLuckyIds() {
      return (bitField0_ & 0x00000040) != 0;
    }

    /**
     * <code>repeated uint32 LuckyIds = 12;</code>
     * @return this
     */
    public SelectPotentialCaseData clearLuckyIds() {
      bitField0_ &= ~0x00000040;
      luckyIds.clear();
      return this;
    }

    /**
     * <code>repeated uint32 LuckyIds = 12;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableLuckyIds()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedInt getLuckyIds() {
      return luckyIds;
    }

    /**
     * <code>repeated uint32 LuckyIds = 12;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedInt getMutableLuckyIds() {
      bitField0_ |= 0x00000040;
      return luckyIds;
    }

    /**
     * <code>repeated uint32 LuckyIds = 12;</code>
     * @param value the luckyIds to add
     * @return this
     */
    public SelectPotentialCaseData addLuckyIds(final int value) {
      bitField0_ |= 0x00000040;
      luckyIds.add(value);
      return this;
    }

    /**
     * <code>repeated uint32 LuckyIds = 12;</code>
     * @param values the luckyIds to add
     * @return this
     */
    public SelectPotentialCaseData addAllLuckyIds(final int... values) {
      bitField0_ |= 0x00000040;
      luckyIds.addAll(values);
      return this;
    }

    /**
     * <code>repeated .PotentialInfo Infos = 1;</code>
     * @return whether the infos field is set
     */
    public boolean hasInfos() {
      return (bitField0_ & 0x00000080) != 0;
    }

    /**
     * <code>repeated .PotentialInfo Infos = 1;</code>
     * @return this
     */
    public SelectPotentialCaseData clearInfos() {
      bitField0_ &= ~0x00000080;
      infos.clear();
      return this;
    }

    /**
     * <code>repeated .PotentialInfo Infos = 1;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableInfos()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<PotentialInfo> getInfos() {
      return infos;
    }

    /**
     * <code>repeated .PotentialInfo Infos = 1;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<PotentialInfo> getMutableInfos() {
      bitField0_ |= 0x00000080;
      return infos;
    }

    /**
     * <code>repeated .PotentialInfo Infos = 1;</code>
     * @param value the infos to add
     * @return this
     */
    public SelectPotentialCaseData addInfos(final PotentialInfo value) {
      bitField0_ |= 0x00000080;
      infos.add(value);
      return this;
    }

    /**
     * <code>repeated .PotentialInfo Infos = 1;</code>
     * @param values the infos to add
     * @return this
     */
    public SelectPotentialCaseData addAllInfos(final PotentialInfo... values) {
      bitField0_ |= 0x00000080;
      infos.addAll(values);
      return this;
    }

    @Override
    public SelectPotentialCaseData copyFrom(final SelectPotentialCaseData other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        teamLevel = other.teamLevel;
        reRollPrice = other.reRollPrice;
        type = other.type;
        canReRoll = other.canReRoll;
        nextPackage.copyFrom(other.nextPackage);
        newIds.copyFrom(other.newIds);
        luckyIds.copyFrom(other.luckyIds);
        infos.copyFrom(other.infos);
      }
      return this;
    }

    @Override
    public SelectPotentialCaseData mergeFrom(final SelectPotentialCaseData other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasTeamLevel()) {
        setTeamLevel(other.teamLevel);
      }
      if (other.hasReRollPrice()) {
        setReRollPrice(other.reRollPrice);
      }
      if (other.hasType()) {
        setType(other.type);
      }
      if (other.hasCanReRoll()) {
        setCanReRoll(other.canReRoll);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      if (other.hasNewIds()) {
        getMutableNewIds().addAll(other.newIds);
      }
      if (other.hasLuckyIds()) {
        getMutableLuckyIds().addAll(other.luckyIds);
      }
      if (other.hasInfos()) {
        getMutableInfos().addAll(other.infos);
      }
      return this;
    }

    @Override
    public SelectPotentialCaseData clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      teamLevel = 0;
      reRollPrice = 0;
      type = 0;
      canReRoll = false;
      nextPackage.clear();
      newIds.clear();
      luckyIds.clear();
      infos.clear();
      return this;
    }

    @Override
    public SelectPotentialCaseData clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      newIds.clear();
      luckyIds.clear();
      infos.clearQuick();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof SelectPotentialCaseData)) {
        return false;
      }
      SelectPotentialCaseData other = (SelectPotentialCaseData) o;
      return bitField0_ == other.bitField0_
        && (!hasTeamLevel() || teamLevel == other.teamLevel)
        && (!hasReRollPrice() || reRollPrice == other.reRollPrice)
        && (!hasType() || type == other.type)
        && (!hasCanReRoll() || canReRoll == other.canReRoll)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage))
        && (!hasNewIds() || newIds.equals(other.newIds))
        && (!hasLuckyIds() || luckyIds.equals(other.luckyIds))
        && (!hasInfos() || infos.equals(other.infos));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 16);
        output.writeUInt32NoTag(teamLevel);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 112);
        output.writeUInt32NoTag(reRollPrice);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawByte((byte) 120);
        output.writeUInt32NoTag(type);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeRawByte((byte) 104);
        output.writeBoolNoTag(canReRoll);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        for (int i = 0; i < newIds.length(); i++) {
          output.writeRawByte((byte) 24);
          output.writeUInt32NoTag(newIds.array()[i]);
        }
      }
      if ((bitField0_ & 0x00000040) != 0) {
        for (int i = 0; i < luckyIds.length(); i++) {
          output.writeRawByte((byte) 96);
          output.writeUInt32NoTag(luckyIds.array()[i]);
        }
      }
      if ((bitField0_ & 0x00000080) != 0) {
        for (int i = 0; i < infos.length(); i++) {
          output.writeRawByte((byte) 10);
          output.writeMessageNoTag(infos.get(i));
        }
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(teamLevel);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(reRollPrice);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(type);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        size += 2;
      }
      if ((bitField0_ & 0x00000010) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        size += (1 * newIds.length()) + ProtoSink.computeRepeatedUInt32SizeNoTag(newIds);
      }
      if ((bitField0_ & 0x00000040) != 0) {
        size += (1 * luckyIds.length()) + ProtoSink.computeRepeatedUInt32SizeNoTag(luckyIds);
      }
      if ((bitField0_ & 0x00000080) != 0) {
        size += (1 * infos.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(infos);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public SelectPotentialCaseData mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 16: {
            // teamLevel
            teamLevel = input.readUInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 112) {
              break;
            }
          }
          case 112: {
            // reRollPrice
            reRollPrice = input.readUInt32();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 120) {
              break;
            }
          }
          case 120: {
            // type
            type = input.readUInt32();
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 104) {
              break;
            }
          }
          case 104: {
            // canReRoll
            canReRoll = input.readBool();
            bitField0_ |= 0x00000008;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000010;
            tag = input.readTag();
            if (tag != 26) {
              break;
            }
          }
          case 26: {
            // newIds [packed=true]
            input.readPackedUInt32(newIds, tag);
            bitField0_ |= 0x00000020;
            tag = input.readTag();
            if (tag != 98) {
              break;
            }
          }
          case 98: {
            // luckyIds [packed=true]
            input.readPackedUInt32(luckyIds, tag);
            bitField0_ |= 0x00000040;
            tag = input.readTag();
            if (tag != 10) {
              break;
            }
          }
          case 10: {
            // infos
            tag = input.readRepeatedMessage(infos, tag);
            bitField0_ |= 0x00000080;
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
          case 24: {
            // newIds [packed=false]
            tag = input.readRepeatedUInt32(newIds, tag);
            bitField0_ |= 0x00000020;
            break;
          }
          case 96: {
            // luckyIds [packed=false]
            tag = input.readRepeatedUInt32(luckyIds, tag);
            bitField0_ |= 0x00000040;
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeUInt32(FieldNames.teamLevel, teamLevel);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeUInt32(FieldNames.reRollPrice, reRollPrice);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeUInt32(FieldNames.type, type);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeBool(FieldNames.canReRoll, canReRoll);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        output.writeRepeatedUInt32(FieldNames.newIds, newIds);
      }
      if ((bitField0_ & 0x00000040) != 0) {
        output.writeRepeatedUInt32(FieldNames.luckyIds, luckyIds);
      }
      if ((bitField0_ & 0x00000080) != 0) {
        output.writeRepeatedMessage(FieldNames.infos, infos);
      }
      output.endObject();
    }

    @Override
    public SelectPotentialCaseData mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 1810266887: {
            if (input.isAtField(FieldNames.teamLevel)) {
              if (!input.trySkipNullValue()) {
                teamLevel = input.readUInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1462629959: {
            if (input.isAtField(FieldNames.reRollPrice)) {
              if (!input.trySkipNullValue()) {
                reRollPrice = input.readUInt32();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 2622298: {
            if (input.isAtField(FieldNames.type)) {
              if (!input.trySkipNullValue()) {
                type = input.readUInt32();
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 1993089312: {
            if (input.isAtField(FieldNames.canReRoll)) {
              if (!input.trySkipNullValue()) {
                canReRoll = input.readBool();
                bitField0_ |= 0x00000008;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000010;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1964999400: {
            if (input.isAtField(FieldNames.newIds)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedUInt32(newIds);
                bitField0_ |= 0x00000020;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1289871664: {
            if (input.isAtField(FieldNames.luckyIds)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedUInt32(luckyIds);
                bitField0_ |= 0x00000040;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 70795621: {
            if (input.isAtField(FieldNames.infos)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedMessage(infos);
                bitField0_ |= 0x00000080;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public SelectPotentialCaseData clone() {
      return new SelectPotentialCaseData().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static SelectPotentialCaseData parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new SelectPotentialCaseData(), data).checkInitialized();
    }

    public static SelectPotentialCaseData parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new SelectPotentialCaseData(), input).checkInitialized();
    }

    public static SelectPotentialCaseData parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new SelectPotentialCaseData(), input).checkInitialized();
    }

    /**
     * @return factory for creating SelectPotentialCaseData messages
     */
    public static MessageFactory<SelectPotentialCaseData> getFactory() {
      return SelectPotentialCaseDataFactory.INSTANCE;
    }

    private enum SelectPotentialCaseDataFactory implements MessageFactory<SelectPotentialCaseData> {
      INSTANCE;

      @Override
      public SelectPotentialCaseData create() {
        return SelectPotentialCaseData.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName teamLevel = FieldName.forField("TeamLevel");

      static final FieldName reRollPrice = FieldName.forField("ReRollPrice");

      static final FieldName type = FieldName.forField("Type");

      static final FieldName canReRoll = FieldName.forField("CanReRoll");

      static final FieldName nextPackage = FieldName.forField("NextPackage");

      static final FieldName newIds = FieldName.forField("NewIds");

      static final FieldName luckyIds = FieldName.forField("LuckyIds");

      static final FieldName infos = FieldName.forField("Infos");
    }
  }

  /**
   * Protobuf type {@code SelectOptionsEventCaseData}
   */
  public static final class SelectOptionsEventCaseData extends ProtoMessage<SelectOptionsEventCaseData> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional uint32 EvtId = 1;</code>
     */
    private int evtId;

    /**
     * <code>optional uint32 NPCId = 4;</code>
     */
    private int nPCId;

    /**
     * <code>optional bool Done = 5;</code>
     */
    private boolean done;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    /**
     * <code>repeated uint32 Options = 2;</code>
     */
    private final RepeatedInt options = RepeatedInt.newEmptyInstance();

    /**
     * <code>repeated uint32 FailedIdxes = 3;</code>
     */
    private final RepeatedInt failedIdxes = RepeatedInt.newEmptyInstance();

    /**
     * <code>repeated .NPCAffinityInfo Infos = 6;</code>
     */
    private final RepeatedMessage<NPCAffinityInfo> infos = RepeatedMessage.newEmptyInstance(NPCAffinityInfo.getFactory());

    private SelectOptionsEventCaseData() {
    }

    /**
     * @return a new empty instance of {@code SelectOptionsEventCaseData}
     */
    public static SelectOptionsEventCaseData newInstance() {
      return new SelectOptionsEventCaseData();
    }

    /**
     * <code>optional uint32 EvtId = 1;</code>
     * @return whether the evtId field is set
     */
    public boolean hasEvtId() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional uint32 EvtId = 1;</code>
     * @return this
     */
    public SelectOptionsEventCaseData clearEvtId() {
      bitField0_ &= ~0x00000001;
      evtId = 0;
      return this;
    }

    /**
     * <code>optional uint32 EvtId = 1;</code>
     * @return the evtId
     */
    public int getEvtId() {
      return evtId;
    }

    /**
     * <code>optional uint32 EvtId = 1;</code>
     * @param value the evtId to set
     * @return this
     */
    public SelectOptionsEventCaseData setEvtId(final int value) {
      bitField0_ |= 0x00000001;
      evtId = value;
      return this;
    }

    /**
     * <code>optional uint32 NPCId = 4;</code>
     * @return whether the nPCId field is set
     */
    public boolean hasNPCId() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional uint32 NPCId = 4;</code>
     * @return this
     */
    public SelectOptionsEventCaseData clearNPCId() {
      bitField0_ &= ~0x00000002;
      nPCId = 0;
      return this;
    }

    /**
     * <code>optional uint32 NPCId = 4;</code>
     * @return the nPCId
     */
    public int getNPCId() {
      return nPCId;
    }

    /**
     * <code>optional uint32 NPCId = 4;</code>
     * @param value the nPCId to set
     * @return this
     */
    public SelectOptionsEventCaseData setNPCId(final int value) {
      bitField0_ |= 0x00000002;
      nPCId = value;
      return this;
    }

    /**
     * <code>optional bool Done = 5;</code>
     * @return whether the done field is set
     */
    public boolean hasDone() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional bool Done = 5;</code>
     * @return this
     */
    public SelectOptionsEventCaseData clearDone() {
      bitField0_ &= ~0x00000004;
      done = false;
      return this;
    }

    /**
     * <code>optional bool Done = 5;</code>
     * @return the done
     */
    public boolean getDone() {
      return done;
    }

    /**
     * <code>optional bool Done = 5;</code>
     * @param value the done to set
     * @return this
     */
    public SelectOptionsEventCaseData setDone(final boolean value) {
      bitField0_ |= 0x00000004;
      done = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000008) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public SelectOptionsEventCaseData clearNextPackage() {
      bitField0_ &= ~0x00000008;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000008;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public SelectOptionsEventCaseData addNextPackage(final byte value) {
      bitField0_ |= 0x00000008;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public SelectOptionsEventCaseData addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000008;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public SelectOptionsEventCaseData setNextPackage(final byte... values) {
      bitField0_ |= 0x00000008;
      nextPackage.copyFrom(values);
      return this;
    }

    /**
     * <code>repeated uint32 Options = 2;</code>
     * @return whether the options field is set
     */
    public boolean hasOptions() {
      return (bitField0_ & 0x00000010) != 0;
    }

    /**
     * <code>repeated uint32 Options = 2;</code>
     * @return this
     */
    public SelectOptionsEventCaseData clearOptions() {
      bitField0_ &= ~0x00000010;
      options.clear();
      return this;
    }

    /**
     * <code>repeated uint32 Options = 2;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableOptions()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedInt getOptions() {
      return options;
    }

    /**
     * <code>repeated uint32 Options = 2;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedInt getMutableOptions() {
      bitField0_ |= 0x00000010;
      return options;
    }

    /**
     * <code>repeated uint32 Options = 2;</code>
     * @param value the options to add
     * @return this
     */
    public SelectOptionsEventCaseData addOptions(final int value) {
      bitField0_ |= 0x00000010;
      options.add(value);
      return this;
    }

    /**
     * <code>repeated uint32 Options = 2;</code>
     * @param values the options to add
     * @return this
     */
    public SelectOptionsEventCaseData addAllOptions(final int... values) {
      bitField0_ |= 0x00000010;
      options.addAll(values);
      return this;
    }

    /**
     * <code>repeated uint32 FailedIdxes = 3;</code>
     * @return whether the failedIdxes field is set
     */
    public boolean hasFailedIdxes() {
      return (bitField0_ & 0x00000020) != 0;
    }

    /**
     * <code>repeated uint32 FailedIdxes = 3;</code>
     * @return this
     */
    public SelectOptionsEventCaseData clearFailedIdxes() {
      bitField0_ &= ~0x00000020;
      failedIdxes.clear();
      return this;
    }

    /**
     * <code>repeated uint32 FailedIdxes = 3;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableFailedIdxes()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedInt getFailedIdxes() {
      return failedIdxes;
    }

    /**
     * <code>repeated uint32 FailedIdxes = 3;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedInt getMutableFailedIdxes() {
      bitField0_ |= 0x00000020;
      return failedIdxes;
    }

    /**
     * <code>repeated uint32 FailedIdxes = 3;</code>
     * @param value the failedIdxes to add
     * @return this
     */
    public SelectOptionsEventCaseData addFailedIdxes(final int value) {
      bitField0_ |= 0x00000020;
      failedIdxes.add(value);
      return this;
    }

    /**
     * <code>repeated uint32 FailedIdxes = 3;</code>
     * @param values the failedIdxes to add
     * @return this
     */
    public SelectOptionsEventCaseData addAllFailedIdxes(final int... values) {
      bitField0_ |= 0x00000020;
      failedIdxes.addAll(values);
      return this;
    }

    /**
     * <code>repeated .NPCAffinityInfo Infos = 6;</code>
     * @return whether the infos field is set
     */
    public boolean hasInfos() {
      return (bitField0_ & 0x00000040) != 0;
    }

    /**
     * <code>repeated .NPCAffinityInfo Infos = 6;</code>
     * @return this
     */
    public SelectOptionsEventCaseData clearInfos() {
      bitField0_ &= ~0x00000040;
      infos.clear();
      return this;
    }

    /**
     * <code>repeated .NPCAffinityInfo Infos = 6;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableInfos()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<NPCAffinityInfo> getInfos() {
      return infos;
    }

    /**
     * <code>repeated .NPCAffinityInfo Infos = 6;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<NPCAffinityInfo> getMutableInfos() {
      bitField0_ |= 0x00000040;
      return infos;
    }

    /**
     * <code>repeated .NPCAffinityInfo Infos = 6;</code>
     * @param value the infos to add
     * @return this
     */
    public SelectOptionsEventCaseData addInfos(final NPCAffinityInfo value) {
      bitField0_ |= 0x00000040;
      infos.add(value);
      return this;
    }

    /**
     * <code>repeated .NPCAffinityInfo Infos = 6;</code>
     * @param values the infos to add
     * @return this
     */
    public SelectOptionsEventCaseData addAllInfos(final NPCAffinityInfo... values) {
      bitField0_ |= 0x00000040;
      infos.addAll(values);
      return this;
    }

    @Override
    public SelectOptionsEventCaseData copyFrom(final SelectOptionsEventCaseData other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        evtId = other.evtId;
        nPCId = other.nPCId;
        done = other.done;
        nextPackage.copyFrom(other.nextPackage);
        options.copyFrom(other.options);
        failedIdxes.copyFrom(other.failedIdxes);
        infos.copyFrom(other.infos);
      }
      return this;
    }

    @Override
    public SelectOptionsEventCaseData mergeFrom(final SelectOptionsEventCaseData other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasEvtId()) {
        setEvtId(other.evtId);
      }
      if (other.hasNPCId()) {
        setNPCId(other.nPCId);
      }
      if (other.hasDone()) {
        setDone(other.done);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      if (other.hasOptions()) {
        getMutableOptions().addAll(other.options);
      }
      if (other.hasFailedIdxes()) {
        getMutableFailedIdxes().addAll(other.failedIdxes);
      }
      if (other.hasInfos()) {
        getMutableInfos().addAll(other.infos);
      }
      return this;
    }

    @Override
    public SelectOptionsEventCaseData clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      evtId = 0;
      nPCId = 0;
      done = false;
      nextPackage.clear();
      options.clear();
      failedIdxes.clear();
      infos.clear();
      return this;
    }

    @Override
    public SelectOptionsEventCaseData clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      options.clear();
      failedIdxes.clear();
      infos.clearQuick();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof SelectOptionsEventCaseData)) {
        return false;
      }
      SelectOptionsEventCaseData other = (SelectOptionsEventCaseData) o;
      return bitField0_ == other.bitField0_
        && (!hasEvtId() || evtId == other.evtId)
        && (!hasNPCId() || nPCId == other.nPCId)
        && (!hasDone() || done == other.done)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage))
        && (!hasOptions() || options.equals(other.options))
        && (!hasFailedIdxes() || failedIdxes.equals(other.failedIdxes))
        && (!hasInfos() || infos.equals(other.infos));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt32NoTag(evtId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 32);
        output.writeUInt32NoTag(nPCId);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawByte((byte) 40);
        output.writeBoolNoTag(done);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        for (int i = 0; i < options.length(); i++) {
          output.writeRawByte((byte) 16);
          output.writeUInt32NoTag(options.array()[i]);
        }
      }
      if ((bitField0_ & 0x00000020) != 0) {
        for (int i = 0; i < failedIdxes.length(); i++) {
          output.writeRawByte((byte) 24);
          output.writeUInt32NoTag(failedIdxes.array()[i]);
        }
      }
      if ((bitField0_ & 0x00000040) != 0) {
        for (int i = 0; i < infos.length(); i++) {
          output.writeRawByte((byte) 50);
          output.writeMessageNoTag(infos.get(i));
        }
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(evtId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(nPCId);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 2;
      }
      if ((bitField0_ & 0x00000008) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        size += (1 * options.length()) + ProtoSink.computeRepeatedUInt32SizeNoTag(options);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        size += (1 * failedIdxes.length()) + ProtoSink.computeRepeatedUInt32SizeNoTag(failedIdxes);
      }
      if ((bitField0_ & 0x00000040) != 0) {
        size += (1 * infos.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(infos);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public SelectOptionsEventCaseData mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            // evtId
            evtId = input.readUInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 32) {
              break;
            }
          }
          case 32: {
            // nPCId
            nPCId = input.readUInt32();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 40) {
              break;
            }
          }
          case 40: {
            // done
            done = input.readBool();
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000008;
            tag = input.readTag();
            if (tag != 18) {
              break;
            }
          }
          case 18: {
            // options [packed=true]
            input.readPackedUInt32(options, tag);
            bitField0_ |= 0x00000010;
            tag = input.readTag();
            if (tag != 26) {
              break;
            }
          }
          case 26: {
            // failedIdxes [packed=true]
            input.readPackedUInt32(failedIdxes, tag);
            bitField0_ |= 0x00000020;
            tag = input.readTag();
            if (tag != 50) {
              break;
            }
          }
          case 50: {
            // infos
            tag = input.readRepeatedMessage(infos, tag);
            bitField0_ |= 0x00000040;
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
          case 16: {
            // options [packed=false]
            tag = input.readRepeatedUInt32(options, tag);
            bitField0_ |= 0x00000010;
            break;
          }
          case 24: {
            // failedIdxes [packed=false]
            tag = input.readRepeatedUInt32(failedIdxes, tag);
            bitField0_ |= 0x00000020;
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeUInt32(FieldNames.evtId, evtId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeUInt32(FieldNames.nPCId, nPCId);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeBool(FieldNames.done, done);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        output.writeRepeatedUInt32(FieldNames.options, options);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        output.writeRepeatedUInt32(FieldNames.failedIdxes, failedIdxes);
      }
      if ((bitField0_ & 0x00000040) != 0) {
        output.writeRepeatedMessage(FieldNames.infos, infos);
      }
      output.endObject();
    }

    @Override
    public SelectOptionsEventCaseData mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 67352126: {
            if (input.isAtField(FieldNames.evtId)) {
              if (!input.trySkipNullValue()) {
                evtId = input.readUInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 74484668: {
            if (input.isAtField(FieldNames.nPCId)) {
              if (!input.trySkipNullValue()) {
                nPCId = input.readUInt32();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 2135970: {
            if (input.isAtField(FieldNames.done)) {
              if (!input.trySkipNullValue()) {
                done = input.readBool();
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000008;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 415178366: {
            if (input.isAtField(FieldNames.options)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedUInt32(options);
                bitField0_ |= 0x00000010;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 1998268878: {
            if (input.isAtField(FieldNames.failedIdxes)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedUInt32(failedIdxes);
                bitField0_ |= 0x00000020;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 70795621: {
            if (input.isAtField(FieldNames.infos)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedMessage(infos);
                bitField0_ |= 0x00000040;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public SelectOptionsEventCaseData clone() {
      return new SelectOptionsEventCaseData().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static SelectOptionsEventCaseData parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new SelectOptionsEventCaseData(), data).checkInitialized();
    }

    public static SelectOptionsEventCaseData parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new SelectOptionsEventCaseData(), input).checkInitialized();
    }

    public static SelectOptionsEventCaseData parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new SelectOptionsEventCaseData(), input).checkInitialized();
    }

    /**
     * @return factory for creating SelectOptionsEventCaseData messages
     */
    public static MessageFactory<SelectOptionsEventCaseData> getFactory() {
      return SelectOptionsEventCaseDataFactory.INSTANCE;
    }

    private enum SelectOptionsEventCaseDataFactory implements MessageFactory<SelectOptionsEventCaseData> {
      INSTANCE;

      @Override
      public SelectOptionsEventCaseData create() {
        return SelectOptionsEventCaseData.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName evtId = FieldName.forField("EvtId");

      static final FieldName nPCId = FieldName.forField("NPCId");

      static final FieldName done = FieldName.forField("Done");

      static final FieldName nextPackage = FieldName.forField("NextPackage");

      static final FieldName options = FieldName.forField("Options");

      static final FieldName failedIdxes = FieldName.forField("FailedIdxes");

      static final FieldName infos = FieldName.forField("Infos");
    }
  }

  /**
   * Protobuf type {@code SelectFateCardCaseData}
   */
  public static final class SelectFateCardCaseData extends ProtoMessage<SelectFateCardCaseData> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional uint32 ReRollPrice = 8;</code>
     */
    private int reRollPrice;

    /**
     * <code>optional bool Give = 3;</code>
     */
    private boolean give;

    /**
     * <code>optional bool CanReRoll = 7;</code>
     */
    private boolean canReRoll;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    /**
     * <code>repeated uint32 Ids = 1;</code>
     */
    private final RepeatedInt ids = RepeatedInt.newEmptyInstance();

    /**
     * <code>repeated uint32 NewIds = 2;</code>
     */
    private final RepeatedInt newIds = RepeatedInt.newEmptyInstance();

    private SelectFateCardCaseData() {
    }

    /**
     * @return a new empty instance of {@code SelectFateCardCaseData}
     */
    public static SelectFateCardCaseData newInstance() {
      return new SelectFateCardCaseData();
    }

    /**
     * <code>optional uint32 ReRollPrice = 8;</code>
     * @return whether the reRollPrice field is set
     */
    public boolean hasReRollPrice() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional uint32 ReRollPrice = 8;</code>
     * @return this
     */
    public SelectFateCardCaseData clearReRollPrice() {
      bitField0_ &= ~0x00000001;
      reRollPrice = 0;
      return this;
    }

    /**
     * <code>optional uint32 ReRollPrice = 8;</code>
     * @return the reRollPrice
     */
    public int getReRollPrice() {
      return reRollPrice;
    }

    /**
     * <code>optional uint32 ReRollPrice = 8;</code>
     * @param value the reRollPrice to set
     * @return this
     */
    public SelectFateCardCaseData setReRollPrice(final int value) {
      bitField0_ |= 0x00000001;
      reRollPrice = value;
      return this;
    }

    /**
     * <code>optional bool Give = 3;</code>
     * @return whether the give field is set
     */
    public boolean hasGive() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional bool Give = 3;</code>
     * @return this
     */
    public SelectFateCardCaseData clearGive() {
      bitField0_ &= ~0x00000002;
      give = false;
      return this;
    }

    /**
     * <code>optional bool Give = 3;</code>
     * @return the give
     */
    public boolean getGive() {
      return give;
    }

    /**
     * <code>optional bool Give = 3;</code>
     * @param value the give to set
     * @return this
     */
    public SelectFateCardCaseData setGive(final boolean value) {
      bitField0_ |= 0x00000002;
      give = value;
      return this;
    }

    /**
     * <code>optional bool CanReRoll = 7;</code>
     * @return whether the canReRoll field is set
     */
    public boolean hasCanReRoll() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional bool CanReRoll = 7;</code>
     * @return this
     */
    public SelectFateCardCaseData clearCanReRoll() {
      bitField0_ &= ~0x00000004;
      canReRoll = false;
      return this;
    }

    /**
     * <code>optional bool CanReRoll = 7;</code>
     * @return the canReRoll
     */
    public boolean getCanReRoll() {
      return canReRoll;
    }

    /**
     * <code>optional bool CanReRoll = 7;</code>
     * @param value the canReRoll to set
     * @return this
     */
    public SelectFateCardCaseData setCanReRoll(final boolean value) {
      bitField0_ |= 0x00000004;
      canReRoll = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000008) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public SelectFateCardCaseData clearNextPackage() {
      bitField0_ &= ~0x00000008;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000008;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public SelectFateCardCaseData addNextPackage(final byte value) {
      bitField0_ |= 0x00000008;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public SelectFateCardCaseData addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000008;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public SelectFateCardCaseData setNextPackage(final byte... values) {
      bitField0_ |= 0x00000008;
      nextPackage.copyFrom(values);
      return this;
    }

    /**
     * <code>repeated uint32 Ids = 1;</code>
     * @return whether the ids field is set
     */
    public boolean hasIds() {
      return (bitField0_ & 0x00000010) != 0;
    }

    /**
     * <code>repeated uint32 Ids = 1;</code>
     * @return this
     */
    public SelectFateCardCaseData clearIds() {
      bitField0_ &= ~0x00000010;
      ids.clear();
      return this;
    }

    /**
     * <code>repeated uint32 Ids = 1;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableIds()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedInt getIds() {
      return ids;
    }

    /**
     * <code>repeated uint32 Ids = 1;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedInt getMutableIds() {
      bitField0_ |= 0x00000010;
      return ids;
    }

    /**
     * <code>repeated uint32 Ids = 1;</code>
     * @param value the ids to add
     * @return this
     */
    public SelectFateCardCaseData addIds(final int value) {
      bitField0_ |= 0x00000010;
      ids.add(value);
      return this;
    }

    /**
     * <code>repeated uint32 Ids = 1;</code>
     * @param values the ids to add
     * @return this
     */
    public SelectFateCardCaseData addAllIds(final int... values) {
      bitField0_ |= 0x00000010;
      ids.addAll(values);
      return this;
    }

    /**
     * <code>repeated uint32 NewIds = 2;</code>
     * @return whether the newIds field is set
     */
    public boolean hasNewIds() {
      return (bitField0_ & 0x00000020) != 0;
    }

    /**
     * <code>repeated uint32 NewIds = 2;</code>
     * @return this
     */
    public SelectFateCardCaseData clearNewIds() {
      bitField0_ &= ~0x00000020;
      newIds.clear();
      return this;
    }

    /**
     * <code>repeated uint32 NewIds = 2;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNewIds()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedInt getNewIds() {
      return newIds;
    }

    /**
     * <code>repeated uint32 NewIds = 2;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedInt getMutableNewIds() {
      bitField0_ |= 0x00000020;
      return newIds;
    }

    /**
     * <code>repeated uint32 NewIds = 2;</code>
     * @param value the newIds to add
     * @return this
     */
    public SelectFateCardCaseData addNewIds(final int value) {
      bitField0_ |= 0x00000020;
      newIds.add(value);
      return this;
    }

    /**
     * <code>repeated uint32 NewIds = 2;</code>
     * @param values the newIds to add
     * @return this
     */
    public SelectFateCardCaseData addAllNewIds(final int... values) {
      bitField0_ |= 0x00000020;
      newIds.addAll(values);
      return this;
    }

    @Override
    public SelectFateCardCaseData copyFrom(final SelectFateCardCaseData other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        reRollPrice = other.reRollPrice;
        give = other.give;
        canReRoll = other.canReRoll;
        nextPackage.copyFrom(other.nextPackage);
        ids.copyFrom(other.ids);
        newIds.copyFrom(other.newIds);
      }
      return this;
    }

    @Override
    public SelectFateCardCaseData mergeFrom(final SelectFateCardCaseData other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasReRollPrice()) {
        setReRollPrice(other.reRollPrice);
      }
      if (other.hasGive()) {
        setGive(other.give);
      }
      if (other.hasCanReRoll()) {
        setCanReRoll(other.canReRoll);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      if (other.hasIds()) {
        getMutableIds().addAll(other.ids);
      }
      if (other.hasNewIds()) {
        getMutableNewIds().addAll(other.newIds);
      }
      return this;
    }

    @Override
    public SelectFateCardCaseData clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      reRollPrice = 0;
      give = false;
      canReRoll = false;
      nextPackage.clear();
      ids.clear();
      newIds.clear();
      return this;
    }

    @Override
    public SelectFateCardCaseData clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      ids.clear();
      newIds.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof SelectFateCardCaseData)) {
        return false;
      }
      SelectFateCardCaseData other = (SelectFateCardCaseData) o;
      return bitField0_ == other.bitField0_
        && (!hasReRollPrice() || reRollPrice == other.reRollPrice)
        && (!hasGive() || give == other.give)
        && (!hasCanReRoll() || canReRoll == other.canReRoll)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage))
        && (!hasIds() || ids.equals(other.ids))
        && (!hasNewIds() || newIds.equals(other.newIds));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 64);
        output.writeUInt32NoTag(reRollPrice);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 24);
        output.writeBoolNoTag(give);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawByte((byte) 56);
        output.writeBoolNoTag(canReRoll);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        for (int i = 0; i < ids.length(); i++) {
          output.writeRawByte((byte) 8);
          output.writeUInt32NoTag(ids.array()[i]);
        }
      }
      if ((bitField0_ & 0x00000020) != 0) {
        for (int i = 0; i < newIds.length(); i++) {
          output.writeRawByte((byte) 16);
          output.writeUInt32NoTag(newIds.array()[i]);
        }
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(reRollPrice);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 2;
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 2;
      }
      if ((bitField0_ & 0x00000008) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        size += (1 * ids.length()) + ProtoSink.computeRepeatedUInt32SizeNoTag(ids);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        size += (1 * newIds.length()) + ProtoSink.computeRepeatedUInt32SizeNoTag(newIds);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public SelectFateCardCaseData mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 64: {
            // reRollPrice
            reRollPrice = input.readUInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 24) {
              break;
            }
          }
          case 24: {
            // give
            give = input.readBool();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 56) {
              break;
            }
          }
          case 56: {
            // canReRoll
            canReRoll = input.readBool();
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000008;
            tag = input.readTag();
            if (tag != 10) {
              break;
            }
          }
          case 10: {
            // ids [packed=true]
            input.readPackedUInt32(ids, tag);
            bitField0_ |= 0x00000010;
            tag = input.readTag();
            if (tag != 18) {
              break;
            }
          }
          case 18: {
            // newIds [packed=true]
            input.readPackedUInt32(newIds, tag);
            bitField0_ |= 0x00000020;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
          case 8: {
            // ids [packed=false]
            tag = input.readRepeatedUInt32(ids, tag);
            bitField0_ |= 0x00000010;
            break;
          }
          case 16: {
            // newIds [packed=false]
            tag = input.readRepeatedUInt32(newIds, tag);
            bitField0_ |= 0x00000020;
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeUInt32(FieldNames.reRollPrice, reRollPrice);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeBool(FieldNames.give, give);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeBool(FieldNames.canReRoll, canReRoll);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        output.writeRepeatedUInt32(FieldNames.ids, ids);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        output.writeRepeatedUInt32(FieldNames.newIds, newIds);
      }
      output.endObject();
    }

    @Override
    public SelectFateCardCaseData mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case -1462629959: {
            if (input.isAtField(FieldNames.reRollPrice)) {
              if (!input.trySkipNullValue()) {
                reRollPrice = input.readUInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 2219825: {
            if (input.isAtField(FieldNames.give)) {
              if (!input.trySkipNullValue()) {
                give = input.readBool();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 1993089312: {
            if (input.isAtField(FieldNames.canReRoll)) {
              if (!input.trySkipNullValue()) {
                canReRoll = input.readBool();
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000008;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 73368: {
            if (input.isAtField(FieldNames.ids)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedUInt32(ids);
                bitField0_ |= 0x00000010;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1964999400: {
            if (input.isAtField(FieldNames.newIds)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedUInt32(newIds);
                bitField0_ |= 0x00000020;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public SelectFateCardCaseData clone() {
      return new SelectFateCardCaseData().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static SelectFateCardCaseData parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new SelectFateCardCaseData(), data).checkInitialized();
    }

    public static SelectFateCardCaseData parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new SelectFateCardCaseData(), input).checkInitialized();
    }

    public static SelectFateCardCaseData parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new SelectFateCardCaseData(), input).checkInitialized();
    }

    /**
     * @return factory for creating SelectFateCardCaseData messages
     */
    public static MessageFactory<SelectFateCardCaseData> getFactory() {
      return SelectFateCardCaseDataFactory.INSTANCE;
    }

    private enum SelectFateCardCaseDataFactory implements MessageFactory<SelectFateCardCaseData> {
      INSTANCE;

      @Override
      public SelectFateCardCaseData create() {
        return SelectFateCardCaseData.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName reRollPrice = FieldName.forField("ReRollPrice");

      static final FieldName give = FieldName.forField("Give");

      static final FieldName canReRoll = FieldName.forField("CanReRoll");

      static final FieldName nextPackage = FieldName.forField("NextPackage");

      static final FieldName ids = FieldName.forField("Ids");

      static final FieldName newIds = FieldName.forField("NewIds");
    }
  }

  /**
   * Protobuf type {@code RecoveryHPCaseData}
   */
  public static final class RecoveryHPCaseData extends ProtoMessage<RecoveryHPCaseData> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional uint32 EffectId = 1;</code>
     */
    private int effectId;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    private RecoveryHPCaseData() {
    }

    /**
     * @return a new empty instance of {@code RecoveryHPCaseData}
     */
    public static RecoveryHPCaseData newInstance() {
      return new RecoveryHPCaseData();
    }

    /**
     * <code>optional uint32 EffectId = 1;</code>
     * @return whether the effectId field is set
     */
    public boolean hasEffectId() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional uint32 EffectId = 1;</code>
     * @return this
     */
    public RecoveryHPCaseData clearEffectId() {
      bitField0_ &= ~0x00000001;
      effectId = 0;
      return this;
    }

    /**
     * <code>optional uint32 EffectId = 1;</code>
     * @return the effectId
     */
    public int getEffectId() {
      return effectId;
    }

    /**
     * <code>optional uint32 EffectId = 1;</code>
     * @param value the effectId to set
     * @return this
     */
    public RecoveryHPCaseData setEffectId(final int value) {
      bitField0_ |= 0x00000001;
      effectId = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public RecoveryHPCaseData clearNextPackage() {
      bitField0_ &= ~0x00000002;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000002;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public RecoveryHPCaseData addNextPackage(final byte value) {
      bitField0_ |= 0x00000002;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public RecoveryHPCaseData addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000002;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public RecoveryHPCaseData setNextPackage(final byte... values) {
      bitField0_ |= 0x00000002;
      nextPackage.copyFrom(values);
      return this;
    }

    @Override
    public RecoveryHPCaseData copyFrom(final RecoveryHPCaseData other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        effectId = other.effectId;
        nextPackage.copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public RecoveryHPCaseData mergeFrom(final RecoveryHPCaseData other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasEffectId()) {
        setEffectId(other.effectId);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public RecoveryHPCaseData clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      effectId = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public RecoveryHPCaseData clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof RecoveryHPCaseData)) {
        return false;
      }
      RecoveryHPCaseData other = (RecoveryHPCaseData) o;
      return bitField0_ == other.bitField0_
        && (!hasEffectId() || effectId == other.effectId)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt32NoTag(effectId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(effectId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public RecoveryHPCaseData mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            // effectId
            effectId = input.readUInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeUInt32(FieldNames.effectId, effectId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      output.endObject();
    }

    @Override
    public RecoveryHPCaseData mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case -952564052: {
            if (input.isAtField(FieldNames.effectId)) {
              if (!input.trySkipNullValue()) {
                effectId = input.readUInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public RecoveryHPCaseData clone() {
      return new RecoveryHPCaseData().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static RecoveryHPCaseData parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new RecoveryHPCaseData(), data).checkInitialized();
    }

    public static RecoveryHPCaseData parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new RecoveryHPCaseData(), input).checkInitialized();
    }

    public static RecoveryHPCaseData parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new RecoveryHPCaseData(), input).checkInitialized();
    }

    /**
     * @return factory for creating RecoveryHPCaseData messages
     */
    public static MessageFactory<RecoveryHPCaseData> getFactory() {
      return RecoveryHPCaseDataFactory.INSTANCE;
    }

    private enum RecoveryHPCaseDataFactory implements MessageFactory<RecoveryHPCaseData> {
      INSTANCE;

      @Override
      public RecoveryHPCaseData create() {
        return RecoveryHPCaseData.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName effectId = FieldName.forField("EffectId");

      static final FieldName nextPackage = FieldName.forField("NextPackage");
    }
  }

  /**
   * Protobuf type {@code NpcRecoveryHPCaseData}
   */
  public static final class NpcRecoveryHPCaseData extends ProtoMessage<NpcRecoveryHPCaseData> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional uint32 EffectId = 1;</code>
     */
    private int effectId;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    private NpcRecoveryHPCaseData() {
    }

    /**
     * @return a new empty instance of {@code NpcRecoveryHPCaseData}
     */
    public static NpcRecoveryHPCaseData newInstance() {
      return new NpcRecoveryHPCaseData();
    }

    /**
     * <code>optional uint32 EffectId = 1;</code>
     * @return whether the effectId field is set
     */
    public boolean hasEffectId() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional uint32 EffectId = 1;</code>
     * @return this
     */
    public NpcRecoveryHPCaseData clearEffectId() {
      bitField0_ &= ~0x00000001;
      effectId = 0;
      return this;
    }

    /**
     * <code>optional uint32 EffectId = 1;</code>
     * @return the effectId
     */
    public int getEffectId() {
      return effectId;
    }

    /**
     * <code>optional uint32 EffectId = 1;</code>
     * @param value the effectId to set
     * @return this
     */
    public NpcRecoveryHPCaseData setEffectId(final int value) {
      bitField0_ |= 0x00000001;
      effectId = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public NpcRecoveryHPCaseData clearNextPackage() {
      bitField0_ &= ~0x00000002;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000002;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public NpcRecoveryHPCaseData addNextPackage(final byte value) {
      bitField0_ |= 0x00000002;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public NpcRecoveryHPCaseData addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000002;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public NpcRecoveryHPCaseData setNextPackage(final byte... values) {
      bitField0_ |= 0x00000002;
      nextPackage.copyFrom(values);
      return this;
    }

    @Override
    public NpcRecoveryHPCaseData copyFrom(final NpcRecoveryHPCaseData other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        effectId = other.effectId;
        nextPackage.copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public NpcRecoveryHPCaseData mergeFrom(final NpcRecoveryHPCaseData other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasEffectId()) {
        setEffectId(other.effectId);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public NpcRecoveryHPCaseData clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      effectId = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public NpcRecoveryHPCaseData clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof NpcRecoveryHPCaseData)) {
        return false;
      }
      NpcRecoveryHPCaseData other = (NpcRecoveryHPCaseData) o;
      return bitField0_ == other.bitField0_
        && (!hasEffectId() || effectId == other.effectId)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt32NoTag(effectId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(effectId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public NpcRecoveryHPCaseData mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            // effectId
            effectId = input.readUInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeUInt32(FieldNames.effectId, effectId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      output.endObject();
    }

    @Override
    public NpcRecoveryHPCaseData mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case -952564052: {
            if (input.isAtField(FieldNames.effectId)) {
              if (!input.trySkipNullValue()) {
                effectId = input.readUInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public NpcRecoveryHPCaseData clone() {
      return new NpcRecoveryHPCaseData().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static NpcRecoveryHPCaseData parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new NpcRecoveryHPCaseData(), data).checkInitialized();
    }

    public static NpcRecoveryHPCaseData parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new NpcRecoveryHPCaseData(), input).checkInitialized();
    }

    public static NpcRecoveryHPCaseData parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new NpcRecoveryHPCaseData(), input).checkInitialized();
    }

    /**
     * @return factory for creating NpcRecoveryHPCaseData messages
     */
    public static MessageFactory<NpcRecoveryHPCaseData> getFactory() {
      return NpcRecoveryHPCaseDataFactory.INSTANCE;
    }

    private enum NpcRecoveryHPCaseDataFactory implements MessageFactory<NpcRecoveryHPCaseData> {
      INSTANCE;

      @Override
      public NpcRecoveryHPCaseData create() {
        return NpcRecoveryHPCaseData.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName effectId = FieldName.forField("EffectId");

      static final FieldName nextPackage = FieldName.forField("NextPackage");
    }
  }

  /**
   * Protobuf type {@code SyncHPCaseData}
   */
  public static final class SyncHPCaseData extends ProtoMessage<SyncHPCaseData> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    private SyncHPCaseData() {
    }

    /**
     * @return a new empty instance of {@code SyncHPCaseData}
     */
    public static SyncHPCaseData newInstance() {
      return new SyncHPCaseData();
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public SyncHPCaseData clearNextPackage() {
      bitField0_ &= ~0x00000001;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000001;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public SyncHPCaseData addNextPackage(final byte value) {
      bitField0_ |= 0x00000001;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public SyncHPCaseData addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000001;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public SyncHPCaseData setNextPackage(final byte... values) {
      bitField0_ |= 0x00000001;
      nextPackage.copyFrom(values);
      return this;
    }

    @Override
    public SyncHPCaseData copyFrom(final SyncHPCaseData other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        nextPackage.copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public SyncHPCaseData mergeFrom(final SyncHPCaseData other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public SyncHPCaseData clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public SyncHPCaseData clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof SyncHPCaseData)) {
        return false;
      }
      SyncHPCaseData other = (SyncHPCaseData) o;
      return bitField0_ == other.bitField0_
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public SyncHPCaseData mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      output.endObject();
    }

    @Override
    public SyncHPCaseData mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public SyncHPCaseData clone() {
      return new SyncHPCaseData().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static SyncHPCaseData parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new SyncHPCaseData(), data).checkInitialized();
    }

    public static SyncHPCaseData parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new SyncHPCaseData(), input).checkInitialized();
    }

    public static SyncHPCaseData parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new SyncHPCaseData(), input).checkInitialized();
    }

    /**
     * @return factory for creating SyncHPCaseData messages
     */
    public static MessageFactory<SyncHPCaseData> getFactory() {
      return SyncHPCaseDataFactory.INSTANCE;
    }

    private enum SyncHPCaseDataFactory implements MessageFactory<SyncHPCaseData> {
      INSTANCE;

      @Override
      public SyncHPCaseData create() {
        return SyncHPCaseData.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName nextPackage = FieldName.forField("NextPackage");
    }
  }

  /**
   * Protobuf type {@code HawkerGoods}
   */
  public static final class HawkerGoods extends ProtoMessage<HawkerGoods> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional int32 Price = 4;</code>
     */
    private int price;

    /**
     * <code>optional int32 Discount = 5;</code>
     */
    private int discount;

    /**
     * <code>optional uint32 Sid = 1;</code>
     */
    private int sid;

    /**
     * <code>optional uint32 Idx = 2;</code>
     */
    private int idx;

    /**
     * <code>optional uint32 CharPos = 3;</code>
     */
    private int charPos;

    /**
     * <code>optional uint32 Type = 6;</code>
     */
    private int type;

    /**
     * <code>optional uint32 GoodsId = 7;</code>
     */
    private int goodsId;

    /**
     * <code>optional uint32 Tag = 15;</code>
     */
    private int tag_;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    private HawkerGoods() {
    }

    /**
     * @return a new empty instance of {@code HawkerGoods}
     */
    public static HawkerGoods newInstance() {
      return new HawkerGoods();
    }

    /**
     * <code>optional int32 Price = 4;</code>
     * @return whether the price field is set
     */
    public boolean hasPrice() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional int32 Price = 4;</code>
     * @return this
     */
    public HawkerGoods clearPrice() {
      bitField0_ &= ~0x00000001;
      price = 0;
      return this;
    }

    /**
     * <code>optional int32 Price = 4;</code>
     * @return the price
     */
    public int getPrice() {
      return price;
    }

    /**
     * <code>optional int32 Price = 4;</code>
     * @param value the price to set
     * @return this
     */
    public HawkerGoods setPrice(final int value) {
      bitField0_ |= 0x00000001;
      price = value;
      return this;
    }

    /**
     * <code>optional int32 Discount = 5;</code>
     * @return whether the discount field is set
     */
    public boolean hasDiscount() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional int32 Discount = 5;</code>
     * @return this
     */
    public HawkerGoods clearDiscount() {
      bitField0_ &= ~0x00000002;
      discount = 0;
      return this;
    }

    /**
     * <code>optional int32 Discount = 5;</code>
     * @return the discount
     */
    public int getDiscount() {
      return discount;
    }

    /**
     * <code>optional int32 Discount = 5;</code>
     * @param value the discount to set
     * @return this
     */
    public HawkerGoods setDiscount(final int value) {
      bitField0_ |= 0x00000002;
      discount = value;
      return this;
    }

    /**
     * <code>optional uint32 Sid = 1;</code>
     * @return whether the sid field is set
     */
    public boolean hasSid() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional uint32 Sid = 1;</code>
     * @return this
     */
    public HawkerGoods clearSid() {
      bitField0_ &= ~0x00000004;
      sid = 0;
      return this;
    }

    /**
     * <code>optional uint32 Sid = 1;</code>
     * @return the sid
     */
    public int getSid() {
      return sid;
    }

    /**
     * <code>optional uint32 Sid = 1;</code>
     * @param value the sid to set
     * @return this
     */
    public HawkerGoods setSid(final int value) {
      bitField0_ |= 0x00000004;
      sid = value;
      return this;
    }

    /**
     * <code>optional uint32 Idx = 2;</code>
     * @return whether the idx field is set
     */
    public boolean hasIdx() {
      return (bitField0_ & 0x00000008) != 0;
    }

    /**
     * <code>optional uint32 Idx = 2;</code>
     * @return this
     */
    public HawkerGoods clearIdx() {
      bitField0_ &= ~0x00000008;
      idx = 0;
      return this;
    }

    /**
     * <code>optional uint32 Idx = 2;</code>
     * @return the idx
     */
    public int getIdx() {
      return idx;
    }

    /**
     * <code>optional uint32 Idx = 2;</code>
     * @param value the idx to set
     * @return this
     */
    public HawkerGoods setIdx(final int value) {
      bitField0_ |= 0x00000008;
      idx = value;
      return this;
    }

    /**
     * <code>optional uint32 CharPos = 3;</code>
     * @return whether the charPos field is set
     */
    public boolean hasCharPos() {
      return (bitField0_ & 0x00000010) != 0;
    }

    /**
     * <code>optional uint32 CharPos = 3;</code>
     * @return this
     */
    public HawkerGoods clearCharPos() {
      bitField0_ &= ~0x00000010;
      charPos = 0;
      return this;
    }

    /**
     * <code>optional uint32 CharPos = 3;</code>
     * @return the charPos
     */
    public int getCharPos() {
      return charPos;
    }

    /**
     * <code>optional uint32 CharPos = 3;</code>
     * @param value the charPos to set
     * @return this
     */
    public HawkerGoods setCharPos(final int value) {
      bitField0_ |= 0x00000010;
      charPos = value;
      return this;
    }

    /**
     * <code>optional uint32 Type = 6;</code>
     * @return whether the type field is set
     */
    public boolean hasType() {
      return (bitField0_ & 0x00000020) != 0;
    }

    /**
     * <code>optional uint32 Type = 6;</code>
     * @return this
     */
    public HawkerGoods clearType() {
      bitField0_ &= ~0x00000020;
      type = 0;
      return this;
    }

    /**
     * <code>optional uint32 Type = 6;</code>
     * @return the type
     */
    public int getType() {
      return type;
    }

    /**
     * <code>optional uint32 Type = 6;</code>
     * @param value the type to set
     * @return this
     */
    public HawkerGoods setType(final int value) {
      bitField0_ |= 0x00000020;
      type = value;
      return this;
    }

    /**
     * <code>optional uint32 GoodsId = 7;</code>
     * @return whether the goodsId field is set
     */
    public boolean hasGoodsId() {
      return (bitField0_ & 0x00000040) != 0;
    }

    /**
     * <code>optional uint32 GoodsId = 7;</code>
     * @return this
     */
    public HawkerGoods clearGoodsId() {
      bitField0_ &= ~0x00000040;
      goodsId = 0;
      return this;
    }

    /**
     * <code>optional uint32 GoodsId = 7;</code>
     * @return the goodsId
     */
    public int getGoodsId() {
      return goodsId;
    }

    /**
     * <code>optional uint32 GoodsId = 7;</code>
     * @param value the goodsId to set
     * @return this
     */
    public HawkerGoods setGoodsId(final int value) {
      bitField0_ |= 0x00000040;
      goodsId = value;
      return this;
    }

    /**
     * <code>optional uint32 Tag = 15;</code>
     * @return whether the tag_ field is set
     */
    public boolean hasTag() {
      return (bitField0_ & 0x00000080) != 0;
    }

    /**
     * <code>optional uint32 Tag = 15;</code>
     * @return this
     */
    public HawkerGoods clearTag() {
      bitField0_ &= ~0x00000080;
      tag_ = 0;
      return this;
    }

    /**
     * <code>optional uint32 Tag = 15;</code>
     * @return the tag_
     */
    public int getTag() {
      return tag_;
    }

    /**
     * <code>optional uint32 Tag = 15;</code>
     * @param value the tag_ to set
     * @return this
     */
    public HawkerGoods setTag(final int value) {
      bitField0_ |= 0x00000080;
      tag_ = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000100) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public HawkerGoods clearNextPackage() {
      bitField0_ &= ~0x00000100;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000100;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public HawkerGoods addNextPackage(final byte value) {
      bitField0_ |= 0x00000100;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public HawkerGoods addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000100;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public HawkerGoods setNextPackage(final byte... values) {
      bitField0_ |= 0x00000100;
      nextPackage.copyFrom(values);
      return this;
    }

    @Override
    public HawkerGoods copyFrom(final HawkerGoods other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        price = other.price;
        discount = other.discount;
        sid = other.sid;
        idx = other.idx;
        charPos = other.charPos;
        type = other.type;
        goodsId = other.goodsId;
        tag_ = other.tag_;
        nextPackage.copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public HawkerGoods mergeFrom(final HawkerGoods other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasPrice()) {
        setPrice(other.price);
      }
      if (other.hasDiscount()) {
        setDiscount(other.discount);
      }
      if (other.hasSid()) {
        setSid(other.sid);
      }
      if (other.hasIdx()) {
        setIdx(other.idx);
      }
      if (other.hasCharPos()) {
        setCharPos(other.charPos);
      }
      if (other.hasType()) {
        setType(other.type);
      }
      if (other.hasGoodsId()) {
        setGoodsId(other.goodsId);
      }
      if (other.hasTag()) {
        setTag(other.tag_);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public HawkerGoods clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      price = 0;
      discount = 0;
      sid = 0;
      idx = 0;
      charPos = 0;
      type = 0;
      goodsId = 0;
      tag_ = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public HawkerGoods clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof HawkerGoods)) {
        return false;
      }
      HawkerGoods other = (HawkerGoods) o;
      return bitField0_ == other.bitField0_
        && (!hasPrice() || price == other.price)
        && (!hasDiscount() || discount == other.discount)
        && (!hasSid() || sid == other.sid)
        && (!hasIdx() || idx == other.idx)
        && (!hasCharPos() || charPos == other.charPos)
        && (!hasType() || type == other.type)
        && (!hasGoodsId() || goodsId == other.goodsId)
        && (!hasTag() || tag_ == other.tag_)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 32);
        output.writeInt32NoTag(price);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 40);
        output.writeInt32NoTag(discount);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt32NoTag(sid);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeRawByte((byte) 16);
        output.writeUInt32NoTag(idx);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        output.writeRawByte((byte) 24);
        output.writeUInt32NoTag(charPos);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        output.writeRawByte((byte) 48);
        output.writeUInt32NoTag(type);
      }
      if ((bitField0_ & 0x00000040) != 0) {
        output.writeRawByte((byte) 56);
        output.writeUInt32NoTag(goodsId);
      }
      if ((bitField0_ & 0x00000080) != 0) {
        output.writeRawByte((byte) 120);
        output.writeUInt32NoTag(tag_);
      }
      if ((bitField0_ & 0x00000100) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeInt32SizeNoTag(price);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeInt32SizeNoTag(discount);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(sid);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(idx);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(charPos);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(type);
      }
      if ((bitField0_ & 0x00000040) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(goodsId);
      }
      if ((bitField0_ & 0x00000080) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(tag_);
      }
      if ((bitField0_ & 0x00000100) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public HawkerGoods mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 32: {
            // price
            price = input.readInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 40) {
              break;
            }
          }
          case 40: {
            // discount
            discount = input.readInt32();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 8) {
              break;
            }
          }
          case 8: {
            // sid
            sid = input.readUInt32();
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 16) {
              break;
            }
          }
          case 16: {
            // idx
            idx = input.readUInt32();
            bitField0_ |= 0x00000008;
            tag = input.readTag();
            if (tag != 24) {
              break;
            }
          }
          case 24: {
            // charPos
            charPos = input.readUInt32();
            bitField0_ |= 0x00000010;
            tag = input.readTag();
            if (tag != 48) {
              break;
            }
          }
          case 48: {
            // type
            type = input.readUInt32();
            bitField0_ |= 0x00000020;
            tag = input.readTag();
            if (tag != 56) {
              break;
            }
          }
          case 56: {
            // goodsId
            goodsId = input.readUInt32();
            bitField0_ |= 0x00000040;
            tag = input.readTag();
            if (tag != 120) {
              break;
            }
          }
          case 120: {
            // tag_
            tag_ = input.readUInt32();
            bitField0_ |= 0x00000080;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000100;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeInt32(FieldNames.price, price);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeInt32(FieldNames.discount, discount);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeUInt32(FieldNames.sid, sid);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeUInt32(FieldNames.idx, idx);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        output.writeUInt32(FieldNames.charPos, charPos);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        output.writeUInt32(FieldNames.type, type);
      }
      if ((bitField0_ & 0x00000040) != 0) {
        output.writeUInt32(FieldNames.goodsId, goodsId);
      }
      if ((bitField0_ & 0x00000080) != 0) {
        output.writeUInt32(FieldNames.tag_, tag_);
      }
      if ((bitField0_ & 0x00000100) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      output.endObject();
    }

    @Override
    public HawkerGoods mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 77381929: {
            if (input.isAtField(FieldNames.price)) {
              if (!input.trySkipNullValue()) {
                price = input.readInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 337828193: {
            if (input.isAtField(FieldNames.discount)) {
              if (!input.trySkipNullValue()) {
                discount = input.readInt32();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 83118: {
            if (input.isAtField(FieldNames.sid)) {
              if (!input.trySkipNullValue()) {
                sid = input.readUInt32();
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 73373: {
            if (input.isAtField(FieldNames.idx)) {
              if (!input.trySkipNullValue()) {
                idx = input.readUInt32();
                bitField0_ |= 0x00000008;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1891272962: {
            if (input.isAtField(FieldNames.charPos)) {
              if (!input.trySkipNullValue()) {
                charPos = input.readUInt32();
                bitField0_ |= 0x00000010;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 2622298: {
            if (input.isAtField(FieldNames.type)) {
              if (!input.trySkipNullValue()) {
                type = input.readUInt32();
                bitField0_ |= 0x00000020;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 1871690481: {
            if (input.isAtField(FieldNames.goodsId)) {
              if (!input.trySkipNullValue()) {
                goodsId = input.readUInt32();
                bitField0_ |= 0x00000040;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 83834: {
            if (input.isAtField(FieldNames.tag_)) {
              if (!input.trySkipNullValue()) {
                tag_ = input.readUInt32();
                bitField0_ |= 0x00000080;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000100;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public HawkerGoods clone() {
      return new HawkerGoods().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static HawkerGoods parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new HawkerGoods(), data).checkInitialized();
    }

    public static HawkerGoods parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new HawkerGoods(), input).checkInitialized();
    }

    public static HawkerGoods parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new HawkerGoods(), input).checkInitialized();
    }

    /**
     * @return factory for creating HawkerGoods messages
     */
    public static MessageFactory<HawkerGoods> getFactory() {
      return HawkerGoodsFactory.INSTANCE;
    }

    private enum HawkerGoodsFactory implements MessageFactory<HawkerGoods> {
      INSTANCE;

      @Override
      public HawkerGoods create() {
        return HawkerGoods.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName price = FieldName.forField("Price");

      static final FieldName discount = FieldName.forField("Discount");

      static final FieldName sid = FieldName.forField("Sid");

      static final FieldName idx = FieldName.forField("Idx");

      static final FieldName charPos = FieldName.forField("CharPos");

      static final FieldName type = FieldName.forField("Type");

      static final FieldName goodsId = FieldName.forField("GoodsId");

      static final FieldName tag_ = FieldName.forField("Tag");

      static final FieldName nextPackage = FieldName.forField("NextPackage");
    }
  }

  /**
   * Protobuf type {@code HawkerCaseData}
   */
  public static final class HawkerCaseData extends ProtoMessage<HawkerCaseData> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional uint32 ReRollPrice = 8;</code>
     */
    private int reRollPrice;

    /**
     * <code>optional uint32 ReRollTimes = 9;</code>
     */
    private int reRollTimes;

    /**
     * <code>optional bool CanReRoll = 7;</code>
     */
    private boolean canReRoll;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    /**
     * <code>repeated uint32 Purchase = 2;</code>
     */
    private final RepeatedInt purchase = RepeatedInt.newEmptyInstance();

    /**
     * <code>repeated .HawkerGoods List = 1;</code>
     */
    private final RepeatedMessage<HawkerGoods> list = RepeatedMessage.newEmptyInstance(HawkerGoods.getFactory());

    private HawkerCaseData() {
    }

    /**
     * @return a new empty instance of {@code HawkerCaseData}
     */
    public static HawkerCaseData newInstance() {
      return new HawkerCaseData();
    }

    /**
     * <code>optional uint32 ReRollPrice = 8;</code>
     * @return whether the reRollPrice field is set
     */
    public boolean hasReRollPrice() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional uint32 ReRollPrice = 8;</code>
     * @return this
     */
    public HawkerCaseData clearReRollPrice() {
      bitField0_ &= ~0x00000001;
      reRollPrice = 0;
      return this;
    }

    /**
     * <code>optional uint32 ReRollPrice = 8;</code>
     * @return the reRollPrice
     */
    public int getReRollPrice() {
      return reRollPrice;
    }

    /**
     * <code>optional uint32 ReRollPrice = 8;</code>
     * @param value the reRollPrice to set
     * @return this
     */
    public HawkerCaseData setReRollPrice(final int value) {
      bitField0_ |= 0x00000001;
      reRollPrice = value;
      return this;
    }

    /**
     * <code>optional uint32 ReRollTimes = 9;</code>
     * @return whether the reRollTimes field is set
     */
    public boolean hasReRollTimes() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional uint32 ReRollTimes = 9;</code>
     * @return this
     */
    public HawkerCaseData clearReRollTimes() {
      bitField0_ &= ~0x00000002;
      reRollTimes = 0;
      return this;
    }

    /**
     * <code>optional uint32 ReRollTimes = 9;</code>
     * @return the reRollTimes
     */
    public int getReRollTimes() {
      return reRollTimes;
    }

    /**
     * <code>optional uint32 ReRollTimes = 9;</code>
     * @param value the reRollTimes to set
     * @return this
     */
    public HawkerCaseData setReRollTimes(final int value) {
      bitField0_ |= 0x00000002;
      reRollTimes = value;
      return this;
    }

    /**
     * <code>optional bool CanReRoll = 7;</code>
     * @return whether the canReRoll field is set
     */
    public boolean hasCanReRoll() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional bool CanReRoll = 7;</code>
     * @return this
     */
    public HawkerCaseData clearCanReRoll() {
      bitField0_ &= ~0x00000004;
      canReRoll = false;
      return this;
    }

    /**
     * <code>optional bool CanReRoll = 7;</code>
     * @return the canReRoll
     */
    public boolean getCanReRoll() {
      return canReRoll;
    }

    /**
     * <code>optional bool CanReRoll = 7;</code>
     * @param value the canReRoll to set
     * @return this
     */
    public HawkerCaseData setCanReRoll(final boolean value) {
      bitField0_ |= 0x00000004;
      canReRoll = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000008) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public HawkerCaseData clearNextPackage() {
      bitField0_ &= ~0x00000008;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000008;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public HawkerCaseData addNextPackage(final byte value) {
      bitField0_ |= 0x00000008;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public HawkerCaseData addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000008;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public HawkerCaseData setNextPackage(final byte... values) {
      bitField0_ |= 0x00000008;
      nextPackage.copyFrom(values);
      return this;
    }

    /**
     * <code>repeated uint32 Purchase = 2;</code>
     * @return whether the purchase field is set
     */
    public boolean hasPurchase() {
      return (bitField0_ & 0x00000010) != 0;
    }

    /**
     * <code>repeated uint32 Purchase = 2;</code>
     * @return this
     */
    public HawkerCaseData clearPurchase() {
      bitField0_ &= ~0x00000010;
      purchase.clear();
      return this;
    }

    /**
     * <code>repeated uint32 Purchase = 2;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutablePurchase()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedInt getPurchase() {
      return purchase;
    }

    /**
     * <code>repeated uint32 Purchase = 2;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedInt getMutablePurchase() {
      bitField0_ |= 0x00000010;
      return purchase;
    }

    /**
     * <code>repeated uint32 Purchase = 2;</code>
     * @param value the purchase to add
     * @return this
     */
    public HawkerCaseData addPurchase(final int value) {
      bitField0_ |= 0x00000010;
      purchase.add(value);
      return this;
    }

    /**
     * <code>repeated uint32 Purchase = 2;</code>
     * @param values the purchase to add
     * @return this
     */
    public HawkerCaseData addAllPurchase(final int... values) {
      bitField0_ |= 0x00000010;
      purchase.addAll(values);
      return this;
    }

    /**
     * <code>repeated .HawkerGoods List = 1;</code>
     * @return whether the list field is set
     */
    public boolean hasList() {
      return (bitField0_ & 0x00000020) != 0;
    }

    /**
     * <code>repeated .HawkerGoods List = 1;</code>
     * @return this
     */
    public HawkerCaseData clearList() {
      bitField0_ &= ~0x00000020;
      list.clear();
      return this;
    }

    /**
     * <code>repeated .HawkerGoods List = 1;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableList()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<HawkerGoods> getList() {
      return list;
    }

    /**
     * <code>repeated .HawkerGoods List = 1;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<HawkerGoods> getMutableList() {
      bitField0_ |= 0x00000020;
      return list;
    }

    /**
     * <code>repeated .HawkerGoods List = 1;</code>
     * @param value the list to add
     * @return this
     */
    public HawkerCaseData addList(final HawkerGoods value) {
      bitField0_ |= 0x00000020;
      list.add(value);
      return this;
    }

    /**
     * <code>repeated .HawkerGoods List = 1;</code>
     * @param values the list to add
     * @return this
     */
    public HawkerCaseData addAllList(final HawkerGoods... values) {
      bitField0_ |= 0x00000020;
      list.addAll(values);
      return this;
    }

    @Override
    public HawkerCaseData copyFrom(final HawkerCaseData other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        reRollPrice = other.reRollPrice;
        reRollTimes = other.reRollTimes;
        canReRoll = other.canReRoll;
        nextPackage.copyFrom(other.nextPackage);
        purchase.copyFrom(other.purchase);
        list.copyFrom(other.list);
      }
      return this;
    }

    @Override
    public HawkerCaseData mergeFrom(final HawkerCaseData other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasReRollPrice()) {
        setReRollPrice(other.reRollPrice);
      }
      if (other.hasReRollTimes()) {
        setReRollTimes(other.reRollTimes);
      }
      if (other.hasCanReRoll()) {
        setCanReRoll(other.canReRoll);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      if (other.hasPurchase()) {
        getMutablePurchase().addAll(other.purchase);
      }
      if (other.hasList()) {
        getMutableList().addAll(other.list);
      }
      return this;
    }

    @Override
    public HawkerCaseData clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      reRollPrice = 0;
      reRollTimes = 0;
      canReRoll = false;
      nextPackage.clear();
      purchase.clear();
      list.clear();
      return this;
    }

    @Override
    public HawkerCaseData clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      purchase.clear();
      list.clearQuick();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof HawkerCaseData)) {
        return false;
      }
      HawkerCaseData other = (HawkerCaseData) o;
      return bitField0_ == other.bitField0_
        && (!hasReRollPrice() || reRollPrice == other.reRollPrice)
        && (!hasReRollTimes() || reRollTimes == other.reRollTimes)
        && (!hasCanReRoll() || canReRoll == other.canReRoll)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage))
        && (!hasPurchase() || purchase.equals(other.purchase))
        && (!hasList() || list.equals(other.list));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 64);
        output.writeUInt32NoTag(reRollPrice);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 72);
        output.writeUInt32NoTag(reRollTimes);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawByte((byte) 56);
        output.writeBoolNoTag(canReRoll);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        for (int i = 0; i < purchase.length(); i++) {
          output.writeRawByte((byte) 16);
          output.writeUInt32NoTag(purchase.array()[i]);
        }
      }
      if ((bitField0_ & 0x00000020) != 0) {
        for (int i = 0; i < list.length(); i++) {
          output.writeRawByte((byte) 10);
          output.writeMessageNoTag(list.get(i));
        }
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(reRollPrice);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(reRollTimes);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 2;
      }
      if ((bitField0_ & 0x00000008) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        size += (1 * purchase.length()) + ProtoSink.computeRepeatedUInt32SizeNoTag(purchase);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        size += (1 * list.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(list);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public HawkerCaseData mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 64: {
            // reRollPrice
            reRollPrice = input.readUInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 72) {
              break;
            }
          }
          case 72: {
            // reRollTimes
            reRollTimes = input.readUInt32();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 56) {
              break;
            }
          }
          case 56: {
            // canReRoll
            canReRoll = input.readBool();
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000008;
            tag = input.readTag();
            if (tag != 18) {
              break;
            }
          }
          case 18: {
            // purchase [packed=true]
            input.readPackedUInt32(purchase, tag);
            bitField0_ |= 0x00000010;
            tag = input.readTag();
            if (tag != 10) {
              break;
            }
          }
          case 10: {
            // list
            tag = input.readRepeatedMessage(list, tag);
            bitField0_ |= 0x00000020;
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
          case 16: {
            // purchase [packed=false]
            tag = input.readRepeatedUInt32(purchase, tag);
            bitField0_ |= 0x00000010;
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeUInt32(FieldNames.reRollPrice, reRollPrice);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeUInt32(FieldNames.reRollTimes, reRollTimes);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeBool(FieldNames.canReRoll, canReRoll);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        output.writeRepeatedUInt32(FieldNames.purchase, purchase);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        output.writeRepeatedMessage(FieldNames.list, list);
      }
      output.endObject();
    }

    @Override
    public HawkerCaseData mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case -1462629959: {
            if (input.isAtField(FieldNames.reRollPrice)) {
              if (!input.trySkipNullValue()) {
                reRollPrice = input.readUInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1459200074: {
            if (input.isAtField(FieldNames.reRollTimes)) {
              if (!input.trySkipNullValue()) {
                reRollTimes = input.readUInt32();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 1993089312: {
            if (input.isAtField(FieldNames.canReRoll)) {
              if (!input.trySkipNullValue()) {
                canReRoll = input.readBool();
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000008;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 1807968545: {
            if (input.isAtField(FieldNames.purchase)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedUInt32(purchase);
                bitField0_ |= 0x00000010;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 2368702: {
            if (input.isAtField(FieldNames.list)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedMessage(list);
                bitField0_ |= 0x00000020;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public HawkerCaseData clone() {
      return new HawkerCaseData().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static HawkerCaseData parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new HawkerCaseData(), data).checkInitialized();
    }

    public static HawkerCaseData parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new HawkerCaseData(), input).checkInitialized();
    }

    public static HawkerCaseData parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new HawkerCaseData(), input).checkInitialized();
    }

    /**
     * @return factory for creating HawkerCaseData messages
     */
    public static MessageFactory<HawkerCaseData> getFactory() {
      return HawkerCaseDataFactory.INSTANCE;
    }

    private enum HawkerCaseDataFactory implements MessageFactory<HawkerCaseData> {
      INSTANCE;

      @Override
      public HawkerCaseData create() {
        return HawkerCaseData.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName reRollPrice = FieldName.forField("ReRollPrice");

      static final FieldName reRollTimes = FieldName.forField("ReRollTimes");

      static final FieldName canReRoll = FieldName.forField("CanReRoll");

      static final FieldName nextPackage = FieldName.forField("NextPackage");

      static final FieldName purchase = FieldName.forField("Purchase");

      static final FieldName list = FieldName.forField("List");
    }
  }

  /**
   * Protobuf type {@code InteractHawkerReq}
   */
  public static final class InteractHawkerReq extends ProtoMessage<InteractHawkerReq> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional uint32 Sid = 1;</code>
     */
    private int sid;

    /**
     * <code>optional bool ReRoll = 2;</code>
     */
    private boolean reRoll;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    private InteractHawkerReq() {
    }

    /**
     * @return a new empty instance of {@code InteractHawkerReq}
     */
    public static InteractHawkerReq newInstance() {
      return new InteractHawkerReq();
    }

    /**
     * <code>optional uint32 Sid = 1;</code>
     * @return whether the sid field is set
     */
    public boolean hasSid() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional uint32 Sid = 1;</code>
     * @return this
     */
    public InteractHawkerReq clearSid() {
      bitField0_ &= ~0x00000001;
      sid = 0;
      return this;
    }

    /**
     * <code>optional uint32 Sid = 1;</code>
     * @return the sid
     */
    public int getSid() {
      return sid;
    }

    /**
     * <code>optional uint32 Sid = 1;</code>
     * @param value the sid to set
     * @return this
     */
    public InteractHawkerReq setSid(final int value) {
      bitField0_ |= 0x00000001;
      sid = value;
      return this;
    }

    /**
     * <code>optional bool ReRoll = 2;</code>
     * @return whether the reRoll field is set
     */
    public boolean hasReRoll() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional bool ReRoll = 2;</code>
     * @return this
     */
    public InteractHawkerReq clearReRoll() {
      bitField0_ &= ~0x00000002;
      reRoll = false;
      return this;
    }

    /**
     * <code>optional bool ReRoll = 2;</code>
     * @return the reRoll
     */
    public boolean getReRoll() {
      return reRoll;
    }

    /**
     * <code>optional bool ReRoll = 2;</code>
     * @param value the reRoll to set
     * @return this
     */
    public InteractHawkerReq setReRoll(final boolean value) {
      bitField0_ |= 0x00000002;
      reRoll = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public InteractHawkerReq clearNextPackage() {
      bitField0_ &= ~0x00000004;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000004;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public InteractHawkerReq addNextPackage(final byte value) {
      bitField0_ |= 0x00000004;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public InteractHawkerReq addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000004;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public InteractHawkerReq setNextPackage(final byte... values) {
      bitField0_ |= 0x00000004;
      nextPackage.copyFrom(values);
      return this;
    }

    @Override
    public InteractHawkerReq copyFrom(final InteractHawkerReq other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        sid = other.sid;
        reRoll = other.reRoll;
        nextPackage.copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public InteractHawkerReq mergeFrom(final InteractHawkerReq other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasSid()) {
        setSid(other.sid);
      }
      if (other.hasReRoll()) {
        setReRoll(other.reRoll);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public InteractHawkerReq clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      sid = 0;
      reRoll = false;
      nextPackage.clear();
      return this;
    }

    @Override
    public InteractHawkerReq clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof InteractHawkerReq)) {
        return false;
      }
      InteractHawkerReq other = (InteractHawkerReq) o;
      return bitField0_ == other.bitField0_
        && (!hasSid() || sid == other.sid)
        && (!hasReRoll() || reRoll == other.reRoll)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt32NoTag(sid);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 16);
        output.writeBoolNoTag(reRoll);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(sid);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 2;
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public InteractHawkerReq mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            // sid
            sid = input.readUInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 16) {
              break;
            }
          }
          case 16: {
            // reRoll
            reRoll = input.readBool();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeUInt32(FieldNames.sid, sid);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeBool(FieldNames.reRoll, reRoll);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      output.endObject();
    }

    @Override
    public InteractHawkerReq mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 83118: {
            if (input.isAtField(FieldNames.sid)) {
              if (!input.trySkipNullValue()) {
                sid = input.readUInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1851548304: {
            if (input.isAtField(FieldNames.reRoll)) {
              if (!input.trySkipNullValue()) {
                reRoll = input.readBool();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public InteractHawkerReq clone() {
      return new InteractHawkerReq().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static InteractHawkerReq parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new InteractHawkerReq(), data).checkInitialized();
    }

    public static InteractHawkerReq parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new InteractHawkerReq(), input).checkInitialized();
    }

    public static InteractHawkerReq parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new InteractHawkerReq(), input).checkInitialized();
    }

    /**
     * @return factory for creating InteractHawkerReq messages
     */
    public static MessageFactory<InteractHawkerReq> getFactory() {
      return InteractHawkerReqFactory.INSTANCE;
    }

    private enum InteractHawkerReqFactory implements MessageFactory<InteractHawkerReq> {
      INSTANCE;

      @Override
      public InteractHawkerReq create() {
        return InteractHawkerReq.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName sid = FieldName.forField("Sid");

      static final FieldName reRoll = FieldName.forField("ReRoll");

      static final FieldName nextPackage = FieldName.forField("NextPackage");
    }
  }

  /**
   * Protobuf type {@code InteractStrengthenMachineResp}
   */
  public static final class InteractStrengthenMachineResp extends ProtoMessage<InteractStrengthenMachineResp> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional bool BuySucceed = 1;</code>
     */
    private boolean buySucceed;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    private InteractStrengthenMachineResp() {
    }

    /**
     * @return a new empty instance of {@code InteractStrengthenMachineResp}
     */
    public static InteractStrengthenMachineResp newInstance() {
      return new InteractStrengthenMachineResp();
    }

    /**
     * <code>optional bool BuySucceed = 1;</code>
     * @return whether the buySucceed field is set
     */
    public boolean hasBuySucceed() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional bool BuySucceed = 1;</code>
     * @return this
     */
    public InteractStrengthenMachineResp clearBuySucceed() {
      bitField0_ &= ~0x00000001;
      buySucceed = false;
      return this;
    }

    /**
     * <code>optional bool BuySucceed = 1;</code>
     * @return the buySucceed
     */
    public boolean getBuySucceed() {
      return buySucceed;
    }

    /**
     * <code>optional bool BuySucceed = 1;</code>
     * @param value the buySucceed to set
     * @return this
     */
    public InteractStrengthenMachineResp setBuySucceed(final boolean value) {
      bitField0_ |= 0x00000001;
      buySucceed = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public InteractStrengthenMachineResp clearNextPackage() {
      bitField0_ &= ~0x00000002;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000002;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public InteractStrengthenMachineResp addNextPackage(final byte value) {
      bitField0_ |= 0x00000002;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public InteractStrengthenMachineResp addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000002;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public InteractStrengthenMachineResp setNextPackage(final byte... values) {
      bitField0_ |= 0x00000002;
      nextPackage.copyFrom(values);
      return this;
    }

    @Override
    public InteractStrengthenMachineResp copyFrom(final InteractStrengthenMachineResp other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        buySucceed = other.buySucceed;
        nextPackage.copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public InteractStrengthenMachineResp mergeFrom(final InteractStrengthenMachineResp other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasBuySucceed()) {
        setBuySucceed(other.buySucceed);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public InteractStrengthenMachineResp clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      buySucceed = false;
      nextPackage.clear();
      return this;
    }

    @Override
    public InteractStrengthenMachineResp clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof InteractStrengthenMachineResp)) {
        return false;
      }
      InteractStrengthenMachineResp other = (InteractStrengthenMachineResp) o;
      return bitField0_ == other.bitField0_
        && (!hasBuySucceed() || buySucceed == other.buySucceed)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 8);
        output.writeBoolNoTag(buySucceed);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 2;
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public InteractStrengthenMachineResp mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            // buySucceed
            buySucceed = input.readBool();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeBool(FieldNames.buySucceed, buySucceed);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      output.endObject();
    }

    @Override
    public InteractStrengthenMachineResp mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case -879628036: {
            if (input.isAtField(FieldNames.buySucceed)) {
              if (!input.trySkipNullValue()) {
                buySucceed = input.readBool();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public InteractStrengthenMachineResp clone() {
      return new InteractStrengthenMachineResp().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static InteractStrengthenMachineResp parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new InteractStrengthenMachineResp(), data).checkInitialized();
    }

    public static InteractStrengthenMachineResp parseFrom(final ProtoSource input) throws
        IOException {
      return ProtoMessage.mergeFrom(new InteractStrengthenMachineResp(), input).checkInitialized();
    }

    public static InteractStrengthenMachineResp parseFrom(final JsonSource input) throws
        IOException {
      return ProtoMessage.mergeFrom(new InteractStrengthenMachineResp(), input).checkInitialized();
    }

    /**
     * @return factory for creating InteractStrengthenMachineResp messages
     */
    public static MessageFactory<InteractStrengthenMachineResp> getFactory() {
      return InteractStrengthenMachineRespFactory.INSTANCE;
    }

    private enum InteractStrengthenMachineRespFactory implements MessageFactory<InteractStrengthenMachineResp> {
      INSTANCE;

      @Override
      public InteractStrengthenMachineResp create() {
        return InteractStrengthenMachineResp.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName buySucceed = FieldName.forField("BuySucceed");

      static final FieldName nextPackage = FieldName.forField("NextPackage");
    }
  }

  /**
   * Protobuf type {@code StrengthenMachineCaseData}
   */
  public static final class StrengthenMachineCaseData extends ProtoMessage<StrengthenMachineCaseData> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional uint32 Times = 1;</code>
     */
    private int times;

    /**
     * <code>optional uint32 Discount = 8;</code>
     */
    private int discount;

    /**
     * <code>optional bool FirstFree = 7;</code>
     */
    private boolean firstFree;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    private StrengthenMachineCaseData() {
    }

    /**
     * @return a new empty instance of {@code StrengthenMachineCaseData}
     */
    public static StrengthenMachineCaseData newInstance() {
      return new StrengthenMachineCaseData();
    }

    /**
     * <code>optional uint32 Times = 1;</code>
     * @return whether the times field is set
     */
    public boolean hasTimes() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional uint32 Times = 1;</code>
     * @return this
     */
    public StrengthenMachineCaseData clearTimes() {
      bitField0_ &= ~0x00000001;
      times = 0;
      return this;
    }

    /**
     * <code>optional uint32 Times = 1;</code>
     * @return the times
     */
    public int getTimes() {
      return times;
    }

    /**
     * <code>optional uint32 Times = 1;</code>
     * @param value the times to set
     * @return this
     */
    public StrengthenMachineCaseData setTimes(final int value) {
      bitField0_ |= 0x00000001;
      times = value;
      return this;
    }

    /**
     * <code>optional uint32 Discount = 8;</code>
     * @return whether the discount field is set
     */
    public boolean hasDiscount() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional uint32 Discount = 8;</code>
     * @return this
     */
    public StrengthenMachineCaseData clearDiscount() {
      bitField0_ &= ~0x00000002;
      discount = 0;
      return this;
    }

    /**
     * <code>optional uint32 Discount = 8;</code>
     * @return the discount
     */
    public int getDiscount() {
      return discount;
    }

    /**
     * <code>optional uint32 Discount = 8;</code>
     * @param value the discount to set
     * @return this
     */
    public StrengthenMachineCaseData setDiscount(final int value) {
      bitField0_ |= 0x00000002;
      discount = value;
      return this;
    }

    /**
     * <code>optional bool FirstFree = 7;</code>
     * @return whether the firstFree field is set
     */
    public boolean hasFirstFree() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional bool FirstFree = 7;</code>
     * @return this
     */
    public StrengthenMachineCaseData clearFirstFree() {
      bitField0_ &= ~0x00000004;
      firstFree = false;
      return this;
    }

    /**
     * <code>optional bool FirstFree = 7;</code>
     * @return the firstFree
     */
    public boolean getFirstFree() {
      return firstFree;
    }

    /**
     * <code>optional bool FirstFree = 7;</code>
     * @param value the firstFree to set
     * @return this
     */
    public StrengthenMachineCaseData setFirstFree(final boolean value) {
      bitField0_ |= 0x00000004;
      firstFree = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000008) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public StrengthenMachineCaseData clearNextPackage() {
      bitField0_ &= ~0x00000008;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000008;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public StrengthenMachineCaseData addNextPackage(final byte value) {
      bitField0_ |= 0x00000008;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public StrengthenMachineCaseData addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000008;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public StrengthenMachineCaseData setNextPackage(final byte... values) {
      bitField0_ |= 0x00000008;
      nextPackage.copyFrom(values);
      return this;
    }

    @Override
    public StrengthenMachineCaseData copyFrom(final StrengthenMachineCaseData other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        times = other.times;
        discount = other.discount;
        firstFree = other.firstFree;
        nextPackage.copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public StrengthenMachineCaseData mergeFrom(final StrengthenMachineCaseData other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasTimes()) {
        setTimes(other.times);
      }
      if (other.hasDiscount()) {
        setDiscount(other.discount);
      }
      if (other.hasFirstFree()) {
        setFirstFree(other.firstFree);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public StrengthenMachineCaseData clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      times = 0;
      discount = 0;
      firstFree = false;
      nextPackage.clear();
      return this;
    }

    @Override
    public StrengthenMachineCaseData clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof StrengthenMachineCaseData)) {
        return false;
      }
      StrengthenMachineCaseData other = (StrengthenMachineCaseData) o;
      return bitField0_ == other.bitField0_
        && (!hasTimes() || times == other.times)
        && (!hasDiscount() || discount == other.discount)
        && (!hasFirstFree() || firstFree == other.firstFree)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt32NoTag(times);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 64);
        output.writeUInt32NoTag(discount);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawByte((byte) 56);
        output.writeBoolNoTag(firstFree);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(times);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(discount);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 2;
      }
      if ((bitField0_ & 0x00000008) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public StrengthenMachineCaseData mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            // times
            times = input.readUInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 64) {
              break;
            }
          }
          case 64: {
            // discount
            discount = input.readUInt32();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 56) {
              break;
            }
          }
          case 56: {
            // firstFree
            firstFree = input.readBool();
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000008;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeUInt32(FieldNames.times, times);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeUInt32(FieldNames.discount, discount);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeBool(FieldNames.firstFree, firstFree);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      output.endObject();
    }

    @Override
    public StrengthenMachineCaseData mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 80811814: {
            if (input.isAtField(FieldNames.times)) {
              if (!input.trySkipNullValue()) {
                times = input.readUInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 337828193: {
            if (input.isAtField(FieldNames.discount)) {
              if (!input.trySkipNullValue()) {
                discount = input.readUInt32();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 2136581404: {
            if (input.isAtField(FieldNames.firstFree)) {
              if (!input.trySkipNullValue()) {
                firstFree = input.readBool();
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000008;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public StrengthenMachineCaseData clone() {
      return new StrengthenMachineCaseData().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static StrengthenMachineCaseData parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new StrengthenMachineCaseData(), data).checkInitialized();
    }

    public static StrengthenMachineCaseData parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new StrengthenMachineCaseData(), input).checkInitialized();
    }

    public static StrengthenMachineCaseData parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new StrengthenMachineCaseData(), input).checkInitialized();
    }

    /**
     * @return factory for creating StrengthenMachineCaseData messages
     */
    public static MessageFactory<StrengthenMachineCaseData> getFactory() {
      return StrengthenMachineCaseDataFactory.INSTANCE;
    }

    private enum StrengthenMachineCaseDataFactory implements MessageFactory<StrengthenMachineCaseData> {
      INSTANCE;

      @Override
      public StrengthenMachineCaseData create() {
        return StrengthenMachineCaseData.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName times = FieldName.forField("Times");

      static final FieldName discount = FieldName.forField("Discount");

      static final FieldName firstFree = FieldName.forField("FirstFree");

      static final FieldName nextPackage = FieldName.forField("NextPackage");
    }
  }

  /**
   * Protobuf type {@code InteractEnterReq}
   */
  public static final class InteractEnterReq extends ProtoMessage<InteractEnterReq> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional uint32 MapId = 1;</code>
     */
    private int mapId;

    /**
     * <code>optional uint32 ParamId = 2;</code>
     */
    private int paramId;

    /**
     * <code>optional uint32 DateLen = 3;</code>
     */
    private int dateLen;

    /**
     * <code>optional uint32 MapTableId = 6;</code>
     */
    private int mapTableId;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    /**
     * <code>optional string ClientData = 4;</code>
     */
    private final Utf8String clientData = Utf8String.newEmptyInstance();

    /**
     * <code>optional string MapParam = 5;</code>
     */
    private final Utf8String mapParam = Utf8String.newEmptyInstance();

    private InteractEnterReq() {
    }

    /**
     * @return a new empty instance of {@code InteractEnterReq}
     */
    public static InteractEnterReq newInstance() {
      return new InteractEnterReq();
    }

    /**
     * <code>optional uint32 MapId = 1;</code>
     * @return whether the mapId field is set
     */
    public boolean hasMapId() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional uint32 MapId = 1;</code>
     * @return this
     */
    public InteractEnterReq clearMapId() {
      bitField0_ &= ~0x00000001;
      mapId = 0;
      return this;
    }

    /**
     * <code>optional uint32 MapId = 1;</code>
     * @return the mapId
     */
    public int getMapId() {
      return mapId;
    }

    /**
     * <code>optional uint32 MapId = 1;</code>
     * @param value the mapId to set
     * @return this
     */
    public InteractEnterReq setMapId(final int value) {
      bitField0_ |= 0x00000001;
      mapId = value;
      return this;
    }

    /**
     * <code>optional uint32 ParamId = 2;</code>
     * @return whether the paramId field is set
     */
    public boolean hasParamId() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional uint32 ParamId = 2;</code>
     * @return this
     */
    public InteractEnterReq clearParamId() {
      bitField0_ &= ~0x00000002;
      paramId = 0;
      return this;
    }

    /**
     * <code>optional uint32 ParamId = 2;</code>
     * @return the paramId
     */
    public int getParamId() {
      return paramId;
    }

    /**
     * <code>optional uint32 ParamId = 2;</code>
     * @param value the paramId to set
     * @return this
     */
    public InteractEnterReq setParamId(final int value) {
      bitField0_ |= 0x00000002;
      paramId = value;
      return this;
    }

    /**
     * <code>optional uint32 DateLen = 3;</code>
     * @return whether the dateLen field is set
     */
    public boolean hasDateLen() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional uint32 DateLen = 3;</code>
     * @return this
     */
    public InteractEnterReq clearDateLen() {
      bitField0_ &= ~0x00000004;
      dateLen = 0;
      return this;
    }

    /**
     * <code>optional uint32 DateLen = 3;</code>
     * @return the dateLen
     */
    public int getDateLen() {
      return dateLen;
    }

    /**
     * <code>optional uint32 DateLen = 3;</code>
     * @param value the dateLen to set
     * @return this
     */
    public InteractEnterReq setDateLen(final int value) {
      bitField0_ |= 0x00000004;
      dateLen = value;
      return this;
    }

    /**
     * <code>optional uint32 MapTableId = 6;</code>
     * @return whether the mapTableId field is set
     */
    public boolean hasMapTableId() {
      return (bitField0_ & 0x00000008) != 0;
    }

    /**
     * <code>optional uint32 MapTableId = 6;</code>
     * @return this
     */
    public InteractEnterReq clearMapTableId() {
      bitField0_ &= ~0x00000008;
      mapTableId = 0;
      return this;
    }

    /**
     * <code>optional uint32 MapTableId = 6;</code>
     * @return the mapTableId
     */
    public int getMapTableId() {
      return mapTableId;
    }

    /**
     * <code>optional uint32 MapTableId = 6;</code>
     * @param value the mapTableId to set
     * @return this
     */
    public InteractEnterReq setMapTableId(final int value) {
      bitField0_ |= 0x00000008;
      mapTableId = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000010) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public InteractEnterReq clearNextPackage() {
      bitField0_ &= ~0x00000010;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000010;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public InteractEnterReq addNextPackage(final byte value) {
      bitField0_ |= 0x00000010;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public InteractEnterReq addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000010;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public InteractEnterReq setNextPackage(final byte... values) {
      bitField0_ |= 0x00000010;
      nextPackage.copyFrom(values);
      return this;
    }

    /**
     * <code>optional string ClientData = 4;</code>
     * @return whether the clientData field is set
     */
    public boolean hasClientData() {
      return (bitField0_ & 0x00000020) != 0;
    }

    /**
     * <code>optional string ClientData = 4;</code>
     * @return this
     */
    public InteractEnterReq clearClientData() {
      bitField0_ &= ~0x00000020;
      clientData.clear();
      return this;
    }

    /**
     * <code>optional string ClientData = 4;</code>
     * @return the clientData
     */
    public String getClientData() {
      return clientData.getString();
    }

    /**
     * <code>optional string ClientData = 4;</code>
     * @return internal {@code Utf8String} representation of clientData for reading
     */
    public Utf8String getClientDataBytes() {
      return this.clientData;
    }

    /**
     * <code>optional string ClientData = 4;</code>
     * @return internal {@code Utf8String} representation of clientData for modifications
     */
    public Utf8String getMutableClientDataBytes() {
      bitField0_ |= 0x00000020;
      return this.clientData;
    }

    /**
     * <code>optional string ClientData = 4;</code>
     * @param value the clientData to set
     * @return this
     */
    public InteractEnterReq setClientData(final CharSequence value) {
      bitField0_ |= 0x00000020;
      clientData.copyFrom(value);
      return this;
    }

    /**
     * <code>optional string ClientData = 4;</code>
     * @param value the clientData to set
     * @return this
     */
    public InteractEnterReq setClientData(final Utf8String value) {
      bitField0_ |= 0x00000020;
      clientData.copyFrom(value);
      return this;
    }

    /**
     * <code>optional string MapParam = 5;</code>
     * @return whether the mapParam field is set
     */
    public boolean hasMapParam() {
      return (bitField0_ & 0x00000040) != 0;
    }

    /**
     * <code>optional string MapParam = 5;</code>
     * @return this
     */
    public InteractEnterReq clearMapParam() {
      bitField0_ &= ~0x00000040;
      mapParam.clear();
      return this;
    }

    /**
     * <code>optional string MapParam = 5;</code>
     * @return the mapParam
     */
    public String getMapParam() {
      return mapParam.getString();
    }

    /**
     * <code>optional string MapParam = 5;</code>
     * @return internal {@code Utf8String} representation of mapParam for reading
     */
    public Utf8String getMapParamBytes() {
      return this.mapParam;
    }

    /**
     * <code>optional string MapParam = 5;</code>
     * @return internal {@code Utf8String} representation of mapParam for modifications
     */
    public Utf8String getMutableMapParamBytes() {
      bitField0_ |= 0x00000040;
      return this.mapParam;
    }

    /**
     * <code>optional string MapParam = 5;</code>
     * @param value the mapParam to set
     * @return this
     */
    public InteractEnterReq setMapParam(final CharSequence value) {
      bitField0_ |= 0x00000040;
      mapParam.copyFrom(value);
      return this;
    }

    /**
     * <code>optional string MapParam = 5;</code>
     * @param value the mapParam to set
     * @return this
     */
    public InteractEnterReq setMapParam(final Utf8String value) {
      bitField0_ |= 0x00000040;
      mapParam.copyFrom(value);
      return this;
    }

    @Override
    public InteractEnterReq copyFrom(final InteractEnterReq other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        mapId = other.mapId;
        paramId = other.paramId;
        dateLen = other.dateLen;
        mapTableId = other.mapTableId;
        nextPackage.copyFrom(other.nextPackage);
        clientData.copyFrom(other.clientData);
        mapParam.copyFrom(other.mapParam);
      }
      return this;
    }

    @Override
    public InteractEnterReq mergeFrom(final InteractEnterReq other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasMapId()) {
        setMapId(other.mapId);
      }
      if (other.hasParamId()) {
        setParamId(other.paramId);
      }
      if (other.hasDateLen()) {
        setDateLen(other.dateLen);
      }
      if (other.hasMapTableId()) {
        setMapTableId(other.mapTableId);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      if (other.hasClientData()) {
        getMutableClientDataBytes().copyFrom(other.clientData);
      }
      if (other.hasMapParam()) {
        getMutableMapParamBytes().copyFrom(other.mapParam);
      }
      return this;
    }

    @Override
    public InteractEnterReq clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      mapId = 0;
      paramId = 0;
      dateLen = 0;
      mapTableId = 0;
      nextPackage.clear();
      clientData.clear();
      mapParam.clear();
      return this;
    }

    @Override
    public InteractEnterReq clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      clientData.clear();
      mapParam.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof InteractEnterReq)) {
        return false;
      }
      InteractEnterReq other = (InteractEnterReq) o;
      return bitField0_ == other.bitField0_
        && (!hasMapId() || mapId == other.mapId)
        && (!hasParamId() || paramId == other.paramId)
        && (!hasDateLen() || dateLen == other.dateLen)
        && (!hasMapTableId() || mapTableId == other.mapTableId)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage))
        && (!hasClientData() || clientData.equals(other.clientData))
        && (!hasMapParam() || mapParam.equals(other.mapParam));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt32NoTag(mapId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 16);
        output.writeUInt32NoTag(paramId);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawByte((byte) 24);
        output.writeUInt32NoTag(dateLen);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeRawByte((byte) 48);
        output.writeUInt32NoTag(mapTableId);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        output.writeRawByte((byte) 34);
        output.writeStringNoTag(clientData);
      }
      if ((bitField0_ & 0x00000040) != 0) {
        output.writeRawByte((byte) 42);
        output.writeStringNoTag(mapParam);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(mapId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(paramId);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(dateLen);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(mapTableId);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        size += 1 + ProtoSink.computeStringSizeNoTag(clientData);
      }
      if ((bitField0_ & 0x00000040) != 0) {
        size += 1 + ProtoSink.computeStringSizeNoTag(mapParam);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public InteractEnterReq mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            // mapId
            mapId = input.readUInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 16) {
              break;
            }
          }
          case 16: {
            // paramId
            paramId = input.readUInt32();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 24) {
              break;
            }
          }
          case 24: {
            // dateLen
            dateLen = input.readUInt32();
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 48) {
              break;
            }
          }
          case 48: {
            // mapTableId
            mapTableId = input.readUInt32();
            bitField0_ |= 0x00000008;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000010;
            tag = input.readTag();
            if (tag != 34) {
              break;
            }
          }
          case 34: {
            // clientData
            input.readString(clientData);
            bitField0_ |= 0x00000020;
            tag = input.readTag();
            if (tag != 42) {
              break;
            }
          }
          case 42: {
            // mapParam
            input.readString(mapParam);
            bitField0_ |= 0x00000040;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeUInt32(FieldNames.mapId, mapId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeUInt32(FieldNames.paramId, paramId);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeUInt32(FieldNames.dateLen, dateLen);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeUInt32(FieldNames.mapTableId, mapTableId);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        output.writeString(FieldNames.clientData, clientData);
      }
      if ((bitField0_ & 0x00000040) != 0) {
        output.writeString(FieldNames.mapParam, mapParam);
      }
      output.endObject();
    }

    @Override
    public InteractEnterReq mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 74110839: {
            if (input.isAtField(FieldNames.mapId)) {
              if (!input.trySkipNullValue()) {
                mapId = input.readUInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 871156328: {
            if (input.isAtField(FieldNames.paramId)) {
              if (!input.trySkipNullValue()) {
                paramId = input.readUInt32();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1187017881: {
            if (input.isAtField(FieldNames.dateLen)) {
              if (!input.trySkipNullValue()) {
                dateLen = input.readUInt32();
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 556914861: {
            if (input.isAtField(FieldNames.mapTableId)) {
              if (!input.trySkipNullValue()) {
                mapTableId = input.readUInt32();
                bitField0_ |= 0x00000008;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000010;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1199548875: {
            if (input.isAtField(FieldNames.clientData)) {
              if (!input.trySkipNullValue()) {
                input.readString(clientData);
                bitField0_ |= 0x00000020;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 229302449: {
            if (input.isAtField(FieldNames.mapParam)) {
              if (!input.trySkipNullValue()) {
                input.readString(mapParam);
                bitField0_ |= 0x00000040;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public InteractEnterReq clone() {
      return new InteractEnterReq().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static InteractEnterReq parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new InteractEnterReq(), data).checkInitialized();
    }

    public static InteractEnterReq parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new InteractEnterReq(), input).checkInitialized();
    }

    public static InteractEnterReq parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new InteractEnterReq(), input).checkInitialized();
    }

    /**
     * @return factory for creating InteractEnterReq messages
     */
    public static MessageFactory<InteractEnterReq> getFactory() {
      return InteractEnterReqFactory.INSTANCE;
    }

    private enum InteractEnterReqFactory implements MessageFactory<InteractEnterReq> {
      INSTANCE;

      @Override
      public InteractEnterReq create() {
        return InteractEnterReq.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName mapId = FieldName.forField("MapId");

      static final FieldName paramId = FieldName.forField("ParamId");

      static final FieldName dateLen = FieldName.forField("DateLen");

      static final FieldName mapTableId = FieldName.forField("MapTableId");

      static final FieldName nextPackage = FieldName.forField("NextPackage");

      static final FieldName clientData = FieldName.forField("ClientData");

      static final FieldName mapParam = FieldName.forField("MapParam");
    }
  }

  /**
   * Protobuf type {@code InteractEnterResp}
   */
  public static final class InteractEnterResp extends ProtoMessage<InteractEnterResp> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional .StarTowerRoom Room = 1;</code>
     */
    private final StarTowerRoom room = StarTowerRoom.newInstance();

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    private InteractEnterResp() {
    }

    /**
     * @return a new empty instance of {@code InteractEnterResp}
     */
    public static InteractEnterResp newInstance() {
      return new InteractEnterResp();
    }

    /**
     * <code>optional .StarTowerRoom Room = 1;</code>
     * @return whether the room field is set
     */
    public boolean hasRoom() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional .StarTowerRoom Room = 1;</code>
     * @return this
     */
    public InteractEnterResp clearRoom() {
      bitField0_ &= ~0x00000001;
      room.clear();
      return this;
    }

    /**
     * <code>optional .StarTowerRoom Room = 1;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableRoom()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public StarTowerRoom getRoom() {
      return room;
    }

    /**
     * <code>optional .StarTowerRoom Room = 1;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public StarTowerRoom getMutableRoom() {
      bitField0_ |= 0x00000001;
      return room;
    }

    /**
     * <code>optional .StarTowerRoom Room = 1;</code>
     * @param value the room to set
     * @return this
     */
    public InteractEnterResp setRoom(final StarTowerRoom value) {
      bitField0_ |= 0x00000001;
      room.copyFrom(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public InteractEnterResp clearNextPackage() {
      bitField0_ &= ~0x00000002;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000002;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public InteractEnterResp addNextPackage(final byte value) {
      bitField0_ |= 0x00000002;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public InteractEnterResp addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000002;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public InteractEnterResp setNextPackage(final byte... values) {
      bitField0_ |= 0x00000002;
      nextPackage.copyFrom(values);
      return this;
    }

    @Override
    public InteractEnterResp copyFrom(final InteractEnterResp other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        room.copyFrom(other.room);
        nextPackage.copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public InteractEnterResp mergeFrom(final InteractEnterResp other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasRoom()) {
        getMutableRoom().mergeFrom(other.room);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public InteractEnterResp clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      room.clear();
      nextPackage.clear();
      return this;
    }

    @Override
    public InteractEnterResp clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      room.clearQuick();
      nextPackage.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof InteractEnterResp)) {
        return false;
      }
      InteractEnterResp other = (InteractEnterResp) o;
      return bitField0_ == other.bitField0_
        && (!hasRoom() || room.equals(other.room))
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 10);
        output.writeMessageNoTag(room);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeMessageSizeNoTag(room);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public InteractEnterResp mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 10: {
            // room
            input.readMessage(room);
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeMessage(FieldNames.room, room);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      output.endObject();
    }

    @Override
    public InteractEnterResp mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 2553083: {
            if (input.isAtField(FieldNames.room)) {
              if (!input.trySkipNullValue()) {
                input.readMessage(room);
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public InteractEnterResp clone() {
      return new InteractEnterResp().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static InteractEnterResp parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new InteractEnterResp(), data).checkInitialized();
    }

    public static InteractEnterResp parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new InteractEnterResp(), input).checkInitialized();
    }

    public static InteractEnterResp parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new InteractEnterResp(), input).checkInitialized();
    }

    /**
     * @return factory for creating InteractEnterResp messages
     */
    public static MessageFactory<InteractEnterResp> getFactory() {
      return InteractEnterRespFactory.INSTANCE;
    }

    private enum InteractEnterRespFactory implements MessageFactory<InteractEnterResp> {
      INSTANCE;

      @Override
      public InteractEnterResp create() {
        return InteractEnterResp.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName room = FieldName.forField("Room");

      static final FieldName nextPackage = FieldName.forField("NextPackage");
    }
  }

  /**
   * Protobuf type {@code InteractBattleEndReq}
   */
  public static final class InteractBattleEndReq extends ProtoMessage<InteractBattleEndReq> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional bool Defeat = 2;</code>
     */
    private boolean defeat;

    /**
     * <code>optional .InteractBattleEndReq.VictoryData Victory = 1;</code>
     */
    private final VictoryData victory = VictoryData.newInstance();

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    private InteractBattleEndReq() {
    }

    /**
     * @return a new empty instance of {@code InteractBattleEndReq}
     */
    public static InteractBattleEndReq newInstance() {
      return new InteractBattleEndReq();
    }

    /**
     * <code>optional bool Defeat = 2;</code>
     * @return whether the defeat field is set
     */
    public boolean hasDefeat() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional bool Defeat = 2;</code>
     * @return this
     */
    public InteractBattleEndReq clearDefeat() {
      bitField0_ &= ~0x00000001;
      defeat = false;
      return this;
    }

    /**
     * <code>optional bool Defeat = 2;</code>
     * @return the defeat
     */
    public boolean getDefeat() {
      return defeat;
    }

    /**
     * <code>optional bool Defeat = 2;</code>
     * @param value the defeat to set
     * @return this
     */
    public InteractBattleEndReq setDefeat(final boolean value) {
      bitField0_ |= 0x00000001;
      defeat = value;
      return this;
    }

    /**
     * <code>optional .InteractBattleEndReq.VictoryData Victory = 1;</code>
     * @return whether the victory field is set
     */
    public boolean hasVictory() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional .InteractBattleEndReq.VictoryData Victory = 1;</code>
     * @return this
     */
    public InteractBattleEndReq clearVictory() {
      bitField0_ &= ~0x00000002;
      victory.clear();
      return this;
    }

    /**
     * <code>optional .InteractBattleEndReq.VictoryData Victory = 1;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableVictory()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public VictoryData getVictory() {
      return victory;
    }

    /**
     * <code>optional .InteractBattleEndReq.VictoryData Victory = 1;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public VictoryData getMutableVictory() {
      bitField0_ |= 0x00000002;
      return victory;
    }

    /**
     * <code>optional .InteractBattleEndReq.VictoryData Victory = 1;</code>
     * @param value the victory to set
     * @return this
     */
    public InteractBattleEndReq setVictory(final VictoryData value) {
      bitField0_ |= 0x00000002;
      victory.copyFrom(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public InteractBattleEndReq clearNextPackage() {
      bitField0_ &= ~0x00000004;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000004;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public InteractBattleEndReq addNextPackage(final byte value) {
      bitField0_ |= 0x00000004;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public InteractBattleEndReq addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000004;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public InteractBattleEndReq setNextPackage(final byte... values) {
      bitField0_ |= 0x00000004;
      nextPackage.copyFrom(values);
      return this;
    }

    @Override
    public InteractBattleEndReq copyFrom(final InteractBattleEndReq other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        defeat = other.defeat;
        victory.copyFrom(other.victory);
        nextPackage.copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public InteractBattleEndReq mergeFrom(final InteractBattleEndReq other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasDefeat()) {
        setDefeat(other.defeat);
      }
      if (other.hasVictory()) {
        getMutableVictory().mergeFrom(other.victory);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public InteractBattleEndReq clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      defeat = false;
      victory.clear();
      nextPackage.clear();
      return this;
    }

    @Override
    public InteractBattleEndReq clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      victory.clearQuick();
      nextPackage.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof InteractBattleEndReq)) {
        return false;
      }
      InteractBattleEndReq other = (InteractBattleEndReq) o;
      return bitField0_ == other.bitField0_
        && (!hasDefeat() || defeat == other.defeat)
        && (!hasVictory() || victory.equals(other.victory))
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 16);
        output.writeBoolNoTag(defeat);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 10);
        output.writeMessageNoTag(victory);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 2;
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeMessageSizeNoTag(victory);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public InteractBattleEndReq mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 16: {
            // defeat
            defeat = input.readBool();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 10) {
              break;
            }
          }
          case 10: {
            // victory
            input.readMessage(victory);
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeBool(FieldNames.defeat, defeat);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeMessage(FieldNames.victory, victory);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      output.endObject();
    }

    @Override
    public InteractBattleEndReq mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 2043196755: {
            if (input.isAtField(FieldNames.defeat)) {
              if (!input.trySkipNullValue()) {
                defeat = input.readBool();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 2116960754: {
            if (input.isAtField(FieldNames.victory)) {
              if (!input.trySkipNullValue()) {
                input.readMessage(victory);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public InteractBattleEndReq clone() {
      return new InteractBattleEndReq().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static InteractBattleEndReq parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new InteractBattleEndReq(), data).checkInitialized();
    }

    public static InteractBattleEndReq parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new InteractBattleEndReq(), input).checkInitialized();
    }

    public static InteractBattleEndReq parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new InteractBattleEndReq(), input).checkInitialized();
    }

    /**
     * @return factory for creating InteractBattleEndReq messages
     */
    public static MessageFactory<InteractBattleEndReq> getFactory() {
      return InteractBattleEndReqFactory.INSTANCE;
    }

    /**
     * Protobuf type {@code VictoryData}
     */
    public static final class VictoryData extends ProtoMessage<VictoryData> implements Cloneable {
      private static final long serialVersionUID = 0L;

      /**
       * <code>optional uint32 HP = 1;</code>
       */
      private int hP;

      /**
       * <code>optional uint32 Time = 2;</code>
       */
      private int time;

      /**
       * <code>optional uint32 DateLen = 3;</code>
       */
      private int dateLen;

      /**
       * <code>optional .Events Events = 15;</code>
       */
      private final Public.Events events = Public.Events.newInstance();

      /**
       * <code>optional string ClientData = 4;</code>
       */
      private final Utf8String clientData = Utf8String.newEmptyInstance();

      /**
       * <code>repeated uint32 Damages = 6;</code>
       */
      private final RepeatedInt damages = RepeatedInt.newEmptyInstance();

      /**
       * <code>repeated .FateCardUsage fateCardUsage = 5;</code>
       */
      private final RepeatedMessage<FateCardUsage> fateCardUsage = RepeatedMessage.newEmptyInstance(FateCardUsage.getFactory());

      private VictoryData() {
      }

      /**
       * @return a new empty instance of {@code VictoryData}
       */
      public static VictoryData newInstance() {
        return new VictoryData();
      }

      /**
       * <code>optional uint32 HP = 1;</code>
       * @return whether the hP field is set
       */
      public boolean hasHP() {
        return (bitField0_ & 0x00000001) != 0;
      }

      /**
       * <code>optional uint32 HP = 1;</code>
       * @return this
       */
      public VictoryData clearHP() {
        bitField0_ &= ~0x00000001;
        hP = 0;
        return this;
      }

      /**
       * <code>optional uint32 HP = 1;</code>
       * @return the hP
       */
      public int getHP() {
        return hP;
      }

      /**
       * <code>optional uint32 HP = 1;</code>
       * @param value the hP to set
       * @return this
       */
      public VictoryData setHP(final int value) {
        bitField0_ |= 0x00000001;
        hP = value;
        return this;
      }

      /**
       * <code>optional uint32 Time = 2;</code>
       * @return whether the time field is set
       */
      public boolean hasTime() {
        return (bitField0_ & 0x00000002) != 0;
      }

      /**
       * <code>optional uint32 Time = 2;</code>
       * @return this
       */
      public VictoryData clearTime() {
        bitField0_ &= ~0x00000002;
        time = 0;
        return this;
      }

      /**
       * <code>optional uint32 Time = 2;</code>
       * @return the time
       */
      public int getTime() {
        return time;
      }

      /**
       * <code>optional uint32 Time = 2;</code>
       * @param value the time to set
       * @return this
       */
      public VictoryData setTime(final int value) {
        bitField0_ |= 0x00000002;
        time = value;
        return this;
      }

      /**
       * <code>optional uint32 DateLen = 3;</code>
       * @return whether the dateLen field is set
       */
      public boolean hasDateLen() {
        return (bitField0_ & 0x00000004) != 0;
      }

      /**
       * <code>optional uint32 DateLen = 3;</code>
       * @return this
       */
      public VictoryData clearDateLen() {
        bitField0_ &= ~0x00000004;
        dateLen = 0;
        return this;
      }

      /**
       * <code>optional uint32 DateLen = 3;</code>
       * @return the dateLen
       */
      public int getDateLen() {
        return dateLen;
      }

      /**
       * <code>optional uint32 DateLen = 3;</code>
       * @param value the dateLen to set
       * @return this
       */
      public VictoryData setDateLen(final int value) {
        bitField0_ |= 0x00000004;
        dateLen = value;
        return this;
      }

      /**
       * <code>optional .Events Events = 15;</code>
       * @return whether the events field is set
       */
      public boolean hasEvents() {
        return (bitField0_ & 0x00000008) != 0;
      }

      /**
       * <code>optional .Events Events = 15;</code>
       * @return this
       */
      public VictoryData clearEvents() {
        bitField0_ &= ~0x00000008;
        events.clear();
        return this;
      }

      /**
       * <code>optional .Events Events = 15;</code>
       *
       * This method returns the internal storage object without modifying any has state.
       * The returned object should not be modified and be treated as read-only.
       *
       * Use {@link #getMutableEvents()} if you want to modify it.
       *
       * @return internal storage object for reading
       */
      public Public.Events getEvents() {
        return events;
      }

      /**
       * <code>optional .Events Events = 15;</code>
       *
       * This method returns the internal storage object and sets the corresponding
       * has state. The returned object will become part of this message and its
       * contents may be modified as long as the has state is not cleared.
       *
       * @return internal storage object for modifications
       */
      public Public.Events getMutableEvents() {
        bitField0_ |= 0x00000008;
        return events;
      }

      /**
       * <code>optional .Events Events = 15;</code>
       * @param value the events to set
       * @return this
       */
      public VictoryData setEvents(final Public.Events value) {
        bitField0_ |= 0x00000008;
        events.copyFrom(value);
        return this;
      }

      /**
       * <code>optional string ClientData = 4;</code>
       * @return whether the clientData field is set
       */
      public boolean hasClientData() {
        return (bitField0_ & 0x00000010) != 0;
      }

      /**
       * <code>optional string ClientData = 4;</code>
       * @return this
       */
      public VictoryData clearClientData() {
        bitField0_ &= ~0x00000010;
        clientData.clear();
        return this;
      }

      /**
       * <code>optional string ClientData = 4;</code>
       * @return the clientData
       */
      public String getClientData() {
        return clientData.getString();
      }

      /**
       * <code>optional string ClientData = 4;</code>
       * @return internal {@code Utf8String} representation of clientData for reading
       */
      public Utf8String getClientDataBytes() {
        return this.clientData;
      }

      /**
       * <code>optional string ClientData = 4;</code>
       * @return internal {@code Utf8String} representation of clientData for modifications
       */
      public Utf8String getMutableClientDataBytes() {
        bitField0_ |= 0x00000010;
        return this.clientData;
      }

      /**
       * <code>optional string ClientData = 4;</code>
       * @param value the clientData to set
       * @return this
       */
      public VictoryData setClientData(final CharSequence value) {
        bitField0_ |= 0x00000010;
        clientData.copyFrom(value);
        return this;
      }

      /**
       * <code>optional string ClientData = 4;</code>
       * @param value the clientData to set
       * @return this
       */
      public VictoryData setClientData(final Utf8String value) {
        bitField0_ |= 0x00000010;
        clientData.copyFrom(value);
        return this;
      }

      /**
       * <code>repeated uint32 Damages = 6;</code>
       * @return whether the damages field is set
       */
      public boolean hasDamages() {
        return (bitField0_ & 0x00000020) != 0;
      }

      /**
       * <code>repeated uint32 Damages = 6;</code>
       * @return this
       */
      public VictoryData clearDamages() {
        bitField0_ &= ~0x00000020;
        damages.clear();
        return this;
      }

      /**
       * <code>repeated uint32 Damages = 6;</code>
       *
       * This method returns the internal storage object without modifying any has state.
       * The returned object should not be modified and be treated as read-only.
       *
       * Use {@link #getMutableDamages()} if you want to modify it.
       *
       * @return internal storage object for reading
       */
      public RepeatedInt getDamages() {
        return damages;
      }

      /**
       * <code>repeated uint32 Damages = 6;</code>
       *
       * This method returns the internal storage object and sets the corresponding
       * has state. The returned object will become part of this message and its
       * contents may be modified as long as the has state is not cleared.
       *
       * @return internal storage object for modifications
       */
      public RepeatedInt getMutableDamages() {
        bitField0_ |= 0x00000020;
        return damages;
      }

      /**
       * <code>repeated uint32 Damages = 6;</code>
       * @param value the damages to add
       * @return this
       */
      public VictoryData addDamages(final int value) {
        bitField0_ |= 0x00000020;
        damages.add(value);
        return this;
      }

      /**
       * <code>repeated uint32 Damages = 6;</code>
       * @param values the damages to add
       * @return this
       */
      public VictoryData addAllDamages(final int... values) {
        bitField0_ |= 0x00000020;
        damages.addAll(values);
        return this;
      }

      /**
       * <code>repeated .FateCardUsage fateCardUsage = 5;</code>
       * @return whether the fateCardUsage field is set
       */
      public boolean hasFateCardUsage() {
        return (bitField0_ & 0x00000040) != 0;
      }

      /**
       * <code>repeated .FateCardUsage fateCardUsage = 5;</code>
       * @return this
       */
      public VictoryData clearFateCardUsage() {
        bitField0_ &= ~0x00000040;
        fateCardUsage.clear();
        return this;
      }

      /**
       * <code>repeated .FateCardUsage fateCardUsage = 5;</code>
       *
       * This method returns the internal storage object without modifying any has state.
       * The returned object should not be modified and be treated as read-only.
       *
       * Use {@link #getMutableFateCardUsage()} if you want to modify it.
       *
       * @return internal storage object for reading
       */
      public RepeatedMessage<FateCardUsage> getFateCardUsage() {
        return fateCardUsage;
      }

      /**
       * <code>repeated .FateCardUsage fateCardUsage = 5;</code>
       *
       * This method returns the internal storage object and sets the corresponding
       * has state. The returned object will become part of this message and its
       * contents may be modified as long as the has state is not cleared.
       *
       * @return internal storage object for modifications
       */
      public RepeatedMessage<FateCardUsage> getMutableFateCardUsage() {
        bitField0_ |= 0x00000040;
        return fateCardUsage;
      }

      /**
       * <code>repeated .FateCardUsage fateCardUsage = 5;</code>
       * @param value the fateCardUsage to add
       * @return this
       */
      public VictoryData addFateCardUsage(final FateCardUsage value) {
        bitField0_ |= 0x00000040;
        fateCardUsage.add(value);
        return this;
      }

      /**
       * <code>repeated .FateCardUsage fateCardUsage = 5;</code>
       * @param values the fateCardUsage to add
       * @return this
       */
      public VictoryData addAllFateCardUsage(final FateCardUsage... values) {
        bitField0_ |= 0x00000040;
        fateCardUsage.addAll(values);
        return this;
      }

      @Override
      public VictoryData copyFrom(final VictoryData other) {
        cachedSize = other.cachedSize;
        if ((bitField0_ | other.bitField0_) != 0) {
          bitField0_ = other.bitField0_;
          hP = other.hP;
          time = other.time;
          dateLen = other.dateLen;
          events.copyFrom(other.events);
          clientData.copyFrom(other.clientData);
          damages.copyFrom(other.damages);
          fateCardUsage.copyFrom(other.fateCardUsage);
        }
        return this;
      }

      @Override
      public VictoryData mergeFrom(final VictoryData other) {
        if (other.isEmpty()) {
          return this;
        }
        cachedSize = -1;
        if (other.hasHP()) {
          setHP(other.hP);
        }
        if (other.hasTime()) {
          setTime(other.time);
        }
        if (other.hasDateLen()) {
          setDateLen(other.dateLen);
        }
        if (other.hasEvents()) {
          getMutableEvents().mergeFrom(other.events);
        }
        if (other.hasClientData()) {
          getMutableClientDataBytes().copyFrom(other.clientData);
        }
        if (other.hasDamages()) {
          getMutableDamages().addAll(other.damages);
        }
        if (other.hasFateCardUsage()) {
          getMutableFateCardUsage().addAll(other.fateCardUsage);
        }
        return this;
      }

      @Override
      public VictoryData clear() {
        if (isEmpty()) {
          return this;
        }
        cachedSize = -1;
        bitField0_ = 0;
        hP = 0;
        time = 0;
        dateLen = 0;
        events.clear();
        clientData.clear();
        damages.clear();
        fateCardUsage.clear();
        return this;
      }

      @Override
      public VictoryData clearQuick() {
        if (isEmpty()) {
          return this;
        }
        cachedSize = -1;
        bitField0_ = 0;
        events.clearQuick();
        clientData.clear();
        damages.clear();
        fateCardUsage.clearQuick();
        return this;
      }

      @Override
      public boolean equals(Object o) {
        if (o == this) {
          return true;
        }
        if (!(o instanceof VictoryData)) {
          return false;
        }
        VictoryData other = (VictoryData) o;
        return bitField0_ == other.bitField0_
          && (!hasHP() || hP == other.hP)
          && (!hasTime() || time == other.time)
          && (!hasDateLen() || dateLen == other.dateLen)
          && (!hasEvents() || events.equals(other.events))
          && (!hasClientData() || clientData.equals(other.clientData))
          && (!hasDamages() || damages.equals(other.damages))
          && (!hasFateCardUsage() || fateCardUsage.equals(other.fateCardUsage));
      }

      @Override
      public void writeTo(final ProtoSink output) throws IOException {
        if ((bitField0_ & 0x00000001) != 0) {
          output.writeRawByte((byte) 8);
          output.writeUInt32NoTag(hP);
        }
        if ((bitField0_ & 0x00000002) != 0) {
          output.writeRawByte((byte) 16);
          output.writeUInt32NoTag(time);
        }
        if ((bitField0_ & 0x00000004) != 0) {
          output.writeRawByte((byte) 24);
          output.writeUInt32NoTag(dateLen);
        }
        if ((bitField0_ & 0x00000008) != 0) {
          output.writeRawByte((byte) 122);
          output.writeMessageNoTag(events);
        }
        if ((bitField0_ & 0x00000010) != 0) {
          output.writeRawByte((byte) 34);
          output.writeStringNoTag(clientData);
        }
        if ((bitField0_ & 0x00000020) != 0) {
          for (int i = 0; i < damages.length(); i++) {
            output.writeRawByte((byte) 48);
            output.writeUInt32NoTag(damages.array()[i]);
          }
        }
        if ((bitField0_ & 0x00000040) != 0) {
          for (int i = 0; i < fateCardUsage.length(); i++) {
            output.writeRawByte((byte) 42);
            output.writeMessageNoTag(fateCardUsage.get(i));
          }
        }
      }

      @Override
      protected int computeSerializedSize() {
        int size = 0;
        if ((bitField0_ & 0x00000001) != 0) {
          size += 1 + ProtoSink.computeUInt32SizeNoTag(hP);
        }
        if ((bitField0_ & 0x00000002) != 0) {
          size += 1 + ProtoSink.computeUInt32SizeNoTag(time);
        }
        if ((bitField0_ & 0x00000004) != 0) {
          size += 1 + ProtoSink.computeUInt32SizeNoTag(dateLen);
        }
        if ((bitField0_ & 0x00000008) != 0) {
          size += 1 + ProtoSink.computeMessageSizeNoTag(events);
        }
        if ((bitField0_ & 0x00000010) != 0) {
          size += 1 + ProtoSink.computeStringSizeNoTag(clientData);
        }
        if ((bitField0_ & 0x00000020) != 0) {
          size += (1 * damages.length()) + ProtoSink.computeRepeatedUInt32SizeNoTag(damages);
        }
        if ((bitField0_ & 0x00000040) != 0) {
          size += (1 * fateCardUsage.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(fateCardUsage);
        }
        return size;
      }

      @Override
      @SuppressWarnings("fallthrough")
      public VictoryData mergeFrom(final ProtoSource input) throws IOException {
        // Enabled Fall-Through Optimization (QuickBuffers)
        int tag = input.readTag();
        while (true) {
          switch (tag) {
            case 8: {
              // hP
              hP = input.readUInt32();
              bitField0_ |= 0x00000001;
              tag = input.readTag();
              if (tag != 16) {
                break;
              }
            }
            case 16: {
              // time
              time = input.readUInt32();
              bitField0_ |= 0x00000002;
              tag = input.readTag();
              if (tag != 24) {
                break;
              }
            }
            case 24: {
              // dateLen
              dateLen = input.readUInt32();
              bitField0_ |= 0x00000004;
              tag = input.readTag();
              if (tag != 122) {
                break;
              }
            }
            case 122: {
              // events
              input.readMessage(events);
              bitField0_ |= 0x00000008;
              tag = input.readTag();
              if (tag != 34) {
                break;
              }
            }
            case 34: {
              // clientData
              input.readString(clientData);
              bitField0_ |= 0x00000010;
              tag = input.readTag();
              if (tag != 50) {
                break;
              }
            }
            case 50: {
              // damages [packed=true]
              input.readPackedUInt32(damages, tag);
              bitField0_ |= 0x00000020;
              tag = input.readTag();
              if (tag != 42) {
                break;
              }
            }
            case 42: {
              // fateCardUsage
              tag = input.readRepeatedMessage(fateCardUsage, tag);
              bitField0_ |= 0x00000040;
              if (tag != 0) {
                break;
              }
            }
            case 0: {
              return this;
            }
            default: {
              if (!input.skipField(tag)) {
                return this;
              }
              tag = input.readTag();
              break;
            }
            case 48: {
              // damages [packed=false]
              tag = input.readRepeatedUInt32(damages, tag);
              bitField0_ |= 0x00000020;
              break;
            }
          }
        }
      }

      @Override
      public void writeTo(final JsonSink output) throws IOException {
        output.beginObject();
        if ((bitField0_ & 0x00000001) != 0) {
          output.writeUInt32(FieldNames.hP, hP);
        }
        if ((bitField0_ & 0x00000002) != 0) {
          output.writeUInt32(FieldNames.time, time);
        }
        if ((bitField0_ & 0x00000004) != 0) {
          output.writeUInt32(FieldNames.dateLen, dateLen);
        }
        if ((bitField0_ & 0x00000008) != 0) {
          output.writeMessage(FieldNames.events, events);
        }
        if ((bitField0_ & 0x00000010) != 0) {
          output.writeString(FieldNames.clientData, clientData);
        }
        if ((bitField0_ & 0x00000020) != 0) {
          output.writeRepeatedUInt32(FieldNames.damages, damages);
        }
        if ((bitField0_ & 0x00000040) != 0) {
          output.writeRepeatedMessage(FieldNames.fateCardUsage, fateCardUsage);
        }
        output.endObject();
      }

      @Override
      public VictoryData mergeFrom(final JsonSource input) throws IOException {
        if (!input.beginObject()) {
          return this;
        }
        while (!input.isAtEnd()) {
          switch (input.readFieldHash()) {
            case 2312: {
              if (input.isAtField(FieldNames.hP)) {
                if (!input.trySkipNullValue()) {
                  hP = input.readUInt32();
                  bitField0_ |= 0x00000001;
                }
              } else {
                input.skipUnknownField();
              }
              break;
            }
            case 2606829: {
              if (input.isAtField(FieldNames.time)) {
                if (!input.trySkipNullValue()) {
                  time = input.readUInt32();
                  bitField0_ |= 0x00000002;
                }
              } else {
                input.skipUnknownField();
              }
              break;
            }
            case -1187017881: {
              if (input.isAtField(FieldNames.dateLen)) {
                if (!input.trySkipNullValue()) {
                  dateLen = input.readUInt32();
                  bitField0_ |= 0x00000004;
                }
              } else {
                input.skipUnknownField();
              }
              break;
            }
            case 2087505209: {
              if (input.isAtField(FieldNames.events)) {
                if (!input.trySkipNullValue()) {
                  input.readMessage(events);
                  bitField0_ |= 0x00000008;
                }
              } else {
                input.skipUnknownField();
              }
              break;
            }
            case -1199548875: {
              if (input.isAtField(FieldNames.clientData)) {
                if (!input.trySkipNullValue()) {
                  input.readString(clientData);
                  bitField0_ |= 0x00000010;
                }
              } else {
                input.skipUnknownField();
              }
              break;
            }
            case -1193575740: {
              if (input.isAtField(FieldNames.damages)) {
                if (!input.trySkipNullValue()) {
                  input.readRepeatedUInt32(damages);
                  bitField0_ |= 0x00000020;
                }
              } else {
                input.skipUnknownField();
              }
              break;
            }
            case 862485861: {
              if (input.isAtField(FieldNames.fateCardUsage)) {
                if (!input.trySkipNullValue()) {
                  input.readRepeatedMessage(fateCardUsage);
                  bitField0_ |= 0x00000040;
                }
              } else {
                input.skipUnknownField();
              }
              break;
            }
            default: {
              input.skipUnknownField();
              break;
            }
          }
        }
        input.endObject();
        return this;
      }

      @Override
      public VictoryData clone() {
        return new VictoryData().copyFrom(this);
      }

      @Override
      public boolean isEmpty() {
        return ((bitField0_) == 0);
      }

      public static VictoryData parseFrom(final byte[] data) throws InvalidProtocolBufferException {
        return ProtoMessage.mergeFrom(new VictoryData(), data).checkInitialized();
      }

      public static VictoryData parseFrom(final ProtoSource input) throws IOException {
        return ProtoMessage.mergeFrom(new VictoryData(), input).checkInitialized();
      }

      public static VictoryData parseFrom(final JsonSource input) throws IOException {
        return ProtoMessage.mergeFrom(new VictoryData(), input).checkInitialized();
      }

      /**
       * @return factory for creating VictoryData messages
       */
      public static MessageFactory<VictoryData> getFactory() {
        return VictoryDataFactory.INSTANCE;
      }

      private enum VictoryDataFactory implements MessageFactory<VictoryData> {
        INSTANCE;

        @Override
        public VictoryData create() {
          return VictoryData.newInstance();
        }
      }

      /**
       * Contains name constants used for serializing JSON
       */
      static class FieldNames {
        static final FieldName hP = FieldName.forField("HP");

        static final FieldName time = FieldName.forField("Time");

        static final FieldName dateLen = FieldName.forField("DateLen");

        static final FieldName events = FieldName.forField("Events");

        static final FieldName clientData = FieldName.forField("ClientData");

        static final FieldName damages = FieldName.forField("Damages");

        static final FieldName fateCardUsage = FieldName.forField("fateCardUsage");
      }
    }

    private enum InteractBattleEndReqFactory implements MessageFactory<InteractBattleEndReq> {
      INSTANCE;

      @Override
      public InteractBattleEndReq create() {
        return InteractBattleEndReq.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName defeat = FieldName.forField("Defeat");

      static final FieldName victory = FieldName.forField("Victory");

      static final FieldName nextPackage = FieldName.forField("NextPackage");
    }
  }

  /**
   * Protobuf type {@code InteractBattleEndResp}
   */
  public static final class InteractBattleEndResp extends ProtoMessage<InteractBattleEndResp> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional .InteractBattleEndResp.VictoryData Victory = 1;</code>
     */
    private final VictoryData victory = VictoryData.newInstance();

    /**
     * <code>optional .InteractBattleEndResp.DefeatData Defeat = 2;</code>
     */
    private final DefeatData defeat = DefeatData.newInstance();

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    private InteractBattleEndResp() {
    }

    /**
     * @return a new empty instance of {@code InteractBattleEndResp}
     */
    public static InteractBattleEndResp newInstance() {
      return new InteractBattleEndResp();
    }

    /**
     * <code>optional .InteractBattleEndResp.VictoryData Victory = 1;</code>
     * @return whether the victory field is set
     */
    public boolean hasVictory() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional .InteractBattleEndResp.VictoryData Victory = 1;</code>
     * @return this
     */
    public InteractBattleEndResp clearVictory() {
      bitField0_ &= ~0x00000001;
      victory.clear();
      return this;
    }

    /**
     * <code>optional .InteractBattleEndResp.VictoryData Victory = 1;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableVictory()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public VictoryData getVictory() {
      return victory;
    }

    /**
     * <code>optional .InteractBattleEndResp.VictoryData Victory = 1;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public VictoryData getMutableVictory() {
      bitField0_ |= 0x00000001;
      return victory;
    }

    /**
     * <code>optional .InteractBattleEndResp.VictoryData Victory = 1;</code>
     * @param value the victory to set
     * @return this
     */
    public InteractBattleEndResp setVictory(final VictoryData value) {
      bitField0_ |= 0x00000001;
      victory.copyFrom(value);
      return this;
    }

    /**
     * <code>optional .InteractBattleEndResp.DefeatData Defeat = 2;</code>
     * @return whether the defeat field is set
     */
    public boolean hasDefeat() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional .InteractBattleEndResp.DefeatData Defeat = 2;</code>
     * @return this
     */
    public InteractBattleEndResp clearDefeat() {
      bitField0_ &= ~0x00000002;
      defeat.clear();
      return this;
    }

    /**
     * <code>optional .InteractBattleEndResp.DefeatData Defeat = 2;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableDefeat()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public DefeatData getDefeat() {
      return defeat;
    }

    /**
     * <code>optional .InteractBattleEndResp.DefeatData Defeat = 2;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public DefeatData getMutableDefeat() {
      bitField0_ |= 0x00000002;
      return defeat;
    }

    /**
     * <code>optional .InteractBattleEndResp.DefeatData Defeat = 2;</code>
     * @param value the defeat to set
     * @return this
     */
    public InteractBattleEndResp setDefeat(final DefeatData value) {
      bitField0_ |= 0x00000002;
      defeat.copyFrom(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public InteractBattleEndResp clearNextPackage() {
      bitField0_ &= ~0x00000004;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000004;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public InteractBattleEndResp addNextPackage(final byte value) {
      bitField0_ |= 0x00000004;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public InteractBattleEndResp addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000004;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public InteractBattleEndResp setNextPackage(final byte... values) {
      bitField0_ |= 0x00000004;
      nextPackage.copyFrom(values);
      return this;
    }

    @Override
    public InteractBattleEndResp copyFrom(final InteractBattleEndResp other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        victory.copyFrom(other.victory);
        defeat.copyFrom(other.defeat);
        nextPackage.copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public InteractBattleEndResp mergeFrom(final InteractBattleEndResp other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasVictory()) {
        getMutableVictory().mergeFrom(other.victory);
      }
      if (other.hasDefeat()) {
        getMutableDefeat().mergeFrom(other.defeat);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public InteractBattleEndResp clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      victory.clear();
      defeat.clear();
      nextPackage.clear();
      return this;
    }

    @Override
    public InteractBattleEndResp clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      victory.clearQuick();
      defeat.clearQuick();
      nextPackage.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof InteractBattleEndResp)) {
        return false;
      }
      InteractBattleEndResp other = (InteractBattleEndResp) o;
      return bitField0_ == other.bitField0_
        && (!hasVictory() || victory.equals(other.victory))
        && (!hasDefeat() || defeat.equals(other.defeat))
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 10);
        output.writeMessageNoTag(victory);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 18);
        output.writeMessageNoTag(defeat);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeMessageSizeNoTag(victory);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeMessageSizeNoTag(defeat);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public InteractBattleEndResp mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 10: {
            // victory
            input.readMessage(victory);
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 18) {
              break;
            }
          }
          case 18: {
            // defeat
            input.readMessage(defeat);
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeMessage(FieldNames.victory, victory);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeMessage(FieldNames.defeat, defeat);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      output.endObject();
    }

    @Override
    public InteractBattleEndResp mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 2116960754: {
            if (input.isAtField(FieldNames.victory)) {
              if (!input.trySkipNullValue()) {
                input.readMessage(victory);
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 2043196755: {
            if (input.isAtField(FieldNames.defeat)) {
              if (!input.trySkipNullValue()) {
                input.readMessage(defeat);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public InteractBattleEndResp clone() {
      return new InteractBattleEndResp().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static InteractBattleEndResp parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new InteractBattleEndResp(), data).checkInitialized();
    }

    public static InteractBattleEndResp parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new InteractBattleEndResp(), input).checkInitialized();
    }

    public static InteractBattleEndResp parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new InteractBattleEndResp(), input).checkInitialized();
    }

    /**
     * @return factory for creating InteractBattleEndResp messages
     */
    public static MessageFactory<InteractBattleEndResp> getFactory() {
      return InteractBattleEndRespFactory.INSTANCE;
    }

    /**
     * Protobuf type {@code VictoryData}
     */
    public static final class VictoryData extends ProtoMessage<VictoryData> implements Cloneable {
      private static final long serialVersionUID = 0L;

      /**
       * <code>optional uint32 Exp = 1;</code>
       */
      private int exp;

      /**
       * <code>optional uint32 Lv = 2;</code>
       */
      private int lv;

      /**
       * <code>optional uint32 BattleTime = 10;</code>
       */
      private int battleTime;

      private VictoryData() {
      }

      /**
       * @return a new empty instance of {@code VictoryData}
       */
      public static VictoryData newInstance() {
        return new VictoryData();
      }

      /**
       * <code>optional uint32 Exp = 1;</code>
       * @return whether the exp field is set
       */
      public boolean hasExp() {
        return (bitField0_ & 0x00000001) != 0;
      }

      /**
       * <code>optional uint32 Exp = 1;</code>
       * @return this
       */
      public VictoryData clearExp() {
        bitField0_ &= ~0x00000001;
        exp = 0;
        return this;
      }

      /**
       * <code>optional uint32 Exp = 1;</code>
       * @return the exp
       */
      public int getExp() {
        return exp;
      }

      /**
       * <code>optional uint32 Exp = 1;</code>
       * @param value the exp to set
       * @return this
       */
      public VictoryData setExp(final int value) {
        bitField0_ |= 0x00000001;
        exp = value;
        return this;
      }

      /**
       * <code>optional uint32 Lv = 2;</code>
       * @return whether the lv field is set
       */
      public boolean hasLv() {
        return (bitField0_ & 0x00000002) != 0;
      }

      /**
       * <code>optional uint32 Lv = 2;</code>
       * @return this
       */
      public VictoryData clearLv() {
        bitField0_ &= ~0x00000002;
        lv = 0;
        return this;
      }

      /**
       * <code>optional uint32 Lv = 2;</code>
       * @return the lv
       */
      public int getLv() {
        return lv;
      }

      /**
       * <code>optional uint32 Lv = 2;</code>
       * @param value the lv to set
       * @return this
       */
      public VictoryData setLv(final int value) {
        bitField0_ |= 0x00000002;
        lv = value;
        return this;
      }

      /**
       * <code>optional uint32 BattleTime = 10;</code>
       * @return whether the battleTime field is set
       */
      public boolean hasBattleTime() {
        return (bitField0_ & 0x00000004) != 0;
      }

      /**
       * <code>optional uint32 BattleTime = 10;</code>
       * @return this
       */
      public VictoryData clearBattleTime() {
        bitField0_ &= ~0x00000004;
        battleTime = 0;
        return this;
      }

      /**
       * <code>optional uint32 BattleTime = 10;</code>
       * @return the battleTime
       */
      public int getBattleTime() {
        return battleTime;
      }

      /**
       * <code>optional uint32 BattleTime = 10;</code>
       * @param value the battleTime to set
       * @return this
       */
      public VictoryData setBattleTime(final int value) {
        bitField0_ |= 0x00000004;
        battleTime = value;
        return this;
      }

      @Override
      public VictoryData copyFrom(final VictoryData other) {
        cachedSize = other.cachedSize;
        if ((bitField0_ | other.bitField0_) != 0) {
          bitField0_ = other.bitField0_;
          exp = other.exp;
          lv = other.lv;
          battleTime = other.battleTime;
        }
        return this;
      }

      @Override
      public VictoryData mergeFrom(final VictoryData other) {
        if (other.isEmpty()) {
          return this;
        }
        cachedSize = -1;
        if (other.hasExp()) {
          setExp(other.exp);
        }
        if (other.hasLv()) {
          setLv(other.lv);
        }
        if (other.hasBattleTime()) {
          setBattleTime(other.battleTime);
        }
        return this;
      }

      @Override
      public VictoryData clear() {
        if (isEmpty()) {
          return this;
        }
        cachedSize = -1;
        bitField0_ = 0;
        exp = 0;
        lv = 0;
        battleTime = 0;
        return this;
      }

      @Override
      public VictoryData clearQuick() {
        if (isEmpty()) {
          return this;
        }
        cachedSize = -1;
        bitField0_ = 0;
        return this;
      }

      @Override
      public boolean equals(Object o) {
        if (o == this) {
          return true;
        }
        if (!(o instanceof VictoryData)) {
          return false;
        }
        VictoryData other = (VictoryData) o;
        return bitField0_ == other.bitField0_
          && (!hasExp() || exp == other.exp)
          && (!hasLv() || lv == other.lv)
          && (!hasBattleTime() || battleTime == other.battleTime);
      }

      @Override
      public void writeTo(final ProtoSink output) throws IOException {
        if ((bitField0_ & 0x00000001) != 0) {
          output.writeRawByte((byte) 8);
          output.writeUInt32NoTag(exp);
        }
        if ((bitField0_ & 0x00000002) != 0) {
          output.writeRawByte((byte) 16);
          output.writeUInt32NoTag(lv);
        }
        if ((bitField0_ & 0x00000004) != 0) {
          output.writeRawByte((byte) 80);
          output.writeUInt32NoTag(battleTime);
        }
      }

      @Override
      protected int computeSerializedSize() {
        int size = 0;
        if ((bitField0_ & 0x00000001) != 0) {
          size += 1 + ProtoSink.computeUInt32SizeNoTag(exp);
        }
        if ((bitField0_ & 0x00000002) != 0) {
          size += 1 + ProtoSink.computeUInt32SizeNoTag(lv);
        }
        if ((bitField0_ & 0x00000004) != 0) {
          size += 1 + ProtoSink.computeUInt32SizeNoTag(battleTime);
        }
        return size;
      }

      @Override
      @SuppressWarnings("fallthrough")
      public VictoryData mergeFrom(final ProtoSource input) throws IOException {
        // Enabled Fall-Through Optimization (QuickBuffers)
        int tag = input.readTag();
        while (true) {
          switch (tag) {
            case 8: {
              // exp
              exp = input.readUInt32();
              bitField0_ |= 0x00000001;
              tag = input.readTag();
              if (tag != 16) {
                break;
              }
            }
            case 16: {
              // lv
              lv = input.readUInt32();
              bitField0_ |= 0x00000002;
              tag = input.readTag();
              if (tag != 80) {
                break;
              }
            }
            case 80: {
              // battleTime
              battleTime = input.readUInt32();
              bitField0_ |= 0x00000004;
              tag = input.readTag();
              if (tag != 0) {
                break;
              }
            }
            case 0: {
              return this;
            }
            default: {
              if (!input.skipField(tag)) {
                return this;
              }
              tag = input.readTag();
              break;
            }
          }
        }
      }

      @Override
      public void writeTo(final JsonSink output) throws IOException {
        output.beginObject();
        if ((bitField0_ & 0x00000001) != 0) {
          output.writeUInt32(FieldNames.exp, exp);
        }
        if ((bitField0_ & 0x00000002) != 0) {
          output.writeUInt32(FieldNames.lv, lv);
        }
        if ((bitField0_ & 0x00000004) != 0) {
          output.writeUInt32(FieldNames.battleTime, battleTime);
        }
        output.endObject();
      }

      @Override
      public VictoryData mergeFrom(final JsonSource input) throws IOException {
        if (!input.beginObject()) {
          return this;
        }
        while (!input.isAtEnd()) {
          switch (input.readFieldHash()) {
            case 70141: {
              if (input.isAtField(FieldNames.exp)) {
                if (!input.trySkipNullValue()) {
                  exp = input.readUInt32();
                  bitField0_ |= 0x00000001;
                }
              } else {
                input.skipUnknownField();
              }
              break;
            }
            case 2474: {
              if (input.isAtField(FieldNames.lv)) {
                if (!input.trySkipNullValue()) {
                  lv = input.readUInt32();
                  bitField0_ |= 0x00000002;
                }
              } else {
                input.skipUnknownField();
              }
              break;
            }
            case -247801915: {
              if (input.isAtField(FieldNames.battleTime)) {
                if (!input.trySkipNullValue()) {
                  battleTime = input.readUInt32();
                  bitField0_ |= 0x00000004;
                }
              } else {
                input.skipUnknownField();
              }
              break;
            }
            default: {
              input.skipUnknownField();
              break;
            }
          }
        }
        input.endObject();
        return this;
      }

      @Override
      public VictoryData clone() {
        return new VictoryData().copyFrom(this);
      }

      @Override
      public boolean isEmpty() {
        return ((bitField0_) == 0);
      }

      public static VictoryData parseFrom(final byte[] data) throws InvalidProtocolBufferException {
        return ProtoMessage.mergeFrom(new VictoryData(), data).checkInitialized();
      }

      public static VictoryData parseFrom(final ProtoSource input) throws IOException {
        return ProtoMessage.mergeFrom(new VictoryData(), input).checkInitialized();
      }

      public static VictoryData parseFrom(final JsonSource input) throws IOException {
        return ProtoMessage.mergeFrom(new VictoryData(), input).checkInitialized();
      }

      /**
       * @return factory for creating VictoryData messages
       */
      public static MessageFactory<VictoryData> getFactory() {
        return VictoryDataFactory.INSTANCE;
      }

      private enum VictoryDataFactory implements MessageFactory<VictoryData> {
        INSTANCE;

        @Override
        public VictoryData create() {
          return VictoryData.newInstance();
        }
      }

      /**
       * Contains name constants used for serializing JSON
       */
      static class FieldNames {
        static final FieldName exp = FieldName.forField("Exp");

        static final FieldName lv = FieldName.forField("Lv");

        static final FieldName battleTime = FieldName.forField("BattleTime");
      }
    }

    /**
     * Protobuf type {@code DefeatData}
     */
    public static final class DefeatData extends ProtoMessage<DefeatData> implements Cloneable {
      private static final long serialVersionUID = 0L;

      /**
       * <code>optional uint32 Lv = 1;</code>
       */
      private int lv;

      private DefeatData() {
      }

      /**
       * @return a new empty instance of {@code DefeatData}
       */
      public static DefeatData newInstance() {
        return new DefeatData();
      }

      /**
       * <code>optional uint32 Lv = 1;</code>
       * @return whether the lv field is set
       */
      public boolean hasLv() {
        return (bitField0_ & 0x00000001) != 0;
      }

      /**
       * <code>optional uint32 Lv = 1;</code>
       * @return this
       */
      public DefeatData clearLv() {
        bitField0_ &= ~0x00000001;
        lv = 0;
        return this;
      }

      /**
       * <code>optional uint32 Lv = 1;</code>
       * @return the lv
       */
      public int getLv() {
        return lv;
      }

      /**
       * <code>optional uint32 Lv = 1;</code>
       * @param value the lv to set
       * @return this
       */
      public DefeatData setLv(final int value) {
        bitField0_ |= 0x00000001;
        lv = value;
        return this;
      }

      @Override
      public DefeatData copyFrom(final DefeatData other) {
        cachedSize = other.cachedSize;
        if ((bitField0_ | other.bitField0_) != 0) {
          bitField0_ = other.bitField0_;
          lv = other.lv;
        }
        return this;
      }

      @Override
      public DefeatData mergeFrom(final DefeatData other) {
        if (other.isEmpty()) {
          return this;
        }
        cachedSize = -1;
        if (other.hasLv()) {
          setLv(other.lv);
        }
        return this;
      }

      @Override
      public DefeatData clear() {
        if (isEmpty()) {
          return this;
        }
        cachedSize = -1;
        bitField0_ = 0;
        lv = 0;
        return this;
      }

      @Override
      public DefeatData clearQuick() {
        if (isEmpty()) {
          return this;
        }
        cachedSize = -1;
        bitField0_ = 0;
        return this;
      }

      @Override
      public boolean equals(Object o) {
        if (o == this) {
          return true;
        }
        if (!(o instanceof DefeatData)) {
          return false;
        }
        DefeatData other = (DefeatData) o;
        return bitField0_ == other.bitField0_
          && (!hasLv() || lv == other.lv);
      }

      @Override
      public void writeTo(final ProtoSink output) throws IOException {
        if ((bitField0_ & 0x00000001) != 0) {
          output.writeRawByte((byte) 8);
          output.writeUInt32NoTag(lv);
        }
      }

      @Override
      protected int computeSerializedSize() {
        int size = 0;
        if ((bitField0_ & 0x00000001) != 0) {
          size += 1 + ProtoSink.computeUInt32SizeNoTag(lv);
        }
        return size;
      }

      @Override
      @SuppressWarnings("fallthrough")
      public DefeatData mergeFrom(final ProtoSource input) throws IOException {
        // Enabled Fall-Through Optimization (QuickBuffers)
        int tag = input.readTag();
        while (true) {
          switch (tag) {
            case 8: {
              // lv
              lv = input.readUInt32();
              bitField0_ |= 0x00000001;
              tag = input.readTag();
              if (tag != 0) {
                break;
              }
            }
            case 0: {
              return this;
            }
            default: {
              if (!input.skipField(tag)) {
                return this;
              }
              tag = input.readTag();
              break;
            }
          }
        }
      }

      @Override
      public void writeTo(final JsonSink output) throws IOException {
        output.beginObject();
        if ((bitField0_ & 0x00000001) != 0) {
          output.writeUInt32(FieldNames.lv, lv);
        }
        output.endObject();
      }

      @Override
      public DefeatData mergeFrom(final JsonSource input) throws IOException {
        if (!input.beginObject()) {
          return this;
        }
        while (!input.isAtEnd()) {
          switch (input.readFieldHash()) {
            case 2474: {
              if (input.isAtField(FieldNames.lv)) {
                if (!input.trySkipNullValue()) {
                  lv = input.readUInt32();
                  bitField0_ |= 0x00000001;
                }
              } else {
                input.skipUnknownField();
              }
              break;
            }
            default: {
              input.skipUnknownField();
              break;
            }
          }
        }
        input.endObject();
        return this;
      }

      @Override
      public DefeatData clone() {
        return new DefeatData().copyFrom(this);
      }

      @Override
      public boolean isEmpty() {
        return ((bitField0_) == 0);
      }

      public static DefeatData parseFrom(final byte[] data) throws InvalidProtocolBufferException {
        return ProtoMessage.mergeFrom(new DefeatData(), data).checkInitialized();
      }

      public static DefeatData parseFrom(final ProtoSource input) throws IOException {
        return ProtoMessage.mergeFrom(new DefeatData(), input).checkInitialized();
      }

      public static DefeatData parseFrom(final JsonSource input) throws IOException {
        return ProtoMessage.mergeFrom(new DefeatData(), input).checkInitialized();
      }

      /**
       * @return factory for creating DefeatData messages
       */
      public static MessageFactory<DefeatData> getFactory() {
        return DefeatDataFactory.INSTANCE;
      }

      private enum DefeatDataFactory implements MessageFactory<DefeatData> {
        INSTANCE;

        @Override
        public DefeatData create() {
          return DefeatData.newInstance();
        }
      }

      /**
       * Contains name constants used for serializing JSON
       */
      static class FieldNames {
        static final FieldName lv = FieldName.forField("Lv");
      }
    }

    private enum InteractBattleEndRespFactory implements MessageFactory<InteractBattleEndResp> {
      INSTANCE;

      @Override
      public InteractBattleEndResp create() {
        return InteractBattleEndResp.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName victory = FieldName.forField("Victory");

      static final FieldName defeat = FieldName.forField("Defeat");

      static final FieldName nextPackage = FieldName.forField("NextPackage");
    }
  }

  /**
   * Protobuf type {@code InteractRecoveryHPReq}
   */
  public static final class InteractRecoveryHPReq extends ProtoMessage<InteractRecoveryHPReq> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional uint32 Hp = 1;</code>
     */
    private int hp;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    private InteractRecoveryHPReq() {
    }

    /**
     * @return a new empty instance of {@code InteractRecoveryHPReq}
     */
    public static InteractRecoveryHPReq newInstance() {
      return new InteractRecoveryHPReq();
    }

    /**
     * <code>optional uint32 Hp = 1;</code>
     * @return whether the hp field is set
     */
    public boolean hasHp() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional uint32 Hp = 1;</code>
     * @return this
     */
    public InteractRecoveryHPReq clearHp() {
      bitField0_ &= ~0x00000001;
      hp = 0;
      return this;
    }

    /**
     * <code>optional uint32 Hp = 1;</code>
     * @return the hp
     */
    public int getHp() {
      return hp;
    }

    /**
     * <code>optional uint32 Hp = 1;</code>
     * @param value the hp to set
     * @return this
     */
    public InteractRecoveryHPReq setHp(final int value) {
      bitField0_ |= 0x00000001;
      hp = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public InteractRecoveryHPReq clearNextPackage() {
      bitField0_ &= ~0x00000002;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000002;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public InteractRecoveryHPReq addNextPackage(final byte value) {
      bitField0_ |= 0x00000002;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public InteractRecoveryHPReq addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000002;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public InteractRecoveryHPReq setNextPackage(final byte... values) {
      bitField0_ |= 0x00000002;
      nextPackage.copyFrom(values);
      return this;
    }

    @Override
    public InteractRecoveryHPReq copyFrom(final InteractRecoveryHPReq other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        hp = other.hp;
        nextPackage.copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public InteractRecoveryHPReq mergeFrom(final InteractRecoveryHPReq other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasHp()) {
        setHp(other.hp);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public InteractRecoveryHPReq clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      hp = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public InteractRecoveryHPReq clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof InteractRecoveryHPReq)) {
        return false;
      }
      InteractRecoveryHPReq other = (InteractRecoveryHPReq) o;
      return bitField0_ == other.bitField0_
        && (!hasHp() || hp == other.hp)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt32NoTag(hp);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(hp);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public InteractRecoveryHPReq mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            // hp
            hp = input.readUInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeUInt32(FieldNames.hp, hp);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      output.endObject();
    }

    @Override
    public InteractRecoveryHPReq mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 2344: {
            if (input.isAtField(FieldNames.hp)) {
              if (!input.trySkipNullValue()) {
                hp = input.readUInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public InteractRecoveryHPReq clone() {
      return new InteractRecoveryHPReq().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static InteractRecoveryHPReq parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new InteractRecoveryHPReq(), data).checkInitialized();
    }

    public static InteractRecoveryHPReq parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new InteractRecoveryHPReq(), input).checkInitialized();
    }

    public static InteractRecoveryHPReq parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new InteractRecoveryHPReq(), input).checkInitialized();
    }

    /**
     * @return factory for creating InteractRecoveryHPReq messages
     */
    public static MessageFactory<InteractRecoveryHPReq> getFactory() {
      return InteractRecoveryHPReqFactory.INSTANCE;
    }

    private enum InteractRecoveryHPReqFactory implements MessageFactory<InteractRecoveryHPReq> {
      INSTANCE;

      @Override
      public InteractRecoveryHPReq create() {
        return InteractRecoveryHPReq.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName hp = FieldName.forField("Hp");

      static final FieldName nextPackage = FieldName.forField("NextPackage");
    }
  }

  /**
   * Protobuf type {@code FateCardUsage}
   */
  public static final class FateCardUsage extends ProtoMessage<FateCardUsage> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional uint32 Id = 1;</code>
     */
    private int id;

    /**
     * <code>optional uint32 Times = 2;</code>
     */
    private int times;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    private FateCardUsage() {
    }

    /**
     * @return a new empty instance of {@code FateCardUsage}
     */
    public static FateCardUsage newInstance() {
      return new FateCardUsage();
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @return whether the id field is set
     */
    public boolean hasId() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @return this
     */
    public FateCardUsage clearId() {
      bitField0_ &= ~0x00000001;
      id = 0;
      return this;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @return the id
     */
    public int getId() {
      return id;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @param value the id to set
     * @return this
     */
    public FateCardUsage setId(final int value) {
      bitField0_ |= 0x00000001;
      id = value;
      return this;
    }

    /**
     * <code>optional uint32 Times = 2;</code>
     * @return whether the times field is set
     */
    public boolean hasTimes() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional uint32 Times = 2;</code>
     * @return this
     */
    public FateCardUsage clearTimes() {
      bitField0_ &= ~0x00000002;
      times = 0;
      return this;
    }

    /**
     * <code>optional uint32 Times = 2;</code>
     * @return the times
     */
    public int getTimes() {
      return times;
    }

    /**
     * <code>optional uint32 Times = 2;</code>
     * @param value the times to set
     * @return this
     */
    public FateCardUsage setTimes(final int value) {
      bitField0_ |= 0x00000002;
      times = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public FateCardUsage clearNextPackage() {
      bitField0_ &= ~0x00000004;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000004;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public FateCardUsage addNextPackage(final byte value) {
      bitField0_ |= 0x00000004;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public FateCardUsage addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000004;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public FateCardUsage setNextPackage(final byte... values) {
      bitField0_ |= 0x00000004;
      nextPackage.copyFrom(values);
      return this;
    }

    @Override
    public FateCardUsage copyFrom(final FateCardUsage other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        id = other.id;
        times = other.times;
        nextPackage.copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public FateCardUsage mergeFrom(final FateCardUsage other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasId()) {
        setId(other.id);
      }
      if (other.hasTimes()) {
        setTimes(other.times);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public FateCardUsage clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      id = 0;
      times = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public FateCardUsage clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof FateCardUsage)) {
        return false;
      }
      FateCardUsage other = (FateCardUsage) o;
      return bitField0_ == other.bitField0_
        && (!hasId() || id == other.id)
        && (!hasTimes() || times == other.times)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt32NoTag(id);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 16);
        output.writeUInt32NoTag(times);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(id);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(times);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public FateCardUsage mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            // id
            id = input.readUInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 16) {
              break;
            }
          }
          case 16: {
            // times
            times = input.readUInt32();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeUInt32(FieldNames.id, id);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeUInt32(FieldNames.times, times);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      output.endObject();
    }

    @Override
    public FateCardUsage mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 2363: {
            if (input.isAtField(FieldNames.id)) {
              if (!input.trySkipNullValue()) {
                id = input.readUInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 80811814: {
            if (input.isAtField(FieldNames.times)) {
              if (!input.trySkipNullValue()) {
                times = input.readUInt32();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public FateCardUsage clone() {
      return new FateCardUsage().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static FateCardUsage parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new FateCardUsage(), data).checkInitialized();
    }

    public static FateCardUsage parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new FateCardUsage(), input).checkInitialized();
    }

    public static FateCardUsage parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new FateCardUsage(), input).checkInitialized();
    }

    /**
     * @return factory for creating FateCardUsage messages
     */
    public static MessageFactory<FateCardUsage> getFactory() {
      return FateCardUsageFactory.INSTANCE;
    }

    private enum FateCardUsageFactory implements MessageFactory<FateCardUsage> {
      INSTANCE;

      @Override
      public FateCardUsage create() {
        return FateCardUsage.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName id = FieldName.forField("Id");

      static final FieldName times = FieldName.forField("Times");

      static final FieldName nextPackage = FieldName.forField("NextPackage");
    }
  }

  /**
   * Protobuf type {@code InteractSelectReq}
   */
  public static final class InteractSelectReq extends ProtoMessage<InteractSelectReq> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional uint32 Index = 1;</code>
     */
    private int index;

    /**
     * <code>optional bool ReRoll = 2;</code>
     */
    private boolean reRoll;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    private InteractSelectReq() {
    }

    /**
     * @return a new empty instance of {@code InteractSelectReq}
     */
    public static InteractSelectReq newInstance() {
      return new InteractSelectReq();
    }

    /**
     * <code>optional uint32 Index = 1;</code>
     * @return whether the index field is set
     */
    public boolean hasIndex() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional uint32 Index = 1;</code>
     * @return this
     */
    public InteractSelectReq clearIndex() {
      bitField0_ &= ~0x00000001;
      index = 0;
      return this;
    }

    /**
     * <code>optional uint32 Index = 1;</code>
     * @return the index
     */
    public int getIndex() {
      return index;
    }

    /**
     * <code>optional uint32 Index = 1;</code>
     * @param value the index to set
     * @return this
     */
    public InteractSelectReq setIndex(final int value) {
      bitField0_ |= 0x00000001;
      index = value;
      return this;
    }

    /**
     * <code>optional bool ReRoll = 2;</code>
     * @return whether the reRoll field is set
     */
    public boolean hasReRoll() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional bool ReRoll = 2;</code>
     * @return this
     */
    public InteractSelectReq clearReRoll() {
      bitField0_ &= ~0x00000002;
      reRoll = false;
      return this;
    }

    /**
     * <code>optional bool ReRoll = 2;</code>
     * @return the reRoll
     */
    public boolean getReRoll() {
      return reRoll;
    }

    /**
     * <code>optional bool ReRoll = 2;</code>
     * @param value the reRoll to set
     * @return this
     */
    public InteractSelectReq setReRoll(final boolean value) {
      bitField0_ |= 0x00000002;
      reRoll = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public InteractSelectReq clearNextPackage() {
      bitField0_ &= ~0x00000004;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000004;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public InteractSelectReq addNextPackage(final byte value) {
      bitField0_ |= 0x00000004;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public InteractSelectReq addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000004;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public InteractSelectReq setNextPackage(final byte... values) {
      bitField0_ |= 0x00000004;
      nextPackage.copyFrom(values);
      return this;
    }

    @Override
    public InteractSelectReq copyFrom(final InteractSelectReq other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        index = other.index;
        reRoll = other.reRoll;
        nextPackage.copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public InteractSelectReq mergeFrom(final InteractSelectReq other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasIndex()) {
        setIndex(other.index);
      }
      if (other.hasReRoll()) {
        setReRoll(other.reRoll);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public InteractSelectReq clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      index = 0;
      reRoll = false;
      nextPackage.clear();
      return this;
    }

    @Override
    public InteractSelectReq clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof InteractSelectReq)) {
        return false;
      }
      InteractSelectReq other = (InteractSelectReq) o;
      return bitField0_ == other.bitField0_
        && (!hasIndex() || index == other.index)
        && (!hasReRoll() || reRoll == other.reRoll)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt32NoTag(index);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 16);
        output.writeBoolNoTag(reRoll);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(index);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 2;
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public InteractSelectReq mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            // index
            index = input.readUInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 16) {
              break;
            }
          }
          case 16: {
            // reRoll
            reRoll = input.readBool();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeUInt32(FieldNames.index, index);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeBool(FieldNames.reRoll, reRoll);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      output.endObject();
    }

    @Override
    public InteractSelectReq mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 70793394: {
            if (input.isAtField(FieldNames.index)) {
              if (!input.trySkipNullValue()) {
                index = input.readUInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1851548304: {
            if (input.isAtField(FieldNames.reRoll)) {
              if (!input.trySkipNullValue()) {
                reRoll = input.readBool();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public InteractSelectReq clone() {
      return new InteractSelectReq().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static InteractSelectReq parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new InteractSelectReq(), data).checkInitialized();
    }

    public static InteractSelectReq parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new InteractSelectReq(), input).checkInitialized();
    }

    public static InteractSelectReq parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new InteractSelectReq(), input).checkInitialized();
    }

    /**
     * @return factory for creating InteractSelectReq messages
     */
    public static MessageFactory<InteractSelectReq> getFactory() {
      return InteractSelectReqFactory.INSTANCE;
    }

    private enum InteractSelectReqFactory implements MessageFactory<InteractSelectReq> {
      INSTANCE;

      @Override
      public InteractSelectReq create() {
        return InteractSelectReq.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName index = FieldName.forField("Index");

      static final FieldName reRoll = FieldName.forField("ReRoll");

      static final FieldName nextPackage = FieldName.forField("NextPackage");
    }
  }

  /**
   * Protobuf type {@code InteractSelectResp}
   */
  public static final class InteractSelectResp extends ProtoMessage<InteractSelectResp> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional .InteractSelectResp.Success Resp = 1;</code>
     */
    private final Success resp = Success.newInstance();

    /**
     * <code>optional .SelectSpecialPotentialCaseData SelectSpecialPotentialCase = 2;</code>
     */
    private final SelectSpecialPotentialCaseData selectSpecialPotentialCase = SelectSpecialPotentialCaseData.newInstance();

    /**
     * <code>optional .SelectPotentialCaseData SelectPotentialCase = 3;</code>
     */
    private final SelectPotentialCaseData selectPotentialCase = SelectPotentialCaseData.newInstance();

    /**
     * <code>optional .SelectFateCardCaseData SelectFateCardCase = 4;</code>
     */
    private final SelectFateCardCaseData selectFateCardCase = SelectFateCardCaseData.newInstance();

    /**
     * <code>optional .HawkerCaseData HawkerCase = 5;</code>
     */
    private final HawkerCaseData hawkerCase = HawkerCaseData.newInstance();

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    private InteractSelectResp() {
    }

    /**
     * @return a new empty instance of {@code InteractSelectResp}
     */
    public static InteractSelectResp newInstance() {
      return new InteractSelectResp();
    }

    /**
     * <code>optional .InteractSelectResp.Success Resp = 1;</code>
     * @return whether the resp field is set
     */
    public boolean hasResp() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional .InteractSelectResp.Success Resp = 1;</code>
     * @return this
     */
    public InteractSelectResp clearResp() {
      bitField0_ &= ~0x00000001;
      resp.clear();
      return this;
    }

    /**
     * <code>optional .InteractSelectResp.Success Resp = 1;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableResp()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public Success getResp() {
      return resp;
    }

    /**
     * <code>optional .InteractSelectResp.Success Resp = 1;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public Success getMutableResp() {
      bitField0_ |= 0x00000001;
      return resp;
    }

    /**
     * <code>optional .InteractSelectResp.Success Resp = 1;</code>
     * @param value the resp to set
     * @return this
     */
    public InteractSelectResp setResp(final Success value) {
      bitField0_ |= 0x00000001;
      resp.copyFrom(value);
      return this;
    }

    /**
     * <code>optional .SelectSpecialPotentialCaseData SelectSpecialPotentialCase = 2;</code>
     * @return whether the selectSpecialPotentialCase field is set
     */
    public boolean hasSelectSpecialPotentialCase() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional .SelectSpecialPotentialCaseData SelectSpecialPotentialCase = 2;</code>
     * @return this
     */
    public InteractSelectResp clearSelectSpecialPotentialCase() {
      bitField0_ &= ~0x00000002;
      selectSpecialPotentialCase.clear();
      return this;
    }

    /**
     * <code>optional .SelectSpecialPotentialCaseData SelectSpecialPotentialCase = 2;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableSelectSpecialPotentialCase()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public SelectSpecialPotentialCaseData getSelectSpecialPotentialCase() {
      return selectSpecialPotentialCase;
    }

    /**
     * <code>optional .SelectSpecialPotentialCaseData SelectSpecialPotentialCase = 2;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public SelectSpecialPotentialCaseData getMutableSelectSpecialPotentialCase() {
      bitField0_ |= 0x00000002;
      return selectSpecialPotentialCase;
    }

    /**
     * <code>optional .SelectSpecialPotentialCaseData SelectSpecialPotentialCase = 2;</code>
     * @param value the selectSpecialPotentialCase to set
     * @return this
     */
    public InteractSelectResp setSelectSpecialPotentialCase(
        final SelectSpecialPotentialCaseData value) {
      bitField0_ |= 0x00000002;
      selectSpecialPotentialCase.copyFrom(value);
      return this;
    }

    /**
     * <code>optional .SelectPotentialCaseData SelectPotentialCase = 3;</code>
     * @return whether the selectPotentialCase field is set
     */
    public boolean hasSelectPotentialCase() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional .SelectPotentialCaseData SelectPotentialCase = 3;</code>
     * @return this
     */
    public InteractSelectResp clearSelectPotentialCase() {
      bitField0_ &= ~0x00000004;
      selectPotentialCase.clear();
      return this;
    }

    /**
     * <code>optional .SelectPotentialCaseData SelectPotentialCase = 3;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableSelectPotentialCase()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public SelectPotentialCaseData getSelectPotentialCase() {
      return selectPotentialCase;
    }

    /**
     * <code>optional .SelectPotentialCaseData SelectPotentialCase = 3;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public SelectPotentialCaseData getMutableSelectPotentialCase() {
      bitField0_ |= 0x00000004;
      return selectPotentialCase;
    }

    /**
     * <code>optional .SelectPotentialCaseData SelectPotentialCase = 3;</code>
     * @param value the selectPotentialCase to set
     * @return this
     */
    public InteractSelectResp setSelectPotentialCase(final SelectPotentialCaseData value) {
      bitField0_ |= 0x00000004;
      selectPotentialCase.copyFrom(value);
      return this;
    }

    /**
     * <code>optional .SelectFateCardCaseData SelectFateCardCase = 4;</code>
     * @return whether the selectFateCardCase field is set
     */
    public boolean hasSelectFateCardCase() {
      return (bitField0_ & 0x00000008) != 0;
    }

    /**
     * <code>optional .SelectFateCardCaseData SelectFateCardCase = 4;</code>
     * @return this
     */
    public InteractSelectResp clearSelectFateCardCase() {
      bitField0_ &= ~0x00000008;
      selectFateCardCase.clear();
      return this;
    }

    /**
     * <code>optional .SelectFateCardCaseData SelectFateCardCase = 4;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableSelectFateCardCase()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public SelectFateCardCaseData getSelectFateCardCase() {
      return selectFateCardCase;
    }

    /**
     * <code>optional .SelectFateCardCaseData SelectFateCardCase = 4;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public SelectFateCardCaseData getMutableSelectFateCardCase() {
      bitField0_ |= 0x00000008;
      return selectFateCardCase;
    }

    /**
     * <code>optional .SelectFateCardCaseData SelectFateCardCase = 4;</code>
     * @param value the selectFateCardCase to set
     * @return this
     */
    public InteractSelectResp setSelectFateCardCase(final SelectFateCardCaseData value) {
      bitField0_ |= 0x00000008;
      selectFateCardCase.copyFrom(value);
      return this;
    }

    /**
     * <code>optional .HawkerCaseData HawkerCase = 5;</code>
     * @return whether the hawkerCase field is set
     */
    public boolean hasHawkerCase() {
      return (bitField0_ & 0x00000010) != 0;
    }

    /**
     * <code>optional .HawkerCaseData HawkerCase = 5;</code>
     * @return this
     */
    public InteractSelectResp clearHawkerCase() {
      bitField0_ &= ~0x00000010;
      hawkerCase.clear();
      return this;
    }

    /**
     * <code>optional .HawkerCaseData HawkerCase = 5;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableHawkerCase()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public HawkerCaseData getHawkerCase() {
      return hawkerCase;
    }

    /**
     * <code>optional .HawkerCaseData HawkerCase = 5;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public HawkerCaseData getMutableHawkerCase() {
      bitField0_ |= 0x00000010;
      return hawkerCase;
    }

    /**
     * <code>optional .HawkerCaseData HawkerCase = 5;</code>
     * @param value the hawkerCase to set
     * @return this
     */
    public InteractSelectResp setHawkerCase(final HawkerCaseData value) {
      bitField0_ |= 0x00000010;
      hawkerCase.copyFrom(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000020) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public InteractSelectResp clearNextPackage() {
      bitField0_ &= ~0x00000020;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000020;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public InteractSelectResp addNextPackage(final byte value) {
      bitField0_ |= 0x00000020;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public InteractSelectResp addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000020;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public InteractSelectResp setNextPackage(final byte... values) {
      bitField0_ |= 0x00000020;
      nextPackage.copyFrom(values);
      return this;
    }

    @Override
    public InteractSelectResp copyFrom(final InteractSelectResp other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        resp.copyFrom(other.resp);
        selectSpecialPotentialCase.copyFrom(other.selectSpecialPotentialCase);
        selectPotentialCase.copyFrom(other.selectPotentialCase);
        selectFateCardCase.copyFrom(other.selectFateCardCase);
        hawkerCase.copyFrom(other.hawkerCase);
        nextPackage.copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public InteractSelectResp mergeFrom(final InteractSelectResp other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasResp()) {
        getMutableResp().mergeFrom(other.resp);
      }
      if (other.hasSelectSpecialPotentialCase()) {
        getMutableSelectSpecialPotentialCase().mergeFrom(other.selectSpecialPotentialCase);
      }
      if (other.hasSelectPotentialCase()) {
        getMutableSelectPotentialCase().mergeFrom(other.selectPotentialCase);
      }
      if (other.hasSelectFateCardCase()) {
        getMutableSelectFateCardCase().mergeFrom(other.selectFateCardCase);
      }
      if (other.hasHawkerCase()) {
        getMutableHawkerCase().mergeFrom(other.hawkerCase);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public InteractSelectResp clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      resp.clear();
      selectSpecialPotentialCase.clear();
      selectPotentialCase.clear();
      selectFateCardCase.clear();
      hawkerCase.clear();
      nextPackage.clear();
      return this;
    }

    @Override
    public InteractSelectResp clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      resp.clearQuick();
      selectSpecialPotentialCase.clearQuick();
      selectPotentialCase.clearQuick();
      selectFateCardCase.clearQuick();
      hawkerCase.clearQuick();
      nextPackage.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof InteractSelectResp)) {
        return false;
      }
      InteractSelectResp other = (InteractSelectResp) o;
      return bitField0_ == other.bitField0_
        && (!hasResp() || resp.equals(other.resp))
        && (!hasSelectSpecialPotentialCase() || selectSpecialPotentialCase.equals(other.selectSpecialPotentialCase))
        && (!hasSelectPotentialCase() || selectPotentialCase.equals(other.selectPotentialCase))
        && (!hasSelectFateCardCase() || selectFateCardCase.equals(other.selectFateCardCase))
        && (!hasHawkerCase() || hawkerCase.equals(other.hawkerCase))
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 10);
        output.writeMessageNoTag(resp);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 18);
        output.writeMessageNoTag(selectSpecialPotentialCase);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawByte((byte) 26);
        output.writeMessageNoTag(selectPotentialCase);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeRawByte((byte) 34);
        output.writeMessageNoTag(selectFateCardCase);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        output.writeRawByte((byte) 42);
        output.writeMessageNoTag(hawkerCase);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeMessageSizeNoTag(resp);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeMessageSizeNoTag(selectSpecialPotentialCase);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 1 + ProtoSink.computeMessageSizeNoTag(selectPotentialCase);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        size += 1 + ProtoSink.computeMessageSizeNoTag(selectFateCardCase);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        size += 1 + ProtoSink.computeMessageSizeNoTag(hawkerCase);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public InteractSelectResp mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 10: {
            // resp
            input.readMessage(resp);
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 18) {
              break;
            }
          }
          case 18: {
            // selectSpecialPotentialCase
            input.readMessage(selectSpecialPotentialCase);
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 26) {
              break;
            }
          }
          case 26: {
            // selectPotentialCase
            input.readMessage(selectPotentialCase);
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 34) {
              break;
            }
          }
          case 34: {
            // selectFateCardCase
            input.readMessage(selectFateCardCase);
            bitField0_ |= 0x00000008;
            tag = input.readTag();
            if (tag != 42) {
              break;
            }
          }
          case 42: {
            // hawkerCase
            input.readMessage(hawkerCase);
            bitField0_ |= 0x00000010;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000020;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeMessage(FieldNames.resp, resp);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeMessage(FieldNames.selectSpecialPotentialCase, selectSpecialPotentialCase);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeMessage(FieldNames.selectPotentialCase, selectPotentialCase);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeMessage(FieldNames.selectFateCardCase, selectFateCardCase);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        output.writeMessage(FieldNames.hawkerCase, hawkerCase);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      output.endObject();
    }

    @Override
    public InteractSelectResp mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 2543600: {
            if (input.isAtField(FieldNames.resp)) {
              if (!input.trySkipNullValue()) {
                input.readMessage(resp);
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1667710095: {
            if (input.isAtField(FieldNames.selectSpecialPotentialCase)) {
              if (!input.trySkipNullValue()) {
                input.readMessage(selectSpecialPotentialCase);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 929377458: {
            if (input.isAtField(FieldNames.selectPotentialCase)) {
              if (!input.trySkipNullValue()) {
                input.readMessage(selectPotentialCase);
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 1348869672: {
            if (input.isAtField(FieldNames.selectFateCardCase)) {
              if (!input.trySkipNullValue()) {
                input.readMessage(selectFateCardCase);
                bitField0_ |= 0x00000008;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -79930006: {
            if (input.isAtField(FieldNames.hawkerCase)) {
              if (!input.trySkipNullValue()) {
                input.readMessage(hawkerCase);
                bitField0_ |= 0x00000010;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000020;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public InteractSelectResp clone() {
      return new InteractSelectResp().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static InteractSelectResp parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new InteractSelectResp(), data).checkInitialized();
    }

    public static InteractSelectResp parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new InteractSelectResp(), input).checkInitialized();
    }

    public static InteractSelectResp parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new InteractSelectResp(), input).checkInitialized();
    }

    /**
     * @return factory for creating InteractSelectResp messages
     */
    public static MessageFactory<InteractSelectResp> getFactory() {
      return InteractSelectRespFactory.INSTANCE;
    }

    /**
     * Protobuf type {@code Success}
     */
    public static final class Success extends ProtoMessage<Success> implements Cloneable {
      private static final long serialVersionUID = 0L;

      /**
       * <code>optional uint32 OptionsParamId = 5;</code>
       */
      private int optionsParamId;

      /**
       * <code>optional bool OptionsResult = 2;</code>
       */
      private boolean optionsResult;

      /**
       * <code>repeated .ItemTpl Items = 1;</code>
       */
      private final RepeatedMessage<Public.ItemTpl> items = RepeatedMessage.newEmptyInstance(Public.ItemTpl.getFactory());

      /**
       * <code>repeated .FateCardInfo FateCard = 3;</code>
       */
      private final RepeatedMessage<FateCardInfo> fateCard = RepeatedMessage.newEmptyInstance(FateCardInfo.getFactory());

      /**
       * <code>repeated .SubNoteSkillInfo SubNoteSkills = 4;</code>
       */
      private final RepeatedMessage<SubNoteSkillInfo> subNoteSkills = RepeatedMessage.newEmptyInstance(SubNoteSkillInfo.getFactory());

      /**
       * <code>repeated .NPCAffinityChange AffinityChange = 6;</code>
       */
      private final RepeatedMessage<NPCAffinityChange> affinityChange = RepeatedMessage.newEmptyInstance(NPCAffinityChange.getFactory());

      private Success() {
      }

      /**
       * @return a new empty instance of {@code Success}
       */
      public static Success newInstance() {
        return new Success();
      }

      /**
       * <code>optional uint32 OptionsParamId = 5;</code>
       * @return whether the optionsParamId field is set
       */
      public boolean hasOptionsParamId() {
        return (bitField0_ & 0x00000001) != 0;
      }

      /**
       * <code>optional uint32 OptionsParamId = 5;</code>
       * @return this
       */
      public Success clearOptionsParamId() {
        bitField0_ &= ~0x00000001;
        optionsParamId = 0;
        return this;
      }

      /**
       * <code>optional uint32 OptionsParamId = 5;</code>
       * @return the optionsParamId
       */
      public int getOptionsParamId() {
        return optionsParamId;
      }

      /**
       * <code>optional uint32 OptionsParamId = 5;</code>
       * @param value the optionsParamId to set
       * @return this
       */
      public Success setOptionsParamId(final int value) {
        bitField0_ |= 0x00000001;
        optionsParamId = value;
        return this;
      }

      /**
       * <code>optional bool OptionsResult = 2;</code>
       * @return whether the optionsResult field is set
       */
      public boolean hasOptionsResult() {
        return (bitField0_ & 0x00000002) != 0;
      }

      /**
       * <code>optional bool OptionsResult = 2;</code>
       * @return this
       */
      public Success clearOptionsResult() {
        bitField0_ &= ~0x00000002;
        optionsResult = false;
        return this;
      }

      /**
       * <code>optional bool OptionsResult = 2;</code>
       * @return the optionsResult
       */
      public boolean getOptionsResult() {
        return optionsResult;
      }

      /**
       * <code>optional bool OptionsResult = 2;</code>
       * @param value the optionsResult to set
       * @return this
       */
      public Success setOptionsResult(final boolean value) {
        bitField0_ |= 0x00000002;
        optionsResult = value;
        return this;
      }

      /**
       * <code>repeated .ItemTpl Items = 1;</code>
       * @return whether the items field is set
       */
      public boolean hasItems() {
        return (bitField0_ & 0x00000004) != 0;
      }

      /**
       * <code>repeated .ItemTpl Items = 1;</code>
       * @return this
       */
      public Success clearItems() {
        bitField0_ &= ~0x00000004;
        items.clear();
        return this;
      }

      /**
       * <code>repeated .ItemTpl Items = 1;</code>
       *
       * This method returns the internal storage object without modifying any has state.
       * The returned object should not be modified and be treated as read-only.
       *
       * Use {@link #getMutableItems()} if you want to modify it.
       *
       * @return internal storage object for reading
       */
      public RepeatedMessage<Public.ItemTpl> getItems() {
        return items;
      }

      /**
       * <code>repeated .ItemTpl Items = 1;</code>
       *
       * This method returns the internal storage object and sets the corresponding
       * has state. The returned object will become part of this message and its
       * contents may be modified as long as the has state is not cleared.
       *
       * @return internal storage object for modifications
       */
      public RepeatedMessage<Public.ItemTpl> getMutableItems() {
        bitField0_ |= 0x00000004;
        return items;
      }

      /**
       * <code>repeated .ItemTpl Items = 1;</code>
       * @param value the items to add
       * @return this
       */
      public Success addItems(final Public.ItemTpl value) {
        bitField0_ |= 0x00000004;
        items.add(value);
        return this;
      }

      /**
       * <code>repeated .ItemTpl Items = 1;</code>
       * @param values the items to add
       * @return this
       */
      public Success addAllItems(final Public.ItemTpl... values) {
        bitField0_ |= 0x00000004;
        items.addAll(values);
        return this;
      }

      /**
       * <code>repeated .FateCardInfo FateCard = 3;</code>
       * @return whether the fateCard field is set
       */
      public boolean hasFateCard() {
        return (bitField0_ & 0x00000008) != 0;
      }

      /**
       * <code>repeated .FateCardInfo FateCard = 3;</code>
       * @return this
       */
      public Success clearFateCard() {
        bitField0_ &= ~0x00000008;
        fateCard.clear();
        return this;
      }

      /**
       * <code>repeated .FateCardInfo FateCard = 3;</code>
       *
       * This method returns the internal storage object without modifying any has state.
       * The returned object should not be modified and be treated as read-only.
       *
       * Use {@link #getMutableFateCard()} if you want to modify it.
       *
       * @return internal storage object for reading
       */
      public RepeatedMessage<FateCardInfo> getFateCard() {
        return fateCard;
      }

      /**
       * <code>repeated .FateCardInfo FateCard = 3;</code>
       *
       * This method returns the internal storage object and sets the corresponding
       * has state. The returned object will become part of this message and its
       * contents may be modified as long as the has state is not cleared.
       *
       * @return internal storage object for modifications
       */
      public RepeatedMessage<FateCardInfo> getMutableFateCard() {
        bitField0_ |= 0x00000008;
        return fateCard;
      }

      /**
       * <code>repeated .FateCardInfo FateCard = 3;</code>
       * @param value the fateCard to add
       * @return this
       */
      public Success addFateCard(final FateCardInfo value) {
        bitField0_ |= 0x00000008;
        fateCard.add(value);
        return this;
      }

      /**
       * <code>repeated .FateCardInfo FateCard = 3;</code>
       * @param values the fateCard to add
       * @return this
       */
      public Success addAllFateCard(final FateCardInfo... values) {
        bitField0_ |= 0x00000008;
        fateCard.addAll(values);
        return this;
      }

      /**
       * <code>repeated .SubNoteSkillInfo SubNoteSkills = 4;</code>
       * @return whether the subNoteSkills field is set
       */
      public boolean hasSubNoteSkills() {
        return (bitField0_ & 0x00000010) != 0;
      }

      /**
       * <code>repeated .SubNoteSkillInfo SubNoteSkills = 4;</code>
       * @return this
       */
      public Success clearSubNoteSkills() {
        bitField0_ &= ~0x00000010;
        subNoteSkills.clear();
        return this;
      }

      /**
       * <code>repeated .SubNoteSkillInfo SubNoteSkills = 4;</code>
       *
       * This method returns the internal storage object without modifying any has state.
       * The returned object should not be modified and be treated as read-only.
       *
       * Use {@link #getMutableSubNoteSkills()} if you want to modify it.
       *
       * @return internal storage object for reading
       */
      public RepeatedMessage<SubNoteSkillInfo> getSubNoteSkills() {
        return subNoteSkills;
      }

      /**
       * <code>repeated .SubNoteSkillInfo SubNoteSkills = 4;</code>
       *
       * This method returns the internal storage object and sets the corresponding
       * has state. The returned object will become part of this message and its
       * contents may be modified as long as the has state is not cleared.
       *
       * @return internal storage object for modifications
       */
      public RepeatedMessage<SubNoteSkillInfo> getMutableSubNoteSkills() {
        bitField0_ |= 0x00000010;
        return subNoteSkills;
      }

      /**
       * <code>repeated .SubNoteSkillInfo SubNoteSkills = 4;</code>
       * @param value the subNoteSkills to add
       * @return this
       */
      public Success addSubNoteSkills(final SubNoteSkillInfo value) {
        bitField0_ |= 0x00000010;
        subNoteSkills.add(value);
        return this;
      }

      /**
       * <code>repeated .SubNoteSkillInfo SubNoteSkills = 4;</code>
       * @param values the subNoteSkills to add
       * @return this
       */
      public Success addAllSubNoteSkills(final SubNoteSkillInfo... values) {
        bitField0_ |= 0x00000010;
        subNoteSkills.addAll(values);
        return this;
      }

      /**
       * <code>repeated .NPCAffinityChange AffinityChange = 6;</code>
       * @return whether the affinityChange field is set
       */
      public boolean hasAffinityChange() {
        return (bitField0_ & 0x00000020) != 0;
      }

      /**
       * <code>repeated .NPCAffinityChange AffinityChange = 6;</code>
       * @return this
       */
      public Success clearAffinityChange() {
        bitField0_ &= ~0x00000020;
        affinityChange.clear();
        return this;
      }

      /**
       * <code>repeated .NPCAffinityChange AffinityChange = 6;</code>
       *
       * This method returns the internal storage object without modifying any has state.
       * The returned object should not be modified and be treated as read-only.
       *
       * Use {@link #getMutableAffinityChange()} if you want to modify it.
       *
       * @return internal storage object for reading
       */
      public RepeatedMessage<NPCAffinityChange> getAffinityChange() {
        return affinityChange;
      }

      /**
       * <code>repeated .NPCAffinityChange AffinityChange = 6;</code>
       *
       * This method returns the internal storage object and sets the corresponding
       * has state. The returned object will become part of this message and its
       * contents may be modified as long as the has state is not cleared.
       *
       * @return internal storage object for modifications
       */
      public RepeatedMessage<NPCAffinityChange> getMutableAffinityChange() {
        bitField0_ |= 0x00000020;
        return affinityChange;
      }

      /**
       * <code>repeated .NPCAffinityChange AffinityChange = 6;</code>
       * @param value the affinityChange to add
       * @return this
       */
      public Success addAffinityChange(final NPCAffinityChange value) {
        bitField0_ |= 0x00000020;
        affinityChange.add(value);
        return this;
      }

      /**
       * <code>repeated .NPCAffinityChange AffinityChange = 6;</code>
       * @param values the affinityChange to add
       * @return this
       */
      public Success addAllAffinityChange(final NPCAffinityChange... values) {
        bitField0_ |= 0x00000020;
        affinityChange.addAll(values);
        return this;
      }

      @Override
      public Success copyFrom(final Success other) {
        cachedSize = other.cachedSize;
        if ((bitField0_ | other.bitField0_) != 0) {
          bitField0_ = other.bitField0_;
          optionsParamId = other.optionsParamId;
          optionsResult = other.optionsResult;
          items.copyFrom(other.items);
          fateCard.copyFrom(other.fateCard);
          subNoteSkills.copyFrom(other.subNoteSkills);
          affinityChange.copyFrom(other.affinityChange);
        }
        return this;
      }

      @Override
      public Success mergeFrom(final Success other) {
        if (other.isEmpty()) {
          return this;
        }
        cachedSize = -1;
        if (other.hasOptionsParamId()) {
          setOptionsParamId(other.optionsParamId);
        }
        if (other.hasOptionsResult()) {
          setOptionsResult(other.optionsResult);
        }
        if (other.hasItems()) {
          getMutableItems().addAll(other.items);
        }
        if (other.hasFateCard()) {
          getMutableFateCard().addAll(other.fateCard);
        }
        if (other.hasSubNoteSkills()) {
          getMutableSubNoteSkills().addAll(other.subNoteSkills);
        }
        if (other.hasAffinityChange()) {
          getMutableAffinityChange().addAll(other.affinityChange);
        }
        return this;
      }

      @Override
      public Success clear() {
        if (isEmpty()) {
          return this;
        }
        cachedSize = -1;
        bitField0_ = 0;
        optionsParamId = 0;
        optionsResult = false;
        items.clear();
        fateCard.clear();
        subNoteSkills.clear();
        affinityChange.clear();
        return this;
      }

      @Override
      public Success clearQuick() {
        if (isEmpty()) {
          return this;
        }
        cachedSize = -1;
        bitField0_ = 0;
        items.clearQuick();
        fateCard.clearQuick();
        subNoteSkills.clearQuick();
        affinityChange.clearQuick();
        return this;
      }

      @Override
      public boolean equals(Object o) {
        if (o == this) {
          return true;
        }
        if (!(o instanceof Success)) {
          return false;
        }
        Success other = (Success) o;
        return bitField0_ == other.bitField0_
          && (!hasOptionsParamId() || optionsParamId == other.optionsParamId)
          && (!hasOptionsResult() || optionsResult == other.optionsResult)
          && (!hasItems() || items.equals(other.items))
          && (!hasFateCard() || fateCard.equals(other.fateCard))
          && (!hasSubNoteSkills() || subNoteSkills.equals(other.subNoteSkills))
          && (!hasAffinityChange() || affinityChange.equals(other.affinityChange));
      }

      @Override
      public void writeTo(final ProtoSink output) throws IOException {
        if ((bitField0_ & 0x00000001) != 0) {
          output.writeRawByte((byte) 40);
          output.writeUInt32NoTag(optionsParamId);
        }
        if ((bitField0_ & 0x00000002) != 0) {
          output.writeRawByte((byte) 16);
          output.writeBoolNoTag(optionsResult);
        }
        if ((bitField0_ & 0x00000004) != 0) {
          for (int i = 0; i < items.length(); i++) {
            output.writeRawByte((byte) 10);
            output.writeMessageNoTag(items.get(i));
          }
        }
        if ((bitField0_ & 0x00000008) != 0) {
          for (int i = 0; i < fateCard.length(); i++) {
            output.writeRawByte((byte) 26);
            output.writeMessageNoTag(fateCard.get(i));
          }
        }
        if ((bitField0_ & 0x00000010) != 0) {
          for (int i = 0; i < subNoteSkills.length(); i++) {
            output.writeRawByte((byte) 34);
            output.writeMessageNoTag(subNoteSkills.get(i));
          }
        }
        if ((bitField0_ & 0x00000020) != 0) {
          for (int i = 0; i < affinityChange.length(); i++) {
            output.writeRawByte((byte) 50);
            output.writeMessageNoTag(affinityChange.get(i));
          }
        }
      }

      @Override
      protected int computeSerializedSize() {
        int size = 0;
        if ((bitField0_ & 0x00000001) != 0) {
          size += 1 + ProtoSink.computeUInt32SizeNoTag(optionsParamId);
        }
        if ((bitField0_ & 0x00000002) != 0) {
          size += 2;
        }
        if ((bitField0_ & 0x00000004) != 0) {
          size += (1 * items.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(items);
        }
        if ((bitField0_ & 0x00000008) != 0) {
          size += (1 * fateCard.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(fateCard);
        }
        if ((bitField0_ & 0x00000010) != 0) {
          size += (1 * subNoteSkills.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(subNoteSkills);
        }
        if ((bitField0_ & 0x00000020) != 0) {
          size += (1 * affinityChange.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(affinityChange);
        }
        return size;
      }

      @Override
      @SuppressWarnings("fallthrough")
      public Success mergeFrom(final ProtoSource input) throws IOException {
        // Enabled Fall-Through Optimization (QuickBuffers)
        int tag = input.readTag();
        while (true) {
          switch (tag) {
            case 40: {
              // optionsParamId
              optionsParamId = input.readUInt32();
              bitField0_ |= 0x00000001;
              tag = input.readTag();
              if (tag != 16) {
                break;
              }
            }
            case 16: {
              // optionsResult
              optionsResult = input.readBool();
              bitField0_ |= 0x00000002;
              tag = input.readTag();
              if (tag != 10) {
                break;
              }
            }
            case 10: {
              // items
              tag = input.readRepeatedMessage(items, tag);
              bitField0_ |= 0x00000004;
              if (tag != 26) {
                break;
              }
            }
            case 26: {
              // fateCard
              tag = input.readRepeatedMessage(fateCard, tag);
              bitField0_ |= 0x00000008;
              if (tag != 34) {
                break;
              }
            }
            case 34: {
              // subNoteSkills
              tag = input.readRepeatedMessage(subNoteSkills, tag);
              bitField0_ |= 0x00000010;
              if (tag != 50) {
                break;
              }
            }
            case 50: {
              // affinityChange
              tag = input.readRepeatedMessage(affinityChange, tag);
              bitField0_ |= 0x00000020;
              if (tag != 0) {
                break;
              }
            }
            case 0: {
              return this;
            }
            default: {
              if (!input.skipField(tag)) {
                return this;
              }
              tag = input.readTag();
              break;
            }
          }
        }
      }

      @Override
      public void writeTo(final JsonSink output) throws IOException {
        output.beginObject();
        if ((bitField0_ & 0x00000001) != 0) {
          output.writeUInt32(FieldNames.optionsParamId, optionsParamId);
        }
        if ((bitField0_ & 0x00000002) != 0) {
          output.writeBool(FieldNames.optionsResult, optionsResult);
        }
        if ((bitField0_ & 0x00000004) != 0) {
          output.writeRepeatedMessage(FieldNames.items, items);
        }
        if ((bitField0_ & 0x00000008) != 0) {
          output.writeRepeatedMessage(FieldNames.fateCard, fateCard);
        }
        if ((bitField0_ & 0x00000010) != 0) {
          output.writeRepeatedMessage(FieldNames.subNoteSkills, subNoteSkills);
        }
        if ((bitField0_ & 0x00000020) != 0) {
          output.writeRepeatedMessage(FieldNames.affinityChange, affinityChange);
        }
        output.endObject();
      }

      @Override
      public Success mergeFrom(final JsonSource input) throws IOException {
        if (!input.beginObject()) {
          return this;
        }
        while (!input.isAtEnd()) {
          switch (input.readFieldHash()) {
            case 442761770: {
              if (input.isAtField(FieldNames.optionsParamId)) {
                if (!input.trySkipNullValue()) {
                  optionsParamId = input.readUInt32();
                  bitField0_ |= 0x00000001;
                }
              } else {
                input.skipUnknownField();
              }
              break;
            }
            case -478905285: {
              if (input.isAtField(FieldNames.optionsResult)) {
                if (!input.trySkipNullValue()) {
                  optionsResult = input.readBool();
                  bitField0_ |= 0x00000002;
                }
              } else {
                input.skipUnknownField();
              }
              break;
            }
            case 70973344: {
              if (input.isAtField(FieldNames.items)) {
                if (!input.trySkipNullValue()) {
                  input.readRepeatedMessage(items);
                  bitField0_ |= 0x00000004;
                }
              } else {
                input.skipUnknownField();
              }
              break;
            }
            case 1047532988: {
              if (input.isAtField(FieldNames.fateCard)) {
                if (!input.trySkipNullValue()) {
                  input.readRepeatedMessage(fateCard);
                  bitField0_ |= 0x00000008;
                }
              } else {
                input.skipUnknownField();
              }
              break;
            }
            case 349821204: {
              if (input.isAtField(FieldNames.subNoteSkills)) {
                if (!input.trySkipNullValue()) {
                  input.readRepeatedMessage(subNoteSkills);
                  bitField0_ |= 0x00000010;
                }
              } else {
                input.skipUnknownField();
              }
              break;
            }
            case -690981096: {
              if (input.isAtField(FieldNames.affinityChange)) {
                if (!input.trySkipNullValue()) {
                  input.readRepeatedMessage(affinityChange);
                  bitField0_ |= 0x00000020;
                }
              } else {
                input.skipUnknownField();
              }
              break;
            }
            default: {
              input.skipUnknownField();
              break;
            }
          }
        }
        input.endObject();
        return this;
      }

      @Override
      public Success clone() {
        return new Success().copyFrom(this);
      }

      @Override
      public boolean isEmpty() {
        return ((bitField0_) == 0);
      }

      public static Success parseFrom(final byte[] data) throws InvalidProtocolBufferException {
        return ProtoMessage.mergeFrom(new Success(), data).checkInitialized();
      }

      public static Success parseFrom(final ProtoSource input) throws IOException {
        return ProtoMessage.mergeFrom(new Success(), input).checkInitialized();
      }

      public static Success parseFrom(final JsonSource input) throws IOException {
        return ProtoMessage.mergeFrom(new Success(), input).checkInitialized();
      }

      /**
       * @return factory for creating Success messages
       */
      public static MessageFactory<Success> getFactory() {
        return SuccessFactory.INSTANCE;
      }

      private enum SuccessFactory implements MessageFactory<Success> {
        INSTANCE;

        @Override
        public Success create() {
          return Success.newInstance();
        }
      }

      /**
       * Contains name constants used for serializing JSON
       */
      static class FieldNames {
        static final FieldName optionsParamId = FieldName.forField("OptionsParamId");

        static final FieldName optionsResult = FieldName.forField("OptionsResult");

        static final FieldName items = FieldName.forField("Items");

        static final FieldName fateCard = FieldName.forField("FateCard");

        static final FieldName subNoteSkills = FieldName.forField("SubNoteSkills");

        static final FieldName affinityChange = FieldName.forField("AffinityChange");
      }
    }

    private enum InteractSelectRespFactory implements MessageFactory<InteractSelectResp> {
      INSTANCE;

      @Override
      public InteractSelectResp create() {
        return InteractSelectResp.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName resp = FieldName.forField("Resp");

      static final FieldName selectSpecialPotentialCase = FieldName.forField("SelectSpecialPotentialCase");

      static final FieldName selectPotentialCase = FieldName.forField("SelectPotentialCase");

      static final FieldName selectFateCardCase = FieldName.forField("SelectFateCardCase");

      static final FieldName hawkerCase = FieldName.forField("HawkerCase");

      static final FieldName nextPackage = FieldName.forField("NextPackage");
    }
  }

  /**
   * Protobuf type {@code FateCardInfo}
   */
  public static final class FateCardInfo extends ProtoMessage<FateCardInfo> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional int32 Qty = 2;</code>
     */
    private int qty;

    /**
     * <code>optional int32 Remain = 3;</code>
     */
    private int remain;

    /**
     * <code>optional int32 Room = 4;</code>
     */
    private int room;

    /**
     * <code>optional uint32 Tid = 1;</code>
     */
    private int tid;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    private FateCardInfo() {
    }

    /**
     * @return a new empty instance of {@code FateCardInfo}
     */
    public static FateCardInfo newInstance() {
      return new FateCardInfo();
    }

    /**
     * <code>optional int32 Qty = 2;</code>
     * @return whether the qty field is set
     */
    public boolean hasQty() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional int32 Qty = 2;</code>
     * @return this
     */
    public FateCardInfo clearQty() {
      bitField0_ &= ~0x00000001;
      qty = 0;
      return this;
    }

    /**
     * <code>optional int32 Qty = 2;</code>
     * @return the qty
     */
    public int getQty() {
      return qty;
    }

    /**
     * <code>optional int32 Qty = 2;</code>
     * @param value the qty to set
     * @return this
     */
    public FateCardInfo setQty(final int value) {
      bitField0_ |= 0x00000001;
      qty = value;
      return this;
    }

    /**
     * <code>optional int32 Remain = 3;</code>
     * @return whether the remain field is set
     */
    public boolean hasRemain() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional int32 Remain = 3;</code>
     * @return this
     */
    public FateCardInfo clearRemain() {
      bitField0_ &= ~0x00000002;
      remain = 0;
      return this;
    }

    /**
     * <code>optional int32 Remain = 3;</code>
     * @return the remain
     */
    public int getRemain() {
      return remain;
    }

    /**
     * <code>optional int32 Remain = 3;</code>
     * @param value the remain to set
     * @return this
     */
    public FateCardInfo setRemain(final int value) {
      bitField0_ |= 0x00000002;
      remain = value;
      return this;
    }

    /**
     * <code>optional int32 Room = 4;</code>
     * @return whether the room field is set
     */
    public boolean hasRoom() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional int32 Room = 4;</code>
     * @return this
     */
    public FateCardInfo clearRoom() {
      bitField0_ &= ~0x00000004;
      room = 0;
      return this;
    }

    /**
     * <code>optional int32 Room = 4;</code>
     * @return the room
     */
    public int getRoom() {
      return room;
    }

    /**
     * <code>optional int32 Room = 4;</code>
     * @param value the room to set
     * @return this
     */
    public FateCardInfo setRoom(final int value) {
      bitField0_ |= 0x00000004;
      room = value;
      return this;
    }

    /**
     * <code>optional uint32 Tid = 1;</code>
     * @return whether the tid field is set
     */
    public boolean hasTid() {
      return (bitField0_ & 0x00000008) != 0;
    }

    /**
     * <code>optional uint32 Tid = 1;</code>
     * @return this
     */
    public FateCardInfo clearTid() {
      bitField0_ &= ~0x00000008;
      tid = 0;
      return this;
    }

    /**
     * <code>optional uint32 Tid = 1;</code>
     * @return the tid
     */
    public int getTid() {
      return tid;
    }

    /**
     * <code>optional uint32 Tid = 1;</code>
     * @param value the tid to set
     * @return this
     */
    public FateCardInfo setTid(final int value) {
      bitField0_ |= 0x00000008;
      tid = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000010) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public FateCardInfo clearNextPackage() {
      bitField0_ &= ~0x00000010;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000010;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public FateCardInfo addNextPackage(final byte value) {
      bitField0_ |= 0x00000010;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public FateCardInfo addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000010;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public FateCardInfo setNextPackage(final byte... values) {
      bitField0_ |= 0x00000010;
      nextPackage.copyFrom(values);
      return this;
    }

    @Override
    public FateCardInfo copyFrom(final FateCardInfo other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        qty = other.qty;
        remain = other.remain;
        room = other.room;
        tid = other.tid;
        nextPackage.copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public FateCardInfo mergeFrom(final FateCardInfo other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasQty()) {
        setQty(other.qty);
      }
      if (other.hasRemain()) {
        setRemain(other.remain);
      }
      if (other.hasRoom()) {
        setRoom(other.room);
      }
      if (other.hasTid()) {
        setTid(other.tid);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public FateCardInfo clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      qty = 0;
      remain = 0;
      room = 0;
      tid = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public FateCardInfo clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof FateCardInfo)) {
        return false;
      }
      FateCardInfo other = (FateCardInfo) o;
      return bitField0_ == other.bitField0_
        && (!hasQty() || qty == other.qty)
        && (!hasRemain() || remain == other.remain)
        && (!hasRoom() || room == other.room)
        && (!hasTid() || tid == other.tid)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 16);
        output.writeInt32NoTag(qty);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 24);
        output.writeInt32NoTag(remain);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawByte((byte) 32);
        output.writeInt32NoTag(room);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt32NoTag(tid);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeInt32SizeNoTag(qty);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeInt32SizeNoTag(remain);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 1 + ProtoSink.computeInt32SizeNoTag(room);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(tid);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public FateCardInfo mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 16: {
            // qty
            qty = input.readInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 24) {
              break;
            }
          }
          case 24: {
            // remain
            remain = input.readInt32();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 32) {
              break;
            }
          }
          case 32: {
            // room
            room = input.readInt32();
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 8) {
              break;
            }
          }
          case 8: {
            // tid
            tid = input.readUInt32();
            bitField0_ |= 0x00000008;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000010;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeInt32(FieldNames.qty, qty);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeInt32(FieldNames.remain, remain);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeInt32(FieldNames.room, room);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeUInt32(FieldNames.tid, tid);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      output.endObject();
    }

    @Override
    public FateCardInfo mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 81558: {
            if (input.isAtField(FieldNames.qty)) {
              if (!input.trySkipNullValue()) {
                qty = input.readInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1850757492: {
            if (input.isAtField(FieldNames.remain)) {
              if (!input.trySkipNullValue()) {
                remain = input.readInt32();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 2553083: {
            if (input.isAtField(FieldNames.room)) {
              if (!input.trySkipNullValue()) {
                room = input.readInt32();
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 84079: {
            if (input.isAtField(FieldNames.tid)) {
              if (!input.trySkipNullValue()) {
                tid = input.readUInt32();
                bitField0_ |= 0x00000008;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000010;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public FateCardInfo clone() {
      return new FateCardInfo().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static FateCardInfo parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new FateCardInfo(), data).checkInitialized();
    }

    public static FateCardInfo parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new FateCardInfo(), input).checkInitialized();
    }

    public static FateCardInfo parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new FateCardInfo(), input).checkInitialized();
    }

    /**
     * @return factory for creating FateCardInfo messages
     */
    public static MessageFactory<FateCardInfo> getFactory() {
      return FateCardInfoFactory.INSTANCE;
    }

    private enum FateCardInfoFactory implements MessageFactory<FateCardInfo> {
      INSTANCE;

      @Override
      public FateCardInfo create() {
        return FateCardInfo.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName qty = FieldName.forField("Qty");

      static final FieldName remain = FieldName.forField("Remain");

      static final FieldName room = FieldName.forField("Room");

      static final FieldName tid = FieldName.forField("Tid");

      static final FieldName nextPackage = FieldName.forField("NextPackage");
    }
  }

  /**
   * Protobuf type {@code PotentialInfo}
   */
  public static final class PotentialInfo extends ProtoMessage<PotentialInfo> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional int32 Level = 2;</code>
     */
    private int level;

    /**
     * <code>optional uint32 Tid = 1;</code>
     */
    private int tid;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    private PotentialInfo() {
    }

    /**
     * @return a new empty instance of {@code PotentialInfo}
     */
    public static PotentialInfo newInstance() {
      return new PotentialInfo();
    }

    /**
     * <code>optional int32 Level = 2;</code>
     * @return whether the level field is set
     */
    public boolean hasLevel() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional int32 Level = 2;</code>
     * @return this
     */
    public PotentialInfo clearLevel() {
      bitField0_ &= ~0x00000001;
      level = 0;
      return this;
    }

    /**
     * <code>optional int32 Level = 2;</code>
     * @return the level
     */
    public int getLevel() {
      return level;
    }

    /**
     * <code>optional int32 Level = 2;</code>
     * @param value the level to set
     * @return this
     */
    public PotentialInfo setLevel(final int value) {
      bitField0_ |= 0x00000001;
      level = value;
      return this;
    }

    /**
     * <code>optional uint32 Tid = 1;</code>
     * @return whether the tid field is set
     */
    public boolean hasTid() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional uint32 Tid = 1;</code>
     * @return this
     */
    public PotentialInfo clearTid() {
      bitField0_ &= ~0x00000002;
      tid = 0;
      return this;
    }

    /**
     * <code>optional uint32 Tid = 1;</code>
     * @return the tid
     */
    public int getTid() {
      return tid;
    }

    /**
     * <code>optional uint32 Tid = 1;</code>
     * @param value the tid to set
     * @return this
     */
    public PotentialInfo setTid(final int value) {
      bitField0_ |= 0x00000002;
      tid = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public PotentialInfo clearNextPackage() {
      bitField0_ &= ~0x00000004;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000004;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public PotentialInfo addNextPackage(final byte value) {
      bitField0_ |= 0x00000004;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public PotentialInfo addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000004;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public PotentialInfo setNextPackage(final byte... values) {
      bitField0_ |= 0x00000004;
      nextPackage.copyFrom(values);
      return this;
    }

    @Override
    public PotentialInfo copyFrom(final PotentialInfo other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        level = other.level;
        tid = other.tid;
        nextPackage.copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public PotentialInfo mergeFrom(final PotentialInfo other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasLevel()) {
        setLevel(other.level);
      }
      if (other.hasTid()) {
        setTid(other.tid);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public PotentialInfo clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      level = 0;
      tid = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public PotentialInfo clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof PotentialInfo)) {
        return false;
      }
      PotentialInfo other = (PotentialInfo) o;
      return bitField0_ == other.bitField0_
        && (!hasLevel() || level == other.level)
        && (!hasTid() || tid == other.tid)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 16);
        output.writeInt32NoTag(level);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt32NoTag(tid);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeInt32SizeNoTag(level);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(tid);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public PotentialInfo mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 16: {
            // level
            level = input.readInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 8) {
              break;
            }
          }
          case 8: {
            // tid
            tid = input.readUInt32();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeInt32(FieldNames.level, level);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeUInt32(FieldNames.tid, tid);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      output.endObject();
    }

    @Override
    public PotentialInfo mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 73313124: {
            if (input.isAtField(FieldNames.level)) {
              if (!input.trySkipNullValue()) {
                level = input.readInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 84079: {
            if (input.isAtField(FieldNames.tid)) {
              if (!input.trySkipNullValue()) {
                tid = input.readUInt32();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public PotentialInfo clone() {
      return new PotentialInfo().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static PotentialInfo parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new PotentialInfo(), data).checkInitialized();
    }

    public static PotentialInfo parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new PotentialInfo(), input).checkInitialized();
    }

    public static PotentialInfo parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new PotentialInfo(), input).checkInitialized();
    }

    /**
     * @return factory for creating PotentialInfo messages
     */
    public static MessageFactory<PotentialInfo> getFactory() {
      return PotentialInfoFactory.INSTANCE;
    }

    private enum PotentialInfoFactory implements MessageFactory<PotentialInfo> {
      INSTANCE;

      @Override
      public PotentialInfo create() {
        return PotentialInfo.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName level = FieldName.forField("Level");

      static final FieldName tid = FieldName.forField("Tid");

      static final FieldName nextPackage = FieldName.forField("NextPackage");
    }
  }

  /**
   * Protobuf type {@code TowerItemInfo}
   */
  public static final class TowerItemInfo extends ProtoMessage<TowerItemInfo> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional int32 Qty = 2;</code>
     */
    private int qty;

    /**
     * <code>optional uint32 Tid = 1;</code>
     */
    private int tid;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    private TowerItemInfo() {
    }

    /**
     * @return a new empty instance of {@code TowerItemInfo}
     */
    public static TowerItemInfo newInstance() {
      return new TowerItemInfo();
    }

    /**
     * <code>optional int32 Qty = 2;</code>
     * @return whether the qty field is set
     */
    public boolean hasQty() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional int32 Qty = 2;</code>
     * @return this
     */
    public TowerItemInfo clearQty() {
      bitField0_ &= ~0x00000001;
      qty = 0;
      return this;
    }

    /**
     * <code>optional int32 Qty = 2;</code>
     * @return the qty
     */
    public int getQty() {
      return qty;
    }

    /**
     * <code>optional int32 Qty = 2;</code>
     * @param value the qty to set
     * @return this
     */
    public TowerItemInfo setQty(final int value) {
      bitField0_ |= 0x00000001;
      qty = value;
      return this;
    }

    /**
     * <code>optional uint32 Tid = 1;</code>
     * @return whether the tid field is set
     */
    public boolean hasTid() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional uint32 Tid = 1;</code>
     * @return this
     */
    public TowerItemInfo clearTid() {
      bitField0_ &= ~0x00000002;
      tid = 0;
      return this;
    }

    /**
     * <code>optional uint32 Tid = 1;</code>
     * @return the tid
     */
    public int getTid() {
      return tid;
    }

    /**
     * <code>optional uint32 Tid = 1;</code>
     * @param value the tid to set
     * @return this
     */
    public TowerItemInfo setTid(final int value) {
      bitField0_ |= 0x00000002;
      tid = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public TowerItemInfo clearNextPackage() {
      bitField0_ &= ~0x00000004;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000004;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public TowerItemInfo addNextPackage(final byte value) {
      bitField0_ |= 0x00000004;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public TowerItemInfo addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000004;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public TowerItemInfo setNextPackage(final byte... values) {
      bitField0_ |= 0x00000004;
      nextPackage.copyFrom(values);
      return this;
    }

    @Override
    public TowerItemInfo copyFrom(final TowerItemInfo other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        qty = other.qty;
        tid = other.tid;
        nextPackage.copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public TowerItemInfo mergeFrom(final TowerItemInfo other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasQty()) {
        setQty(other.qty);
      }
      if (other.hasTid()) {
        setTid(other.tid);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public TowerItemInfo clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      qty = 0;
      tid = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public TowerItemInfo clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof TowerItemInfo)) {
        return false;
      }
      TowerItemInfo other = (TowerItemInfo) o;
      return bitField0_ == other.bitField0_
        && (!hasQty() || qty == other.qty)
        && (!hasTid() || tid == other.tid)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 16);
        output.writeInt32NoTag(qty);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt32NoTag(tid);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeInt32SizeNoTag(qty);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(tid);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public TowerItemInfo mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 16: {
            // qty
            qty = input.readInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 8) {
              break;
            }
          }
          case 8: {
            // tid
            tid = input.readUInt32();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeInt32(FieldNames.qty, qty);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeUInt32(FieldNames.tid, tid);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      output.endObject();
    }

    @Override
    public TowerItemInfo mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 81558: {
            if (input.isAtField(FieldNames.qty)) {
              if (!input.trySkipNullValue()) {
                qty = input.readInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 84079: {
            if (input.isAtField(FieldNames.tid)) {
              if (!input.trySkipNullValue()) {
                tid = input.readUInt32();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public TowerItemInfo clone() {
      return new TowerItemInfo().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static TowerItemInfo parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new TowerItemInfo(), data).checkInitialized();
    }

    public static TowerItemInfo parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new TowerItemInfo(), input).checkInitialized();
    }

    public static TowerItemInfo parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new TowerItemInfo(), input).checkInitialized();
    }

    /**
     * @return factory for creating TowerItemInfo messages
     */
    public static MessageFactory<TowerItemInfo> getFactory() {
      return TowerItemInfoFactory.INSTANCE;
    }

    private enum TowerItemInfoFactory implements MessageFactory<TowerItemInfo> {
      INSTANCE;

      @Override
      public TowerItemInfo create() {
        return TowerItemInfo.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName qty = FieldName.forField("Qty");

      static final FieldName tid = FieldName.forField("Tid");

      static final FieldName nextPackage = FieldName.forField("NextPackage");
    }
  }

  /**
   * Protobuf type {@code TowerResInfo}
   */
  public static final class TowerResInfo extends ProtoMessage<TowerResInfo> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional int32 Qty = 2;</code>
     */
    private int qty;

    /**
     * <code>optional uint32 Tid = 1;</code>
     */
    private int tid;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    private TowerResInfo() {
    }

    /**
     * @return a new empty instance of {@code TowerResInfo}
     */
    public static TowerResInfo newInstance() {
      return new TowerResInfo();
    }

    /**
     * <code>optional int32 Qty = 2;</code>
     * @return whether the qty field is set
     */
    public boolean hasQty() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional int32 Qty = 2;</code>
     * @return this
     */
    public TowerResInfo clearQty() {
      bitField0_ &= ~0x00000001;
      qty = 0;
      return this;
    }

    /**
     * <code>optional int32 Qty = 2;</code>
     * @return the qty
     */
    public int getQty() {
      return qty;
    }

    /**
     * <code>optional int32 Qty = 2;</code>
     * @param value the qty to set
     * @return this
     */
    public TowerResInfo setQty(final int value) {
      bitField0_ |= 0x00000001;
      qty = value;
      return this;
    }

    /**
     * <code>optional uint32 Tid = 1;</code>
     * @return whether the tid field is set
     */
    public boolean hasTid() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional uint32 Tid = 1;</code>
     * @return this
     */
    public TowerResInfo clearTid() {
      bitField0_ &= ~0x00000002;
      tid = 0;
      return this;
    }

    /**
     * <code>optional uint32 Tid = 1;</code>
     * @return the tid
     */
    public int getTid() {
      return tid;
    }

    /**
     * <code>optional uint32 Tid = 1;</code>
     * @param value the tid to set
     * @return this
     */
    public TowerResInfo setTid(final int value) {
      bitField0_ |= 0x00000002;
      tid = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public TowerResInfo clearNextPackage() {
      bitField0_ &= ~0x00000004;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000004;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public TowerResInfo addNextPackage(final byte value) {
      bitField0_ |= 0x00000004;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public TowerResInfo addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000004;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public TowerResInfo setNextPackage(final byte... values) {
      bitField0_ |= 0x00000004;
      nextPackage.copyFrom(values);
      return this;
    }

    @Override
    public TowerResInfo copyFrom(final TowerResInfo other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        qty = other.qty;
        tid = other.tid;
        nextPackage.copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public TowerResInfo mergeFrom(final TowerResInfo other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasQty()) {
        setQty(other.qty);
      }
      if (other.hasTid()) {
        setTid(other.tid);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public TowerResInfo clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      qty = 0;
      tid = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public TowerResInfo clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof TowerResInfo)) {
        return false;
      }
      TowerResInfo other = (TowerResInfo) o;
      return bitField0_ == other.bitField0_
        && (!hasQty() || qty == other.qty)
        && (!hasTid() || tid == other.tid)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 16);
        output.writeInt32NoTag(qty);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt32NoTag(tid);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeInt32SizeNoTag(qty);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(tid);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public TowerResInfo mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 16: {
            // qty
            qty = input.readInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 8) {
              break;
            }
          }
          case 8: {
            // tid
            tid = input.readUInt32();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeInt32(FieldNames.qty, qty);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeUInt32(FieldNames.tid, tid);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      output.endObject();
    }

    @Override
    public TowerResInfo mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 81558: {
            if (input.isAtField(FieldNames.qty)) {
              if (!input.trySkipNullValue()) {
                qty = input.readInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 84079: {
            if (input.isAtField(FieldNames.tid)) {
              if (!input.trySkipNullValue()) {
                tid = input.readUInt32();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public TowerResInfo clone() {
      return new TowerResInfo().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static TowerResInfo parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new TowerResInfo(), data).checkInitialized();
    }

    public static TowerResInfo parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new TowerResInfo(), input).checkInitialized();
    }

    public static TowerResInfo parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new TowerResInfo(), input).checkInitialized();
    }

    /**
     * @return factory for creating TowerResInfo messages
     */
    public static MessageFactory<TowerResInfo> getFactory() {
      return TowerResInfoFactory.INSTANCE;
    }

    private enum TowerResInfoFactory implements MessageFactory<TowerResInfo> {
      INSTANCE;

      @Override
      public TowerResInfo create() {
        return TowerResInfo.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName qty = FieldName.forField("Qty");

      static final FieldName tid = FieldName.forField("Tid");

      static final FieldName nextPackage = FieldName.forField("NextPackage");
    }
  }

  /**
   * Protobuf type {@code SubNoteSkillInfo}
   */
  public static final class SubNoteSkillInfo extends ProtoMessage<SubNoteSkillInfo> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional int32 Qty = 2;</code>
     */
    private int qty;

    /**
     * <code>optional uint32 Tid = 1;</code>
     */
    private int tid;

    /**
     * <code>optional uint32 LuckyLevel = 4;</code>
     */
    private int luckyLevel;

    /**
     * <code>optional bool New = 3;</code>
     */
    private boolean new_;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    private SubNoteSkillInfo() {
    }

    /**
     * @return a new empty instance of {@code SubNoteSkillInfo}
     */
    public static SubNoteSkillInfo newInstance() {
      return new SubNoteSkillInfo();
    }

    /**
     * <code>optional int32 Qty = 2;</code>
     * @return whether the qty field is set
     */
    public boolean hasQty() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional int32 Qty = 2;</code>
     * @return this
     */
    public SubNoteSkillInfo clearQty() {
      bitField0_ &= ~0x00000001;
      qty = 0;
      return this;
    }

    /**
     * <code>optional int32 Qty = 2;</code>
     * @return the qty
     */
    public int getQty() {
      return qty;
    }

    /**
     * <code>optional int32 Qty = 2;</code>
     * @param value the qty to set
     * @return this
     */
    public SubNoteSkillInfo setQty(final int value) {
      bitField0_ |= 0x00000001;
      qty = value;
      return this;
    }

    /**
     * <code>optional uint32 Tid = 1;</code>
     * @return whether the tid field is set
     */
    public boolean hasTid() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional uint32 Tid = 1;</code>
     * @return this
     */
    public SubNoteSkillInfo clearTid() {
      bitField0_ &= ~0x00000002;
      tid = 0;
      return this;
    }

    /**
     * <code>optional uint32 Tid = 1;</code>
     * @return the tid
     */
    public int getTid() {
      return tid;
    }

    /**
     * <code>optional uint32 Tid = 1;</code>
     * @param value the tid to set
     * @return this
     */
    public SubNoteSkillInfo setTid(final int value) {
      bitField0_ |= 0x00000002;
      tid = value;
      return this;
    }

    /**
     * <code>optional uint32 LuckyLevel = 4;</code>
     * @return whether the luckyLevel field is set
     */
    public boolean hasLuckyLevel() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional uint32 LuckyLevel = 4;</code>
     * @return this
     */
    public SubNoteSkillInfo clearLuckyLevel() {
      bitField0_ &= ~0x00000004;
      luckyLevel = 0;
      return this;
    }

    /**
     * <code>optional uint32 LuckyLevel = 4;</code>
     * @return the luckyLevel
     */
    public int getLuckyLevel() {
      return luckyLevel;
    }

    /**
     * <code>optional uint32 LuckyLevel = 4;</code>
     * @param value the luckyLevel to set
     * @return this
     */
    public SubNoteSkillInfo setLuckyLevel(final int value) {
      bitField0_ |= 0x00000004;
      luckyLevel = value;
      return this;
    }

    /**
     * <code>optional bool New = 3;</code>
     * @return whether the new_ field is set
     */
    public boolean hasNew() {
      return (bitField0_ & 0x00000008) != 0;
    }

    /**
     * <code>optional bool New = 3;</code>
     * @return this
     */
    public SubNoteSkillInfo clearNew() {
      bitField0_ &= ~0x00000008;
      new_ = false;
      return this;
    }

    /**
     * <code>optional bool New = 3;</code>
     * @return the new_
     */
    public boolean getNew() {
      return new_;
    }

    /**
     * <code>optional bool New = 3;</code>
     * @param value the new_ to set
     * @return this
     */
    public SubNoteSkillInfo setNew(final boolean value) {
      bitField0_ |= 0x00000008;
      new_ = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000010) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public SubNoteSkillInfo clearNextPackage() {
      bitField0_ &= ~0x00000010;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000010;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public SubNoteSkillInfo addNextPackage(final byte value) {
      bitField0_ |= 0x00000010;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public SubNoteSkillInfo addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000010;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public SubNoteSkillInfo setNextPackage(final byte... values) {
      bitField0_ |= 0x00000010;
      nextPackage.copyFrom(values);
      return this;
    }

    @Override
    public SubNoteSkillInfo copyFrom(final SubNoteSkillInfo other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        qty = other.qty;
        tid = other.tid;
        luckyLevel = other.luckyLevel;
        new_ = other.new_;
        nextPackage.copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public SubNoteSkillInfo mergeFrom(final SubNoteSkillInfo other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasQty()) {
        setQty(other.qty);
      }
      if (other.hasTid()) {
        setTid(other.tid);
      }
      if (other.hasLuckyLevel()) {
        setLuckyLevel(other.luckyLevel);
      }
      if (other.hasNew()) {
        setNew(other.new_);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public SubNoteSkillInfo clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      qty = 0;
      tid = 0;
      luckyLevel = 0;
      new_ = false;
      nextPackage.clear();
      return this;
    }

    @Override
    public SubNoteSkillInfo clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof SubNoteSkillInfo)) {
        return false;
      }
      SubNoteSkillInfo other = (SubNoteSkillInfo) o;
      return bitField0_ == other.bitField0_
        && (!hasQty() || qty == other.qty)
        && (!hasTid() || tid == other.tid)
        && (!hasLuckyLevel() || luckyLevel == other.luckyLevel)
        && (!hasNew() || new_ == other.new_)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 16);
        output.writeInt32NoTag(qty);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt32NoTag(tid);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawByte((byte) 32);
        output.writeUInt32NoTag(luckyLevel);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeRawByte((byte) 24);
        output.writeBoolNoTag(new_);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeInt32SizeNoTag(qty);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(tid);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(luckyLevel);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        size += 2;
      }
      if ((bitField0_ & 0x00000010) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public SubNoteSkillInfo mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 16: {
            // qty
            qty = input.readInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 8) {
              break;
            }
          }
          case 8: {
            // tid
            tid = input.readUInt32();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 32) {
              break;
            }
          }
          case 32: {
            // luckyLevel
            luckyLevel = input.readUInt32();
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 24) {
              break;
            }
          }
          case 24: {
            // new_
            new_ = input.readBool();
            bitField0_ |= 0x00000008;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000010;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeInt32(FieldNames.qty, qty);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeUInt32(FieldNames.tid, tid);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeUInt32(FieldNames.luckyLevel, luckyLevel);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeBool(FieldNames.new_, new_);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      output.endObject();
    }

    @Override
    public SubNoteSkillInfo mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 81558: {
            if (input.isAtField(FieldNames.qty)) {
              if (!input.trySkipNullValue()) {
                qty = input.readInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 84079: {
            if (input.isAtField(FieldNames.tid)) {
              if (!input.trySkipNullValue()) {
                tid = input.readUInt32();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 1681685916: {
            if (input.isAtField(FieldNames.luckyLevel)) {
              if (!input.trySkipNullValue()) {
                luckyLevel = input.readUInt32();
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 78208: {
            if (input.isAtField(FieldNames.new_)) {
              if (!input.trySkipNullValue()) {
                new_ = input.readBool();
                bitField0_ |= 0x00000008;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000010;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public SubNoteSkillInfo clone() {
      return new SubNoteSkillInfo().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static SubNoteSkillInfo parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new SubNoteSkillInfo(), data).checkInitialized();
    }

    public static SubNoteSkillInfo parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new SubNoteSkillInfo(), input).checkInitialized();
    }

    public static SubNoteSkillInfo parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new SubNoteSkillInfo(), input).checkInitialized();
    }

    /**
     * @return factory for creating SubNoteSkillInfo messages
     */
    public static MessageFactory<SubNoteSkillInfo> getFactory() {
      return SubNoteSkillInfoFactory.INSTANCE;
    }

    private enum SubNoteSkillInfoFactory implements MessageFactory<SubNoteSkillInfo> {
      INSTANCE;

      @Override
      public SubNoteSkillInfo create() {
        return SubNoteSkillInfo.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName qty = FieldName.forField("Qty");

      static final FieldName tid = FieldName.forField("Tid");

      static final FieldName luckyLevel = FieldName.forField("LuckyLevel");

      static final FieldName new_ = FieldName.forField("New");

      static final FieldName nextPackage = FieldName.forField("NextPackage");
    }
  }

  /**
   * Protobuf type {@code FirstAward}
   */
  public static final class FirstAward extends ProtoMessage<FirstAward> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional uint32 TowerId = 1;</code>
     */
    private int towerId;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    /**
     * <code>repeated .ItemTpl Items = 2;</code>
     */
    private final RepeatedMessage<Public.ItemTpl> items = RepeatedMessage.newEmptyInstance(Public.ItemTpl.getFactory());

    private FirstAward() {
    }

    /**
     * @return a new empty instance of {@code FirstAward}
     */
    public static FirstAward newInstance() {
      return new FirstAward();
    }

    /**
     * <code>optional uint32 TowerId = 1;</code>
     * @return whether the towerId field is set
     */
    public boolean hasTowerId() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional uint32 TowerId = 1;</code>
     * @return this
     */
    public FirstAward clearTowerId() {
      bitField0_ &= ~0x00000001;
      towerId = 0;
      return this;
    }

    /**
     * <code>optional uint32 TowerId = 1;</code>
     * @return the towerId
     */
    public int getTowerId() {
      return towerId;
    }

    /**
     * <code>optional uint32 TowerId = 1;</code>
     * @param value the towerId to set
     * @return this
     */
    public FirstAward setTowerId(final int value) {
      bitField0_ |= 0x00000001;
      towerId = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public FirstAward clearNextPackage() {
      bitField0_ &= ~0x00000002;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000002;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public FirstAward addNextPackage(final byte value) {
      bitField0_ |= 0x00000002;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public FirstAward addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000002;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public FirstAward setNextPackage(final byte... values) {
      bitField0_ |= 0x00000002;
      nextPackage.copyFrom(values);
      return this;
    }

    /**
     * <code>repeated .ItemTpl Items = 2;</code>
     * @return whether the items field is set
     */
    public boolean hasItems() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>repeated .ItemTpl Items = 2;</code>
     * @return this
     */
    public FirstAward clearItems() {
      bitField0_ &= ~0x00000004;
      items.clear();
      return this;
    }

    /**
     * <code>repeated .ItemTpl Items = 2;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableItems()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<Public.ItemTpl> getItems() {
      return items;
    }

    /**
     * <code>repeated .ItemTpl Items = 2;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<Public.ItemTpl> getMutableItems() {
      bitField0_ |= 0x00000004;
      return items;
    }

    /**
     * <code>repeated .ItemTpl Items = 2;</code>
     * @param value the items to add
     * @return this
     */
    public FirstAward addItems(final Public.ItemTpl value) {
      bitField0_ |= 0x00000004;
      items.add(value);
      return this;
    }

    /**
     * <code>repeated .ItemTpl Items = 2;</code>
     * @param values the items to add
     * @return this
     */
    public FirstAward addAllItems(final Public.ItemTpl... values) {
      bitField0_ |= 0x00000004;
      items.addAll(values);
      return this;
    }

    @Override
    public FirstAward copyFrom(final FirstAward other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        towerId = other.towerId;
        nextPackage.copyFrom(other.nextPackage);
        items.copyFrom(other.items);
      }
      return this;
    }

    @Override
    public FirstAward mergeFrom(final FirstAward other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasTowerId()) {
        setTowerId(other.towerId);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      if (other.hasItems()) {
        getMutableItems().addAll(other.items);
      }
      return this;
    }

    @Override
    public FirstAward clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      towerId = 0;
      nextPackage.clear();
      items.clear();
      return this;
    }

    @Override
    public FirstAward clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      items.clearQuick();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof FirstAward)) {
        return false;
      }
      FirstAward other = (FirstAward) o;
      return bitField0_ == other.bitField0_
        && (!hasTowerId() || towerId == other.towerId)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage))
        && (!hasItems() || items.equals(other.items));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt32NoTag(towerId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        for (int i = 0; i < items.length(); i++) {
          output.writeRawByte((byte) 18);
          output.writeMessageNoTag(items.get(i));
        }
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(towerId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += (1 * items.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(items);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public FirstAward mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            // towerId
            towerId = input.readUInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 18) {
              break;
            }
          }
          case 18: {
            // items
            tag = input.readRepeatedMessage(items, tag);
            bitField0_ |= 0x00000004;
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeUInt32(FieldNames.towerId, towerId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRepeatedMessage(FieldNames.items, items);
      }
      output.endObject();
    }

    @Override
    public FirstAward mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 531753444: {
            if (input.isAtField(FieldNames.towerId)) {
              if (!input.trySkipNullValue()) {
                towerId = input.readUInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 70973344: {
            if (input.isAtField(FieldNames.items)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedMessage(items);
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public FirstAward clone() {
      return new FirstAward().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static FirstAward parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new FirstAward(), data).checkInitialized();
    }

    public static FirstAward parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new FirstAward(), input).checkInitialized();
    }

    public static FirstAward parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new FirstAward(), input).checkInitialized();
    }

    /**
     * @return factory for creating FirstAward messages
     */
    public static MessageFactory<FirstAward> getFactory() {
      return FirstAwardFactory.INSTANCE;
    }

    private enum FirstAwardFactory implements MessageFactory<FirstAward> {
      INSTANCE;

      @Override
      public FirstAward create() {
        return FirstAward.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName towerId = FieldName.forField("TowerId");

      static final FieldName nextPackage = FieldName.forField("NextPackage");

      static final FieldName items = FieldName.forField("Items");
    }
  }

  /**
   * Protobuf type {@code SettleDataResp}
   */
  public static final class SettleDataResp extends ProtoMessage<SettleDataResp> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional uint32 NpcInteraction = 5;</code>
     */
    private int npcInteraction;

    /**
     * <code>optional uint32 TotalTime = 14;</code>
     */
    private int totalTime;

    /**
     * <code>optional .ChangeInfo Change = 1;</code>
     */
    private final Public.ChangeInfo change = Public.ChangeInfo.newInstance();

    /**
     * <code>optional .StarTowerBuildInfo Build = 2;</code>
     */
    private final StarTowerBuildInfo build = StarTowerBuildInfo.newInstance();

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    /**
     * <code>repeated uint64 TotalDamages = 15;</code>
     */
    private final RepeatedLong totalDamages = RepeatedLong.newEmptyInstance();

    /**
     * <code>repeated .FirstAward Awards = 3;</code>
     */
    private final RepeatedMessage<FirstAward> awards = RepeatedMessage.newEmptyInstance(FirstAward.getFactory());

    /**
     * <code>repeated .NPCAffinityLevelReward Reward = 4;</code>
     */
    private final RepeatedMessage<NPCAffinityLevelReward> reward = RepeatedMessage.newEmptyInstance(NPCAffinityLevelReward.getFactory());

    /**
     * <code>repeated .ItemTpl TowerRewards = 6;</code>
     */
    private final RepeatedMessage<Public.ItemTpl> towerRewards = RepeatedMessage.newEmptyInstance(Public.ItemTpl.getFactory());

    private SettleDataResp() {
    }

    /**
     * @return a new empty instance of {@code SettleDataResp}
     */
    public static SettleDataResp newInstance() {
      return new SettleDataResp();
    }

    /**
     * <code>optional uint32 NpcInteraction = 5;</code>
     * @return whether the npcInteraction field is set
     */
    public boolean hasNpcInteraction() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional uint32 NpcInteraction = 5;</code>
     * @return this
     */
    public SettleDataResp clearNpcInteraction() {
      bitField0_ &= ~0x00000001;
      npcInteraction = 0;
      return this;
    }

    /**
     * <code>optional uint32 NpcInteraction = 5;</code>
     * @return the npcInteraction
     */
    public int getNpcInteraction() {
      return npcInteraction;
    }

    /**
     * <code>optional uint32 NpcInteraction = 5;</code>
     * @param value the npcInteraction to set
     * @return this
     */
    public SettleDataResp setNpcInteraction(final int value) {
      bitField0_ |= 0x00000001;
      npcInteraction = value;
      return this;
    }

    /**
     * <code>optional uint32 TotalTime = 14;</code>
     * @return whether the totalTime field is set
     */
    public boolean hasTotalTime() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional uint32 TotalTime = 14;</code>
     * @return this
     */
    public SettleDataResp clearTotalTime() {
      bitField0_ &= ~0x00000002;
      totalTime = 0;
      return this;
    }

    /**
     * <code>optional uint32 TotalTime = 14;</code>
     * @return the totalTime
     */
    public int getTotalTime() {
      return totalTime;
    }

    /**
     * <code>optional uint32 TotalTime = 14;</code>
     * @param value the totalTime to set
     * @return this
     */
    public SettleDataResp setTotalTime(final int value) {
      bitField0_ |= 0x00000002;
      totalTime = value;
      return this;
    }

    /**
     * <code>optional .ChangeInfo Change = 1;</code>
     * @return whether the change field is set
     */
    public boolean hasChange() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional .ChangeInfo Change = 1;</code>
     * @return this
     */
    public SettleDataResp clearChange() {
      bitField0_ &= ~0x00000004;
      change.clear();
      return this;
    }

    /**
     * <code>optional .ChangeInfo Change = 1;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableChange()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public Public.ChangeInfo getChange() {
      return change;
    }

    /**
     * <code>optional .ChangeInfo Change = 1;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public Public.ChangeInfo getMutableChange() {
      bitField0_ |= 0x00000004;
      return change;
    }

    /**
     * <code>optional .ChangeInfo Change = 1;</code>
     * @param value the change to set
     * @return this
     */
    public SettleDataResp setChange(final Public.ChangeInfo value) {
      bitField0_ |= 0x00000004;
      change.copyFrom(value);
      return this;
    }

    /**
     * <code>optional .StarTowerBuildInfo Build = 2;</code>
     * @return whether the build field is set
     */
    public boolean hasBuild() {
      return (bitField0_ & 0x00000008) != 0;
    }

    /**
     * <code>optional .StarTowerBuildInfo Build = 2;</code>
     * @return this
     */
    public SettleDataResp clearBuild() {
      bitField0_ &= ~0x00000008;
      build.clear();
      return this;
    }

    /**
     * <code>optional .StarTowerBuildInfo Build = 2;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableBuild()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public StarTowerBuildInfo getBuild() {
      return build;
    }

    /**
     * <code>optional .StarTowerBuildInfo Build = 2;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public StarTowerBuildInfo getMutableBuild() {
      bitField0_ |= 0x00000008;
      return build;
    }

    /**
     * <code>optional .StarTowerBuildInfo Build = 2;</code>
     * @param value the build to set
     * @return this
     */
    public SettleDataResp setBuild(final StarTowerBuildInfo value) {
      bitField0_ |= 0x00000008;
      build.copyFrom(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000010) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public SettleDataResp clearNextPackage() {
      bitField0_ &= ~0x00000010;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000010;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public SettleDataResp addNextPackage(final byte value) {
      bitField0_ |= 0x00000010;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public SettleDataResp addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000010;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public SettleDataResp setNextPackage(final byte... values) {
      bitField0_ |= 0x00000010;
      nextPackage.copyFrom(values);
      return this;
    }

    /**
     * <code>repeated uint64 TotalDamages = 15;</code>
     * @return whether the totalDamages field is set
     */
    public boolean hasTotalDamages() {
      return (bitField0_ & 0x00000020) != 0;
    }

    /**
     * <code>repeated uint64 TotalDamages = 15;</code>
     * @return this
     */
    public SettleDataResp clearTotalDamages() {
      bitField0_ &= ~0x00000020;
      totalDamages.clear();
      return this;
    }

    /**
     * <code>repeated uint64 TotalDamages = 15;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableTotalDamages()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedLong getTotalDamages() {
      return totalDamages;
    }

    /**
     * <code>repeated uint64 TotalDamages = 15;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedLong getMutableTotalDamages() {
      bitField0_ |= 0x00000020;
      return totalDamages;
    }

    /**
     * <code>repeated uint64 TotalDamages = 15;</code>
     * @param value the totalDamages to add
     * @return this
     */
    public SettleDataResp addTotalDamages(final long value) {
      bitField0_ |= 0x00000020;
      totalDamages.add(value);
      return this;
    }

    /**
     * <code>repeated uint64 TotalDamages = 15;</code>
     * @param values the totalDamages to add
     * @return this
     */
    public SettleDataResp addAllTotalDamages(final long... values) {
      bitField0_ |= 0x00000020;
      totalDamages.addAll(values);
      return this;
    }

    /**
     * <code>repeated .FirstAward Awards = 3;</code>
     * @return whether the awards field is set
     */
    public boolean hasAwards() {
      return (bitField0_ & 0x00000040) != 0;
    }

    /**
     * <code>repeated .FirstAward Awards = 3;</code>
     * @return this
     */
    public SettleDataResp clearAwards() {
      bitField0_ &= ~0x00000040;
      awards.clear();
      return this;
    }

    /**
     * <code>repeated .FirstAward Awards = 3;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableAwards()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<FirstAward> getAwards() {
      return awards;
    }

    /**
     * <code>repeated .FirstAward Awards = 3;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<FirstAward> getMutableAwards() {
      bitField0_ |= 0x00000040;
      return awards;
    }

    /**
     * <code>repeated .FirstAward Awards = 3;</code>
     * @param value the awards to add
     * @return this
     */
    public SettleDataResp addAwards(final FirstAward value) {
      bitField0_ |= 0x00000040;
      awards.add(value);
      return this;
    }

    /**
     * <code>repeated .FirstAward Awards = 3;</code>
     * @param values the awards to add
     * @return this
     */
    public SettleDataResp addAllAwards(final FirstAward... values) {
      bitField0_ |= 0x00000040;
      awards.addAll(values);
      return this;
    }

    /**
     * <code>repeated .NPCAffinityLevelReward Reward = 4;</code>
     * @return whether the reward field is set
     */
    public boolean hasReward() {
      return (bitField0_ & 0x00000080) != 0;
    }

    /**
     * <code>repeated .NPCAffinityLevelReward Reward = 4;</code>
     * @return this
     */
    public SettleDataResp clearReward() {
      bitField0_ &= ~0x00000080;
      reward.clear();
      return this;
    }

    /**
     * <code>repeated .NPCAffinityLevelReward Reward = 4;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableReward()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<NPCAffinityLevelReward> getReward() {
      return reward;
    }

    /**
     * <code>repeated .NPCAffinityLevelReward Reward = 4;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<NPCAffinityLevelReward> getMutableReward() {
      bitField0_ |= 0x00000080;
      return reward;
    }

    /**
     * <code>repeated .NPCAffinityLevelReward Reward = 4;</code>
     * @param value the reward to add
     * @return this
     */
    public SettleDataResp addReward(final NPCAffinityLevelReward value) {
      bitField0_ |= 0x00000080;
      reward.add(value);
      return this;
    }

    /**
     * <code>repeated .NPCAffinityLevelReward Reward = 4;</code>
     * @param values the reward to add
     * @return this
     */
    public SettleDataResp addAllReward(final NPCAffinityLevelReward... values) {
      bitField0_ |= 0x00000080;
      reward.addAll(values);
      return this;
    }

    /**
     * <code>repeated .ItemTpl TowerRewards = 6;</code>
     * @return whether the towerRewards field is set
     */
    public boolean hasTowerRewards() {
      return (bitField0_ & 0x00000100) != 0;
    }

    /**
     * <code>repeated .ItemTpl TowerRewards = 6;</code>
     * @return this
     */
    public SettleDataResp clearTowerRewards() {
      bitField0_ &= ~0x00000100;
      towerRewards.clear();
      return this;
    }

    /**
     * <code>repeated .ItemTpl TowerRewards = 6;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableTowerRewards()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<Public.ItemTpl> getTowerRewards() {
      return towerRewards;
    }

    /**
     * <code>repeated .ItemTpl TowerRewards = 6;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<Public.ItemTpl> getMutableTowerRewards() {
      bitField0_ |= 0x00000100;
      return towerRewards;
    }

    /**
     * <code>repeated .ItemTpl TowerRewards = 6;</code>
     * @param value the towerRewards to add
     * @return this
     */
    public SettleDataResp addTowerRewards(final Public.ItemTpl value) {
      bitField0_ |= 0x00000100;
      towerRewards.add(value);
      return this;
    }

    /**
     * <code>repeated .ItemTpl TowerRewards = 6;</code>
     * @param values the towerRewards to add
     * @return this
     */
    public SettleDataResp addAllTowerRewards(final Public.ItemTpl... values) {
      bitField0_ |= 0x00000100;
      towerRewards.addAll(values);
      return this;
    }

    @Override
    public SettleDataResp copyFrom(final SettleDataResp other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        npcInteraction = other.npcInteraction;
        totalTime = other.totalTime;
        change.copyFrom(other.change);
        build.copyFrom(other.build);
        nextPackage.copyFrom(other.nextPackage);
        totalDamages.copyFrom(other.totalDamages);
        awards.copyFrom(other.awards);
        reward.copyFrom(other.reward);
        towerRewards.copyFrom(other.towerRewards);
      }
      return this;
    }

    @Override
    public SettleDataResp mergeFrom(final SettleDataResp other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasNpcInteraction()) {
        setNpcInteraction(other.npcInteraction);
      }
      if (other.hasTotalTime()) {
        setTotalTime(other.totalTime);
      }
      if (other.hasChange()) {
        getMutableChange().mergeFrom(other.change);
      }
      if (other.hasBuild()) {
        getMutableBuild().mergeFrom(other.build);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      if (other.hasTotalDamages()) {
        getMutableTotalDamages().addAll(other.totalDamages);
      }
      if (other.hasAwards()) {
        getMutableAwards().addAll(other.awards);
      }
      if (other.hasReward()) {
        getMutableReward().addAll(other.reward);
      }
      if (other.hasTowerRewards()) {
        getMutableTowerRewards().addAll(other.towerRewards);
      }
      return this;
    }

    @Override
    public SettleDataResp clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      npcInteraction = 0;
      totalTime = 0;
      change.clear();
      build.clear();
      nextPackage.clear();
      totalDamages.clear();
      awards.clear();
      reward.clear();
      towerRewards.clear();
      return this;
    }

    @Override
    public SettleDataResp clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      change.clearQuick();
      build.clearQuick();
      nextPackage.clear();
      totalDamages.clear();
      awards.clearQuick();
      reward.clearQuick();
      towerRewards.clearQuick();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof SettleDataResp)) {
        return false;
      }
      SettleDataResp other = (SettleDataResp) o;
      return bitField0_ == other.bitField0_
        && (!hasNpcInteraction() || npcInteraction == other.npcInteraction)
        && (!hasTotalTime() || totalTime == other.totalTime)
        && (!hasChange() || change.equals(other.change))
        && (!hasBuild() || build.equals(other.build))
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage))
        && (!hasTotalDamages() || totalDamages.equals(other.totalDamages))
        && (!hasAwards() || awards.equals(other.awards))
        && (!hasReward() || reward.equals(other.reward))
        && (!hasTowerRewards() || towerRewards.equals(other.towerRewards));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 40);
        output.writeUInt32NoTag(npcInteraction);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 112);
        output.writeUInt32NoTag(totalTime);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawByte((byte) 10);
        output.writeMessageNoTag(change);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeRawByte((byte) 18);
        output.writeMessageNoTag(build);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        for (int i = 0; i < totalDamages.length(); i++) {
          output.writeRawByte((byte) 120);
          output.writeUInt64NoTag(totalDamages.array()[i]);
        }
      }
      if ((bitField0_ & 0x00000040) != 0) {
        for (int i = 0; i < awards.length(); i++) {
          output.writeRawByte((byte) 26);
          output.writeMessageNoTag(awards.get(i));
        }
      }
      if ((bitField0_ & 0x00000080) != 0) {
        for (int i = 0; i < reward.length(); i++) {
          output.writeRawByte((byte) 34);
          output.writeMessageNoTag(reward.get(i));
        }
      }
      if ((bitField0_ & 0x00000100) != 0) {
        for (int i = 0; i < towerRewards.length(); i++) {
          output.writeRawByte((byte) 50);
          output.writeMessageNoTag(towerRewards.get(i));
        }
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(npcInteraction);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(totalTime);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 1 + ProtoSink.computeMessageSizeNoTag(change);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        size += 1 + ProtoSink.computeMessageSizeNoTag(build);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        size += (1 * totalDamages.length()) + ProtoSink.computeRepeatedUInt64SizeNoTag(totalDamages);
      }
      if ((bitField0_ & 0x00000040) != 0) {
        size += (1 * awards.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(awards);
      }
      if ((bitField0_ & 0x00000080) != 0) {
        size += (1 * reward.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(reward);
      }
      if ((bitField0_ & 0x00000100) != 0) {
        size += (1 * towerRewards.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(towerRewards);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public SettleDataResp mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 40: {
            // npcInteraction
            npcInteraction = input.readUInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 112) {
              break;
            }
          }
          case 112: {
            // totalTime
            totalTime = input.readUInt32();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 10) {
              break;
            }
          }
          case 10: {
            // change
            input.readMessage(change);
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 18) {
              break;
            }
          }
          case 18: {
            // build
            input.readMessage(build);
            bitField0_ |= 0x00000008;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000010;
            tag = input.readTag();
            if (tag != 122) {
              break;
            }
          }
          case 122: {
            // totalDamages [packed=true]
            input.readPackedUInt64(totalDamages, tag);
            bitField0_ |= 0x00000020;
            tag = input.readTag();
            if (tag != 26) {
              break;
            }
          }
          case 26: {
            // awards
            tag = input.readRepeatedMessage(awards, tag);
            bitField0_ |= 0x00000040;
            if (tag != 34) {
              break;
            }
          }
          case 34: {
            // reward
            tag = input.readRepeatedMessage(reward, tag);
            bitField0_ |= 0x00000080;
            if (tag != 50) {
              break;
            }
          }
          case 50: {
            // towerRewards
            tag = input.readRepeatedMessage(towerRewards, tag);
            bitField0_ |= 0x00000100;
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
          case 120: {
            // totalDamages [packed=false]
            tag = input.readRepeatedUInt64(totalDamages, tag);
            bitField0_ |= 0x00000020;
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeUInt32(FieldNames.npcInteraction, npcInteraction);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeUInt32(FieldNames.totalTime, totalTime);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeMessage(FieldNames.change, change);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeMessage(FieldNames.build, build);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        output.writeRepeatedUInt64(FieldNames.totalDamages, totalDamages);
      }
      if ((bitField0_ & 0x00000040) != 0) {
        output.writeRepeatedMessage(FieldNames.awards, awards);
      }
      if ((bitField0_ & 0x00000080) != 0) {
        output.writeRepeatedMessage(FieldNames.reward, reward);
      }
      if ((bitField0_ & 0x00000100) != 0) {
        output.writeRepeatedMessage(FieldNames.towerRewards, towerRewards);
      }
      output.endObject();
    }

    @Override
    public SettleDataResp mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case -168972143: {
            if (input.isAtField(FieldNames.npcInteraction)) {
              if (!input.trySkipNullValue()) {
                npcInteraction = input.readUInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 1426685969: {
            if (input.isAtField(FieldNames.totalTime)) {
              if (!input.trySkipNullValue()) {
                totalTime = input.readUInt32();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 2017198032: {
            if (input.isAtField(FieldNames.change)) {
              if (!input.trySkipNullValue()) {
                input.readMessage(change);
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 64542286: {
            if (input.isAtField(FieldNames.build)) {
              if (!input.trySkipNullValue()) {
                input.readMessage(build);
                bitField0_ |= 0x00000008;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000010;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2138865888: {
            if (input.isAtField(FieldNames.totalDamages)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedUInt64(totalDamages);
                bitField0_ |= 0x00000020;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 1973796310: {
            if (input.isAtField(FieldNames.awards)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedMessage(awards);
                bitField0_ |= 0x00000040;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1850459313: {
            if (input.isAtField(FieldNames.reward)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedMessage(reward);
                bitField0_ |= 0x00000080;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 162549755: {
            if (input.isAtField(FieldNames.towerRewards)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedMessage(towerRewards);
                bitField0_ |= 0x00000100;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public SettleDataResp clone() {
      return new SettleDataResp().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static SettleDataResp parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new SettleDataResp(), data).checkInitialized();
    }

    public static SettleDataResp parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new SettleDataResp(), input).checkInitialized();
    }

    public static SettleDataResp parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new SettleDataResp(), input).checkInitialized();
    }

    /**
     * @return factory for creating SettleDataResp messages
     */
    public static MessageFactory<SettleDataResp> getFactory() {
      return SettleDataRespFactory.INSTANCE;
    }

    private enum SettleDataRespFactory implements MessageFactory<SettleDataResp> {
      INSTANCE;

      @Override
      public SettleDataResp create() {
        return SettleDataResp.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName npcInteraction = FieldName.forField("NpcInteraction");

      static final FieldName totalTime = FieldName.forField("TotalTime");

      static final FieldName change = FieldName.forField("Change");

      static final FieldName build = FieldName.forField("Build");

      static final FieldName nextPackage = FieldName.forField("NextPackage");

      static final FieldName totalDamages = FieldName.forField("TotalDamages");

      static final FieldName awards = FieldName.forField("Awards");

      static final FieldName reward = FieldName.forField("Reward");

      static final FieldName towerRewards = FieldName.forField("TowerRewards");
    }
  }

  /**
   * Protobuf type {@code TowerBuildChar}
   */
  public static final class TowerBuildChar extends ProtoMessage<TowerBuildChar> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional uint32 CharId = 1;</code>
     */
    private int charId;

    /**
     * <code>optional uint32 PotentialCnt = 2;</code>
     */
    private int potentialCnt;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    private TowerBuildChar() {
    }

    /**
     * @return a new empty instance of {@code TowerBuildChar}
     */
    public static TowerBuildChar newInstance() {
      return new TowerBuildChar();
    }

    /**
     * <code>optional uint32 CharId = 1;</code>
     * @return whether the charId field is set
     */
    public boolean hasCharId() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional uint32 CharId = 1;</code>
     * @return this
     */
    public TowerBuildChar clearCharId() {
      bitField0_ &= ~0x00000001;
      charId = 0;
      return this;
    }

    /**
     * <code>optional uint32 CharId = 1;</code>
     * @return the charId
     */
    public int getCharId() {
      return charId;
    }

    /**
     * <code>optional uint32 CharId = 1;</code>
     * @param value the charId to set
     * @return this
     */
    public TowerBuildChar setCharId(final int value) {
      bitField0_ |= 0x00000001;
      charId = value;
      return this;
    }

    /**
     * <code>optional uint32 PotentialCnt = 2;</code>
     * @return whether the potentialCnt field is set
     */
    public boolean hasPotentialCnt() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional uint32 PotentialCnt = 2;</code>
     * @return this
     */
    public TowerBuildChar clearPotentialCnt() {
      bitField0_ &= ~0x00000002;
      potentialCnt = 0;
      return this;
    }

    /**
     * <code>optional uint32 PotentialCnt = 2;</code>
     * @return the potentialCnt
     */
    public int getPotentialCnt() {
      return potentialCnt;
    }

    /**
     * <code>optional uint32 PotentialCnt = 2;</code>
     * @param value the potentialCnt to set
     * @return this
     */
    public TowerBuildChar setPotentialCnt(final int value) {
      bitField0_ |= 0x00000002;
      potentialCnt = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public TowerBuildChar clearNextPackage() {
      bitField0_ &= ~0x00000004;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000004;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public TowerBuildChar addNextPackage(final byte value) {
      bitField0_ |= 0x00000004;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public TowerBuildChar addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000004;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public TowerBuildChar setNextPackage(final byte... values) {
      bitField0_ |= 0x00000004;
      nextPackage.copyFrom(values);
      return this;
    }

    @Override
    public TowerBuildChar copyFrom(final TowerBuildChar other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        charId = other.charId;
        potentialCnt = other.potentialCnt;
        nextPackage.copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public TowerBuildChar mergeFrom(final TowerBuildChar other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasCharId()) {
        setCharId(other.charId);
      }
      if (other.hasPotentialCnt()) {
        setPotentialCnt(other.potentialCnt);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public TowerBuildChar clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      charId = 0;
      potentialCnt = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public TowerBuildChar clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof TowerBuildChar)) {
        return false;
      }
      TowerBuildChar other = (TowerBuildChar) o;
      return bitField0_ == other.bitField0_
        && (!hasCharId() || charId == other.charId)
        && (!hasPotentialCnt() || potentialCnt == other.potentialCnt)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt32NoTag(charId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 16);
        output.writeUInt32NoTag(potentialCnt);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(charId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(potentialCnt);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public TowerBuildChar mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            // charId
            charId = input.readUInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 16) {
              break;
            }
          }
          case 16: {
            // potentialCnt
            potentialCnt = input.readUInt32();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeUInt32(FieldNames.charId, charId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeUInt32(FieldNames.potentialCnt, potentialCnt);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      output.endObject();
    }

    @Override
    public TowerBuildChar mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 2017200945: {
            if (input.isAtField(FieldNames.charId)) {
              if (!input.trySkipNullValue()) {
                charId = input.readUInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 2059288715: {
            if (input.isAtField(FieldNames.potentialCnt)) {
              if (!input.trySkipNullValue()) {
                potentialCnt = input.readUInt32();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public TowerBuildChar clone() {
      return new TowerBuildChar().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static TowerBuildChar parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new TowerBuildChar(), data).checkInitialized();
    }

    public static TowerBuildChar parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new TowerBuildChar(), input).checkInitialized();
    }

    public static TowerBuildChar parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new TowerBuildChar(), input).checkInitialized();
    }

    /**
     * @return factory for creating TowerBuildChar messages
     */
    public static MessageFactory<TowerBuildChar> getFactory() {
      return TowerBuildCharFactory.INSTANCE;
    }

    private enum TowerBuildCharFactory implements MessageFactory<TowerBuildChar> {
      INSTANCE;

      @Override
      public TowerBuildChar create() {
        return TowerBuildChar.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName charId = FieldName.forField("CharId");

      static final FieldName potentialCnt = FieldName.forField("PotentialCnt");

      static final FieldName nextPackage = FieldName.forField("NextPackage");
    }
  }

  /**
   * Protobuf type {@code BuildPotential}
   */
  public static final class BuildPotential extends ProtoMessage<BuildPotential> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional uint32 PotentialId = 1;</code>
     */
    private int potentialId;

    /**
     * <code>optional uint32 Level = 2;</code>
     */
    private int level;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    private BuildPotential() {
    }

    /**
     * @return a new empty instance of {@code BuildPotential}
     */
    public static BuildPotential newInstance() {
      return new BuildPotential();
    }

    /**
     * <code>optional uint32 PotentialId = 1;</code>
     * @return whether the potentialId field is set
     */
    public boolean hasPotentialId() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional uint32 PotentialId = 1;</code>
     * @return this
     */
    public BuildPotential clearPotentialId() {
      bitField0_ &= ~0x00000001;
      potentialId = 0;
      return this;
    }

    /**
     * <code>optional uint32 PotentialId = 1;</code>
     * @return the potentialId
     */
    public int getPotentialId() {
      return potentialId;
    }

    /**
     * <code>optional uint32 PotentialId = 1;</code>
     * @param value the potentialId to set
     * @return this
     */
    public BuildPotential setPotentialId(final int value) {
      bitField0_ |= 0x00000001;
      potentialId = value;
      return this;
    }

    /**
     * <code>optional uint32 Level = 2;</code>
     * @return whether the level field is set
     */
    public boolean hasLevel() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional uint32 Level = 2;</code>
     * @return this
     */
    public BuildPotential clearLevel() {
      bitField0_ &= ~0x00000002;
      level = 0;
      return this;
    }

    /**
     * <code>optional uint32 Level = 2;</code>
     * @return the level
     */
    public int getLevel() {
      return level;
    }

    /**
     * <code>optional uint32 Level = 2;</code>
     * @param value the level to set
     * @return this
     */
    public BuildPotential setLevel(final int value) {
      bitField0_ |= 0x00000002;
      level = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public BuildPotential clearNextPackage() {
      bitField0_ &= ~0x00000004;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000004;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public BuildPotential addNextPackage(final byte value) {
      bitField0_ |= 0x00000004;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public BuildPotential addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000004;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public BuildPotential setNextPackage(final byte... values) {
      bitField0_ |= 0x00000004;
      nextPackage.copyFrom(values);
      return this;
    }

    @Override
    public BuildPotential copyFrom(final BuildPotential other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        potentialId = other.potentialId;
        level = other.level;
        nextPackage.copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public BuildPotential mergeFrom(final BuildPotential other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasPotentialId()) {
        setPotentialId(other.potentialId);
      }
      if (other.hasLevel()) {
        setLevel(other.level);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public BuildPotential clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      potentialId = 0;
      level = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public BuildPotential clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof BuildPotential)) {
        return false;
      }
      BuildPotential other = (BuildPotential) o;
      return bitField0_ == other.bitField0_
        && (!hasPotentialId() || potentialId == other.potentialId)
        && (!hasLevel() || level == other.level)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt32NoTag(potentialId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 16);
        output.writeUInt32NoTag(level);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(potentialId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(level);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public BuildPotential mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            // potentialId
            potentialId = input.readUInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 16) {
              break;
            }
          }
          case 16: {
            // level
            level = input.readUInt32();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeUInt32(FieldNames.potentialId, potentialId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeUInt32(FieldNames.level, level);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      output.endObject();
    }

    @Override
    public BuildPotential mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 620618169: {
            if (input.isAtField(FieldNames.potentialId)) {
              if (!input.trySkipNullValue()) {
                potentialId = input.readUInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 73313124: {
            if (input.isAtField(FieldNames.level)) {
              if (!input.trySkipNullValue()) {
                level = input.readUInt32();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public BuildPotential clone() {
      return new BuildPotential().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static BuildPotential parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new BuildPotential(), data).checkInitialized();
    }

    public static BuildPotential parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new BuildPotential(), input).checkInitialized();
    }

    public static BuildPotential parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new BuildPotential(), input).checkInitialized();
    }

    /**
     * @return factory for creating BuildPotential messages
     */
    public static MessageFactory<BuildPotential> getFactory() {
      return BuildPotentialFactory.INSTANCE;
    }

    private enum BuildPotentialFactory implements MessageFactory<BuildPotential> {
      INSTANCE;

      @Override
      public BuildPotential create() {
        return BuildPotential.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName potentialId = FieldName.forField("PotentialId");

      static final FieldName level = FieldName.forField("Level");

      static final FieldName nextPackage = FieldName.forField("NextPackage");
    }
  }

  /**
   * Protobuf type {@code StarTowerBuildInfo}
   */
  public static final class StarTowerBuildInfo extends ProtoMessage<StarTowerBuildInfo> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional uint32 BuildCoin = 3;</code>
     */
    private int buildCoin;

    /**
     * <code>optional .StarTowerBuildBrief Brief = 1;</code>
     */
    private final StarTowerBuildBrief brief = StarTowerBuildBrief.newInstance();

    /**
     * <code>optional .StarTowerBuildDetail Detail = 2;</code>
     */
    private final StarTowerBuildDetail detail = StarTowerBuildDetail.newInstance();

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    private StarTowerBuildInfo() {
    }

    /**
     * @return a new empty instance of {@code StarTowerBuildInfo}
     */
    public static StarTowerBuildInfo newInstance() {
      return new StarTowerBuildInfo();
    }

    /**
     * <code>optional uint32 BuildCoin = 3;</code>
     * @return whether the buildCoin field is set
     */
    public boolean hasBuildCoin() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional uint32 BuildCoin = 3;</code>
     * @return this
     */
    public StarTowerBuildInfo clearBuildCoin() {
      bitField0_ &= ~0x00000001;
      buildCoin = 0;
      return this;
    }

    /**
     * <code>optional uint32 BuildCoin = 3;</code>
     * @return the buildCoin
     */
    public int getBuildCoin() {
      return buildCoin;
    }

    /**
     * <code>optional uint32 BuildCoin = 3;</code>
     * @param value the buildCoin to set
     * @return this
     */
    public StarTowerBuildInfo setBuildCoin(final int value) {
      bitField0_ |= 0x00000001;
      buildCoin = value;
      return this;
    }

    /**
     * <code>optional .StarTowerBuildBrief Brief = 1;</code>
     * @return whether the brief field is set
     */
    public boolean hasBrief() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional .StarTowerBuildBrief Brief = 1;</code>
     * @return this
     */
    public StarTowerBuildInfo clearBrief() {
      bitField0_ &= ~0x00000002;
      brief.clear();
      return this;
    }

    /**
     * <code>optional .StarTowerBuildBrief Brief = 1;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableBrief()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public StarTowerBuildBrief getBrief() {
      return brief;
    }

    /**
     * <code>optional .StarTowerBuildBrief Brief = 1;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public StarTowerBuildBrief getMutableBrief() {
      bitField0_ |= 0x00000002;
      return brief;
    }

    /**
     * <code>optional .StarTowerBuildBrief Brief = 1;</code>
     * @param value the brief to set
     * @return this
     */
    public StarTowerBuildInfo setBrief(final StarTowerBuildBrief value) {
      bitField0_ |= 0x00000002;
      brief.copyFrom(value);
      return this;
    }

    /**
     * <code>optional .StarTowerBuildDetail Detail = 2;</code>
     * @return whether the detail field is set
     */
    public boolean hasDetail() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional .StarTowerBuildDetail Detail = 2;</code>
     * @return this
     */
    public StarTowerBuildInfo clearDetail() {
      bitField0_ &= ~0x00000004;
      detail.clear();
      return this;
    }

    /**
     * <code>optional .StarTowerBuildDetail Detail = 2;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableDetail()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public StarTowerBuildDetail getDetail() {
      return detail;
    }

    /**
     * <code>optional .StarTowerBuildDetail Detail = 2;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public StarTowerBuildDetail getMutableDetail() {
      bitField0_ |= 0x00000004;
      return detail;
    }

    /**
     * <code>optional .StarTowerBuildDetail Detail = 2;</code>
     * @param value the detail to set
     * @return this
     */
    public StarTowerBuildInfo setDetail(final StarTowerBuildDetail value) {
      bitField0_ |= 0x00000004;
      detail.copyFrom(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000008) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public StarTowerBuildInfo clearNextPackage() {
      bitField0_ &= ~0x00000008;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000008;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public StarTowerBuildInfo addNextPackage(final byte value) {
      bitField0_ |= 0x00000008;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public StarTowerBuildInfo addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000008;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public StarTowerBuildInfo setNextPackage(final byte... values) {
      bitField0_ |= 0x00000008;
      nextPackage.copyFrom(values);
      return this;
    }

    @Override
    public StarTowerBuildInfo copyFrom(final StarTowerBuildInfo other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        buildCoin = other.buildCoin;
        brief.copyFrom(other.brief);
        detail.copyFrom(other.detail);
        nextPackage.copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public StarTowerBuildInfo mergeFrom(final StarTowerBuildInfo other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasBuildCoin()) {
        setBuildCoin(other.buildCoin);
      }
      if (other.hasBrief()) {
        getMutableBrief().mergeFrom(other.brief);
      }
      if (other.hasDetail()) {
        getMutableDetail().mergeFrom(other.detail);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public StarTowerBuildInfo clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      buildCoin = 0;
      brief.clear();
      detail.clear();
      nextPackage.clear();
      return this;
    }

    @Override
    public StarTowerBuildInfo clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      brief.clearQuick();
      detail.clearQuick();
      nextPackage.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof StarTowerBuildInfo)) {
        return false;
      }
      StarTowerBuildInfo other = (StarTowerBuildInfo) o;
      return bitField0_ == other.bitField0_
        && (!hasBuildCoin() || buildCoin == other.buildCoin)
        && (!hasBrief() || brief.equals(other.brief))
        && (!hasDetail() || detail.equals(other.detail))
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 24);
        output.writeUInt32NoTag(buildCoin);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 10);
        output.writeMessageNoTag(brief);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawByte((byte) 18);
        output.writeMessageNoTag(detail);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(buildCoin);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeMessageSizeNoTag(brief);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 1 + ProtoSink.computeMessageSizeNoTag(detail);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public StarTowerBuildInfo mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 24: {
            // buildCoin
            buildCoin = input.readUInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 10) {
              break;
            }
          }
          case 10: {
            // brief
            input.readMessage(brief);
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 18) {
              break;
            }
          }
          case 18: {
            // detail
            input.readMessage(detail);
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000008;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeUInt32(FieldNames.buildCoin, buildCoin);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeMessage(FieldNames.brief, brief);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeMessage(FieldNames.detail, detail);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      output.endObject();
    }

    @Override
    public StarTowerBuildInfo mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 602481151: {
            if (input.isAtField(FieldNames.buildCoin)) {
              if (!input.trySkipNullValue()) {
                buildCoin = input.readUInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 64452698: {
            if (input.isAtField(FieldNames.brief)) {
              if (!input.trySkipNullValue()) {
                input.readMessage(brief);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 2043610225: {
            if (input.isAtField(FieldNames.detail)) {
              if (!input.trySkipNullValue()) {
                input.readMessage(detail);
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000008;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public StarTowerBuildInfo clone() {
      return new StarTowerBuildInfo().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static StarTowerBuildInfo parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new StarTowerBuildInfo(), data).checkInitialized();
    }

    public static StarTowerBuildInfo parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new StarTowerBuildInfo(), input).checkInitialized();
    }

    public static StarTowerBuildInfo parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new StarTowerBuildInfo(), input).checkInitialized();
    }

    /**
     * @return factory for creating StarTowerBuildInfo messages
     */
    public static MessageFactory<StarTowerBuildInfo> getFactory() {
      return StarTowerBuildInfoFactory.INSTANCE;
    }

    private enum StarTowerBuildInfoFactory implements MessageFactory<StarTowerBuildInfo> {
      INSTANCE;

      @Override
      public StarTowerBuildInfo create() {
        return StarTowerBuildInfo.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName buildCoin = FieldName.forField("BuildCoin");

      static final FieldName brief = FieldName.forField("Brief");

      static final FieldName detail = FieldName.forField("Detail");

      static final FieldName nextPackage = FieldName.forField("NextPackage");
    }
  }

  /**
   * Protobuf type {@code StarTowerBuildBrief}
   */
  public static final class StarTowerBuildBrief extends ProtoMessage<StarTowerBuildBrief> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional uint64 Id = 1;</code>
     */
    private long id;

    /**
     * <code>optional uint32 Score = 5;</code>
     */
    private int score;

    /**
     * <code>optional uint32 StarTowerId = 8;</code>
     */
    private int starTowerId;

    /**
     * <code>optional bool Lock = 3;</code>
     */
    private boolean lock;

    /**
     * <code>optional bool Preference = 4;</code>
     */
    private boolean preference;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    /**
     * <code>optional string Name = 2;</code>
     */
    private final Utf8String name = Utf8String.newEmptyInstance();

    /**
     * <code>repeated uint32 DiscIds = 6;</code>
     */
    private final RepeatedInt discIds = RepeatedInt.newEmptyInstance();

    /**
     * <code>repeated .TowerBuildChar Chars = 7;</code>
     */
    private final RepeatedMessage<TowerBuildChar> chars = RepeatedMessage.newEmptyInstance(TowerBuildChar.getFactory());

    private StarTowerBuildBrief() {
    }

    /**
     * @return a new empty instance of {@code StarTowerBuildBrief}
     */
    public static StarTowerBuildBrief newInstance() {
      return new StarTowerBuildBrief();
    }

    /**
     * <code>optional uint64 Id = 1;</code>
     * @return whether the id field is set
     */
    public boolean hasId() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional uint64 Id = 1;</code>
     * @return this
     */
    public StarTowerBuildBrief clearId() {
      bitField0_ &= ~0x00000001;
      id = 0L;
      return this;
    }

    /**
     * <code>optional uint64 Id = 1;</code>
     * @return the id
     */
    public long getId() {
      return id;
    }

    /**
     * <code>optional uint64 Id = 1;</code>
     * @param value the id to set
     * @return this
     */
    public StarTowerBuildBrief setId(final long value) {
      bitField0_ |= 0x00000001;
      id = value;
      return this;
    }

    /**
     * <code>optional uint32 Score = 5;</code>
     * @return whether the score field is set
     */
    public boolean hasScore() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional uint32 Score = 5;</code>
     * @return this
     */
    public StarTowerBuildBrief clearScore() {
      bitField0_ &= ~0x00000002;
      score = 0;
      return this;
    }

    /**
     * <code>optional uint32 Score = 5;</code>
     * @return the score
     */
    public int getScore() {
      return score;
    }

    /**
     * <code>optional uint32 Score = 5;</code>
     * @param value the score to set
     * @return this
     */
    public StarTowerBuildBrief setScore(final int value) {
      bitField0_ |= 0x00000002;
      score = value;
      return this;
    }

    /**
     * <code>optional uint32 StarTowerId = 8;</code>
     * @return whether the starTowerId field is set
     */
    public boolean hasStarTowerId() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional uint32 StarTowerId = 8;</code>
     * @return this
     */
    public StarTowerBuildBrief clearStarTowerId() {
      bitField0_ &= ~0x00000004;
      starTowerId = 0;
      return this;
    }

    /**
     * <code>optional uint32 StarTowerId = 8;</code>
     * @return the starTowerId
     */
    public int getStarTowerId() {
      return starTowerId;
    }

    /**
     * <code>optional uint32 StarTowerId = 8;</code>
     * @param value the starTowerId to set
     * @return this
     */
    public StarTowerBuildBrief setStarTowerId(final int value) {
      bitField0_ |= 0x00000004;
      starTowerId = value;
      return this;
    }

    /**
     * <code>optional bool Lock = 3;</code>
     * @return whether the lock field is set
     */
    public boolean hasLock() {
      return (bitField0_ & 0x00000008) != 0;
    }

    /**
     * <code>optional bool Lock = 3;</code>
     * @return this
     */
    public StarTowerBuildBrief clearLock() {
      bitField0_ &= ~0x00000008;
      lock = false;
      return this;
    }

    /**
     * <code>optional bool Lock = 3;</code>
     * @return the lock
     */
    public boolean getLock() {
      return lock;
    }

    /**
     * <code>optional bool Lock = 3;</code>
     * @param value the lock to set
     * @return this
     */
    public StarTowerBuildBrief setLock(final boolean value) {
      bitField0_ |= 0x00000008;
      lock = value;
      return this;
    }

    /**
     * <code>optional bool Preference = 4;</code>
     * @return whether the preference field is set
     */
    public boolean hasPreference() {
      return (bitField0_ & 0x00000010) != 0;
    }

    /**
     * <code>optional bool Preference = 4;</code>
     * @return this
     */
    public StarTowerBuildBrief clearPreference() {
      bitField0_ &= ~0x00000010;
      preference = false;
      return this;
    }

    /**
     * <code>optional bool Preference = 4;</code>
     * @return the preference
     */
    public boolean getPreference() {
      return preference;
    }

    /**
     * <code>optional bool Preference = 4;</code>
     * @param value the preference to set
     * @return this
     */
    public StarTowerBuildBrief setPreference(final boolean value) {
      bitField0_ |= 0x00000010;
      preference = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000020) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public StarTowerBuildBrief clearNextPackage() {
      bitField0_ &= ~0x00000020;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000020;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public StarTowerBuildBrief addNextPackage(final byte value) {
      bitField0_ |= 0x00000020;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public StarTowerBuildBrief addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000020;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public StarTowerBuildBrief setNextPackage(final byte... values) {
      bitField0_ |= 0x00000020;
      nextPackage.copyFrom(values);
      return this;
    }

    /**
     * <code>optional string Name = 2;</code>
     * @return whether the name field is set
     */
    public boolean hasName() {
      return (bitField0_ & 0x00000040) != 0;
    }

    /**
     * <code>optional string Name = 2;</code>
     * @return this
     */
    public StarTowerBuildBrief clearName() {
      bitField0_ &= ~0x00000040;
      name.clear();
      return this;
    }

    /**
     * <code>optional string Name = 2;</code>
     * @return the name
     */
    public String getName() {
      return name.getString();
    }

    /**
     * <code>optional string Name = 2;</code>
     * @return internal {@code Utf8String} representation of name for reading
     */
    public Utf8String getNameBytes() {
      return this.name;
    }

    /**
     * <code>optional string Name = 2;</code>
     * @return internal {@code Utf8String} representation of name for modifications
     */
    public Utf8String getMutableNameBytes() {
      bitField0_ |= 0x00000040;
      return this.name;
    }

    /**
     * <code>optional string Name = 2;</code>
     * @param value the name to set
     * @return this
     */
    public StarTowerBuildBrief setName(final CharSequence value) {
      bitField0_ |= 0x00000040;
      name.copyFrom(value);
      return this;
    }

    /**
     * <code>optional string Name = 2;</code>
     * @param value the name to set
     * @return this
     */
    public StarTowerBuildBrief setName(final Utf8String value) {
      bitField0_ |= 0x00000040;
      name.copyFrom(value);
      return this;
    }

    /**
     * <code>repeated uint32 DiscIds = 6;</code>
     * @return whether the discIds field is set
     */
    public boolean hasDiscIds() {
      return (bitField0_ & 0x00000080) != 0;
    }

    /**
     * <code>repeated uint32 DiscIds = 6;</code>
     * @return this
     */
    public StarTowerBuildBrief clearDiscIds() {
      bitField0_ &= ~0x00000080;
      discIds.clear();
      return this;
    }

    /**
     * <code>repeated uint32 DiscIds = 6;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableDiscIds()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedInt getDiscIds() {
      return discIds;
    }

    /**
     * <code>repeated uint32 DiscIds = 6;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedInt getMutableDiscIds() {
      bitField0_ |= 0x00000080;
      return discIds;
    }

    /**
     * <code>repeated uint32 DiscIds = 6;</code>
     * @param value the discIds to add
     * @return this
     */
    public StarTowerBuildBrief addDiscIds(final int value) {
      bitField0_ |= 0x00000080;
      discIds.add(value);
      return this;
    }

    /**
     * <code>repeated uint32 DiscIds = 6;</code>
     * @param values the discIds to add
     * @return this
     */
    public StarTowerBuildBrief addAllDiscIds(final int... values) {
      bitField0_ |= 0x00000080;
      discIds.addAll(values);
      return this;
    }

    /**
     * <code>repeated .TowerBuildChar Chars = 7;</code>
     * @return whether the chars field is set
     */
    public boolean hasChars() {
      return (bitField0_ & 0x00000100) != 0;
    }

    /**
     * <code>repeated .TowerBuildChar Chars = 7;</code>
     * @return this
     */
    public StarTowerBuildBrief clearChars() {
      bitField0_ &= ~0x00000100;
      chars.clear();
      return this;
    }

    /**
     * <code>repeated .TowerBuildChar Chars = 7;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableChars()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<TowerBuildChar> getChars() {
      return chars;
    }

    /**
     * <code>repeated .TowerBuildChar Chars = 7;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<TowerBuildChar> getMutableChars() {
      bitField0_ |= 0x00000100;
      return chars;
    }

    /**
     * <code>repeated .TowerBuildChar Chars = 7;</code>
     * @param value the chars to add
     * @return this
     */
    public StarTowerBuildBrief addChars(final TowerBuildChar value) {
      bitField0_ |= 0x00000100;
      chars.add(value);
      return this;
    }

    /**
     * <code>repeated .TowerBuildChar Chars = 7;</code>
     * @param values the chars to add
     * @return this
     */
    public StarTowerBuildBrief addAllChars(final TowerBuildChar... values) {
      bitField0_ |= 0x00000100;
      chars.addAll(values);
      return this;
    }

    @Override
    public StarTowerBuildBrief copyFrom(final StarTowerBuildBrief other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        id = other.id;
        score = other.score;
        starTowerId = other.starTowerId;
        lock = other.lock;
        preference = other.preference;
        nextPackage.copyFrom(other.nextPackage);
        name.copyFrom(other.name);
        discIds.copyFrom(other.discIds);
        chars.copyFrom(other.chars);
      }
      return this;
    }

    @Override
    public StarTowerBuildBrief mergeFrom(final StarTowerBuildBrief other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasId()) {
        setId(other.id);
      }
      if (other.hasScore()) {
        setScore(other.score);
      }
      if (other.hasStarTowerId()) {
        setStarTowerId(other.starTowerId);
      }
      if (other.hasLock()) {
        setLock(other.lock);
      }
      if (other.hasPreference()) {
        setPreference(other.preference);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      if (other.hasName()) {
        getMutableNameBytes().copyFrom(other.name);
      }
      if (other.hasDiscIds()) {
        getMutableDiscIds().addAll(other.discIds);
      }
      if (other.hasChars()) {
        getMutableChars().addAll(other.chars);
      }
      return this;
    }

    @Override
    public StarTowerBuildBrief clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      id = 0L;
      score = 0;
      starTowerId = 0;
      lock = false;
      preference = false;
      nextPackage.clear();
      name.clear();
      discIds.clear();
      chars.clear();
      return this;
    }

    @Override
    public StarTowerBuildBrief clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      name.clear();
      discIds.clear();
      chars.clearQuick();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof StarTowerBuildBrief)) {
        return false;
      }
      StarTowerBuildBrief other = (StarTowerBuildBrief) o;
      return bitField0_ == other.bitField0_
        && (!hasId() || id == other.id)
        && (!hasScore() || score == other.score)
        && (!hasStarTowerId() || starTowerId == other.starTowerId)
        && (!hasLock() || lock == other.lock)
        && (!hasPreference() || preference == other.preference)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage))
        && (!hasName() || name.equals(other.name))
        && (!hasDiscIds() || discIds.equals(other.discIds))
        && (!hasChars() || chars.equals(other.chars));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt64NoTag(id);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 40);
        output.writeUInt32NoTag(score);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawByte((byte) 64);
        output.writeUInt32NoTag(starTowerId);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeRawByte((byte) 24);
        output.writeBoolNoTag(lock);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        output.writeRawByte((byte) 32);
        output.writeBoolNoTag(preference);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000040) != 0) {
        output.writeRawByte((byte) 18);
        output.writeStringNoTag(name);
      }
      if ((bitField0_ & 0x00000080) != 0) {
        for (int i = 0; i < discIds.length(); i++) {
          output.writeRawByte((byte) 48);
          output.writeUInt32NoTag(discIds.array()[i]);
        }
      }
      if ((bitField0_ & 0x00000100) != 0) {
        for (int i = 0; i < chars.length(); i++) {
          output.writeRawByte((byte) 58);
          output.writeMessageNoTag(chars.get(i));
        }
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeUInt64SizeNoTag(id);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(score);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(starTowerId);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        size += 2;
      }
      if ((bitField0_ & 0x00000010) != 0) {
        size += 2;
      }
      if ((bitField0_ & 0x00000020) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000040) != 0) {
        size += 1 + ProtoSink.computeStringSizeNoTag(name);
      }
      if ((bitField0_ & 0x00000080) != 0) {
        size += (1 * discIds.length()) + ProtoSink.computeRepeatedUInt32SizeNoTag(discIds);
      }
      if ((bitField0_ & 0x00000100) != 0) {
        size += (1 * chars.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(chars);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public StarTowerBuildBrief mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            // id
            id = input.readUInt64();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 40) {
              break;
            }
          }
          case 40: {
            // score
            score = input.readUInt32();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 64) {
              break;
            }
          }
          case 64: {
            // starTowerId
            starTowerId = input.readUInt32();
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 24) {
              break;
            }
          }
          case 24: {
            // lock
            lock = input.readBool();
            bitField0_ |= 0x00000008;
            tag = input.readTag();
            if (tag != 32) {
              break;
            }
          }
          case 32: {
            // preference
            preference = input.readBool();
            bitField0_ |= 0x00000010;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000020;
            tag = input.readTag();
            if (tag != 18) {
              break;
            }
          }
          case 18: {
            // name
            input.readString(name);
            bitField0_ |= 0x00000040;
            tag = input.readTag();
            if (tag != 50) {
              break;
            }
          }
          case 50: {
            // discIds [packed=true]
            input.readPackedUInt32(discIds, tag);
            bitField0_ |= 0x00000080;
            tag = input.readTag();
            if (tag != 58) {
              break;
            }
          }
          case 58: {
            // chars
            tag = input.readRepeatedMessage(chars, tag);
            bitField0_ |= 0x00000100;
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
          case 48: {
            // discIds [packed=false]
            tag = input.readRepeatedUInt32(discIds, tag);
            bitField0_ |= 0x00000080;
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeUInt64(FieldNames.id, id);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeUInt32(FieldNames.score, score);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeUInt32(FieldNames.starTowerId, starTowerId);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeBool(FieldNames.lock, lock);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        output.writeBool(FieldNames.preference, preference);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      if ((bitField0_ & 0x00000040) != 0) {
        output.writeString(FieldNames.name, name);
      }
      if ((bitField0_ & 0x00000080) != 0) {
        output.writeRepeatedUInt32(FieldNames.discIds, discIds);
      }
      if ((bitField0_ & 0x00000100) != 0) {
        output.writeRepeatedMessage(FieldNames.chars, chars);
      }
      output.endObject();
    }

    @Override
    public StarTowerBuildBrief mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 2363: {
            if (input.isAtField(FieldNames.id)) {
              if (!input.trySkipNullValue()) {
                id = input.readUInt64();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 79711858: {
            if (input.isAtField(FieldNames.score)) {
              if (!input.trySkipNullValue()) {
                score = input.readUInt32();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2024592590: {
            if (input.isAtField(FieldNames.starTowerId)) {
              if (!input.trySkipNullValue()) {
                starTowerId = input.readUInt32();
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 2373963: {
            if (input.isAtField(FieldNames.lock)) {
              if (!input.trySkipNullValue()) {
                lock = input.readBool();
                bitField0_ |= 0x00000008;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 533633275: {
            if (input.isAtField(FieldNames.preference)) {
              if (!input.trySkipNullValue()) {
                preference = input.readBool();
                bitField0_ |= 0x00000010;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000020;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 2420395: {
            if (input.isAtField(FieldNames.name)) {
              if (!input.trySkipNullValue()) {
                input.readString(name);
                bitField0_ |= 0x00000040;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -958970685: {
            if (input.isAtField(FieldNames.discIds)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedUInt32(discIds);
                bitField0_ |= 0x00000080;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 65071037: {
            if (input.isAtField(FieldNames.chars)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedMessage(chars);
                bitField0_ |= 0x00000100;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public StarTowerBuildBrief clone() {
      return new StarTowerBuildBrief().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static StarTowerBuildBrief parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new StarTowerBuildBrief(), data).checkInitialized();
    }

    public static StarTowerBuildBrief parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new StarTowerBuildBrief(), input).checkInitialized();
    }

    public static StarTowerBuildBrief parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new StarTowerBuildBrief(), input).checkInitialized();
    }

    /**
     * @return factory for creating StarTowerBuildBrief messages
     */
    public static MessageFactory<StarTowerBuildBrief> getFactory() {
      return StarTowerBuildBriefFactory.INSTANCE;
    }

    private enum StarTowerBuildBriefFactory implements MessageFactory<StarTowerBuildBrief> {
      INSTANCE;

      @Override
      public StarTowerBuildBrief create() {
        return StarTowerBuildBrief.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName id = FieldName.forField("Id");

      static final FieldName score = FieldName.forField("Score");

      static final FieldName starTowerId = FieldName.forField("StarTowerId");

      static final FieldName lock = FieldName.forField("Lock");

      static final FieldName preference = FieldName.forField("Preference");

      static final FieldName nextPackage = FieldName.forField("NextPackage");

      static final FieldName name = FieldName.forField("Name");

      static final FieldName discIds = FieldName.forField("DiscIds");

      static final FieldName chars = FieldName.forField("Chars");
    }
  }

  /**
   * Protobuf type {@code StarTowerBuildDetail}
   */
  public static final class StarTowerBuildDetail extends ProtoMessage<StarTowerBuildDetail> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    /**
     * <code>repeated uint32 ActiveSecondaryIds = 3;</code>
     */
    private final RepeatedInt activeSecondaryIds = RepeatedInt.newEmptyInstance();

    /**
     * <code>repeated .BuildPotential Potentials = 1;</code>
     */
    private final RepeatedMessage<BuildPotential> potentials = RepeatedMessage.newEmptyInstance(BuildPotential.getFactory());

    /**
     * <code>repeated .ItemTpl SubNoteSkills = 2;</code>
     */
    private final RepeatedMessage<Public.ItemTpl> subNoteSkills = RepeatedMessage.newEmptyInstance(Public.ItemTpl.getFactory());

    private StarTowerBuildDetail() {
    }

    /**
     * @return a new empty instance of {@code StarTowerBuildDetail}
     */
    public static StarTowerBuildDetail newInstance() {
      return new StarTowerBuildDetail();
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public StarTowerBuildDetail clearNextPackage() {
      bitField0_ &= ~0x00000001;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000001;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public StarTowerBuildDetail addNextPackage(final byte value) {
      bitField0_ |= 0x00000001;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public StarTowerBuildDetail addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000001;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public StarTowerBuildDetail setNextPackage(final byte... values) {
      bitField0_ |= 0x00000001;
      nextPackage.copyFrom(values);
      return this;
    }

    /**
     * <code>repeated uint32 ActiveSecondaryIds = 3;</code>
     * @return whether the activeSecondaryIds field is set
     */
    public boolean hasActiveSecondaryIds() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>repeated uint32 ActiveSecondaryIds = 3;</code>
     * @return this
     */
    public StarTowerBuildDetail clearActiveSecondaryIds() {
      bitField0_ &= ~0x00000002;
      activeSecondaryIds.clear();
      return this;
    }

    /**
     * <code>repeated uint32 ActiveSecondaryIds = 3;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableActiveSecondaryIds()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedInt getActiveSecondaryIds() {
      return activeSecondaryIds;
    }

    /**
     * <code>repeated uint32 ActiveSecondaryIds = 3;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedInt getMutableActiveSecondaryIds() {
      bitField0_ |= 0x00000002;
      return activeSecondaryIds;
    }

    /**
     * <code>repeated uint32 ActiveSecondaryIds = 3;</code>
     * @param value the activeSecondaryIds to add
     * @return this
     */
    public StarTowerBuildDetail addActiveSecondaryIds(final int value) {
      bitField0_ |= 0x00000002;
      activeSecondaryIds.add(value);
      return this;
    }

    /**
     * <code>repeated uint32 ActiveSecondaryIds = 3;</code>
     * @param values the activeSecondaryIds to add
     * @return this
     */
    public StarTowerBuildDetail addAllActiveSecondaryIds(final int... values) {
      bitField0_ |= 0x00000002;
      activeSecondaryIds.addAll(values);
      return this;
    }

    /**
     * <code>repeated .BuildPotential Potentials = 1;</code>
     * @return whether the potentials field is set
     */
    public boolean hasPotentials() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>repeated .BuildPotential Potentials = 1;</code>
     * @return this
     */
    public StarTowerBuildDetail clearPotentials() {
      bitField0_ &= ~0x00000004;
      potentials.clear();
      return this;
    }

    /**
     * <code>repeated .BuildPotential Potentials = 1;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutablePotentials()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<BuildPotential> getPotentials() {
      return potentials;
    }

    /**
     * <code>repeated .BuildPotential Potentials = 1;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<BuildPotential> getMutablePotentials() {
      bitField0_ |= 0x00000004;
      return potentials;
    }

    /**
     * <code>repeated .BuildPotential Potentials = 1;</code>
     * @param value the potentials to add
     * @return this
     */
    public StarTowerBuildDetail addPotentials(final BuildPotential value) {
      bitField0_ |= 0x00000004;
      potentials.add(value);
      return this;
    }

    /**
     * <code>repeated .BuildPotential Potentials = 1;</code>
     * @param values the potentials to add
     * @return this
     */
    public StarTowerBuildDetail addAllPotentials(final BuildPotential... values) {
      bitField0_ |= 0x00000004;
      potentials.addAll(values);
      return this;
    }

    /**
     * <code>repeated .ItemTpl SubNoteSkills = 2;</code>
     * @return whether the subNoteSkills field is set
     */
    public boolean hasSubNoteSkills() {
      return (bitField0_ & 0x00000008) != 0;
    }

    /**
     * <code>repeated .ItemTpl SubNoteSkills = 2;</code>
     * @return this
     */
    public StarTowerBuildDetail clearSubNoteSkills() {
      bitField0_ &= ~0x00000008;
      subNoteSkills.clear();
      return this;
    }

    /**
     * <code>repeated .ItemTpl SubNoteSkills = 2;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableSubNoteSkills()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<Public.ItemTpl> getSubNoteSkills() {
      return subNoteSkills;
    }

    /**
     * <code>repeated .ItemTpl SubNoteSkills = 2;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<Public.ItemTpl> getMutableSubNoteSkills() {
      bitField0_ |= 0x00000008;
      return subNoteSkills;
    }

    /**
     * <code>repeated .ItemTpl SubNoteSkills = 2;</code>
     * @param value the subNoteSkills to add
     * @return this
     */
    public StarTowerBuildDetail addSubNoteSkills(final Public.ItemTpl value) {
      bitField0_ |= 0x00000008;
      subNoteSkills.add(value);
      return this;
    }

    /**
     * <code>repeated .ItemTpl SubNoteSkills = 2;</code>
     * @param values the subNoteSkills to add
     * @return this
     */
    public StarTowerBuildDetail addAllSubNoteSkills(final Public.ItemTpl... values) {
      bitField0_ |= 0x00000008;
      subNoteSkills.addAll(values);
      return this;
    }

    @Override
    public StarTowerBuildDetail copyFrom(final StarTowerBuildDetail other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        nextPackage.copyFrom(other.nextPackage);
        activeSecondaryIds.copyFrom(other.activeSecondaryIds);
        potentials.copyFrom(other.potentials);
        subNoteSkills.copyFrom(other.subNoteSkills);
      }
      return this;
    }

    @Override
    public StarTowerBuildDetail mergeFrom(final StarTowerBuildDetail other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      if (other.hasActiveSecondaryIds()) {
        getMutableActiveSecondaryIds().addAll(other.activeSecondaryIds);
      }
      if (other.hasPotentials()) {
        getMutablePotentials().addAll(other.potentials);
      }
      if (other.hasSubNoteSkills()) {
        getMutableSubNoteSkills().addAll(other.subNoteSkills);
      }
      return this;
    }

    @Override
    public StarTowerBuildDetail clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      activeSecondaryIds.clear();
      potentials.clear();
      subNoteSkills.clear();
      return this;
    }

    @Override
    public StarTowerBuildDetail clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      activeSecondaryIds.clear();
      potentials.clearQuick();
      subNoteSkills.clearQuick();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof StarTowerBuildDetail)) {
        return false;
      }
      StarTowerBuildDetail other = (StarTowerBuildDetail) o;
      return bitField0_ == other.bitField0_
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage))
        && (!hasActiveSecondaryIds() || activeSecondaryIds.equals(other.activeSecondaryIds))
        && (!hasPotentials() || potentials.equals(other.potentials))
        && (!hasSubNoteSkills() || subNoteSkills.equals(other.subNoteSkills));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        for (int i = 0; i < activeSecondaryIds.length(); i++) {
          output.writeRawByte((byte) 24);
          output.writeUInt32NoTag(activeSecondaryIds.array()[i]);
        }
      }
      if ((bitField0_ & 0x00000004) != 0) {
        for (int i = 0; i < potentials.length(); i++) {
          output.writeRawByte((byte) 10);
          output.writeMessageNoTag(potentials.get(i));
        }
      }
      if ((bitField0_ & 0x00000008) != 0) {
        for (int i = 0; i < subNoteSkills.length(); i++) {
          output.writeRawByte((byte) 18);
          output.writeMessageNoTag(subNoteSkills.get(i));
        }
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += (1 * activeSecondaryIds.length()) + ProtoSink.computeRepeatedUInt32SizeNoTag(activeSecondaryIds);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += (1 * potentials.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(potentials);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        size += (1 * subNoteSkills.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(subNoteSkills);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public StarTowerBuildDetail mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 26) {
              break;
            }
          }
          case 26: {
            // activeSecondaryIds [packed=true]
            input.readPackedUInt32(activeSecondaryIds, tag);
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 10) {
              break;
            }
          }
          case 10: {
            // potentials
            tag = input.readRepeatedMessage(potentials, tag);
            bitField0_ |= 0x00000004;
            if (tag != 18) {
              break;
            }
          }
          case 18: {
            // subNoteSkills
            tag = input.readRepeatedMessage(subNoteSkills, tag);
            bitField0_ |= 0x00000008;
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
          case 24: {
            // activeSecondaryIds [packed=false]
            tag = input.readRepeatedUInt32(activeSecondaryIds, tag);
            bitField0_ |= 0x00000002;
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRepeatedUInt32(FieldNames.activeSecondaryIds, activeSecondaryIds);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRepeatedMessage(FieldNames.potentials, potentials);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeRepeatedMessage(FieldNames.subNoteSkills, subNoteSkills);
      }
      output.endObject();
    }

    @Override
    public StarTowerBuildDetail mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 1499070186: {
            if (input.isAtField(FieldNames.activeSecondaryIds)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedUInt32(activeSecondaryIds);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 1405493301: {
            if (input.isAtField(FieldNames.potentials)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedMessage(potentials);
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 349821204: {
            if (input.isAtField(FieldNames.subNoteSkills)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedMessage(subNoteSkills);
                bitField0_ |= 0x00000008;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public StarTowerBuildDetail clone() {
      return new StarTowerBuildDetail().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static StarTowerBuildDetail parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new StarTowerBuildDetail(), data).checkInitialized();
    }

    public static StarTowerBuildDetail parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new StarTowerBuildDetail(), input).checkInitialized();
    }

    public static StarTowerBuildDetail parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new StarTowerBuildDetail(), input).checkInitialized();
    }

    /**
     * @return factory for creating StarTowerBuildDetail messages
     */
    public static MessageFactory<StarTowerBuildDetail> getFactory() {
      return StarTowerBuildDetailFactory.INSTANCE;
    }

    private enum StarTowerBuildDetailFactory implements MessageFactory<StarTowerBuildDetail> {
      INSTANCE;

      @Override
      public StarTowerBuildDetail create() {
        return StarTowerBuildDetail.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName nextPackage = FieldName.forField("NextPackage");

      static final FieldName activeSecondaryIds = FieldName.forField("ActiveSecondaryIds");

      static final FieldName potentials = FieldName.forField("Potentials");

      static final FieldName subNoteSkills = FieldName.forField("SubNoteSkills");
    }
  }

  /**
   * Protobuf type {@code StarTowerBookCharPotentialBrief}
   */
  public static final class StarTowerBookCharPotentialBrief extends ProtoMessage<StarTowerBookCharPotentialBrief> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional uint32 CharId = 1;</code>
     */
    private int charId;

    /**
     * <code>optional uint32 Count = 2;</code>
     */
    private int count;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    private StarTowerBookCharPotentialBrief() {
    }

    /**
     * @return a new empty instance of {@code StarTowerBookCharPotentialBrief}
     */
    public static StarTowerBookCharPotentialBrief newInstance() {
      return new StarTowerBookCharPotentialBrief();
    }

    /**
     * <code>optional uint32 CharId = 1;</code>
     * @return whether the charId field is set
     */
    public boolean hasCharId() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional uint32 CharId = 1;</code>
     * @return this
     */
    public StarTowerBookCharPotentialBrief clearCharId() {
      bitField0_ &= ~0x00000001;
      charId = 0;
      return this;
    }

    /**
     * <code>optional uint32 CharId = 1;</code>
     * @return the charId
     */
    public int getCharId() {
      return charId;
    }

    /**
     * <code>optional uint32 CharId = 1;</code>
     * @param value the charId to set
     * @return this
     */
    public StarTowerBookCharPotentialBrief setCharId(final int value) {
      bitField0_ |= 0x00000001;
      charId = value;
      return this;
    }

    /**
     * <code>optional uint32 Count = 2;</code>
     * @return whether the count field is set
     */
    public boolean hasCount() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional uint32 Count = 2;</code>
     * @return this
     */
    public StarTowerBookCharPotentialBrief clearCount() {
      bitField0_ &= ~0x00000002;
      count = 0;
      return this;
    }

    /**
     * <code>optional uint32 Count = 2;</code>
     * @return the count
     */
    public int getCount() {
      return count;
    }

    /**
     * <code>optional uint32 Count = 2;</code>
     * @param value the count to set
     * @return this
     */
    public StarTowerBookCharPotentialBrief setCount(final int value) {
      bitField0_ |= 0x00000002;
      count = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public StarTowerBookCharPotentialBrief clearNextPackage() {
      bitField0_ &= ~0x00000004;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000004;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public StarTowerBookCharPotentialBrief addNextPackage(final byte value) {
      bitField0_ |= 0x00000004;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public StarTowerBookCharPotentialBrief addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000004;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public StarTowerBookCharPotentialBrief setNextPackage(final byte... values) {
      bitField0_ |= 0x00000004;
      nextPackage.copyFrom(values);
      return this;
    }

    @Override
    public StarTowerBookCharPotentialBrief copyFrom(final StarTowerBookCharPotentialBrief other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        charId = other.charId;
        count = other.count;
        nextPackage.copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public StarTowerBookCharPotentialBrief mergeFrom(final StarTowerBookCharPotentialBrief other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasCharId()) {
        setCharId(other.charId);
      }
      if (other.hasCount()) {
        setCount(other.count);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public StarTowerBookCharPotentialBrief clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      charId = 0;
      count = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public StarTowerBookCharPotentialBrief clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof StarTowerBookCharPotentialBrief)) {
        return false;
      }
      StarTowerBookCharPotentialBrief other = (StarTowerBookCharPotentialBrief) o;
      return bitField0_ == other.bitField0_
        && (!hasCharId() || charId == other.charId)
        && (!hasCount() || count == other.count)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt32NoTag(charId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 16);
        output.writeUInt32NoTag(count);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(charId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(count);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public StarTowerBookCharPotentialBrief mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            // charId
            charId = input.readUInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 16) {
              break;
            }
          }
          case 16: {
            // count
            count = input.readUInt32();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeUInt32(FieldNames.charId, charId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeUInt32(FieldNames.count, count);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      output.endObject();
    }

    @Override
    public StarTowerBookCharPotentialBrief mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 2017200945: {
            if (input.isAtField(FieldNames.charId)) {
              if (!input.trySkipNullValue()) {
                charId = input.readUInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 65298671: {
            if (input.isAtField(FieldNames.count)) {
              if (!input.trySkipNullValue()) {
                count = input.readUInt32();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public StarTowerBookCharPotentialBrief clone() {
      return new StarTowerBookCharPotentialBrief().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static StarTowerBookCharPotentialBrief parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new StarTowerBookCharPotentialBrief(), data).checkInitialized();
    }

    public static StarTowerBookCharPotentialBrief parseFrom(final ProtoSource input) throws
        IOException {
      return ProtoMessage.mergeFrom(new StarTowerBookCharPotentialBrief(), input).checkInitialized();
    }

    public static StarTowerBookCharPotentialBrief parseFrom(final JsonSource input) throws
        IOException {
      return ProtoMessage.mergeFrom(new StarTowerBookCharPotentialBrief(), input).checkInitialized();
    }

    /**
     * @return factory for creating StarTowerBookCharPotentialBrief messages
     */
    public static MessageFactory<StarTowerBookCharPotentialBrief> getFactory() {
      return StarTowerBookCharPotentialBriefFactory.INSTANCE;
    }

    private enum StarTowerBookCharPotentialBriefFactory implements MessageFactory<StarTowerBookCharPotentialBrief> {
      INSTANCE;

      @Override
      public StarTowerBookCharPotentialBrief create() {
        return StarTowerBookCharPotentialBrief.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName charId = FieldName.forField("CharId");

      static final FieldName count = FieldName.forField("Count");

      static final FieldName nextPackage = FieldName.forField("NextPackage");
    }
  }

  /**
   * Protobuf type {@code StarTowerBookPotential}
   */
  public static final class StarTowerBookPotential extends ProtoMessage<StarTowerBookPotential> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional uint32 Id = 1;</code>
     */
    private int id;

    /**
     * <code>optional uint32 Level = 2;</code>
     */
    private int level;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    private StarTowerBookPotential() {
    }

    /**
     * @return a new empty instance of {@code StarTowerBookPotential}
     */
    public static StarTowerBookPotential newInstance() {
      return new StarTowerBookPotential();
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @return whether the id field is set
     */
    public boolean hasId() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @return this
     */
    public StarTowerBookPotential clearId() {
      bitField0_ &= ~0x00000001;
      id = 0;
      return this;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @return the id
     */
    public int getId() {
      return id;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @param value the id to set
     * @return this
     */
    public StarTowerBookPotential setId(final int value) {
      bitField0_ |= 0x00000001;
      id = value;
      return this;
    }

    /**
     * <code>optional uint32 Level = 2;</code>
     * @return whether the level field is set
     */
    public boolean hasLevel() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional uint32 Level = 2;</code>
     * @return this
     */
    public StarTowerBookPotential clearLevel() {
      bitField0_ &= ~0x00000002;
      level = 0;
      return this;
    }

    /**
     * <code>optional uint32 Level = 2;</code>
     * @return the level
     */
    public int getLevel() {
      return level;
    }

    /**
     * <code>optional uint32 Level = 2;</code>
     * @param value the level to set
     * @return this
     */
    public StarTowerBookPotential setLevel(final int value) {
      bitField0_ |= 0x00000002;
      level = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public StarTowerBookPotential clearNextPackage() {
      bitField0_ &= ~0x00000004;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000004;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public StarTowerBookPotential addNextPackage(final byte value) {
      bitField0_ |= 0x00000004;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public StarTowerBookPotential addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000004;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public StarTowerBookPotential setNextPackage(final byte... values) {
      bitField0_ |= 0x00000004;
      nextPackage.copyFrom(values);
      return this;
    }

    @Override
    public StarTowerBookPotential copyFrom(final StarTowerBookPotential other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        id = other.id;
        level = other.level;
        nextPackage.copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public StarTowerBookPotential mergeFrom(final StarTowerBookPotential other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasId()) {
        setId(other.id);
      }
      if (other.hasLevel()) {
        setLevel(other.level);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public StarTowerBookPotential clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      id = 0;
      level = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public StarTowerBookPotential clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof StarTowerBookPotential)) {
        return false;
      }
      StarTowerBookPotential other = (StarTowerBookPotential) o;
      return bitField0_ == other.bitField0_
        && (!hasId() || id == other.id)
        && (!hasLevel() || level == other.level)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt32NoTag(id);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 16);
        output.writeUInt32NoTag(level);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(id);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(level);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public StarTowerBookPotential mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            // id
            id = input.readUInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 16) {
              break;
            }
          }
          case 16: {
            // level
            level = input.readUInt32();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeUInt32(FieldNames.id, id);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeUInt32(FieldNames.level, level);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      output.endObject();
    }

    @Override
    public StarTowerBookPotential mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 2363: {
            if (input.isAtField(FieldNames.id)) {
              if (!input.trySkipNullValue()) {
                id = input.readUInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 73313124: {
            if (input.isAtField(FieldNames.level)) {
              if (!input.trySkipNullValue()) {
                level = input.readUInt32();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public StarTowerBookPotential clone() {
      return new StarTowerBookPotential().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static StarTowerBookPotential parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new StarTowerBookPotential(), data).checkInitialized();
    }

    public static StarTowerBookPotential parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new StarTowerBookPotential(), input).checkInitialized();
    }

    public static StarTowerBookPotential parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new StarTowerBookPotential(), input).checkInitialized();
    }

    /**
     * @return factory for creating StarTowerBookPotential messages
     */
    public static MessageFactory<StarTowerBookPotential> getFactory() {
      return StarTowerBookPotentialFactory.INSTANCE;
    }

    private enum StarTowerBookPotentialFactory implements MessageFactory<StarTowerBookPotential> {
      INSTANCE;

      @Override
      public StarTowerBookPotential create() {
        return StarTowerBookPotential.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName id = FieldName.forField("Id");

      static final FieldName level = FieldName.forField("Level");

      static final FieldName nextPackage = FieldName.forField("NextPackage");
    }
  }

  /**
   * Protobuf type {@code StarTowerBookCharPotential}
   */
  public static final class StarTowerBookCharPotential extends ProtoMessage<StarTowerBookCharPotential> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional uint32 CharId = 1;</code>
     */
    private int charId;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    /**
     * <code>repeated .StarTowerBookPotential Potentials = 2;</code>
     */
    private final RepeatedMessage<StarTowerBookPotential> potentials = RepeatedMessage.newEmptyInstance(StarTowerBookPotential.getFactory());

    private StarTowerBookCharPotential() {
    }

    /**
     * @return a new empty instance of {@code StarTowerBookCharPotential}
     */
    public static StarTowerBookCharPotential newInstance() {
      return new StarTowerBookCharPotential();
    }

    /**
     * <code>optional uint32 CharId = 1;</code>
     * @return whether the charId field is set
     */
    public boolean hasCharId() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional uint32 CharId = 1;</code>
     * @return this
     */
    public StarTowerBookCharPotential clearCharId() {
      bitField0_ &= ~0x00000001;
      charId = 0;
      return this;
    }

    /**
     * <code>optional uint32 CharId = 1;</code>
     * @return the charId
     */
    public int getCharId() {
      return charId;
    }

    /**
     * <code>optional uint32 CharId = 1;</code>
     * @param value the charId to set
     * @return this
     */
    public StarTowerBookCharPotential setCharId(final int value) {
      bitField0_ |= 0x00000001;
      charId = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public StarTowerBookCharPotential clearNextPackage() {
      bitField0_ &= ~0x00000002;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000002;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public StarTowerBookCharPotential addNextPackage(final byte value) {
      bitField0_ |= 0x00000002;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public StarTowerBookCharPotential addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000002;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public StarTowerBookCharPotential setNextPackage(final byte... values) {
      bitField0_ |= 0x00000002;
      nextPackage.copyFrom(values);
      return this;
    }

    /**
     * <code>repeated .StarTowerBookPotential Potentials = 2;</code>
     * @return whether the potentials field is set
     */
    public boolean hasPotentials() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>repeated .StarTowerBookPotential Potentials = 2;</code>
     * @return this
     */
    public StarTowerBookCharPotential clearPotentials() {
      bitField0_ &= ~0x00000004;
      potentials.clear();
      return this;
    }

    /**
     * <code>repeated .StarTowerBookPotential Potentials = 2;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutablePotentials()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<StarTowerBookPotential> getPotentials() {
      return potentials;
    }

    /**
     * <code>repeated .StarTowerBookPotential Potentials = 2;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<StarTowerBookPotential> getMutablePotentials() {
      bitField0_ |= 0x00000004;
      return potentials;
    }

    /**
     * <code>repeated .StarTowerBookPotential Potentials = 2;</code>
     * @param value the potentials to add
     * @return this
     */
    public StarTowerBookCharPotential addPotentials(final StarTowerBookPotential value) {
      bitField0_ |= 0x00000004;
      potentials.add(value);
      return this;
    }

    /**
     * <code>repeated .StarTowerBookPotential Potentials = 2;</code>
     * @param values the potentials to add
     * @return this
     */
    public StarTowerBookCharPotential addAllPotentials(final StarTowerBookPotential... values) {
      bitField0_ |= 0x00000004;
      potentials.addAll(values);
      return this;
    }

    @Override
    public StarTowerBookCharPotential copyFrom(final StarTowerBookCharPotential other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        charId = other.charId;
        nextPackage.copyFrom(other.nextPackage);
        potentials.copyFrom(other.potentials);
      }
      return this;
    }

    @Override
    public StarTowerBookCharPotential mergeFrom(final StarTowerBookCharPotential other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasCharId()) {
        setCharId(other.charId);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      if (other.hasPotentials()) {
        getMutablePotentials().addAll(other.potentials);
      }
      return this;
    }

    @Override
    public StarTowerBookCharPotential clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      charId = 0;
      nextPackage.clear();
      potentials.clear();
      return this;
    }

    @Override
    public StarTowerBookCharPotential clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      potentials.clearQuick();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof StarTowerBookCharPotential)) {
        return false;
      }
      StarTowerBookCharPotential other = (StarTowerBookCharPotential) o;
      return bitField0_ == other.bitField0_
        && (!hasCharId() || charId == other.charId)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage))
        && (!hasPotentials() || potentials.equals(other.potentials));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt32NoTag(charId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        for (int i = 0; i < potentials.length(); i++) {
          output.writeRawByte((byte) 18);
          output.writeMessageNoTag(potentials.get(i));
        }
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(charId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += (1 * potentials.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(potentials);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public StarTowerBookCharPotential mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            // charId
            charId = input.readUInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 18) {
              break;
            }
          }
          case 18: {
            // potentials
            tag = input.readRepeatedMessage(potentials, tag);
            bitField0_ |= 0x00000004;
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeUInt32(FieldNames.charId, charId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRepeatedMessage(FieldNames.potentials, potentials);
      }
      output.endObject();
    }

    @Override
    public StarTowerBookCharPotential mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 2017200945: {
            if (input.isAtField(FieldNames.charId)) {
              if (!input.trySkipNullValue()) {
                charId = input.readUInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 1405493301: {
            if (input.isAtField(FieldNames.potentials)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedMessage(potentials);
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public StarTowerBookCharPotential clone() {
      return new StarTowerBookCharPotential().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static StarTowerBookCharPotential parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new StarTowerBookCharPotential(), data).checkInitialized();
    }

    public static StarTowerBookCharPotential parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new StarTowerBookCharPotential(), input).checkInitialized();
    }

    public static StarTowerBookCharPotential parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new StarTowerBookCharPotential(), input).checkInitialized();
    }

    /**
     * @return factory for creating StarTowerBookCharPotential messages
     */
    public static MessageFactory<StarTowerBookCharPotential> getFactory() {
      return StarTowerBookCharPotentialFactory.INSTANCE;
    }

    private enum StarTowerBookCharPotentialFactory implements MessageFactory<StarTowerBookCharPotential> {
      INSTANCE;

      @Override
      public StarTowerBookCharPotential create() {
        return StarTowerBookCharPotential.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName charId = FieldName.forField("CharId");

      static final FieldName nextPackage = FieldName.forField("NextPackage");

      static final FieldName potentials = FieldName.forField("Potentials");
    }
  }

  /**
   * Protobuf type {@code TowerChangeData}
   */
  public static final class TowerChangeData extends ProtoMessage<TowerChangeData> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    /**
     * <code>repeated .SubNoteSkillInfo Infos = 1;</code>
     */
    private final RepeatedMessage<SubNoteSkillInfo> infos = RepeatedMessage.newEmptyInstance(SubNoteSkillInfo.getFactory());

    /**
     * <code>repeated .ActiveSecondaryChange Secondaries = 2;</code>
     */
    private final RepeatedMessage<ActiveSecondaryChange> secondaries = RepeatedMessage.newEmptyInstance(ActiveSecondaryChange.getFactory());

    private TowerChangeData() {
    }

    /**
     * @return a new empty instance of {@code TowerChangeData}
     */
    public static TowerChangeData newInstance() {
      return new TowerChangeData();
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public TowerChangeData clearNextPackage() {
      bitField0_ &= ~0x00000001;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000001;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public TowerChangeData addNextPackage(final byte value) {
      bitField0_ |= 0x00000001;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public TowerChangeData addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000001;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public TowerChangeData setNextPackage(final byte... values) {
      bitField0_ |= 0x00000001;
      nextPackage.copyFrom(values);
      return this;
    }

    /**
     * <code>repeated .SubNoteSkillInfo Infos = 1;</code>
     * @return whether the infos field is set
     */
    public boolean hasInfos() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>repeated .SubNoteSkillInfo Infos = 1;</code>
     * @return this
     */
    public TowerChangeData clearInfos() {
      bitField0_ &= ~0x00000002;
      infos.clear();
      return this;
    }

    /**
     * <code>repeated .SubNoteSkillInfo Infos = 1;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableInfos()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<SubNoteSkillInfo> getInfos() {
      return infos;
    }

    /**
     * <code>repeated .SubNoteSkillInfo Infos = 1;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<SubNoteSkillInfo> getMutableInfos() {
      bitField0_ |= 0x00000002;
      return infos;
    }

    /**
     * <code>repeated .SubNoteSkillInfo Infos = 1;</code>
     * @param value the infos to add
     * @return this
     */
    public TowerChangeData addInfos(final SubNoteSkillInfo value) {
      bitField0_ |= 0x00000002;
      infos.add(value);
      return this;
    }

    /**
     * <code>repeated .SubNoteSkillInfo Infos = 1;</code>
     * @param values the infos to add
     * @return this
     */
    public TowerChangeData addAllInfos(final SubNoteSkillInfo... values) {
      bitField0_ |= 0x00000002;
      infos.addAll(values);
      return this;
    }

    /**
     * <code>repeated .ActiveSecondaryChange Secondaries = 2;</code>
     * @return whether the secondaries field is set
     */
    public boolean hasSecondaries() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>repeated .ActiveSecondaryChange Secondaries = 2;</code>
     * @return this
     */
    public TowerChangeData clearSecondaries() {
      bitField0_ &= ~0x00000004;
      secondaries.clear();
      return this;
    }

    /**
     * <code>repeated .ActiveSecondaryChange Secondaries = 2;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableSecondaries()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<ActiveSecondaryChange> getSecondaries() {
      return secondaries;
    }

    /**
     * <code>repeated .ActiveSecondaryChange Secondaries = 2;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<ActiveSecondaryChange> getMutableSecondaries() {
      bitField0_ |= 0x00000004;
      return secondaries;
    }

    /**
     * <code>repeated .ActiveSecondaryChange Secondaries = 2;</code>
     * @param value the secondaries to add
     * @return this
     */
    public TowerChangeData addSecondaries(final ActiveSecondaryChange value) {
      bitField0_ |= 0x00000004;
      secondaries.add(value);
      return this;
    }

    /**
     * <code>repeated .ActiveSecondaryChange Secondaries = 2;</code>
     * @param values the secondaries to add
     * @return this
     */
    public TowerChangeData addAllSecondaries(final ActiveSecondaryChange... values) {
      bitField0_ |= 0x00000004;
      secondaries.addAll(values);
      return this;
    }

    @Override
    public TowerChangeData copyFrom(final TowerChangeData other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        nextPackage.copyFrom(other.nextPackage);
        infos.copyFrom(other.infos);
        secondaries.copyFrom(other.secondaries);
      }
      return this;
    }

    @Override
    public TowerChangeData mergeFrom(final TowerChangeData other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      if (other.hasInfos()) {
        getMutableInfos().addAll(other.infos);
      }
      if (other.hasSecondaries()) {
        getMutableSecondaries().addAll(other.secondaries);
      }
      return this;
    }

    @Override
    public TowerChangeData clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      infos.clear();
      secondaries.clear();
      return this;
    }

    @Override
    public TowerChangeData clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      infos.clearQuick();
      secondaries.clearQuick();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof TowerChangeData)) {
        return false;
      }
      TowerChangeData other = (TowerChangeData) o;
      return bitField0_ == other.bitField0_
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage))
        && (!hasInfos() || infos.equals(other.infos))
        && (!hasSecondaries() || secondaries.equals(other.secondaries));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        for (int i = 0; i < infos.length(); i++) {
          output.writeRawByte((byte) 10);
          output.writeMessageNoTag(infos.get(i));
        }
      }
      if ((bitField0_ & 0x00000004) != 0) {
        for (int i = 0; i < secondaries.length(); i++) {
          output.writeRawByte((byte) 18);
          output.writeMessageNoTag(secondaries.get(i));
        }
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += (1 * infos.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(infos);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += (1 * secondaries.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(secondaries);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public TowerChangeData mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 10) {
              break;
            }
          }
          case 10: {
            // infos
            tag = input.readRepeatedMessage(infos, tag);
            bitField0_ |= 0x00000002;
            if (tag != 18) {
              break;
            }
          }
          case 18: {
            // secondaries
            tag = input.readRepeatedMessage(secondaries, tag);
            bitField0_ |= 0x00000004;
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRepeatedMessage(FieldNames.infos, infos);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRepeatedMessage(FieldNames.secondaries, secondaries);
      }
      output.endObject();
    }

    @Override
    public TowerChangeData mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 70795621: {
            if (input.isAtField(FieldNames.infos)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedMessage(infos);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 1935105266: {
            if (input.isAtField(FieldNames.secondaries)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedMessage(secondaries);
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public TowerChangeData clone() {
      return new TowerChangeData().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static TowerChangeData parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new TowerChangeData(), data).checkInitialized();
    }

    public static TowerChangeData parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new TowerChangeData(), input).checkInitialized();
    }

    public static TowerChangeData parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new TowerChangeData(), input).checkInitialized();
    }

    /**
     * @return factory for creating TowerChangeData messages
     */
    public static MessageFactory<TowerChangeData> getFactory() {
      return TowerChangeDataFactory.INSTANCE;
    }

    private enum TowerChangeDataFactory implements MessageFactory<TowerChangeData> {
      INSTANCE;

      @Override
      public TowerChangeData create() {
        return TowerChangeData.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName nextPackage = FieldName.forField("NextPackage");

      static final FieldName infos = FieldName.forField("Infos");

      static final FieldName secondaries = FieldName.forField("Secondaries");
    }
  }

  /**
   * Protobuf type {@code ActiveSecondaryChange}
   */
  public static final class ActiveSecondaryChange extends ProtoMessage<ActiveSecondaryChange> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional uint32 SecondaryId = 1;</code>
     */
    private int secondaryId;

    /**
     * <code>optional bool Active = 2;</code>
     */
    private boolean active;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    private ActiveSecondaryChange() {
    }

    /**
     * @return a new empty instance of {@code ActiveSecondaryChange}
     */
    public static ActiveSecondaryChange newInstance() {
      return new ActiveSecondaryChange();
    }

    /**
     * <code>optional uint32 SecondaryId = 1;</code>
     * @return whether the secondaryId field is set
     */
    public boolean hasSecondaryId() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional uint32 SecondaryId = 1;</code>
     * @return this
     */
    public ActiveSecondaryChange clearSecondaryId() {
      bitField0_ &= ~0x00000001;
      secondaryId = 0;
      return this;
    }

    /**
     * <code>optional uint32 SecondaryId = 1;</code>
     * @return the secondaryId
     */
    public int getSecondaryId() {
      return secondaryId;
    }

    /**
     * <code>optional uint32 SecondaryId = 1;</code>
     * @param value the secondaryId to set
     * @return this
     */
    public ActiveSecondaryChange setSecondaryId(final int value) {
      bitField0_ |= 0x00000001;
      secondaryId = value;
      return this;
    }

    /**
     * <code>optional bool Active = 2;</code>
     * @return whether the active field is set
     */
    public boolean hasActive() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional bool Active = 2;</code>
     * @return this
     */
    public ActiveSecondaryChange clearActive() {
      bitField0_ &= ~0x00000002;
      active = false;
      return this;
    }

    /**
     * <code>optional bool Active = 2;</code>
     * @return the active
     */
    public boolean getActive() {
      return active;
    }

    /**
     * <code>optional bool Active = 2;</code>
     * @param value the active to set
     * @return this
     */
    public ActiveSecondaryChange setActive(final boolean value) {
      bitField0_ |= 0x00000002;
      active = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public ActiveSecondaryChange clearNextPackage() {
      bitField0_ &= ~0x00000004;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000004;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public ActiveSecondaryChange addNextPackage(final byte value) {
      bitField0_ |= 0x00000004;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public ActiveSecondaryChange addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000004;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public ActiveSecondaryChange setNextPackage(final byte... values) {
      bitField0_ |= 0x00000004;
      nextPackage.copyFrom(values);
      return this;
    }

    @Override
    public ActiveSecondaryChange copyFrom(final ActiveSecondaryChange other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        secondaryId = other.secondaryId;
        active = other.active;
        nextPackage.copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public ActiveSecondaryChange mergeFrom(final ActiveSecondaryChange other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasSecondaryId()) {
        setSecondaryId(other.secondaryId);
      }
      if (other.hasActive()) {
        setActive(other.active);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public ActiveSecondaryChange clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      secondaryId = 0;
      active = false;
      nextPackage.clear();
      return this;
    }

    @Override
    public ActiveSecondaryChange clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof ActiveSecondaryChange)) {
        return false;
      }
      ActiveSecondaryChange other = (ActiveSecondaryChange) o;
      return bitField0_ == other.bitField0_
        && (!hasSecondaryId() || secondaryId == other.secondaryId)
        && (!hasActive() || active == other.active)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt32NoTag(secondaryId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 16);
        output.writeBoolNoTag(active);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(secondaryId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 2;
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public ActiveSecondaryChange mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            // secondaryId
            secondaryId = input.readUInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 16) {
              break;
            }
          }
          case 16: {
            // active
            active = input.readBool();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeUInt32(FieldNames.secondaryId, secondaryId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeBool(FieldNames.active, active);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      output.endObject();
    }

    @Override
    public ActiveSecondaryChange mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 1935119759: {
            if (input.isAtField(FieldNames.secondaryId)) {
              if (!input.trySkipNullValue()) {
                secondaryId = input.readUInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 1955883814: {
            if (input.isAtField(FieldNames.active)) {
              if (!input.trySkipNullValue()) {
                active = input.readBool();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public ActiveSecondaryChange clone() {
      return new ActiveSecondaryChange().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static ActiveSecondaryChange parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new ActiveSecondaryChange(), data).checkInitialized();
    }

    public static ActiveSecondaryChange parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new ActiveSecondaryChange(), input).checkInitialized();
    }

    public static ActiveSecondaryChange parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new ActiveSecondaryChange(), input).checkInitialized();
    }

    /**
     * @return factory for creating ActiveSecondaryChange messages
     */
    public static MessageFactory<ActiveSecondaryChange> getFactory() {
      return ActiveSecondaryChangeFactory.INSTANCE;
    }

    private enum ActiveSecondaryChangeFactory implements MessageFactory<ActiveSecondaryChange> {
      INSTANCE;

      @Override
      public ActiveSecondaryChange create() {
        return ActiveSecondaryChange.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName secondaryId = FieldName.forField("SecondaryId");

      static final FieldName active = FieldName.forField("Active");

      static final FieldName nextPackage = FieldName.forField("NextPackage");
    }
  }

  /**
   * Protobuf type {@code NPCAffinityInfo}
   */
  public static final class NPCAffinityInfo extends ProtoMessage<NPCAffinityInfo> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional uint32 NPCId = 1;</code>
     */
    private int nPCId;

    /**
     * <code>optional uint32 Affinity = 2;</code>
     */
    private int affinity;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    private NPCAffinityInfo() {
    }

    /**
     * @return a new empty instance of {@code NPCAffinityInfo}
     */
    public static NPCAffinityInfo newInstance() {
      return new NPCAffinityInfo();
    }

    /**
     * <code>optional uint32 NPCId = 1;</code>
     * @return whether the nPCId field is set
     */
    public boolean hasNPCId() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional uint32 NPCId = 1;</code>
     * @return this
     */
    public NPCAffinityInfo clearNPCId() {
      bitField0_ &= ~0x00000001;
      nPCId = 0;
      return this;
    }

    /**
     * <code>optional uint32 NPCId = 1;</code>
     * @return the nPCId
     */
    public int getNPCId() {
      return nPCId;
    }

    /**
     * <code>optional uint32 NPCId = 1;</code>
     * @param value the nPCId to set
     * @return this
     */
    public NPCAffinityInfo setNPCId(final int value) {
      bitField0_ |= 0x00000001;
      nPCId = value;
      return this;
    }

    /**
     * <code>optional uint32 Affinity = 2;</code>
     * @return whether the affinity field is set
     */
    public boolean hasAffinity() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional uint32 Affinity = 2;</code>
     * @return this
     */
    public NPCAffinityInfo clearAffinity() {
      bitField0_ &= ~0x00000002;
      affinity = 0;
      return this;
    }

    /**
     * <code>optional uint32 Affinity = 2;</code>
     * @return the affinity
     */
    public int getAffinity() {
      return affinity;
    }

    /**
     * <code>optional uint32 Affinity = 2;</code>
     * @param value the affinity to set
     * @return this
     */
    public NPCAffinityInfo setAffinity(final int value) {
      bitField0_ |= 0x00000002;
      affinity = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public NPCAffinityInfo clearNextPackage() {
      bitField0_ &= ~0x00000004;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000004;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public NPCAffinityInfo addNextPackage(final byte value) {
      bitField0_ |= 0x00000004;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public NPCAffinityInfo addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000004;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public NPCAffinityInfo setNextPackage(final byte... values) {
      bitField0_ |= 0x00000004;
      nextPackage.copyFrom(values);
      return this;
    }

    @Override
    public NPCAffinityInfo copyFrom(final NPCAffinityInfo other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        nPCId = other.nPCId;
        affinity = other.affinity;
        nextPackage.copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public NPCAffinityInfo mergeFrom(final NPCAffinityInfo other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasNPCId()) {
        setNPCId(other.nPCId);
      }
      if (other.hasAffinity()) {
        setAffinity(other.affinity);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public NPCAffinityInfo clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nPCId = 0;
      affinity = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public NPCAffinityInfo clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof NPCAffinityInfo)) {
        return false;
      }
      NPCAffinityInfo other = (NPCAffinityInfo) o;
      return bitField0_ == other.bitField0_
        && (!hasNPCId() || nPCId == other.nPCId)
        && (!hasAffinity() || affinity == other.affinity)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt32NoTag(nPCId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 16);
        output.writeUInt32NoTag(affinity);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(nPCId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(affinity);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public NPCAffinityInfo mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            // nPCId
            nPCId = input.readUInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 16) {
              break;
            }
          }
          case 16: {
            // affinity
            affinity = input.readUInt32();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeUInt32(FieldNames.nPCId, nPCId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeUInt32(FieldNames.affinity, affinity);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      output.endObject();
    }

    @Override
    public NPCAffinityInfo mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 74484668: {
            if (input.isAtField(FieldNames.nPCId)) {
              if (!input.trySkipNullValue()) {
                nPCId = input.readUInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 670141768: {
            if (input.isAtField(FieldNames.affinity)) {
              if (!input.trySkipNullValue()) {
                affinity = input.readUInt32();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public NPCAffinityInfo clone() {
      return new NPCAffinityInfo().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static NPCAffinityInfo parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new NPCAffinityInfo(), data).checkInitialized();
    }

    public static NPCAffinityInfo parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new NPCAffinityInfo(), input).checkInitialized();
    }

    public static NPCAffinityInfo parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new NPCAffinityInfo(), input).checkInitialized();
    }

    /**
     * @return factory for creating NPCAffinityInfo messages
     */
    public static MessageFactory<NPCAffinityInfo> getFactory() {
      return NPCAffinityInfoFactory.INSTANCE;
    }

    private enum NPCAffinityInfoFactory implements MessageFactory<NPCAffinityInfo> {
      INSTANCE;

      @Override
      public NPCAffinityInfo create() {
        return NPCAffinityInfo.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName nPCId = FieldName.forField("NPCId");

      static final FieldName affinity = FieldName.forField("Affinity");

      static final FieldName nextPackage = FieldName.forField("NextPackage");
    }
  }

  /**
   * Protobuf type {@code NPCAffinityChange}
   */
  public static final class NPCAffinityChange extends ProtoMessage<NPCAffinityChange> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional uint32 NPCId = 1;</code>
     */
    private int nPCId;

    /**
     * <code>optional uint32 Affinity = 2;</code>
     */
    private int affinity;

    /**
     * <code>optional uint32 Increase = 3;</code>
     */
    private int increase;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    private NPCAffinityChange() {
    }

    /**
     * @return a new empty instance of {@code NPCAffinityChange}
     */
    public static NPCAffinityChange newInstance() {
      return new NPCAffinityChange();
    }

    /**
     * <code>optional uint32 NPCId = 1;</code>
     * @return whether the nPCId field is set
     */
    public boolean hasNPCId() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional uint32 NPCId = 1;</code>
     * @return this
     */
    public NPCAffinityChange clearNPCId() {
      bitField0_ &= ~0x00000001;
      nPCId = 0;
      return this;
    }

    /**
     * <code>optional uint32 NPCId = 1;</code>
     * @return the nPCId
     */
    public int getNPCId() {
      return nPCId;
    }

    /**
     * <code>optional uint32 NPCId = 1;</code>
     * @param value the nPCId to set
     * @return this
     */
    public NPCAffinityChange setNPCId(final int value) {
      bitField0_ |= 0x00000001;
      nPCId = value;
      return this;
    }

    /**
     * <code>optional uint32 Affinity = 2;</code>
     * @return whether the affinity field is set
     */
    public boolean hasAffinity() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional uint32 Affinity = 2;</code>
     * @return this
     */
    public NPCAffinityChange clearAffinity() {
      bitField0_ &= ~0x00000002;
      affinity = 0;
      return this;
    }

    /**
     * <code>optional uint32 Affinity = 2;</code>
     * @return the affinity
     */
    public int getAffinity() {
      return affinity;
    }

    /**
     * <code>optional uint32 Affinity = 2;</code>
     * @param value the affinity to set
     * @return this
     */
    public NPCAffinityChange setAffinity(final int value) {
      bitField0_ |= 0x00000002;
      affinity = value;
      return this;
    }

    /**
     * <code>optional uint32 Increase = 3;</code>
     * @return whether the increase field is set
     */
    public boolean hasIncrease() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional uint32 Increase = 3;</code>
     * @return this
     */
    public NPCAffinityChange clearIncrease() {
      bitField0_ &= ~0x00000004;
      increase = 0;
      return this;
    }

    /**
     * <code>optional uint32 Increase = 3;</code>
     * @return the increase
     */
    public int getIncrease() {
      return increase;
    }

    /**
     * <code>optional uint32 Increase = 3;</code>
     * @param value the increase to set
     * @return this
     */
    public NPCAffinityChange setIncrease(final int value) {
      bitField0_ |= 0x00000004;
      increase = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000008) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public NPCAffinityChange clearNextPackage() {
      bitField0_ &= ~0x00000008;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000008;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public NPCAffinityChange addNextPackage(final byte value) {
      bitField0_ |= 0x00000008;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public NPCAffinityChange addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000008;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public NPCAffinityChange setNextPackage(final byte... values) {
      bitField0_ |= 0x00000008;
      nextPackage.copyFrom(values);
      return this;
    }

    @Override
    public NPCAffinityChange copyFrom(final NPCAffinityChange other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        nPCId = other.nPCId;
        affinity = other.affinity;
        increase = other.increase;
        nextPackage.copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public NPCAffinityChange mergeFrom(final NPCAffinityChange other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasNPCId()) {
        setNPCId(other.nPCId);
      }
      if (other.hasAffinity()) {
        setAffinity(other.affinity);
      }
      if (other.hasIncrease()) {
        setIncrease(other.increase);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public NPCAffinityChange clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nPCId = 0;
      affinity = 0;
      increase = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public NPCAffinityChange clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof NPCAffinityChange)) {
        return false;
      }
      NPCAffinityChange other = (NPCAffinityChange) o;
      return bitField0_ == other.bitField0_
        && (!hasNPCId() || nPCId == other.nPCId)
        && (!hasAffinity() || affinity == other.affinity)
        && (!hasIncrease() || increase == other.increase)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt32NoTag(nPCId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 16);
        output.writeUInt32NoTag(affinity);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawByte((byte) 24);
        output.writeUInt32NoTag(increase);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(nPCId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(affinity);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(increase);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public NPCAffinityChange mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            // nPCId
            nPCId = input.readUInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 16) {
              break;
            }
          }
          case 16: {
            // affinity
            affinity = input.readUInt32();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 24) {
              break;
            }
          }
          case 24: {
            // increase
            increase = input.readUInt32();
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000008;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeUInt32(FieldNames.nPCId, nPCId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeUInt32(FieldNames.affinity, affinity);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeUInt32(FieldNames.increase, increase);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      output.endObject();
    }

    @Override
    public NPCAffinityChange mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 74484668: {
            if (input.isAtField(FieldNames.nPCId)) {
              if (!input.trySkipNullValue()) {
                nPCId = input.readUInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 670141768: {
            if (input.isAtField(FieldNames.affinity)) {
              if (!input.trySkipNullValue()) {
                affinity = input.readUInt32();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 159965794: {
            if (input.isAtField(FieldNames.increase)) {
              if (!input.trySkipNullValue()) {
                increase = input.readUInt32();
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000008;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public NPCAffinityChange clone() {
      return new NPCAffinityChange().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static NPCAffinityChange parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new NPCAffinityChange(), data).checkInitialized();
    }

    public static NPCAffinityChange parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new NPCAffinityChange(), input).checkInitialized();
    }

    public static NPCAffinityChange parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new NPCAffinityChange(), input).checkInitialized();
    }

    /**
     * @return factory for creating NPCAffinityChange messages
     */
    public static MessageFactory<NPCAffinityChange> getFactory() {
      return NPCAffinityChangeFactory.INSTANCE;
    }

    private enum NPCAffinityChangeFactory implements MessageFactory<NPCAffinityChange> {
      INSTANCE;

      @Override
      public NPCAffinityChange create() {
        return NPCAffinityChange.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName nPCId = FieldName.forField("NPCId");

      static final FieldName affinity = FieldName.forField("Affinity");

      static final FieldName increase = FieldName.forField("Increase");

      static final FieldName nextPackage = FieldName.forField("NextPackage");
    }
  }

  /**
   * Protobuf type {@code NPCAffinityLevelReward}
   */
  public static final class NPCAffinityLevelReward extends ProtoMessage<NPCAffinityLevelReward> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional .NPCAffinityChange Change = 1;</code>
     */
    private final NPCAffinityChange change = NPCAffinityChange.newInstance();

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    /**
     * <code>repeated .ItemTpl Items = 2;</code>
     */
    private final RepeatedMessage<Public.ItemTpl> items = RepeatedMessage.newEmptyInstance(Public.ItemTpl.getFactory());

    private NPCAffinityLevelReward() {
    }

    /**
     * @return a new empty instance of {@code NPCAffinityLevelReward}
     */
    public static NPCAffinityLevelReward newInstance() {
      return new NPCAffinityLevelReward();
    }

    /**
     * <code>optional .NPCAffinityChange Change = 1;</code>
     * @return whether the change field is set
     */
    public boolean hasChange() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional .NPCAffinityChange Change = 1;</code>
     * @return this
     */
    public NPCAffinityLevelReward clearChange() {
      bitField0_ &= ~0x00000001;
      change.clear();
      return this;
    }

    /**
     * <code>optional .NPCAffinityChange Change = 1;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableChange()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public NPCAffinityChange getChange() {
      return change;
    }

    /**
     * <code>optional .NPCAffinityChange Change = 1;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public NPCAffinityChange getMutableChange() {
      bitField0_ |= 0x00000001;
      return change;
    }

    /**
     * <code>optional .NPCAffinityChange Change = 1;</code>
     * @param value the change to set
     * @return this
     */
    public NPCAffinityLevelReward setChange(final NPCAffinityChange value) {
      bitField0_ |= 0x00000001;
      change.copyFrom(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public NPCAffinityLevelReward clearNextPackage() {
      bitField0_ &= ~0x00000002;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000002;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public NPCAffinityLevelReward addNextPackage(final byte value) {
      bitField0_ |= 0x00000002;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public NPCAffinityLevelReward addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000002;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public NPCAffinityLevelReward setNextPackage(final byte... values) {
      bitField0_ |= 0x00000002;
      nextPackage.copyFrom(values);
      return this;
    }

    /**
     * <code>repeated .ItemTpl Items = 2;</code>
     * @return whether the items field is set
     */
    public boolean hasItems() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>repeated .ItemTpl Items = 2;</code>
     * @return this
     */
    public NPCAffinityLevelReward clearItems() {
      bitField0_ &= ~0x00000004;
      items.clear();
      return this;
    }

    /**
     * <code>repeated .ItemTpl Items = 2;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableItems()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<Public.ItemTpl> getItems() {
      return items;
    }

    /**
     * <code>repeated .ItemTpl Items = 2;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<Public.ItemTpl> getMutableItems() {
      bitField0_ |= 0x00000004;
      return items;
    }

    /**
     * <code>repeated .ItemTpl Items = 2;</code>
     * @param value the items to add
     * @return this
     */
    public NPCAffinityLevelReward addItems(final Public.ItemTpl value) {
      bitField0_ |= 0x00000004;
      items.add(value);
      return this;
    }

    /**
     * <code>repeated .ItemTpl Items = 2;</code>
     * @param values the items to add
     * @return this
     */
    public NPCAffinityLevelReward addAllItems(final Public.ItemTpl... values) {
      bitField0_ |= 0x00000004;
      items.addAll(values);
      return this;
    }

    @Override
    public NPCAffinityLevelReward copyFrom(final NPCAffinityLevelReward other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        change.copyFrom(other.change);
        nextPackage.copyFrom(other.nextPackage);
        items.copyFrom(other.items);
      }
      return this;
    }

    @Override
    public NPCAffinityLevelReward mergeFrom(final NPCAffinityLevelReward other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasChange()) {
        getMutableChange().mergeFrom(other.change);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      if (other.hasItems()) {
        getMutableItems().addAll(other.items);
      }
      return this;
    }

    @Override
    public NPCAffinityLevelReward clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      change.clear();
      nextPackage.clear();
      items.clear();
      return this;
    }

    @Override
    public NPCAffinityLevelReward clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      change.clearQuick();
      nextPackage.clear();
      items.clearQuick();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof NPCAffinityLevelReward)) {
        return false;
      }
      NPCAffinityLevelReward other = (NPCAffinityLevelReward) o;
      return bitField0_ == other.bitField0_
        && (!hasChange() || change.equals(other.change))
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage))
        && (!hasItems() || items.equals(other.items));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 10);
        output.writeMessageNoTag(change);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        for (int i = 0; i < items.length(); i++) {
          output.writeRawByte((byte) 18);
          output.writeMessageNoTag(items.get(i));
        }
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeMessageSizeNoTag(change);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += (1 * items.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(items);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public NPCAffinityLevelReward mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 10: {
            // change
            input.readMessage(change);
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 18) {
              break;
            }
          }
          case 18: {
            // items
            tag = input.readRepeatedMessage(items, tag);
            bitField0_ |= 0x00000004;
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeMessage(FieldNames.change, change);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRepeatedMessage(FieldNames.items, items);
      }
      output.endObject();
    }

    @Override
    public NPCAffinityLevelReward mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 2017198032: {
            if (input.isAtField(FieldNames.change)) {
              if (!input.trySkipNullValue()) {
                input.readMessage(change);
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 70973344: {
            if (input.isAtField(FieldNames.items)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedMessage(items);
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public NPCAffinityLevelReward clone() {
      return new NPCAffinityLevelReward().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static NPCAffinityLevelReward parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new NPCAffinityLevelReward(), data).checkInitialized();
    }

    public static NPCAffinityLevelReward parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new NPCAffinityLevelReward(), input).checkInitialized();
    }

    public static NPCAffinityLevelReward parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new NPCAffinityLevelReward(), input).checkInitialized();
    }

    /**
     * @return factory for creating NPCAffinityLevelReward messages
     */
    public static MessageFactory<NPCAffinityLevelReward> getFactory() {
      return NPCAffinityLevelRewardFactory.INSTANCE;
    }

    private enum NPCAffinityLevelRewardFactory implements MessageFactory<NPCAffinityLevelReward> {
      INSTANCE;

      @Override
      public NPCAffinityLevelReward create() {
        return NPCAffinityLevelReward.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName change = FieldName.forField("Change");

      static final FieldName nextPackage = FieldName.forField("NextPackage");

      static final FieldName items = FieldName.forField("Items");
    }
  }
}
