// Code generated by protocol buffer compiler. Do not edit!
package emu.nebula.proto;

import java.io.IOException;
import us.hebi.quickbuf.FieldName;
import us.hebi.quickbuf.InvalidProtocolBufferException;
import us.hebi.quickbuf.JsonSink;
import us.hebi.quickbuf.JsonSource;
import us.hebi.quickbuf.MessageFactory;
import us.hebi.quickbuf.ProtoEnum;
import us.hebi.quickbuf.ProtoMessage;
import us.hebi.quickbuf.ProtoSink;
import us.hebi.quickbuf.ProtoSource;
import us.hebi.quickbuf.ProtoUtil;
import us.hebi.quickbuf.RepeatedByte;
import us.hebi.quickbuf.RepeatedInt;
import us.hebi.quickbuf.RepeatedLong;
import us.hebi.quickbuf.RepeatedMessage;
import us.hebi.quickbuf.RepeatedString;
import us.hebi.quickbuf.Utf8String;

public final class Public {
  /**
   * Protobuf enum {@code QuestType}
   */
  public enum QuestType implements ProtoEnum<QuestType> {
    /**
     * <code>UnknownQuest = 0;</code>
     */
    UnknownQuest("UnknownQuest", 0),

    /**
     * <code>TourGuide = 1;</code>
     */
    TourGuide("TourGuide", 1),

    /**
     * <code>Daily = 2;</code>
     */
    Daily("Daily", 2),

    /**
     * <code>TravelerDuel = 3;</code>
     */
    TravelerDuel("TravelerDuel", 3),

    /**
     * <code>TravelerDuelChallenge = 4;</code>
     */
    TravelerDuelChallenge("TravelerDuelChallenge", 4),

    /**
     * <code>Affinity = 5;</code>
     */
    Affinity("Affinity", 5),

    /**
     * <code>BattlePassDaily = 6;</code>
     */
    BattlePassDaily("BattlePassDaily", 6),

    /**
     * <code>BattlePassWeekly = 7;</code>
     */
    BattlePassWeekly("BattlePassWeekly", 7),

    /**
     * <code>VampireSurvivorNormal = 8;</code>
     */
    VampireSurvivorNormal("VampireSurvivorNormal", 8),

    /**
     * <code>VampireSurvivorSeason = 9;</code>
     */
    VampireSurvivorSeason("VampireSurvivorSeason", 9),

    /**
     * <code>Tower = 10;</code>
     */
    Tower("Tower", 10),

    /**
     * <code>Demon = 11;</code>
     */
    Demon("Demon", 11),

    /**
     * <code>TowerEvent = 12;</code>
     */
    TowerEvent("TowerEvent", 12);

    /**
     * <code>UnknownQuest = 0;</code>
     */
    public static final int UnknownQuest_VALUE = 0;

    /**
     * <code>TourGuide = 1;</code>
     */
    public static final int TourGuide_VALUE = 1;

    /**
     * <code>Daily = 2;</code>
     */
    public static final int Daily_VALUE = 2;

    /**
     * <code>TravelerDuel = 3;</code>
     */
    public static final int TravelerDuel_VALUE = 3;

    /**
     * <code>TravelerDuelChallenge = 4;</code>
     */
    public static final int TravelerDuelChallenge_VALUE = 4;

    /**
     * <code>Affinity = 5;</code>
     */
    public static final int Affinity_VALUE = 5;

    /**
     * <code>BattlePassDaily = 6;</code>
     */
    public static final int BattlePassDaily_VALUE = 6;

    /**
     * <code>BattlePassWeekly = 7;</code>
     */
    public static final int BattlePassWeekly_VALUE = 7;

    /**
     * <code>VampireSurvivorNormal = 8;</code>
     */
    public static final int VampireSurvivorNormal_VALUE = 8;

    /**
     * <code>VampireSurvivorSeason = 9;</code>
     */
    public static final int VampireSurvivorSeason_VALUE = 9;

    /**
     * <code>Tower = 10;</code>
     */
    public static final int Tower_VALUE = 10;

    /**
     * <code>Demon = 11;</code>
     */
    public static final int Demon_VALUE = 11;

    /**
     * <code>TowerEvent = 12;</code>
     */
    public static final int TowerEvent_VALUE = 12;

    private final java.lang.String name;

    private final int number;

    private QuestType(java.lang.String name, int number) {
      this.name = name;
      this.number = number;
    }

    /**
     * @return the string representation of enum entry
     */
    @Override
    public java.lang.String getName() {
      return name;
    }

    /**
     * @return the numeric wire value of this enum entry
     */
    @Override
    public int getNumber() {
      return number;
    }

    /**
     * @return a converter that maps between this enum's numeric and text representations
     */
    public static ProtoEnum.EnumConverter<QuestType> converter() {
      return QuestTypeConverter.INSTANCE;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value, or null if unknown.
     */
    public static QuestType forNumber(int value) {
      return QuestTypeConverter.INSTANCE.forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @param other Fallback value in case the value is not known.
     * @return The enum associated with the given numeric wire value, or the fallback value if unknown.
     */
    public static QuestType forNumberOr(int number, QuestType other) {
      QuestType value = forNumber(number);
      return value == null ? other : value;
    }

    enum QuestTypeConverter implements ProtoEnum.EnumConverter<QuestType> {
      INSTANCE;

      private static final QuestType[] lookup = new QuestType[13];

      static {
        lookup[0] = UnknownQuest;
        lookup[1] = TourGuide;
        lookup[2] = Daily;
        lookup[3] = TravelerDuel;
        lookup[4] = TravelerDuelChallenge;
        lookup[5] = Affinity;
        lookup[6] = BattlePassDaily;
        lookup[7] = BattlePassWeekly;
        lookup[8] = VampireSurvivorNormal;
        lookup[9] = VampireSurvivorSeason;
        lookup[10] = Tower;
        lookup[11] = Demon;
        lookup[12] = TowerEvent;
      }

      @Override
      public final QuestType forNumber(final int value) {
        if (value >= 0 && value < lookup.length) {
          return lookup[value];
        }
        return null;
      }

      @Override
      public final QuestType forName(final CharSequence value) {
        switch (value.length()) {
          case 5: {
            if (ProtoUtil.isEqual("Daily", value)) {
              return Daily;
            }
            if (ProtoUtil.isEqual("Tower", value)) {
              return Tower;
            }
            if (ProtoUtil.isEqual("Demon", value)) {
              return Demon;
            }
            break;
          }
          case 8: {
            if (ProtoUtil.isEqual("Affinity", value)) {
              return Affinity;
            }
            break;
          }
          case 9: {
            if (ProtoUtil.isEqual("TourGuide", value)) {
              return TourGuide;
            }
            break;
          }
          case 10: {
            if (ProtoUtil.isEqual("TowerEvent", value)) {
              return TowerEvent;
            }
            break;
          }
          case 12: {
            if (ProtoUtil.isEqual("UnknownQuest", value)) {
              return UnknownQuest;
            }
            if (ProtoUtil.isEqual("TravelerDuel", value)) {
              return TravelerDuel;
            }
            break;
          }
          case 15: {
            if (ProtoUtil.isEqual("BattlePassDaily", value)) {
              return BattlePassDaily;
            }
            break;
          }
          case 16: {
            if (ProtoUtil.isEqual("BattlePassWeekly", value)) {
              return BattlePassWeekly;
            }
            break;
          }
          case 21: {
            if (ProtoUtil.isEqual("TravelerDuelChallenge", value)) {
              return TravelerDuelChallenge;
            }
            if (ProtoUtil.isEqual("VampireSurvivorNormal", value)) {
              return VampireSurvivorNormal;
            }
            if (ProtoUtil.isEqual("VampireSurvivorSeason", value)) {
              return VampireSurvivorSeason;
            }
            break;
          }
        }
        return null;
      }
    }
  }

  /**
   * Protobuf type {@code Nil}
   */
  public static final class Nil extends ProtoMessage<Nil> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    private Nil() {
    }

    /**
     * @return a new empty instance of {@code Nil}
     */
    public static Nil newInstance() {
      return new Nil();
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public Nil clearNextPackage() {
      bitField0_ &= ~0x00000001;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000001;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public Nil addNextPackage(final byte value) {
      bitField0_ |= 0x00000001;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public Nil addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000001;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public Nil setNextPackage(final byte... values) {
      bitField0_ |= 0x00000001;
      nextPackage.copyFrom(values);
      return this;
    }

    @Override
    public Nil copyFrom(final Nil other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        nextPackage.copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public Nil mergeFrom(final Nil other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public Nil clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public Nil clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof Nil)) {
        return false;
      }
      Nil other = (Nil) o;
      return bitField0_ == other.bitField0_
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public Nil mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      output.endObject();
    }

    @Override
    public Nil mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public Nil clone() {
      return new Nil().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static Nil parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new Nil(), data).checkInitialized();
    }

    public static Nil parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new Nil(), input).checkInitialized();
    }

    public static Nil parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new Nil(), input).checkInitialized();
    }

    /**
     * @return factory for creating Nil messages
     */
    public static MessageFactory<Nil> getFactory() {
      return NilFactory.INSTANCE;
    }

    private enum NilFactory implements MessageFactory<Nil> {
      INSTANCE;

      @Override
      public Nil create() {
        return Nil.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName nextPackage = FieldName.forField("NextPackage");
    }
  }

  /**
   * Protobuf type {@code I32}
   */
  public static final class I32 extends ProtoMessage<I32> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional int32 Value = 1;</code>
     */
    private int value_;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    private I32() {
    }

    /**
     * @return a new empty instance of {@code I32}
     */
    public static I32 newInstance() {
      return new I32();
    }

    /**
     * <code>optional int32 Value = 1;</code>
     * @return whether the value_ field is set
     */
    public boolean hasValue() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional int32 Value = 1;</code>
     * @return this
     */
    public I32 clearValue() {
      bitField0_ &= ~0x00000001;
      value_ = 0;
      return this;
    }

    /**
     * <code>optional int32 Value = 1;</code>
     * @return the value_
     */
    public int getValue() {
      return value_;
    }

    /**
     * <code>optional int32 Value = 1;</code>
     * @param value the value_ to set
     * @return this
     */
    public I32 setValue(final int value) {
      bitField0_ |= 0x00000001;
      value_ = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public I32 clearNextPackage() {
      bitField0_ &= ~0x00000002;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000002;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public I32 addNextPackage(final byte value) {
      bitField0_ |= 0x00000002;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public I32 addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000002;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public I32 setNextPackage(final byte... values) {
      bitField0_ |= 0x00000002;
      nextPackage.copyFrom(values);
      return this;
    }

    @Override
    public I32 copyFrom(final I32 other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        value_ = other.value_;
        nextPackage.copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public I32 mergeFrom(final I32 other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasValue()) {
        setValue(other.value_);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public I32 clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      value_ = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public I32 clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof I32)) {
        return false;
      }
      I32 other = (I32) o;
      return bitField0_ == other.bitField0_
        && (!hasValue() || value_ == other.value_)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 8);
        output.writeInt32NoTag(value_);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeInt32SizeNoTag(value_);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public I32 mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            // value_
            value_ = input.readInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeInt32(FieldNames.value_, value_);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      output.endObject();
    }

    @Override
    public I32 mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 82420049: {
            if (input.isAtField(FieldNames.value_)) {
              if (!input.trySkipNullValue()) {
                value_ = input.readInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public I32 clone() {
      return new I32().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static I32 parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new I32(), data).checkInitialized();
    }

    public static I32 parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new I32(), input).checkInitialized();
    }

    public static I32 parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new I32(), input).checkInitialized();
    }

    /**
     * @return factory for creating I32 messages
     */
    public static MessageFactory<I32> getFactory() {
      return I32Factory.INSTANCE;
    }

    private enum I32Factory implements MessageFactory<I32> {
      INSTANCE;

      @Override
      public I32 create() {
        return I32.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName value_ = FieldName.forField("Value");

      static final FieldName nextPackage = FieldName.forField("NextPackage");
    }
  }

  /**
   * Protobuf type {@code I64}
   */
  public static final class I64 extends ProtoMessage<I64> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional int64 Value = 1;</code>
     */
    private long value_;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    private I64() {
    }

    /**
     * @return a new empty instance of {@code I64}
     */
    public static I64 newInstance() {
      return new I64();
    }

    /**
     * <code>optional int64 Value = 1;</code>
     * @return whether the value_ field is set
     */
    public boolean hasValue() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional int64 Value = 1;</code>
     * @return this
     */
    public I64 clearValue() {
      bitField0_ &= ~0x00000001;
      value_ = 0L;
      return this;
    }

    /**
     * <code>optional int64 Value = 1;</code>
     * @return the value_
     */
    public long getValue() {
      return value_;
    }

    /**
     * <code>optional int64 Value = 1;</code>
     * @param value the value_ to set
     * @return this
     */
    public I64 setValue(final long value) {
      bitField0_ |= 0x00000001;
      value_ = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public I64 clearNextPackage() {
      bitField0_ &= ~0x00000002;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000002;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public I64 addNextPackage(final byte value) {
      bitField0_ |= 0x00000002;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public I64 addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000002;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public I64 setNextPackage(final byte... values) {
      bitField0_ |= 0x00000002;
      nextPackage.copyFrom(values);
      return this;
    }

    @Override
    public I64 copyFrom(final I64 other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        value_ = other.value_;
        nextPackage.copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public I64 mergeFrom(final I64 other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasValue()) {
        setValue(other.value_);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public I64 clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      value_ = 0L;
      nextPackage.clear();
      return this;
    }

    @Override
    public I64 clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof I64)) {
        return false;
      }
      I64 other = (I64) o;
      return bitField0_ == other.bitField0_
        && (!hasValue() || value_ == other.value_)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 8);
        output.writeInt64NoTag(value_);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeInt64SizeNoTag(value_);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public I64 mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            // value_
            value_ = input.readInt64();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeInt64(FieldNames.value_, value_);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      output.endObject();
    }

    @Override
    public I64 mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 82420049: {
            if (input.isAtField(FieldNames.value_)) {
              if (!input.trySkipNullValue()) {
                value_ = input.readInt64();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public I64 clone() {
      return new I64().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static I64 parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new I64(), data).checkInitialized();
    }

    public static I64 parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new I64(), input).checkInitialized();
    }

    public static I64 parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new I64(), input).checkInitialized();
    }

    /**
     * @return factory for creating I64 messages
     */
    public static MessageFactory<I64> getFactory() {
      return I64Factory.INSTANCE;
    }

    private enum I64Factory implements MessageFactory<I64> {
      INSTANCE;

      @Override
      public I64 create() {
        return I64.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName value_ = FieldName.forField("Value");

      static final FieldName nextPackage = FieldName.forField("NextPackage");
    }
  }

  /**
   * Protobuf type {@code UI32}
   */
  public static final class UI32 extends ProtoMessage<UI32> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional uint32 Value = 1;</code>
     */
    private int value_;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    private UI32() {
    }

    /**
     * @return a new empty instance of {@code UI32}
     */
    public static UI32 newInstance() {
      return new UI32();
    }

    /**
     * <code>optional uint32 Value = 1;</code>
     * @return whether the value_ field is set
     */
    public boolean hasValue() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional uint32 Value = 1;</code>
     * @return this
     */
    public UI32 clearValue() {
      bitField0_ &= ~0x00000001;
      value_ = 0;
      return this;
    }

    /**
     * <code>optional uint32 Value = 1;</code>
     * @return the value_
     */
    public int getValue() {
      return value_;
    }

    /**
     * <code>optional uint32 Value = 1;</code>
     * @param value the value_ to set
     * @return this
     */
    public UI32 setValue(final int value) {
      bitField0_ |= 0x00000001;
      value_ = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public UI32 clearNextPackage() {
      bitField0_ &= ~0x00000002;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000002;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public UI32 addNextPackage(final byte value) {
      bitField0_ |= 0x00000002;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public UI32 addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000002;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public UI32 setNextPackage(final byte... values) {
      bitField0_ |= 0x00000002;
      nextPackage.copyFrom(values);
      return this;
    }

    @Override
    public UI32 copyFrom(final UI32 other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        value_ = other.value_;
        nextPackage.copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public UI32 mergeFrom(final UI32 other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasValue()) {
        setValue(other.value_);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public UI32 clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      value_ = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public UI32 clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof UI32)) {
        return false;
      }
      UI32 other = (UI32) o;
      return bitField0_ == other.bitField0_
        && (!hasValue() || value_ == other.value_)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt32NoTag(value_);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(value_);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public UI32 mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            // value_
            value_ = input.readUInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeUInt32(FieldNames.value_, value_);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      output.endObject();
    }

    @Override
    public UI32 mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 82420049: {
            if (input.isAtField(FieldNames.value_)) {
              if (!input.trySkipNullValue()) {
                value_ = input.readUInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public UI32 clone() {
      return new UI32().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static UI32 parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new UI32(), data).checkInitialized();
    }

    public static UI32 parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new UI32(), input).checkInitialized();
    }

    public static UI32 parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new UI32(), input).checkInitialized();
    }

    /**
     * @return factory for creating UI32 messages
     */
    public static MessageFactory<UI32> getFactory() {
      return UI32Factory.INSTANCE;
    }

    private enum UI32Factory implements MessageFactory<UI32> {
      INSTANCE;

      @Override
      public UI32 create() {
        return UI32.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName value_ = FieldName.forField("Value");

      static final FieldName nextPackage = FieldName.forField("NextPackage");
    }
  }

  /**
   * Protobuf type {@code UI64}
   */
  public static final class UI64 extends ProtoMessage<UI64> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional uint64 Value = 1;</code>
     */
    private long value_;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    private UI64() {
    }

    /**
     * @return a new empty instance of {@code UI64}
     */
    public static UI64 newInstance() {
      return new UI64();
    }

    /**
     * <code>optional uint64 Value = 1;</code>
     * @return whether the value_ field is set
     */
    public boolean hasValue() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional uint64 Value = 1;</code>
     * @return this
     */
    public UI64 clearValue() {
      bitField0_ &= ~0x00000001;
      value_ = 0L;
      return this;
    }

    /**
     * <code>optional uint64 Value = 1;</code>
     * @return the value_
     */
    public long getValue() {
      return value_;
    }

    /**
     * <code>optional uint64 Value = 1;</code>
     * @param value the value_ to set
     * @return this
     */
    public UI64 setValue(final long value) {
      bitField0_ |= 0x00000001;
      value_ = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public UI64 clearNextPackage() {
      bitField0_ &= ~0x00000002;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000002;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public UI64 addNextPackage(final byte value) {
      bitField0_ |= 0x00000002;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public UI64 addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000002;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public UI64 setNextPackage(final byte... values) {
      bitField0_ |= 0x00000002;
      nextPackage.copyFrom(values);
      return this;
    }

    @Override
    public UI64 copyFrom(final UI64 other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        value_ = other.value_;
        nextPackage.copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public UI64 mergeFrom(final UI64 other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasValue()) {
        setValue(other.value_);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public UI64 clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      value_ = 0L;
      nextPackage.clear();
      return this;
    }

    @Override
    public UI64 clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof UI64)) {
        return false;
      }
      UI64 other = (UI64) o;
      return bitField0_ == other.bitField0_
        && (!hasValue() || value_ == other.value_)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt64NoTag(value_);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeUInt64SizeNoTag(value_);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public UI64 mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            // value_
            value_ = input.readUInt64();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeUInt64(FieldNames.value_, value_);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      output.endObject();
    }

    @Override
    public UI64 mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 82420049: {
            if (input.isAtField(FieldNames.value_)) {
              if (!input.trySkipNullValue()) {
                value_ = input.readUInt64();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public UI64 clone() {
      return new UI64().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static UI64 parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new UI64(), data).checkInitialized();
    }

    public static UI64 parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new UI64(), input).checkInitialized();
    }

    public static UI64 parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new UI64(), input).checkInitialized();
    }

    /**
     * @return factory for creating UI64 messages
     */
    public static MessageFactory<UI64> getFactory() {
      return UI64Factory.INSTANCE;
    }

    private enum UI64Factory implements MessageFactory<UI64> {
      INSTANCE;

      @Override
      public UI64 create() {
        return UI64.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName value_ = FieldName.forField("Value");

      static final FieldName nextPackage = FieldName.forField("NextPackage");
    }
  }

  /**
   * Protobuf type {@code String}
   */
  public static final class String extends ProtoMessage<String> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    /**
     * <code>optional string Value = 1;</code>
     */
    private final Utf8String value_ = Utf8String.newEmptyInstance();

    private String() {
    }

    /**
     * @return a new empty instance of {@code String}
     */
    public static String newInstance() {
      return new String();
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public String clearNextPackage() {
      bitField0_ &= ~0x00000001;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000001;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public String addNextPackage(final byte value) {
      bitField0_ |= 0x00000001;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public String addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000001;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public String setNextPackage(final byte... values) {
      bitField0_ |= 0x00000001;
      nextPackage.copyFrom(values);
      return this;
    }

    /**
     * <code>optional string Value = 1;</code>
     * @return whether the value_ field is set
     */
    public boolean hasValue() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional string Value = 1;</code>
     * @return this
     */
    public String clearValue() {
      bitField0_ &= ~0x00000002;
      value_.clear();
      return this;
    }

    /**
     * <code>optional string Value = 1;</code>
     * @return the value_
     */
    public java.lang.String getValue() {
      return value_.getString();
    }

    /**
     * <code>optional string Value = 1;</code>
     * @return internal {@code Utf8String} representation of value_ for reading
     */
    public Utf8String getValueBytes() {
      return this.value_;
    }

    /**
     * <code>optional string Value = 1;</code>
     * @return internal {@code Utf8String} representation of value_ for modifications
     */
    public Utf8String getMutableValueBytes() {
      bitField0_ |= 0x00000002;
      return this.value_;
    }

    /**
     * <code>optional string Value = 1;</code>
     * @param value the value_ to set
     * @return this
     */
    public String setValue(final CharSequence value) {
      bitField0_ |= 0x00000002;
      value_.copyFrom(value);
      return this;
    }

    /**
     * <code>optional string Value = 1;</code>
     * @param value the value_ to set
     * @return this
     */
    public String setValue(final Utf8String value) {
      bitField0_ |= 0x00000002;
      value_.copyFrom(value);
      return this;
    }

    @Override
    public String copyFrom(final String other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        nextPackage.copyFrom(other.nextPackage);
        value_.copyFrom(other.value_);
      }
      return this;
    }

    @Override
    public String mergeFrom(final String other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      if (other.hasValue()) {
        getMutableValueBytes().copyFrom(other.value_);
      }
      return this;
    }

    @Override
    public String clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      value_.clear();
      return this;
    }

    @Override
    public String clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      value_.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof String)) {
        return false;
      }
      String other = (String) o;
      return bitField0_ == other.bitField0_
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage))
        && (!hasValue() || value_.equals(other.value_));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 10);
        output.writeStringNoTag(value_);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeStringSizeNoTag(value_);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public String mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 10) {
              break;
            }
          }
          case 10: {
            // value_
            input.readString(value_);
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeString(FieldNames.value_, value_);
      }
      output.endObject();
    }

    @Override
    public String mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 82420049: {
            if (input.isAtField(FieldNames.value_)) {
              if (!input.trySkipNullValue()) {
                input.readString(value_);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public String clone() {
      return new String().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static String parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new String(), data).checkInitialized();
    }

    public static String parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new String(), input).checkInitialized();
    }

    public static String parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new String(), input).checkInitialized();
    }

    /**
     * @return factory for creating String messages
     */
    public static MessageFactory<String> getFactory() {
      return StringFactory.INSTANCE;
    }

    private enum StringFactory implements MessageFactory<String> {
      INSTANCE;

      @Override
      public String create() {
        return String.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName nextPackage = FieldName.forField("NextPackage");

      static final FieldName value_ = FieldName.forField("Value");
    }
  }

  /**
   * Protobuf type {@code I32V}
   */
  public static final class I32V extends ProtoMessage<I32V> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional int32 Value = 1;</code>
     */
    private int value_;

    /**
     * <code>optional uint32 Version = 2;</code>
     */
    private int version;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    private I32V() {
    }

    /**
     * @return a new empty instance of {@code I32V}
     */
    public static I32V newInstance() {
      return new I32V();
    }

    /**
     * <code>optional int32 Value = 1;</code>
     * @return whether the value_ field is set
     */
    public boolean hasValue() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional int32 Value = 1;</code>
     * @return this
     */
    public I32V clearValue() {
      bitField0_ &= ~0x00000001;
      value_ = 0;
      return this;
    }

    /**
     * <code>optional int32 Value = 1;</code>
     * @return the value_
     */
    public int getValue() {
      return value_;
    }

    /**
     * <code>optional int32 Value = 1;</code>
     * @param value the value_ to set
     * @return this
     */
    public I32V setValue(final int value) {
      bitField0_ |= 0x00000001;
      value_ = value;
      return this;
    }

    /**
     * <code>optional uint32 Version = 2;</code>
     * @return whether the version field is set
     */
    public boolean hasVersion() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional uint32 Version = 2;</code>
     * @return this
     */
    public I32V clearVersion() {
      bitField0_ &= ~0x00000002;
      version = 0;
      return this;
    }

    /**
     * <code>optional uint32 Version = 2;</code>
     * @return the version
     */
    public int getVersion() {
      return version;
    }

    /**
     * <code>optional uint32 Version = 2;</code>
     * @param value the version to set
     * @return this
     */
    public I32V setVersion(final int value) {
      bitField0_ |= 0x00000002;
      version = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public I32V clearNextPackage() {
      bitField0_ &= ~0x00000004;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000004;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public I32V addNextPackage(final byte value) {
      bitField0_ |= 0x00000004;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public I32V addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000004;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public I32V setNextPackage(final byte... values) {
      bitField0_ |= 0x00000004;
      nextPackage.copyFrom(values);
      return this;
    }

    @Override
    public I32V copyFrom(final I32V other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        value_ = other.value_;
        version = other.version;
        nextPackage.copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public I32V mergeFrom(final I32V other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasValue()) {
        setValue(other.value_);
      }
      if (other.hasVersion()) {
        setVersion(other.version);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public I32V clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      value_ = 0;
      version = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public I32V clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof I32V)) {
        return false;
      }
      I32V other = (I32V) o;
      return bitField0_ == other.bitField0_
        && (!hasValue() || value_ == other.value_)
        && (!hasVersion() || version == other.version)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 8);
        output.writeInt32NoTag(value_);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 16);
        output.writeUInt32NoTag(version);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeInt32SizeNoTag(value_);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(version);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public I32V mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            // value_
            value_ = input.readInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 16) {
              break;
            }
          }
          case 16: {
            // version
            version = input.readUInt32();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeInt32(FieldNames.value_, value_);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeUInt32(FieldNames.version, version);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      output.endObject();
    }

    @Override
    public I32V mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 82420049: {
            if (input.isAtField(FieldNames.value_)) {
              if (!input.trySkipNullValue()) {
                value_ = input.readInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 2016261304: {
            if (input.isAtField(FieldNames.version)) {
              if (!input.trySkipNullValue()) {
                version = input.readUInt32();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public I32V clone() {
      return new I32V().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static I32V parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new I32V(), data).checkInitialized();
    }

    public static I32V parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new I32V(), input).checkInitialized();
    }

    public static I32V parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new I32V(), input).checkInitialized();
    }

    /**
     * @return factory for creating I32V messages
     */
    public static MessageFactory<I32V> getFactory() {
      return I32VFactory.INSTANCE;
    }

    private enum I32VFactory implements MessageFactory<I32V> {
      INSTANCE;

      @Override
      public I32V create() {
        return I32V.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName value_ = FieldName.forField("Value");

      static final FieldName version = FieldName.forField("Version");

      static final FieldName nextPackage = FieldName.forField("NextPackage");
    }
  }

  /**
   * Protobuf type {@code UI32V}
   */
  public static final class UI32V extends ProtoMessage<UI32V> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional uint32 Value = 1;</code>
     */
    private int value_;

    /**
     * <code>optional uint32 Version = 2;</code>
     */
    private int version;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    private UI32V() {
    }

    /**
     * @return a new empty instance of {@code UI32V}
     */
    public static UI32V newInstance() {
      return new UI32V();
    }

    /**
     * <code>optional uint32 Value = 1;</code>
     * @return whether the value_ field is set
     */
    public boolean hasValue() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional uint32 Value = 1;</code>
     * @return this
     */
    public UI32V clearValue() {
      bitField0_ &= ~0x00000001;
      value_ = 0;
      return this;
    }

    /**
     * <code>optional uint32 Value = 1;</code>
     * @return the value_
     */
    public int getValue() {
      return value_;
    }

    /**
     * <code>optional uint32 Value = 1;</code>
     * @param value the value_ to set
     * @return this
     */
    public UI32V setValue(final int value) {
      bitField0_ |= 0x00000001;
      value_ = value;
      return this;
    }

    /**
     * <code>optional uint32 Version = 2;</code>
     * @return whether the version field is set
     */
    public boolean hasVersion() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional uint32 Version = 2;</code>
     * @return this
     */
    public UI32V clearVersion() {
      bitField0_ &= ~0x00000002;
      version = 0;
      return this;
    }

    /**
     * <code>optional uint32 Version = 2;</code>
     * @return the version
     */
    public int getVersion() {
      return version;
    }

    /**
     * <code>optional uint32 Version = 2;</code>
     * @param value the version to set
     * @return this
     */
    public UI32V setVersion(final int value) {
      bitField0_ |= 0x00000002;
      version = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public UI32V clearNextPackage() {
      bitField0_ &= ~0x00000004;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000004;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public UI32V addNextPackage(final byte value) {
      bitField0_ |= 0x00000004;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public UI32V addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000004;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public UI32V setNextPackage(final byte... values) {
      bitField0_ |= 0x00000004;
      nextPackage.copyFrom(values);
      return this;
    }

    @Override
    public UI32V copyFrom(final UI32V other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        value_ = other.value_;
        version = other.version;
        nextPackage.copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public UI32V mergeFrom(final UI32V other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasValue()) {
        setValue(other.value_);
      }
      if (other.hasVersion()) {
        setVersion(other.version);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public UI32V clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      value_ = 0;
      version = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public UI32V clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof UI32V)) {
        return false;
      }
      UI32V other = (UI32V) o;
      return bitField0_ == other.bitField0_
        && (!hasValue() || value_ == other.value_)
        && (!hasVersion() || version == other.version)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt32NoTag(value_);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 16);
        output.writeUInt32NoTag(version);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(value_);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(version);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public UI32V mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            // value_
            value_ = input.readUInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 16) {
              break;
            }
          }
          case 16: {
            // version
            version = input.readUInt32();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeUInt32(FieldNames.value_, value_);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeUInt32(FieldNames.version, version);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      output.endObject();
    }

    @Override
    public UI32V mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 82420049: {
            if (input.isAtField(FieldNames.value_)) {
              if (!input.trySkipNullValue()) {
                value_ = input.readUInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 2016261304: {
            if (input.isAtField(FieldNames.version)) {
              if (!input.trySkipNullValue()) {
                version = input.readUInt32();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public UI32V clone() {
      return new UI32V().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static UI32V parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new UI32V(), data).checkInitialized();
    }

    public static UI32V parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new UI32V(), input).checkInitialized();
    }

    public static UI32V parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new UI32V(), input).checkInitialized();
    }

    /**
     * @return factory for creating UI32V messages
     */
    public static MessageFactory<UI32V> getFactory() {
      return UI32VFactory.INSTANCE;
    }

    private enum UI32VFactory implements MessageFactory<UI32V> {
      INSTANCE;

      @Override
      public UI32V create() {
        return UI32V.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName value_ = FieldName.forField("Value");

      static final FieldName version = FieldName.forField("Version");

      static final FieldName nextPackage = FieldName.forField("NextPackage");
    }
  }

  /**
   * Protobuf type {@code UI64V}
   */
  public static final class UI64V extends ProtoMessage<UI64V> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional uint64 Value = 1;</code>
     */
    private long value_;

    /**
     * <code>optional uint32 Version = 2;</code>
     */
    private int version;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    private UI64V() {
    }

    /**
     * @return a new empty instance of {@code UI64V}
     */
    public static UI64V newInstance() {
      return new UI64V();
    }

    /**
     * <code>optional uint64 Value = 1;</code>
     * @return whether the value_ field is set
     */
    public boolean hasValue() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional uint64 Value = 1;</code>
     * @return this
     */
    public UI64V clearValue() {
      bitField0_ &= ~0x00000001;
      value_ = 0L;
      return this;
    }

    /**
     * <code>optional uint64 Value = 1;</code>
     * @return the value_
     */
    public long getValue() {
      return value_;
    }

    /**
     * <code>optional uint64 Value = 1;</code>
     * @param value the value_ to set
     * @return this
     */
    public UI64V setValue(final long value) {
      bitField0_ |= 0x00000001;
      value_ = value;
      return this;
    }

    /**
     * <code>optional uint32 Version = 2;</code>
     * @return whether the version field is set
     */
    public boolean hasVersion() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional uint32 Version = 2;</code>
     * @return this
     */
    public UI64V clearVersion() {
      bitField0_ &= ~0x00000002;
      version = 0;
      return this;
    }

    /**
     * <code>optional uint32 Version = 2;</code>
     * @return the version
     */
    public int getVersion() {
      return version;
    }

    /**
     * <code>optional uint32 Version = 2;</code>
     * @param value the version to set
     * @return this
     */
    public UI64V setVersion(final int value) {
      bitField0_ |= 0x00000002;
      version = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public UI64V clearNextPackage() {
      bitField0_ &= ~0x00000004;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000004;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public UI64V addNextPackage(final byte value) {
      bitField0_ |= 0x00000004;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public UI64V addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000004;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public UI64V setNextPackage(final byte... values) {
      bitField0_ |= 0x00000004;
      nextPackage.copyFrom(values);
      return this;
    }

    @Override
    public UI64V copyFrom(final UI64V other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        value_ = other.value_;
        version = other.version;
        nextPackage.copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public UI64V mergeFrom(final UI64V other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasValue()) {
        setValue(other.value_);
      }
      if (other.hasVersion()) {
        setVersion(other.version);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public UI64V clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      value_ = 0L;
      version = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public UI64V clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof UI64V)) {
        return false;
      }
      UI64V other = (UI64V) o;
      return bitField0_ == other.bitField0_
        && (!hasValue() || value_ == other.value_)
        && (!hasVersion() || version == other.version)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt64NoTag(value_);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 16);
        output.writeUInt32NoTag(version);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeUInt64SizeNoTag(value_);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(version);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public UI64V mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            // value_
            value_ = input.readUInt64();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 16) {
              break;
            }
          }
          case 16: {
            // version
            version = input.readUInt32();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeUInt64(FieldNames.value_, value_);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeUInt32(FieldNames.version, version);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      output.endObject();
    }

    @Override
    public UI64V mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 82420049: {
            if (input.isAtField(FieldNames.value_)) {
              if (!input.trySkipNullValue()) {
                value_ = input.readUInt64();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 2016261304: {
            if (input.isAtField(FieldNames.version)) {
              if (!input.trySkipNullValue()) {
                version = input.readUInt32();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public UI64V clone() {
      return new UI64V().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static UI64V parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new UI64V(), data).checkInitialized();
    }

    public static UI64V parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new UI64V(), input).checkInitialized();
    }

    public static UI64V parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new UI64V(), input).checkInitialized();
    }

    /**
     * @return factory for creating UI64V messages
     */
    public static MessageFactory<UI64V> getFactory() {
      return UI64VFactory.INSTANCE;
    }

    private enum UI64VFactory implements MessageFactory<UI64V> {
      INSTANCE;

      @Override
      public UI64V create() {
        return UI64V.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName value_ = FieldName.forField("Value");

      static final FieldName version = FieldName.forField("Version");

      static final FieldName nextPackage = FieldName.forField("NextPackage");
    }
  }

  /**
   * Protobuf type {@code StringV}
   */
  public static final class StringV extends ProtoMessage<StringV> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional uint32 Version = 2;</code>
     */
    private int version;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    /**
     * <code>optional string Value = 1;</code>
     */
    private final Utf8String value_ = Utf8String.newEmptyInstance();

    private StringV() {
    }

    /**
     * @return a new empty instance of {@code StringV}
     */
    public static StringV newInstance() {
      return new StringV();
    }

    /**
     * <code>optional uint32 Version = 2;</code>
     * @return whether the version field is set
     */
    public boolean hasVersion() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional uint32 Version = 2;</code>
     * @return this
     */
    public StringV clearVersion() {
      bitField0_ &= ~0x00000001;
      version = 0;
      return this;
    }

    /**
     * <code>optional uint32 Version = 2;</code>
     * @return the version
     */
    public int getVersion() {
      return version;
    }

    /**
     * <code>optional uint32 Version = 2;</code>
     * @param value the version to set
     * @return this
     */
    public StringV setVersion(final int value) {
      bitField0_ |= 0x00000001;
      version = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public StringV clearNextPackage() {
      bitField0_ &= ~0x00000002;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000002;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public StringV addNextPackage(final byte value) {
      bitField0_ |= 0x00000002;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public StringV addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000002;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public StringV setNextPackage(final byte... values) {
      bitField0_ |= 0x00000002;
      nextPackage.copyFrom(values);
      return this;
    }

    /**
     * <code>optional string Value = 1;</code>
     * @return whether the value_ field is set
     */
    public boolean hasValue() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional string Value = 1;</code>
     * @return this
     */
    public StringV clearValue() {
      bitField0_ &= ~0x00000004;
      value_.clear();
      return this;
    }

    /**
     * <code>optional string Value = 1;</code>
     * @return the value_
     */
    public java.lang.String getValue() {
      return value_.getString();
    }

    /**
     * <code>optional string Value = 1;</code>
     * @return internal {@code Utf8String} representation of value_ for reading
     */
    public Utf8String getValueBytes() {
      return this.value_;
    }

    /**
     * <code>optional string Value = 1;</code>
     * @return internal {@code Utf8String} representation of value_ for modifications
     */
    public Utf8String getMutableValueBytes() {
      bitField0_ |= 0x00000004;
      return this.value_;
    }

    /**
     * <code>optional string Value = 1;</code>
     * @param value the value_ to set
     * @return this
     */
    public StringV setValue(final CharSequence value) {
      bitField0_ |= 0x00000004;
      value_.copyFrom(value);
      return this;
    }

    /**
     * <code>optional string Value = 1;</code>
     * @param value the value_ to set
     * @return this
     */
    public StringV setValue(final Utf8String value) {
      bitField0_ |= 0x00000004;
      value_.copyFrom(value);
      return this;
    }

    @Override
    public StringV copyFrom(final StringV other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        version = other.version;
        nextPackage.copyFrom(other.nextPackage);
        value_.copyFrom(other.value_);
      }
      return this;
    }

    @Override
    public StringV mergeFrom(final StringV other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasVersion()) {
        setVersion(other.version);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      if (other.hasValue()) {
        getMutableValueBytes().copyFrom(other.value_);
      }
      return this;
    }

    @Override
    public StringV clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      version = 0;
      nextPackage.clear();
      value_.clear();
      return this;
    }

    @Override
    public StringV clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      value_.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof StringV)) {
        return false;
      }
      StringV other = (StringV) o;
      return bitField0_ == other.bitField0_
        && (!hasVersion() || version == other.version)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage))
        && (!hasValue() || value_.equals(other.value_));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 16);
        output.writeUInt32NoTag(version);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawByte((byte) 10);
        output.writeStringNoTag(value_);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(version);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 1 + ProtoSink.computeStringSizeNoTag(value_);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public StringV mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 16: {
            // version
            version = input.readUInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 10) {
              break;
            }
          }
          case 10: {
            // value_
            input.readString(value_);
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeUInt32(FieldNames.version, version);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeString(FieldNames.value_, value_);
      }
      output.endObject();
    }

    @Override
    public StringV mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 2016261304: {
            if (input.isAtField(FieldNames.version)) {
              if (!input.trySkipNullValue()) {
                version = input.readUInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 82420049: {
            if (input.isAtField(FieldNames.value_)) {
              if (!input.trySkipNullValue()) {
                input.readString(value_);
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public StringV clone() {
      return new StringV().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static StringV parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new StringV(), data).checkInitialized();
    }

    public static StringV parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new StringV(), input).checkInitialized();
    }

    public static StringV parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new StringV(), input).checkInitialized();
    }

    /**
     * @return factory for creating StringV messages
     */
    public static MessageFactory<StringV> getFactory() {
      return StringVFactory.INSTANCE;
    }

    private enum StringVFactory implements MessageFactory<StringV> {
      INSTANCE;

      @Override
      public StringV create() {
        return StringV.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName version = FieldName.forField("Version");

      static final FieldName nextPackage = FieldName.forField("NextPackage");

      static final FieldName value_ = FieldName.forField("Value");
    }
  }

  /**
   * Protobuf type {@code Bytes}
   */
  public static final class Bytes extends ProtoMessage<Bytes> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional bytes Value = 1;</code>
     */
    private final RepeatedByte value_ = RepeatedByte.newEmptyInstance();

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    private Bytes() {
    }

    /**
     * @return a new empty instance of {@code Bytes}
     */
    public static Bytes newInstance() {
      return new Bytes();
    }

    /**
     * <code>optional bytes Value = 1;</code>
     * @return whether the value_ field is set
     */
    public boolean hasValue() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional bytes Value = 1;</code>
     * @return this
     */
    public Bytes clearValue() {
      bitField0_ &= ~0x00000001;
      value_.clear();
      return this;
    }

    /**
     * <code>optional bytes Value = 1;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableValue()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getValue() {
      return value_;
    }

    /**
     * <code>optional bytes Value = 1;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableValue() {
      bitField0_ |= 0x00000001;
      return value_;
    }

    /**
     * <code>optional bytes Value = 1;</code>
     * @param value the value_ to add
     * @return this
     */
    public Bytes addValue(final byte value) {
      bitField0_ |= 0x00000001;
      value_.add(value);
      return this;
    }

    /**
     * <code>optional bytes Value = 1;</code>
     * @param values the value_ to add
     * @return this
     */
    public Bytes addAllValue(final byte... values) {
      bitField0_ |= 0x00000001;
      value_.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes Value = 1;</code>
     * @param values the value_ to set
     * @return this
     */
    public Bytes setValue(final byte... values) {
      bitField0_ |= 0x00000001;
      value_.copyFrom(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public Bytes clearNextPackage() {
      bitField0_ &= ~0x00000002;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000002;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public Bytes addNextPackage(final byte value) {
      bitField0_ |= 0x00000002;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public Bytes addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000002;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public Bytes setNextPackage(final byte... values) {
      bitField0_ |= 0x00000002;
      nextPackage.copyFrom(values);
      return this;
    }

    @Override
    public Bytes copyFrom(final Bytes other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        value_.copyFrom(other.value_);
        nextPackage.copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public Bytes mergeFrom(final Bytes other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasValue()) {
        getMutableValue().copyFrom(other.value_);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public Bytes clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      value_.clear();
      nextPackage.clear();
      return this;
    }

    @Override
    public Bytes clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      value_.clear();
      nextPackage.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof Bytes)) {
        return false;
      }
      Bytes other = (Bytes) o;
      return bitField0_ == other.bitField0_
        && (!hasValue() || value_.equals(other.value_))
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 10);
        output.writeBytesNoTag(value_);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeBytesSizeNoTag(value_);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public Bytes mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 10: {
            // value_
            input.readBytes(value_);
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeBytes(FieldNames.value_, value_);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      output.endObject();
    }

    @Override
    public Bytes mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 82420049: {
            if (input.isAtField(FieldNames.value_)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(value_);
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public Bytes clone() {
      return new Bytes().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static Bytes parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new Bytes(), data).checkInitialized();
    }

    public static Bytes parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new Bytes(), input).checkInitialized();
    }

    public static Bytes parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new Bytes(), input).checkInitialized();
    }

    /**
     * @return factory for creating Bytes messages
     */
    public static MessageFactory<Bytes> getFactory() {
      return BytesFactory.INSTANCE;
    }

    private enum BytesFactory implements MessageFactory<Bytes> {
      INSTANCE;

      @Override
      public Bytes create() {
        return Bytes.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName value_ = FieldName.forField("Value");

      static final FieldName nextPackage = FieldName.forField("NextPackage");
    }
  }

  /**
   * Protobuf type {@code BytesV}
   */
  public static final class BytesV extends ProtoMessage<BytesV> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional uint32 Version = 2;</code>
     */
    private int version;

    /**
     * <code>optional bytes Value = 1;</code>
     */
    private final RepeatedByte value_ = RepeatedByte.newEmptyInstance();

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    private BytesV() {
    }

    /**
     * @return a new empty instance of {@code BytesV}
     */
    public static BytesV newInstance() {
      return new BytesV();
    }

    /**
     * <code>optional uint32 Version = 2;</code>
     * @return whether the version field is set
     */
    public boolean hasVersion() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional uint32 Version = 2;</code>
     * @return this
     */
    public BytesV clearVersion() {
      bitField0_ &= ~0x00000001;
      version = 0;
      return this;
    }

    /**
     * <code>optional uint32 Version = 2;</code>
     * @return the version
     */
    public int getVersion() {
      return version;
    }

    /**
     * <code>optional uint32 Version = 2;</code>
     * @param value the version to set
     * @return this
     */
    public BytesV setVersion(final int value) {
      bitField0_ |= 0x00000001;
      version = value;
      return this;
    }

    /**
     * <code>optional bytes Value = 1;</code>
     * @return whether the value_ field is set
     */
    public boolean hasValue() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional bytes Value = 1;</code>
     * @return this
     */
    public BytesV clearValue() {
      bitField0_ &= ~0x00000002;
      value_.clear();
      return this;
    }

    /**
     * <code>optional bytes Value = 1;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableValue()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getValue() {
      return value_;
    }

    /**
     * <code>optional bytes Value = 1;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableValue() {
      bitField0_ |= 0x00000002;
      return value_;
    }

    /**
     * <code>optional bytes Value = 1;</code>
     * @param value the value_ to add
     * @return this
     */
    public BytesV addValue(final byte value) {
      bitField0_ |= 0x00000002;
      value_.add(value);
      return this;
    }

    /**
     * <code>optional bytes Value = 1;</code>
     * @param values the value_ to add
     * @return this
     */
    public BytesV addAllValue(final byte... values) {
      bitField0_ |= 0x00000002;
      value_.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes Value = 1;</code>
     * @param values the value_ to set
     * @return this
     */
    public BytesV setValue(final byte... values) {
      bitField0_ |= 0x00000002;
      value_.copyFrom(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public BytesV clearNextPackage() {
      bitField0_ &= ~0x00000004;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000004;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public BytesV addNextPackage(final byte value) {
      bitField0_ |= 0x00000004;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public BytesV addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000004;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public BytesV setNextPackage(final byte... values) {
      bitField0_ |= 0x00000004;
      nextPackage.copyFrom(values);
      return this;
    }

    @Override
    public BytesV copyFrom(final BytesV other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        version = other.version;
        value_.copyFrom(other.value_);
        nextPackage.copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public BytesV mergeFrom(final BytesV other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasVersion()) {
        setVersion(other.version);
      }
      if (other.hasValue()) {
        getMutableValue().copyFrom(other.value_);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public BytesV clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      version = 0;
      value_.clear();
      nextPackage.clear();
      return this;
    }

    @Override
    public BytesV clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      value_.clear();
      nextPackage.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof BytesV)) {
        return false;
      }
      BytesV other = (BytesV) o;
      return bitField0_ == other.bitField0_
        && (!hasVersion() || version == other.version)
        && (!hasValue() || value_.equals(other.value_))
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 16);
        output.writeUInt32NoTag(version);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 10);
        output.writeBytesNoTag(value_);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(version);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeBytesSizeNoTag(value_);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public BytesV mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 16: {
            // version
            version = input.readUInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 10) {
              break;
            }
          }
          case 10: {
            // value_
            input.readBytes(value_);
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeUInt32(FieldNames.version, version);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeBytes(FieldNames.value_, value_);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      output.endObject();
    }

    @Override
    public BytesV mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 2016261304: {
            if (input.isAtField(FieldNames.version)) {
              if (!input.trySkipNullValue()) {
                version = input.readUInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 82420049: {
            if (input.isAtField(FieldNames.value_)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(value_);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public BytesV clone() {
      return new BytesV().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static BytesV parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new BytesV(), data).checkInitialized();
    }

    public static BytesV parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new BytesV(), input).checkInitialized();
    }

    public static BytesV parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new BytesV(), input).checkInitialized();
    }

    /**
     * @return factory for creating BytesV messages
     */
    public static MessageFactory<BytesV> getFactory() {
      return BytesVFactory.INSTANCE;
    }

    private enum BytesVFactory implements MessageFactory<BytesV> {
      INSTANCE;

      @Override
      public BytesV create() {
        return BytesV.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName version = FieldName.forField("Version");

      static final FieldName value_ = FieldName.forField("Value");

      static final FieldName nextPackage = FieldName.forField("NextPackage");
    }
  }

  /**
   * Protobuf type {@code Boolean}
   */
  public static final class Boolean extends ProtoMessage<Boolean> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional bool Ok = 1;</code>
     */
    private boolean ok;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    private Boolean() {
    }

    /**
     * @return a new empty instance of {@code Boolean}
     */
    public static Boolean newInstance() {
      return new Boolean();
    }

    /**
     * <code>optional bool Ok = 1;</code>
     * @return whether the ok field is set
     */
    public boolean hasOk() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional bool Ok = 1;</code>
     * @return this
     */
    public Boolean clearOk() {
      bitField0_ &= ~0x00000001;
      ok = false;
      return this;
    }

    /**
     * <code>optional bool Ok = 1;</code>
     * @return the ok
     */
    public boolean getOk() {
      return ok;
    }

    /**
     * <code>optional bool Ok = 1;</code>
     * @param value the ok to set
     * @return this
     */
    public Boolean setOk(final boolean value) {
      bitField0_ |= 0x00000001;
      ok = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public Boolean clearNextPackage() {
      bitField0_ &= ~0x00000002;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000002;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public Boolean addNextPackage(final byte value) {
      bitField0_ |= 0x00000002;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public Boolean addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000002;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public Boolean setNextPackage(final byte... values) {
      bitField0_ |= 0x00000002;
      nextPackage.copyFrom(values);
      return this;
    }

    @Override
    public Boolean copyFrom(final Boolean other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        ok = other.ok;
        nextPackage.copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public Boolean mergeFrom(final Boolean other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasOk()) {
        setOk(other.ok);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public Boolean clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      ok = false;
      nextPackage.clear();
      return this;
    }

    @Override
    public Boolean clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof Boolean)) {
        return false;
      }
      Boolean other = (Boolean) o;
      return bitField0_ == other.bitField0_
        && (!hasOk() || ok == other.ok)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 8);
        output.writeBoolNoTag(ok);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 2;
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public Boolean mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            // ok
            ok = input.readBool();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeBool(FieldNames.ok, ok);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      output.endObject();
    }

    @Override
    public Boolean mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 2556: {
            if (input.isAtField(FieldNames.ok)) {
              if (!input.trySkipNullValue()) {
                ok = input.readBool();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public Boolean clone() {
      return new Boolean().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static Boolean parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new Boolean(), data).checkInitialized();
    }

    public static Boolean parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new Boolean(), input).checkInitialized();
    }

    public static Boolean parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new Boolean(), input).checkInitialized();
    }

    /**
     * @return factory for creating Boolean messages
     */
    public static MessageFactory<Boolean> getFactory() {
      return BooleanFactory.INSTANCE;
    }

    private enum BooleanFactory implements MessageFactory<Boolean> {
      INSTANCE;

      @Override
      public Boolean create() {
        return Boolean.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName ok = FieldName.forField("Ok");

      static final FieldName nextPackage = FieldName.forField("NextPackage");
    }
  }

  /**
   * Protobuf type {@code Error}
   */
  public static final class Error extends ProtoMessage<Error> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional uint64 TraceId = 3;</code>
     */
    private long traceId;

    /**
     * <code>optional int32 Action = 4;</code>
     */
    private int action;

    /**
     * <code>optional uint32 Code = 1;</code>
     */
    private int code;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    /**
     * <code>repeated string Arguments = 2;</code>
     */
    private final RepeatedString arguments = RepeatedString.newEmptyInstance();

    private Error() {
    }

    /**
     * @return a new empty instance of {@code Error}
     */
    public static Error newInstance() {
      return new Error();
    }

    /**
     * <code>optional uint64 TraceId = 3;</code>
     * @return whether the traceId field is set
     */
    public boolean hasTraceId() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional uint64 TraceId = 3;</code>
     * @return this
     */
    public Error clearTraceId() {
      bitField0_ &= ~0x00000001;
      traceId = 0L;
      return this;
    }

    /**
     * <code>optional uint64 TraceId = 3;</code>
     * @return the traceId
     */
    public long getTraceId() {
      return traceId;
    }

    /**
     * <code>optional uint64 TraceId = 3;</code>
     * @param value the traceId to set
     * @return this
     */
    public Error setTraceId(final long value) {
      bitField0_ |= 0x00000001;
      traceId = value;
      return this;
    }

    /**
     * <code>optional int32 Action = 4;</code>
     * @return whether the action field is set
     */
    public boolean hasAction() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional int32 Action = 4;</code>
     * @return this
     */
    public Error clearAction() {
      bitField0_ &= ~0x00000002;
      action = 0;
      return this;
    }

    /**
     * <code>optional int32 Action = 4;</code>
     * @return the action
     */
    public int getAction() {
      return action;
    }

    /**
     * <code>optional int32 Action = 4;</code>
     * @param value the action to set
     * @return this
     */
    public Error setAction(final int value) {
      bitField0_ |= 0x00000002;
      action = value;
      return this;
    }

    /**
     * <code>optional uint32 Code = 1;</code>
     * @return whether the code field is set
     */
    public boolean hasCode() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional uint32 Code = 1;</code>
     * @return this
     */
    public Error clearCode() {
      bitField0_ &= ~0x00000004;
      code = 0;
      return this;
    }

    /**
     * <code>optional uint32 Code = 1;</code>
     * @return the code
     */
    public int getCode() {
      return code;
    }

    /**
     * <code>optional uint32 Code = 1;</code>
     * @param value the code to set
     * @return this
     */
    public Error setCode(final int value) {
      bitField0_ |= 0x00000004;
      code = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000008) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public Error clearNextPackage() {
      bitField0_ &= ~0x00000008;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000008;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public Error addNextPackage(final byte value) {
      bitField0_ |= 0x00000008;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public Error addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000008;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public Error setNextPackage(final byte... values) {
      bitField0_ |= 0x00000008;
      nextPackage.copyFrom(values);
      return this;
    }

    /**
     * <code>repeated string Arguments = 2;</code>
     * @return whether the arguments field is set
     */
    public boolean hasArguments() {
      return (bitField0_ & 0x00000010) != 0;
    }

    /**
     * <code>repeated string Arguments = 2;</code>
     * @return this
     */
    public Error clearArguments() {
      bitField0_ &= ~0x00000010;
      arguments.clear();
      return this;
    }

    /**
     * <code>repeated string Arguments = 2;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableArguments()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedString getArguments() {
      return arguments;
    }

    /**
     * <code>repeated string Arguments = 2;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedString getMutableArguments() {
      bitField0_ |= 0x00000010;
      return arguments;
    }

    /**
     * <code>repeated string Arguments = 2;</code>
     * @param value the arguments to add
     * @return this
     */
    public Error addArguments(final CharSequence value) {
      bitField0_ |= 0x00000010;
      arguments.add(value);
      return this;
    }

    /**
     * <code>repeated string Arguments = 2;</code>
     * @param values the arguments to add
     * @return this
     */
    public Error addAllArguments(final CharSequence... values) {
      bitField0_ |= 0x00000010;
      arguments.addAll(values);
      return this;
    }

    @Override
    public Error copyFrom(final Error other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        traceId = other.traceId;
        action = other.action;
        code = other.code;
        nextPackage.copyFrom(other.nextPackage);
        arguments.copyFrom(other.arguments);
      }
      return this;
    }

    @Override
    public Error mergeFrom(final Error other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasTraceId()) {
        setTraceId(other.traceId);
      }
      if (other.hasAction()) {
        setAction(other.action);
      }
      if (other.hasCode()) {
        setCode(other.code);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      if (other.hasArguments()) {
        getMutableArguments().addAll(other.arguments);
      }
      return this;
    }

    @Override
    public Error clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      traceId = 0L;
      action = 0;
      code = 0;
      nextPackage.clear();
      arguments.clear();
      return this;
    }

    @Override
    public Error clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      arguments.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof Error)) {
        return false;
      }
      Error other = (Error) o;
      return bitField0_ == other.bitField0_
        && (!hasTraceId() || traceId == other.traceId)
        && (!hasAction() || action == other.action)
        && (!hasCode() || code == other.code)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage))
        && (!hasArguments() || arguments.equals(other.arguments));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 24);
        output.writeUInt64NoTag(traceId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 32);
        output.writeInt32NoTag(action);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt32NoTag(code);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        for (int i = 0; i < arguments.length(); i++) {
          output.writeRawByte((byte) 18);
          output.writeStringNoTag(arguments.get(i));
        }
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeUInt64SizeNoTag(traceId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeInt32SizeNoTag(action);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(code);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        size += (1 * arguments.length()) + ProtoSink.computeRepeatedStringSizeNoTag(arguments);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public Error mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 24: {
            // traceId
            traceId = input.readUInt64();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 32) {
              break;
            }
          }
          case 32: {
            // action
            action = input.readInt32();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 8) {
              break;
            }
          }
          case 8: {
            // code
            code = input.readUInt32();
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000008;
            tag = input.readTag();
            if (tag != 18) {
              break;
            }
          }
          case 18: {
            // arguments
            tag = input.readRepeatedString(arguments, tag);
            bitField0_ |= 0x00000010;
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeUInt64(FieldNames.traceId, traceId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeInt32(FieldNames.action, action);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeUInt32(FieldNames.code, code);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        output.writeRepeatedString(FieldNames.arguments, arguments);
      }
      output.endObject();
    }

    @Override
    public Error mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 597251360: {
            if (input.isAtField(FieldNames.traceId)) {
              if (!input.trySkipNullValue()) {
                traceId = input.readUInt64();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 1955883606: {
            if (input.isAtField(FieldNames.action)) {
              if (!input.trySkipNullValue()) {
                action = input.readInt32();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 2105869: {
            if (input.isAtField(FieldNames.code)) {
              if (!input.trySkipNullValue()) {
                code = input.readUInt32();
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000008;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -31549130: {
            if (input.isAtField(FieldNames.arguments)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedString(arguments);
                bitField0_ |= 0x00000010;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public Error clone() {
      return new Error().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static Error parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new Error(), data).checkInitialized();
    }

    public static Error parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new Error(), input).checkInitialized();
    }

    public static Error parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new Error(), input).checkInitialized();
    }

    /**
     * @return factory for creating Error messages
     */
    public static MessageFactory<Error> getFactory() {
      return ErrorFactory.INSTANCE;
    }

    private enum ErrorFactory implements MessageFactory<Error> {
      INSTANCE;

      @Override
      public Error create() {
        return Error.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName traceId = FieldName.forField("TraceId");

      static final FieldName action = FieldName.forField("Action");

      static final FieldName code = FieldName.forField("Code");

      static final FieldName nextPackage = FieldName.forField("NextPackage");

      static final FieldName arguments = FieldName.forField("Arguments");
    }
  }

  /**
   * Protobuf type {@code AccInfo}
   */
  public static final class AccInfo extends ProtoMessage<AccInfo> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional int64 CreateTime = 15;</code>
     */
    private long createTime;

    /**
     * <code>optional uint64 Id = 1;</code>
     */
    private long id;

    /**
     * <code>optional uint32 Hashtag = 3;</code>
     */
    private int hashtag;

    /**
     * <code>optional uint32 HeadIcon = 4;</code>
     */
    private int headIcon;

    /**
     * <code>optional uint32 TitlePrefix = 7;</code>
     */
    private int titlePrefix;

    /**
     * <code>optional uint32 TitleSuffix = 8;</code>
     */
    private int titleSuffix;

    /**
     * <code>optional uint32 SkinId = 10;</code>
     */
    private int skinId;

    /**
     * <code>optional bool Gender = 5;</code>
     */
    private boolean gender;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    /**
     * <code>optional string NickName = 2;</code>
     */
    private final Utf8String nickName = Utf8String.newEmptyInstance();

    /**
     * <code>optional string Signature = 6;</code>
     */
    private final Utf8String signature = Utf8String.newEmptyInstance();

    /**
     * <code>repeated .CharShow Chars = 9;</code>
     */
    private final RepeatedMessage<CharShow> chars = RepeatedMessage.newEmptyInstance(CharShow.getFactory());

    /**
     * <code>repeated .NewbieInfo Newbies = 14;</code>
     */
    private final RepeatedMessage<NewbieInfo> newbies = RepeatedMessage.newEmptyInstance(NewbieInfo.getFactory());

    private AccInfo() {
    }

    /**
     * @return a new empty instance of {@code AccInfo}
     */
    public static AccInfo newInstance() {
      return new AccInfo();
    }

    /**
     * <code>optional int64 CreateTime = 15;</code>
     * @return whether the createTime field is set
     */
    public boolean hasCreateTime() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional int64 CreateTime = 15;</code>
     * @return this
     */
    public AccInfo clearCreateTime() {
      bitField0_ &= ~0x00000001;
      createTime = 0L;
      return this;
    }

    /**
     * <code>optional int64 CreateTime = 15;</code>
     * @return the createTime
     */
    public long getCreateTime() {
      return createTime;
    }

    /**
     * <code>optional int64 CreateTime = 15;</code>
     * @param value the createTime to set
     * @return this
     */
    public AccInfo setCreateTime(final long value) {
      bitField0_ |= 0x00000001;
      createTime = value;
      return this;
    }

    /**
     * <code>optional uint64 Id = 1;</code>
     * @return whether the id field is set
     */
    public boolean hasId() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional uint64 Id = 1;</code>
     * @return this
     */
    public AccInfo clearId() {
      bitField0_ &= ~0x00000002;
      id = 0L;
      return this;
    }

    /**
     * <code>optional uint64 Id = 1;</code>
     * @return the id
     */
    public long getId() {
      return id;
    }

    /**
     * <code>optional uint64 Id = 1;</code>
     * @param value the id to set
     * @return this
     */
    public AccInfo setId(final long value) {
      bitField0_ |= 0x00000002;
      id = value;
      return this;
    }

    /**
     * <code>optional uint32 Hashtag = 3;</code>
     * @return whether the hashtag field is set
     */
    public boolean hasHashtag() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional uint32 Hashtag = 3;</code>
     * @return this
     */
    public AccInfo clearHashtag() {
      bitField0_ &= ~0x00000004;
      hashtag = 0;
      return this;
    }

    /**
     * <code>optional uint32 Hashtag = 3;</code>
     * @return the hashtag
     */
    public int getHashtag() {
      return hashtag;
    }

    /**
     * <code>optional uint32 Hashtag = 3;</code>
     * @param value the hashtag to set
     * @return this
     */
    public AccInfo setHashtag(final int value) {
      bitField0_ |= 0x00000004;
      hashtag = value;
      return this;
    }

    /**
     * <code>optional uint32 HeadIcon = 4;</code>
     * @return whether the headIcon field is set
     */
    public boolean hasHeadIcon() {
      return (bitField0_ & 0x00000008) != 0;
    }

    /**
     * <code>optional uint32 HeadIcon = 4;</code>
     * @return this
     */
    public AccInfo clearHeadIcon() {
      bitField0_ &= ~0x00000008;
      headIcon = 0;
      return this;
    }

    /**
     * <code>optional uint32 HeadIcon = 4;</code>
     * @return the headIcon
     */
    public int getHeadIcon() {
      return headIcon;
    }

    /**
     * <code>optional uint32 HeadIcon = 4;</code>
     * @param value the headIcon to set
     * @return this
     */
    public AccInfo setHeadIcon(final int value) {
      bitField0_ |= 0x00000008;
      headIcon = value;
      return this;
    }

    /**
     * <code>optional uint32 TitlePrefix = 7;</code>
     * @return whether the titlePrefix field is set
     */
    public boolean hasTitlePrefix() {
      return (bitField0_ & 0x00000010) != 0;
    }

    /**
     * <code>optional uint32 TitlePrefix = 7;</code>
     * @return this
     */
    public AccInfo clearTitlePrefix() {
      bitField0_ &= ~0x00000010;
      titlePrefix = 0;
      return this;
    }

    /**
     * <code>optional uint32 TitlePrefix = 7;</code>
     * @return the titlePrefix
     */
    public int getTitlePrefix() {
      return titlePrefix;
    }

    /**
     * <code>optional uint32 TitlePrefix = 7;</code>
     * @param value the titlePrefix to set
     * @return this
     */
    public AccInfo setTitlePrefix(final int value) {
      bitField0_ |= 0x00000010;
      titlePrefix = value;
      return this;
    }

    /**
     * <code>optional uint32 TitleSuffix = 8;</code>
     * @return whether the titleSuffix field is set
     */
    public boolean hasTitleSuffix() {
      return (bitField0_ & 0x00000020) != 0;
    }

    /**
     * <code>optional uint32 TitleSuffix = 8;</code>
     * @return this
     */
    public AccInfo clearTitleSuffix() {
      bitField0_ &= ~0x00000020;
      titleSuffix = 0;
      return this;
    }

    /**
     * <code>optional uint32 TitleSuffix = 8;</code>
     * @return the titleSuffix
     */
    public int getTitleSuffix() {
      return titleSuffix;
    }

    /**
     * <code>optional uint32 TitleSuffix = 8;</code>
     * @param value the titleSuffix to set
     * @return this
     */
    public AccInfo setTitleSuffix(final int value) {
      bitField0_ |= 0x00000020;
      titleSuffix = value;
      return this;
    }

    /**
     * <code>optional uint32 SkinId = 10;</code>
     * @return whether the skinId field is set
     */
    public boolean hasSkinId() {
      return (bitField0_ & 0x00000040) != 0;
    }

    /**
     * <code>optional uint32 SkinId = 10;</code>
     * @return this
     */
    public AccInfo clearSkinId() {
      bitField0_ &= ~0x00000040;
      skinId = 0;
      return this;
    }

    /**
     * <code>optional uint32 SkinId = 10;</code>
     * @return the skinId
     */
    public int getSkinId() {
      return skinId;
    }

    /**
     * <code>optional uint32 SkinId = 10;</code>
     * @param value the skinId to set
     * @return this
     */
    public AccInfo setSkinId(final int value) {
      bitField0_ |= 0x00000040;
      skinId = value;
      return this;
    }

    /**
     * <code>optional bool Gender = 5;</code>
     * @return whether the gender field is set
     */
    public boolean hasGender() {
      return (bitField0_ & 0x00000080) != 0;
    }

    /**
     * <code>optional bool Gender = 5;</code>
     * @return this
     */
    public AccInfo clearGender() {
      bitField0_ &= ~0x00000080;
      gender = false;
      return this;
    }

    /**
     * <code>optional bool Gender = 5;</code>
     * @return the gender
     */
    public boolean getGender() {
      return gender;
    }

    /**
     * <code>optional bool Gender = 5;</code>
     * @param value the gender to set
     * @return this
     */
    public AccInfo setGender(final boolean value) {
      bitField0_ |= 0x00000080;
      gender = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000100) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public AccInfo clearNextPackage() {
      bitField0_ &= ~0x00000100;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000100;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public AccInfo addNextPackage(final byte value) {
      bitField0_ |= 0x00000100;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public AccInfo addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000100;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public AccInfo setNextPackage(final byte... values) {
      bitField0_ |= 0x00000100;
      nextPackage.copyFrom(values);
      return this;
    }

    /**
     * <code>optional string NickName = 2;</code>
     * @return whether the nickName field is set
     */
    public boolean hasNickName() {
      return (bitField0_ & 0x00000200) != 0;
    }

    /**
     * <code>optional string NickName = 2;</code>
     * @return this
     */
    public AccInfo clearNickName() {
      bitField0_ &= ~0x00000200;
      nickName.clear();
      return this;
    }

    /**
     * <code>optional string NickName = 2;</code>
     * @return the nickName
     */
    public java.lang.String getNickName() {
      return nickName.getString();
    }

    /**
     * <code>optional string NickName = 2;</code>
     * @return internal {@code Utf8String} representation of nickName for reading
     */
    public Utf8String getNickNameBytes() {
      return this.nickName;
    }

    /**
     * <code>optional string NickName = 2;</code>
     * @return internal {@code Utf8String} representation of nickName for modifications
     */
    public Utf8String getMutableNickNameBytes() {
      bitField0_ |= 0x00000200;
      return this.nickName;
    }

    /**
     * <code>optional string NickName = 2;</code>
     * @param value the nickName to set
     * @return this
     */
    public AccInfo setNickName(final CharSequence value) {
      bitField0_ |= 0x00000200;
      nickName.copyFrom(value);
      return this;
    }

    /**
     * <code>optional string NickName = 2;</code>
     * @param value the nickName to set
     * @return this
     */
    public AccInfo setNickName(final Utf8String value) {
      bitField0_ |= 0x00000200;
      nickName.copyFrom(value);
      return this;
    }

    /**
     * <code>optional string Signature = 6;</code>
     * @return whether the signature field is set
     */
    public boolean hasSignature() {
      return (bitField0_ & 0x00000400) != 0;
    }

    /**
     * <code>optional string Signature = 6;</code>
     * @return this
     */
    public AccInfo clearSignature() {
      bitField0_ &= ~0x00000400;
      signature.clear();
      return this;
    }

    /**
     * <code>optional string Signature = 6;</code>
     * @return the signature
     */
    public java.lang.String getSignature() {
      return signature.getString();
    }

    /**
     * <code>optional string Signature = 6;</code>
     * @return internal {@code Utf8String} representation of signature for reading
     */
    public Utf8String getSignatureBytes() {
      return this.signature;
    }

    /**
     * <code>optional string Signature = 6;</code>
     * @return internal {@code Utf8String} representation of signature for modifications
     */
    public Utf8String getMutableSignatureBytes() {
      bitField0_ |= 0x00000400;
      return this.signature;
    }

    /**
     * <code>optional string Signature = 6;</code>
     * @param value the signature to set
     * @return this
     */
    public AccInfo setSignature(final CharSequence value) {
      bitField0_ |= 0x00000400;
      signature.copyFrom(value);
      return this;
    }

    /**
     * <code>optional string Signature = 6;</code>
     * @param value the signature to set
     * @return this
     */
    public AccInfo setSignature(final Utf8String value) {
      bitField0_ |= 0x00000400;
      signature.copyFrom(value);
      return this;
    }

    /**
     * <code>repeated .CharShow Chars = 9;</code>
     * @return whether the chars field is set
     */
    public boolean hasChars() {
      return (bitField0_ & 0x00000800) != 0;
    }

    /**
     * <code>repeated .CharShow Chars = 9;</code>
     * @return this
     */
    public AccInfo clearChars() {
      bitField0_ &= ~0x00000800;
      chars.clear();
      return this;
    }

    /**
     * <code>repeated .CharShow Chars = 9;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableChars()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<CharShow> getChars() {
      return chars;
    }

    /**
     * <code>repeated .CharShow Chars = 9;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<CharShow> getMutableChars() {
      bitField0_ |= 0x00000800;
      return chars;
    }

    /**
     * <code>repeated .CharShow Chars = 9;</code>
     * @param value the chars to add
     * @return this
     */
    public AccInfo addChars(final CharShow value) {
      bitField0_ |= 0x00000800;
      chars.add(value);
      return this;
    }

    /**
     * <code>repeated .CharShow Chars = 9;</code>
     * @param values the chars to add
     * @return this
     */
    public AccInfo addAllChars(final CharShow... values) {
      bitField0_ |= 0x00000800;
      chars.addAll(values);
      return this;
    }

    /**
     * <code>repeated .NewbieInfo Newbies = 14;</code>
     * @return whether the newbies field is set
     */
    public boolean hasNewbies() {
      return (bitField0_ & 0x00001000) != 0;
    }

    /**
     * <code>repeated .NewbieInfo Newbies = 14;</code>
     * @return this
     */
    public AccInfo clearNewbies() {
      bitField0_ &= ~0x00001000;
      newbies.clear();
      return this;
    }

    /**
     * <code>repeated .NewbieInfo Newbies = 14;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNewbies()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<NewbieInfo> getNewbies() {
      return newbies;
    }

    /**
     * <code>repeated .NewbieInfo Newbies = 14;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<NewbieInfo> getMutableNewbies() {
      bitField0_ |= 0x00001000;
      return newbies;
    }

    /**
     * <code>repeated .NewbieInfo Newbies = 14;</code>
     * @param value the newbies to add
     * @return this
     */
    public AccInfo addNewbies(final NewbieInfo value) {
      bitField0_ |= 0x00001000;
      newbies.add(value);
      return this;
    }

    /**
     * <code>repeated .NewbieInfo Newbies = 14;</code>
     * @param values the newbies to add
     * @return this
     */
    public AccInfo addAllNewbies(final NewbieInfo... values) {
      bitField0_ |= 0x00001000;
      newbies.addAll(values);
      return this;
    }

    @Override
    public AccInfo copyFrom(final AccInfo other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        createTime = other.createTime;
        id = other.id;
        hashtag = other.hashtag;
        headIcon = other.headIcon;
        titlePrefix = other.titlePrefix;
        titleSuffix = other.titleSuffix;
        skinId = other.skinId;
        gender = other.gender;
        nextPackage.copyFrom(other.nextPackage);
        nickName.copyFrom(other.nickName);
        signature.copyFrom(other.signature);
        chars.copyFrom(other.chars);
        newbies.copyFrom(other.newbies);
      }
      return this;
    }

    @Override
    public AccInfo mergeFrom(final AccInfo other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasCreateTime()) {
        setCreateTime(other.createTime);
      }
      if (other.hasId()) {
        setId(other.id);
      }
      if (other.hasHashtag()) {
        setHashtag(other.hashtag);
      }
      if (other.hasHeadIcon()) {
        setHeadIcon(other.headIcon);
      }
      if (other.hasTitlePrefix()) {
        setTitlePrefix(other.titlePrefix);
      }
      if (other.hasTitleSuffix()) {
        setTitleSuffix(other.titleSuffix);
      }
      if (other.hasSkinId()) {
        setSkinId(other.skinId);
      }
      if (other.hasGender()) {
        setGender(other.gender);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      if (other.hasNickName()) {
        getMutableNickNameBytes().copyFrom(other.nickName);
      }
      if (other.hasSignature()) {
        getMutableSignatureBytes().copyFrom(other.signature);
      }
      if (other.hasChars()) {
        getMutableChars().addAll(other.chars);
      }
      if (other.hasNewbies()) {
        getMutableNewbies().addAll(other.newbies);
      }
      return this;
    }

    @Override
    public AccInfo clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      createTime = 0L;
      id = 0L;
      hashtag = 0;
      headIcon = 0;
      titlePrefix = 0;
      titleSuffix = 0;
      skinId = 0;
      gender = false;
      nextPackage.clear();
      nickName.clear();
      signature.clear();
      chars.clear();
      newbies.clear();
      return this;
    }

    @Override
    public AccInfo clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      nickName.clear();
      signature.clear();
      chars.clearQuick();
      newbies.clearQuick();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof AccInfo)) {
        return false;
      }
      AccInfo other = (AccInfo) o;
      return bitField0_ == other.bitField0_
        && (!hasCreateTime() || createTime == other.createTime)
        && (!hasId() || id == other.id)
        && (!hasHashtag() || hashtag == other.hashtag)
        && (!hasHeadIcon() || headIcon == other.headIcon)
        && (!hasTitlePrefix() || titlePrefix == other.titlePrefix)
        && (!hasTitleSuffix() || titleSuffix == other.titleSuffix)
        && (!hasSkinId() || skinId == other.skinId)
        && (!hasGender() || gender == other.gender)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage))
        && (!hasNickName() || nickName.equals(other.nickName))
        && (!hasSignature() || signature.equals(other.signature))
        && (!hasChars() || chars.equals(other.chars))
        && (!hasNewbies() || newbies.equals(other.newbies));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 120);
        output.writeInt64NoTag(createTime);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt64NoTag(id);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawByte((byte) 24);
        output.writeUInt32NoTag(hashtag);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeRawByte((byte) 32);
        output.writeUInt32NoTag(headIcon);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        output.writeRawByte((byte) 56);
        output.writeUInt32NoTag(titlePrefix);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        output.writeRawByte((byte) 64);
        output.writeUInt32NoTag(titleSuffix);
      }
      if ((bitField0_ & 0x00000040) != 0) {
        output.writeRawByte((byte) 80);
        output.writeUInt32NoTag(skinId);
      }
      if ((bitField0_ & 0x00000080) != 0) {
        output.writeRawByte((byte) 40);
        output.writeBoolNoTag(gender);
      }
      if ((bitField0_ & 0x00000100) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000200) != 0) {
        output.writeRawByte((byte) 18);
        output.writeStringNoTag(nickName);
      }
      if ((bitField0_ & 0x00000400) != 0) {
        output.writeRawByte((byte) 50);
        output.writeStringNoTag(signature);
      }
      if ((bitField0_ & 0x00000800) != 0) {
        for (int i = 0; i < chars.length(); i++) {
          output.writeRawByte((byte) 74);
          output.writeMessageNoTag(chars.get(i));
        }
      }
      if ((bitField0_ & 0x00001000) != 0) {
        for (int i = 0; i < newbies.length(); i++) {
          output.writeRawByte((byte) 114);
          output.writeMessageNoTag(newbies.get(i));
        }
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeInt64SizeNoTag(createTime);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeUInt64SizeNoTag(id);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(hashtag);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(headIcon);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(titlePrefix);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(titleSuffix);
      }
      if ((bitField0_ & 0x00000040) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(skinId);
      }
      if ((bitField0_ & 0x00000080) != 0) {
        size += 2;
      }
      if ((bitField0_ & 0x00000100) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000200) != 0) {
        size += 1 + ProtoSink.computeStringSizeNoTag(nickName);
      }
      if ((bitField0_ & 0x00000400) != 0) {
        size += 1 + ProtoSink.computeStringSizeNoTag(signature);
      }
      if ((bitField0_ & 0x00000800) != 0) {
        size += (1 * chars.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(chars);
      }
      if ((bitField0_ & 0x00001000) != 0) {
        size += (1 * newbies.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(newbies);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public AccInfo mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 120: {
            // createTime
            createTime = input.readInt64();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 8) {
              break;
            }
          }
          case 8: {
            // id
            id = input.readUInt64();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 24) {
              break;
            }
          }
          case 24: {
            // hashtag
            hashtag = input.readUInt32();
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 32) {
              break;
            }
          }
          case 32: {
            // headIcon
            headIcon = input.readUInt32();
            bitField0_ |= 0x00000008;
            tag = input.readTag();
            if (tag != 56) {
              break;
            }
          }
          case 56: {
            // titlePrefix
            titlePrefix = input.readUInt32();
            bitField0_ |= 0x00000010;
            tag = input.readTag();
            if (tag != 64) {
              break;
            }
          }
          case 64: {
            // titleSuffix
            titleSuffix = input.readUInt32();
            bitField0_ |= 0x00000020;
            tag = input.readTag();
            if (tag != 80) {
              break;
            }
          }
          case 80: {
            // skinId
            skinId = input.readUInt32();
            bitField0_ |= 0x00000040;
            tag = input.readTag();
            if (tag != 40) {
              break;
            }
          }
          case 40: {
            // gender
            gender = input.readBool();
            bitField0_ |= 0x00000080;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000100;
            tag = input.readTag();
            if (tag != 18) {
              break;
            }
          }
          case 18: {
            // nickName
            input.readString(nickName);
            bitField0_ |= 0x00000200;
            tag = input.readTag();
            if (tag != 50) {
              break;
            }
          }
          case 50: {
            // signature
            input.readString(signature);
            bitField0_ |= 0x00000400;
            tag = input.readTag();
            if (tag != 74) {
              break;
            }
          }
          case 74: {
            // chars
            tag = input.readRepeatedMessage(chars, tag);
            bitField0_ |= 0x00000800;
            if (tag != 114) {
              break;
            }
          }
          case 114: {
            // newbies
            tag = input.readRepeatedMessage(newbies, tag);
            bitField0_ |= 0x00001000;
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeInt64(FieldNames.createTime, createTime);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeUInt64(FieldNames.id, id);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeUInt32(FieldNames.hashtag, hashtag);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeUInt32(FieldNames.headIcon, headIcon);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        output.writeUInt32(FieldNames.titlePrefix, titlePrefix);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        output.writeUInt32(FieldNames.titleSuffix, titleSuffix);
      }
      if ((bitField0_ & 0x00000040) != 0) {
        output.writeUInt32(FieldNames.skinId, skinId);
      }
      if ((bitField0_ & 0x00000080) != 0) {
        output.writeBool(FieldNames.gender, gender);
      }
      if ((bitField0_ & 0x00000100) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      if ((bitField0_ & 0x00000200) != 0) {
        output.writeString(FieldNames.nickName, nickName);
      }
      if ((bitField0_ & 0x00000400) != 0) {
        output.writeString(FieldNames.signature, signature);
      }
      if ((bitField0_ & 0x00000800) != 0) {
        output.writeRepeatedMessage(FieldNames.chars, chars);
      }
      if ((bitField0_ & 0x00001000) != 0) {
        output.writeRepeatedMessage(FieldNames.newbies, newbies);
      }
      output.endObject();
    }

    @Override
    public AccInfo mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case -932289015: {
            if (input.isAtField(FieldNames.createTime)) {
              if (!input.trySkipNullValue()) {
                createTime = input.readInt64();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 2363: {
            if (input.isAtField(FieldNames.id)) {
              if (!input.trySkipNullValue()) {
                id = input.readUInt64();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1932766292: {
            if (input.isAtField(FieldNames.hashtag)) {
              if (!input.trySkipNullValue()) {
                hashtag = input.readUInt32();
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1051463015: {
            if (input.isAtField(FieldNames.headIcon)) {
              if (!input.trySkipNullValue()) {
                headIcon = input.readUInt32();
                bitField0_ |= 0x00000008;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 2096776938: {
            if (input.isAtField(FieldNames.titlePrefix)) {
              if (!input.trySkipNullValue()) {
                titlePrefix = input.readUInt32();
                bitField0_ |= 0x00000010;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2109502551: {
            if (input.isAtField(FieldNames.titleSuffix)) {
              if (!input.trySkipNullValue()) {
                titleSuffix = input.readUInt32();
                bitField0_ |= 0x00000020;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1816694888: {
            if (input.isAtField(FieldNames.skinId)) {
              if (!input.trySkipNullValue()) {
                skinId = input.readUInt32();
                bitField0_ |= 0x00000040;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 2129321697: {
            if (input.isAtField(FieldNames.gender)) {
              if (!input.trySkipNullValue()) {
                gender = input.readBool();
                bitField0_ |= 0x00000080;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000100;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 134381742: {
            if (input.isAtField(FieldNames.nickName)) {
              if (!input.trySkipNullValue()) {
                input.readString(nickName);
                bitField0_ |= 0x00000200;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1217415016: {
            if (input.isAtField(FieldNames.signature)) {
              if (!input.trySkipNullValue()) {
                input.readString(signature);
                bitField0_ |= 0x00000400;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 65071037: {
            if (input.isAtField(FieldNames.chars)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedMessage(chars);
                bitField0_ |= 0x00000800;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -784689995: {
            if (input.isAtField(FieldNames.newbies)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedMessage(newbies);
                bitField0_ |= 0x00001000;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public AccInfo clone() {
      return new AccInfo().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static AccInfo parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new AccInfo(), data).checkInitialized();
    }

    public static AccInfo parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new AccInfo(), input).checkInitialized();
    }

    public static AccInfo parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new AccInfo(), input).checkInitialized();
    }

    /**
     * @return factory for creating AccInfo messages
     */
    public static MessageFactory<AccInfo> getFactory() {
      return AccInfoFactory.INSTANCE;
    }

    private enum AccInfoFactory implements MessageFactory<AccInfo> {
      INSTANCE;

      @Override
      public AccInfo create() {
        return AccInfo.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName createTime = FieldName.forField("CreateTime");

      static final FieldName id = FieldName.forField("Id");

      static final FieldName hashtag = FieldName.forField("Hashtag");

      static final FieldName headIcon = FieldName.forField("HeadIcon");

      static final FieldName titlePrefix = FieldName.forField("TitlePrefix");

      static final FieldName titleSuffix = FieldName.forField("TitleSuffix");

      static final FieldName skinId = FieldName.forField("SkinId");

      static final FieldName gender = FieldName.forField("Gender");

      static final FieldName nextPackage = FieldName.forField("NextPackage");

      static final FieldName nickName = FieldName.forField("NickName");

      static final FieldName signature = FieldName.forField("Signature");

      static final FieldName chars = FieldName.forField("Chars");

      static final FieldName newbies = FieldName.forField("Newbies");
    }
  }

  /**
   * Protobuf type {@code NewbieInfo}
   */
  public static final class NewbieInfo extends ProtoMessage<NewbieInfo> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional int32 StepId = 2;</code>
     */
    private int stepId;

    /**
     * <code>optional uint32 GroupId = 1;</code>
     */
    private int groupId;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    private NewbieInfo() {
    }

    /**
     * @return a new empty instance of {@code NewbieInfo}
     */
    public static NewbieInfo newInstance() {
      return new NewbieInfo();
    }

    /**
     * <code>optional int32 StepId = 2;</code>
     * @return whether the stepId field is set
     */
    public boolean hasStepId() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional int32 StepId = 2;</code>
     * @return this
     */
    public NewbieInfo clearStepId() {
      bitField0_ &= ~0x00000001;
      stepId = 0;
      return this;
    }

    /**
     * <code>optional int32 StepId = 2;</code>
     * @return the stepId
     */
    public int getStepId() {
      return stepId;
    }

    /**
     * <code>optional int32 StepId = 2;</code>
     * @param value the stepId to set
     * @return this
     */
    public NewbieInfo setStepId(final int value) {
      bitField0_ |= 0x00000001;
      stepId = value;
      return this;
    }

    /**
     * <code>optional uint32 GroupId = 1;</code>
     * @return whether the groupId field is set
     */
    public boolean hasGroupId() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional uint32 GroupId = 1;</code>
     * @return this
     */
    public NewbieInfo clearGroupId() {
      bitField0_ &= ~0x00000002;
      groupId = 0;
      return this;
    }

    /**
     * <code>optional uint32 GroupId = 1;</code>
     * @return the groupId
     */
    public int getGroupId() {
      return groupId;
    }

    /**
     * <code>optional uint32 GroupId = 1;</code>
     * @param value the groupId to set
     * @return this
     */
    public NewbieInfo setGroupId(final int value) {
      bitField0_ |= 0x00000002;
      groupId = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public NewbieInfo clearNextPackage() {
      bitField0_ &= ~0x00000004;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000004;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public NewbieInfo addNextPackage(final byte value) {
      bitField0_ |= 0x00000004;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public NewbieInfo addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000004;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public NewbieInfo setNextPackage(final byte... values) {
      bitField0_ |= 0x00000004;
      nextPackage.copyFrom(values);
      return this;
    }

    @Override
    public NewbieInfo copyFrom(final NewbieInfo other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        stepId = other.stepId;
        groupId = other.groupId;
        nextPackage.copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public NewbieInfo mergeFrom(final NewbieInfo other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasStepId()) {
        setStepId(other.stepId);
      }
      if (other.hasGroupId()) {
        setGroupId(other.groupId);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public NewbieInfo clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      stepId = 0;
      groupId = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public NewbieInfo clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof NewbieInfo)) {
        return false;
      }
      NewbieInfo other = (NewbieInfo) o;
      return bitField0_ == other.bitField0_
        && (!hasStepId() || stepId == other.stepId)
        && (!hasGroupId() || groupId == other.groupId)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 16);
        output.writeInt32NoTag(stepId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt32NoTag(groupId);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeInt32SizeNoTag(stepId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(groupId);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public NewbieInfo mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 16: {
            // stepId
            stepId = input.readInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 8) {
              break;
            }
          }
          case 8: {
            // groupId
            groupId = input.readUInt32();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeInt32(FieldNames.stepId, stepId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeUInt32(FieldNames.groupId, groupId);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      output.endObject();
    }

    @Override
    public NewbieInfo mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case -1808500441: {
            if (input.isAtField(FieldNames.stepId)) {
              if (!input.trySkipNullValue()) {
                stepId = input.readInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 1958081498: {
            if (input.isAtField(FieldNames.groupId)) {
              if (!input.trySkipNullValue()) {
                groupId = input.readUInt32();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public NewbieInfo clone() {
      return new NewbieInfo().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static NewbieInfo parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new NewbieInfo(), data).checkInitialized();
    }

    public static NewbieInfo parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new NewbieInfo(), input).checkInitialized();
    }

    public static NewbieInfo parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new NewbieInfo(), input).checkInitialized();
    }

    /**
     * @return factory for creating NewbieInfo messages
     */
    public static MessageFactory<NewbieInfo> getFactory() {
      return NewbieInfoFactory.INSTANCE;
    }

    private enum NewbieInfoFactory implements MessageFactory<NewbieInfo> {
      INSTANCE;

      @Override
      public NewbieInfo create() {
        return NewbieInfo.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName stepId = FieldName.forField("StepId");

      static final FieldName groupId = FieldName.forField("GroupId");

      static final FieldName nextPackage = FieldName.forField("NextPackage");
    }
  }

  /**
   * Protobuf type {@code QuestProgress}
   */
  public static final class QuestProgress extends ProtoMessage<QuestProgress> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional uint32 Cur = 1;</code>
     */
    private int cur;

    /**
     * <code>optional uint32 Max = 2;</code>
     */
    private int max;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    private QuestProgress() {
    }

    /**
     * @return a new empty instance of {@code QuestProgress}
     */
    public static QuestProgress newInstance() {
      return new QuestProgress();
    }

    /**
     * <code>optional uint32 Cur = 1;</code>
     * @return whether the cur field is set
     */
    public boolean hasCur() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional uint32 Cur = 1;</code>
     * @return this
     */
    public QuestProgress clearCur() {
      bitField0_ &= ~0x00000001;
      cur = 0;
      return this;
    }

    /**
     * <code>optional uint32 Cur = 1;</code>
     * @return the cur
     */
    public int getCur() {
      return cur;
    }

    /**
     * <code>optional uint32 Cur = 1;</code>
     * @param value the cur to set
     * @return this
     */
    public QuestProgress setCur(final int value) {
      bitField0_ |= 0x00000001;
      cur = value;
      return this;
    }

    /**
     * <code>optional uint32 Max = 2;</code>
     * @return whether the max field is set
     */
    public boolean hasMax() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional uint32 Max = 2;</code>
     * @return this
     */
    public QuestProgress clearMax() {
      bitField0_ &= ~0x00000002;
      max = 0;
      return this;
    }

    /**
     * <code>optional uint32 Max = 2;</code>
     * @return the max
     */
    public int getMax() {
      return max;
    }

    /**
     * <code>optional uint32 Max = 2;</code>
     * @param value the max to set
     * @return this
     */
    public QuestProgress setMax(final int value) {
      bitField0_ |= 0x00000002;
      max = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public QuestProgress clearNextPackage() {
      bitField0_ &= ~0x00000004;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000004;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public QuestProgress addNextPackage(final byte value) {
      bitField0_ |= 0x00000004;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public QuestProgress addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000004;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public QuestProgress setNextPackage(final byte... values) {
      bitField0_ |= 0x00000004;
      nextPackage.copyFrom(values);
      return this;
    }

    @Override
    public QuestProgress copyFrom(final QuestProgress other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        cur = other.cur;
        max = other.max;
        nextPackage.copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public QuestProgress mergeFrom(final QuestProgress other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasCur()) {
        setCur(other.cur);
      }
      if (other.hasMax()) {
        setMax(other.max);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public QuestProgress clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      cur = 0;
      max = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public QuestProgress clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof QuestProgress)) {
        return false;
      }
      QuestProgress other = (QuestProgress) o;
      return bitField0_ == other.bitField0_
        && (!hasCur() || cur == other.cur)
        && (!hasMax() || max == other.max)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt32NoTag(cur);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 16);
        output.writeUInt32NoTag(max);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(cur);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(max);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public QuestProgress mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            // cur
            cur = input.readUInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 16) {
              break;
            }
          }
          case 16: {
            // max
            max = input.readUInt32();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeUInt32(FieldNames.cur, cur);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeUInt32(FieldNames.max, max);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      output.endObject();
    }

    @Override
    public QuestProgress mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 68128: {
            if (input.isAtField(FieldNames.cur)) {
              if (!input.trySkipNullValue()) {
                cur = input.readUInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 77124: {
            if (input.isAtField(FieldNames.max)) {
              if (!input.trySkipNullValue()) {
                max = input.readUInt32();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public QuestProgress clone() {
      return new QuestProgress().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static QuestProgress parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new QuestProgress(), data).checkInitialized();
    }

    public static QuestProgress parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new QuestProgress(), input).checkInitialized();
    }

    public static QuestProgress parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new QuestProgress(), input).checkInitialized();
    }

    /**
     * @return factory for creating QuestProgress messages
     */
    public static MessageFactory<QuestProgress> getFactory() {
      return QuestProgressFactory.INSTANCE;
    }

    private enum QuestProgressFactory implements MessageFactory<QuestProgress> {
      INSTANCE;

      @Override
      public QuestProgress create() {
        return QuestProgress.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName cur = FieldName.forField("Cur");

      static final FieldName max = FieldName.forField("Max");

      static final FieldName nextPackage = FieldName.forField("NextPackage");
    }
  }

  /**
   * Protobuf type {@code Quest}
   */
  public static final class Quest extends ProtoMessage<Quest> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional int64 Expire = 3;</code>
     */
    private long expire;

    /**
     * <code>optional uint32 Id = 1;</code>
     */
    private int id;

    /**
     * <code>optional uint32 Status = 2;</code>
     */
    private int status;

    /**
     * <code>optional .QuestType Type = 4;</code>
     */
    private int type;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    /**
     * <code>repeated .QuestProgress Progress = 15;</code>
     */
    private final RepeatedMessage<QuestProgress> progress = RepeatedMessage.newEmptyInstance(QuestProgress.getFactory());

    private Quest() {
    }

    /**
     * @return a new empty instance of {@code Quest}
     */
    public static Quest newInstance() {
      return new Quest();
    }

    /**
     * <code>optional int64 Expire = 3;</code>
     * @return whether the expire field is set
     */
    public boolean hasExpire() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional int64 Expire = 3;</code>
     * @return this
     */
    public Quest clearExpire() {
      bitField0_ &= ~0x00000001;
      expire = 0L;
      return this;
    }

    /**
     * <code>optional int64 Expire = 3;</code>
     * @return the expire
     */
    public long getExpire() {
      return expire;
    }

    /**
     * <code>optional int64 Expire = 3;</code>
     * @param value the expire to set
     * @return this
     */
    public Quest setExpire(final long value) {
      bitField0_ |= 0x00000001;
      expire = value;
      return this;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @return whether the id field is set
     */
    public boolean hasId() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @return this
     */
    public Quest clearId() {
      bitField0_ &= ~0x00000002;
      id = 0;
      return this;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @return the id
     */
    public int getId() {
      return id;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @param value the id to set
     * @return this
     */
    public Quest setId(final int value) {
      bitField0_ |= 0x00000002;
      id = value;
      return this;
    }

    /**
     * <code>optional uint32 Status = 2;</code>
     * @return whether the status field is set
     */
    public boolean hasStatus() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional uint32 Status = 2;</code>
     * @return this
     */
    public Quest clearStatus() {
      bitField0_ &= ~0x00000004;
      status = 0;
      return this;
    }

    /**
     * <code>optional uint32 Status = 2;</code>
     * @return the status
     */
    public int getStatus() {
      return status;
    }

    /**
     * <code>optional uint32 Status = 2;</code>
     * @param value the status to set
     * @return this
     */
    public Quest setStatus(final int value) {
      bitField0_ |= 0x00000004;
      status = value;
      return this;
    }

    /**
     * <code>optional .QuestType Type = 4;</code>
     * @return whether the type field is set
     */
    public boolean hasType() {
      return (bitField0_ & 0x00000008) != 0;
    }

    /**
     * <code>optional .QuestType Type = 4;</code>
     * @return this
     */
    public Quest clearType() {
      bitField0_ &= ~0x00000008;
      type = 0;
      return this;
    }

    /**
     * <code>optional .QuestType Type = 4;</code>
     * @return the type
     */
    public QuestType getType() {
      return QuestType.forNumber(type);
    }

    /**
     * Gets the value of the internal enum store. The result is
     * equivalent to {@link Quest#getType()}.getNumber().
     *
     * @return numeric wire representation
     */
    public int getTypeValue() {
      return type;
    }

    /**
     * Sets the value of the internal enum store. This does not
     * do any validity checks, so be sure to use appropriate value
     * constants from {@link QuestType}. Setting an invalid value
     * can cause {@link Quest#getType()} to return null
     *
     * @param value the numeric wire value to set
     * @return this
     */
    public Quest setTypeValue(final int value) {
      bitField0_ |= 0x00000008;
      type = value;
      return this;
    }

    /**
     * <code>optional .QuestType Type = 4;</code>
     * @param value the type to set
     * @return this
     */
    public Quest setType(final QuestType value) {
      bitField0_ |= 0x00000008;
      type = value.getNumber();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000010) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public Quest clearNextPackage() {
      bitField0_ &= ~0x00000010;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000010;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public Quest addNextPackage(final byte value) {
      bitField0_ |= 0x00000010;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public Quest addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000010;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public Quest setNextPackage(final byte... values) {
      bitField0_ |= 0x00000010;
      nextPackage.copyFrom(values);
      return this;
    }

    /**
     * <code>repeated .QuestProgress Progress = 15;</code>
     * @return whether the progress field is set
     */
    public boolean hasProgress() {
      return (bitField0_ & 0x00000020) != 0;
    }

    /**
     * <code>repeated .QuestProgress Progress = 15;</code>
     * @return this
     */
    public Quest clearProgress() {
      bitField0_ &= ~0x00000020;
      progress.clear();
      return this;
    }

    /**
     * <code>repeated .QuestProgress Progress = 15;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableProgress()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<QuestProgress> getProgress() {
      return progress;
    }

    /**
     * <code>repeated .QuestProgress Progress = 15;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<QuestProgress> getMutableProgress() {
      bitField0_ |= 0x00000020;
      return progress;
    }

    /**
     * <code>repeated .QuestProgress Progress = 15;</code>
     * @param value the progress to add
     * @return this
     */
    public Quest addProgress(final QuestProgress value) {
      bitField0_ |= 0x00000020;
      progress.add(value);
      return this;
    }

    /**
     * <code>repeated .QuestProgress Progress = 15;</code>
     * @param values the progress to add
     * @return this
     */
    public Quest addAllProgress(final QuestProgress... values) {
      bitField0_ |= 0x00000020;
      progress.addAll(values);
      return this;
    }

    @Override
    public Quest copyFrom(final Quest other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        expire = other.expire;
        id = other.id;
        status = other.status;
        type = other.type;
        nextPackage.copyFrom(other.nextPackage);
        progress.copyFrom(other.progress);
      }
      return this;
    }

    @Override
    public Quest mergeFrom(final Quest other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasExpire()) {
        setExpire(other.expire);
      }
      if (other.hasId()) {
        setId(other.id);
      }
      if (other.hasStatus()) {
        setStatus(other.status);
      }
      if (other.hasType()) {
        setTypeValue(other.type);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      if (other.hasProgress()) {
        getMutableProgress().addAll(other.progress);
      }
      return this;
    }

    @Override
    public Quest clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      expire = 0L;
      id = 0;
      status = 0;
      type = 0;
      nextPackage.clear();
      progress.clear();
      return this;
    }

    @Override
    public Quest clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      progress.clearQuick();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof Quest)) {
        return false;
      }
      Quest other = (Quest) o;
      return bitField0_ == other.bitField0_
        && (!hasExpire() || expire == other.expire)
        && (!hasId() || id == other.id)
        && (!hasStatus() || status == other.status)
        && (!hasType() || type == other.type)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage))
        && (!hasProgress() || progress.equals(other.progress));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 24);
        output.writeInt64NoTag(expire);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt32NoTag(id);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawByte((byte) 16);
        output.writeUInt32NoTag(status);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeRawByte((byte) 32);
        output.writeEnumNoTag(type);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        for (int i = 0; i < progress.length(); i++) {
          output.writeRawByte((byte) 122);
          output.writeMessageNoTag(progress.get(i));
        }
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeInt64SizeNoTag(expire);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(id);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(status);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        size += 1 + ProtoSink.computeEnumSizeNoTag(type);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        size += (1 * progress.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(progress);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public Quest mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 24: {
            // expire
            expire = input.readInt64();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 8) {
              break;
            }
          }
          case 8: {
            // id
            id = input.readUInt32();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 16) {
              break;
            }
          }
          case 16: {
            // status
            status = input.readUInt32();
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 32) {
              break;
            }
          }
          case 32: {
            // type
            final int value = input.readInt32();
            if (QuestType.forNumber(value) != null) {
              type = value;
              bitField0_ |= 0x00000008;
            }
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000010;
            tag = input.readTag();
            if (tag != 122) {
              break;
            }
          }
          case 122: {
            // progress
            tag = input.readRepeatedMessage(progress, tag);
            bitField0_ |= 0x00000020;
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeInt64(FieldNames.expire, expire);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeUInt32(FieldNames.id, id);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeUInt32(FieldNames.status, status);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeEnum(FieldNames.type, type, QuestType.converter());
      }
      if ((bitField0_ & 0x00000010) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        output.writeRepeatedMessage(FieldNames.progress, progress);
      }
      output.endObject();
    }

    @Override
    public Quest mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 2089675071: {
            if (input.isAtField(FieldNames.expire)) {
              if (!input.trySkipNullValue()) {
                expire = input.readInt64();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 2363: {
            if (input.isAtField(FieldNames.id)) {
              if (!input.trySkipNullValue()) {
                id = input.readUInt32();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1808614382: {
            if (input.isAtField(FieldNames.status)) {
              if (!input.trySkipNullValue()) {
                status = input.readUInt32();
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 2622298: {
            if (input.isAtField(FieldNames.type)) {
              if (!input.trySkipNullValue()) {
                final QuestType value = input.readEnum(QuestType.converter());
                if (value != null) {
                  type = value.getNumber();
                  bitField0_ |= 0x00000008;
                } else {
                  input.skipUnknownEnumValue();
                }
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000010;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -936434099: {
            if (input.isAtField(FieldNames.progress)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedMessage(progress);
                bitField0_ |= 0x00000020;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public Quest clone() {
      return new Quest().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static Quest parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new Quest(), data).checkInitialized();
    }

    public static Quest parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new Quest(), input).checkInitialized();
    }

    public static Quest parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new Quest(), input).checkInitialized();
    }

    /**
     * @return factory for creating Quest messages
     */
    public static MessageFactory<Quest> getFactory() {
      return QuestFactory.INSTANCE;
    }

    private enum QuestFactory implements MessageFactory<Quest> {
      INSTANCE;

      @Override
      public Quest create() {
        return Quest.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName expire = FieldName.forField("Expire");

      static final FieldName id = FieldName.forField("Id");

      static final FieldName status = FieldName.forField("Status");

      static final FieldName type = FieldName.forField("Type");

      static final FieldName nextPackage = FieldName.forField("NextPackage");

      static final FieldName progress = FieldName.forField("Progress");
    }
  }

  /**
   * Protobuf type {@code Quests}
   */
  public static final class Quests extends ProtoMessage<Quests> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    /**
     * <code>repeated .Quest List = 1;</code>
     */
    private final RepeatedMessage<Quest> list = RepeatedMessage.newEmptyInstance(Quest.getFactory());

    private Quests() {
    }

    /**
     * @return a new empty instance of {@code Quests}
     */
    public static Quests newInstance() {
      return new Quests();
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public Quests clearNextPackage() {
      bitField0_ &= ~0x00000001;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000001;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public Quests addNextPackage(final byte value) {
      bitField0_ |= 0x00000001;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public Quests addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000001;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public Quests setNextPackage(final byte... values) {
      bitField0_ |= 0x00000001;
      nextPackage.copyFrom(values);
      return this;
    }

    /**
     * <code>repeated .Quest List = 1;</code>
     * @return whether the list field is set
     */
    public boolean hasList() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>repeated .Quest List = 1;</code>
     * @return this
     */
    public Quests clearList() {
      bitField0_ &= ~0x00000002;
      list.clear();
      return this;
    }

    /**
     * <code>repeated .Quest List = 1;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableList()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<Quest> getList() {
      return list;
    }

    /**
     * <code>repeated .Quest List = 1;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<Quest> getMutableList() {
      bitField0_ |= 0x00000002;
      return list;
    }

    /**
     * <code>repeated .Quest List = 1;</code>
     * @param value the list to add
     * @return this
     */
    public Quests addList(final Quest value) {
      bitField0_ |= 0x00000002;
      list.add(value);
      return this;
    }

    /**
     * <code>repeated .Quest List = 1;</code>
     * @param values the list to add
     * @return this
     */
    public Quests addAllList(final Quest... values) {
      bitField0_ |= 0x00000002;
      list.addAll(values);
      return this;
    }

    @Override
    public Quests copyFrom(final Quests other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        nextPackage.copyFrom(other.nextPackage);
        list.copyFrom(other.list);
      }
      return this;
    }

    @Override
    public Quests mergeFrom(final Quests other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      if (other.hasList()) {
        getMutableList().addAll(other.list);
      }
      return this;
    }

    @Override
    public Quests clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      list.clear();
      return this;
    }

    @Override
    public Quests clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      list.clearQuick();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof Quests)) {
        return false;
      }
      Quests other = (Quests) o;
      return bitField0_ == other.bitField0_
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage))
        && (!hasList() || list.equals(other.list));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        for (int i = 0; i < list.length(); i++) {
          output.writeRawByte((byte) 10);
          output.writeMessageNoTag(list.get(i));
        }
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += (1 * list.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(list);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public Quests mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 10) {
              break;
            }
          }
          case 10: {
            // list
            tag = input.readRepeatedMessage(list, tag);
            bitField0_ |= 0x00000002;
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRepeatedMessage(FieldNames.list, list);
      }
      output.endObject();
    }

    @Override
    public Quests mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 2368702: {
            if (input.isAtField(FieldNames.list)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedMessage(list);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public Quests clone() {
      return new Quests().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static Quests parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new Quests(), data).checkInitialized();
    }

    public static Quests parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new Quests(), input).checkInitialized();
    }

    public static Quests parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new Quests(), input).checkInitialized();
    }

    /**
     * @return factory for creating Quests messages
     */
    public static MessageFactory<Quests> getFactory() {
      return QuestsFactory.INSTANCE;
    }

    private enum QuestsFactory implements MessageFactory<Quests> {
      INSTANCE;

      @Override
      public Quests create() {
        return Quests.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName nextPackage = FieldName.forField("NextPackage");

      static final FieldName list = FieldName.forField("List");
    }
  }

  /**
   * Protobuf type {@code Achievement}
   */
  public static final class Achievement extends ProtoMessage<Achievement> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional int64 Completed = 3;</code>
     */
    private long completed;

    /**
     * <code>optional uint32 Id = 1;</code>
     */
    private int id;

    /**
     * <code>optional uint32 Status = 2;</code>
     */
    private int status;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    /**
     * <code>repeated .QuestProgress Progress = 4;</code>
     */
    private final RepeatedMessage<QuestProgress> progress = RepeatedMessage.newEmptyInstance(QuestProgress.getFactory());

    private Achievement() {
    }

    /**
     * @return a new empty instance of {@code Achievement}
     */
    public static Achievement newInstance() {
      return new Achievement();
    }

    /**
     * <code>optional int64 Completed = 3;</code>
     * @return whether the completed field is set
     */
    public boolean hasCompleted() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional int64 Completed = 3;</code>
     * @return this
     */
    public Achievement clearCompleted() {
      bitField0_ &= ~0x00000001;
      completed = 0L;
      return this;
    }

    /**
     * <code>optional int64 Completed = 3;</code>
     * @return the completed
     */
    public long getCompleted() {
      return completed;
    }

    /**
     * <code>optional int64 Completed = 3;</code>
     * @param value the completed to set
     * @return this
     */
    public Achievement setCompleted(final long value) {
      bitField0_ |= 0x00000001;
      completed = value;
      return this;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @return whether the id field is set
     */
    public boolean hasId() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @return this
     */
    public Achievement clearId() {
      bitField0_ &= ~0x00000002;
      id = 0;
      return this;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @return the id
     */
    public int getId() {
      return id;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @param value the id to set
     * @return this
     */
    public Achievement setId(final int value) {
      bitField0_ |= 0x00000002;
      id = value;
      return this;
    }

    /**
     * <code>optional uint32 Status = 2;</code>
     * @return whether the status field is set
     */
    public boolean hasStatus() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional uint32 Status = 2;</code>
     * @return this
     */
    public Achievement clearStatus() {
      bitField0_ &= ~0x00000004;
      status = 0;
      return this;
    }

    /**
     * <code>optional uint32 Status = 2;</code>
     * @return the status
     */
    public int getStatus() {
      return status;
    }

    /**
     * <code>optional uint32 Status = 2;</code>
     * @param value the status to set
     * @return this
     */
    public Achievement setStatus(final int value) {
      bitField0_ |= 0x00000004;
      status = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000008) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public Achievement clearNextPackage() {
      bitField0_ &= ~0x00000008;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000008;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public Achievement addNextPackage(final byte value) {
      bitField0_ |= 0x00000008;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public Achievement addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000008;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public Achievement setNextPackage(final byte... values) {
      bitField0_ |= 0x00000008;
      nextPackage.copyFrom(values);
      return this;
    }

    /**
     * <code>repeated .QuestProgress Progress = 4;</code>
     * @return whether the progress field is set
     */
    public boolean hasProgress() {
      return (bitField0_ & 0x00000010) != 0;
    }

    /**
     * <code>repeated .QuestProgress Progress = 4;</code>
     * @return this
     */
    public Achievement clearProgress() {
      bitField0_ &= ~0x00000010;
      progress.clear();
      return this;
    }

    /**
     * <code>repeated .QuestProgress Progress = 4;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableProgress()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<QuestProgress> getProgress() {
      return progress;
    }

    /**
     * <code>repeated .QuestProgress Progress = 4;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<QuestProgress> getMutableProgress() {
      bitField0_ |= 0x00000010;
      return progress;
    }

    /**
     * <code>repeated .QuestProgress Progress = 4;</code>
     * @param value the progress to add
     * @return this
     */
    public Achievement addProgress(final QuestProgress value) {
      bitField0_ |= 0x00000010;
      progress.add(value);
      return this;
    }

    /**
     * <code>repeated .QuestProgress Progress = 4;</code>
     * @param values the progress to add
     * @return this
     */
    public Achievement addAllProgress(final QuestProgress... values) {
      bitField0_ |= 0x00000010;
      progress.addAll(values);
      return this;
    }

    @Override
    public Achievement copyFrom(final Achievement other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        completed = other.completed;
        id = other.id;
        status = other.status;
        nextPackage.copyFrom(other.nextPackage);
        progress.copyFrom(other.progress);
      }
      return this;
    }

    @Override
    public Achievement mergeFrom(final Achievement other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasCompleted()) {
        setCompleted(other.completed);
      }
      if (other.hasId()) {
        setId(other.id);
      }
      if (other.hasStatus()) {
        setStatus(other.status);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      if (other.hasProgress()) {
        getMutableProgress().addAll(other.progress);
      }
      return this;
    }

    @Override
    public Achievement clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      completed = 0L;
      id = 0;
      status = 0;
      nextPackage.clear();
      progress.clear();
      return this;
    }

    @Override
    public Achievement clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      progress.clearQuick();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof Achievement)) {
        return false;
      }
      Achievement other = (Achievement) o;
      return bitField0_ == other.bitField0_
        && (!hasCompleted() || completed == other.completed)
        && (!hasId() || id == other.id)
        && (!hasStatus() || status == other.status)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage))
        && (!hasProgress() || progress.equals(other.progress));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 24);
        output.writeInt64NoTag(completed);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt32NoTag(id);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawByte((byte) 16);
        output.writeUInt32NoTag(status);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        for (int i = 0; i < progress.length(); i++) {
          output.writeRawByte((byte) 34);
          output.writeMessageNoTag(progress.get(i));
        }
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeInt64SizeNoTag(completed);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(id);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(status);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        size += (1 * progress.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(progress);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public Achievement mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 24: {
            // completed
            completed = input.readInt64();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 8) {
              break;
            }
          }
          case 8: {
            // id
            id = input.readUInt32();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 16) {
              break;
            }
          }
          case 16: {
            // status
            status = input.readUInt32();
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000008;
            tag = input.readTag();
            if (tag != 34) {
              break;
            }
          }
          case 34: {
            // progress
            tag = input.readRepeatedMessage(progress, tag);
            bitField0_ |= 0x00000010;
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeInt64(FieldNames.completed, completed);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeUInt32(FieldNames.id, id);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeUInt32(FieldNames.status, status);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        output.writeRepeatedMessage(FieldNames.progress, progress);
      }
      output.endObject();
    }

    @Override
    public Achievement mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 601036331: {
            if (input.isAtField(FieldNames.completed)) {
              if (!input.trySkipNullValue()) {
                completed = input.readInt64();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 2363: {
            if (input.isAtField(FieldNames.id)) {
              if (!input.trySkipNullValue()) {
                id = input.readUInt32();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1808614382: {
            if (input.isAtField(FieldNames.status)) {
              if (!input.trySkipNullValue()) {
                status = input.readUInt32();
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000008;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -936434099: {
            if (input.isAtField(FieldNames.progress)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedMessage(progress);
                bitField0_ |= 0x00000010;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public Achievement clone() {
      return new Achievement().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static Achievement parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new Achievement(), data).checkInitialized();
    }

    public static Achievement parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new Achievement(), input).checkInitialized();
    }

    public static Achievement parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new Achievement(), input).checkInitialized();
    }

    /**
     * @return factory for creating Achievement messages
     */
    public static MessageFactory<Achievement> getFactory() {
      return AchievementFactory.INSTANCE;
    }

    private enum AchievementFactory implements MessageFactory<Achievement> {
      INSTANCE;

      @Override
      public Achievement create() {
        return Achievement.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName completed = FieldName.forField("Completed");

      static final FieldName id = FieldName.forField("Id");

      static final FieldName status = FieldName.forField("Status");

      static final FieldName nextPackage = FieldName.forField("NextPackage");

      static final FieldName progress = FieldName.forField("Progress");
    }
  }

  /**
   * Protobuf type {@code Achievements}
   */
  public static final class Achievements extends ProtoMessage<Achievements> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    /**
     * <code>repeated .Achievement List = 1;</code>
     */
    private final RepeatedMessage<Achievement> list = RepeatedMessage.newEmptyInstance(Achievement.getFactory());

    private Achievements() {
    }

    /**
     * @return a new empty instance of {@code Achievements}
     */
    public static Achievements newInstance() {
      return new Achievements();
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public Achievements clearNextPackage() {
      bitField0_ &= ~0x00000001;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000001;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public Achievements addNextPackage(final byte value) {
      bitField0_ |= 0x00000001;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public Achievements addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000001;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public Achievements setNextPackage(final byte... values) {
      bitField0_ |= 0x00000001;
      nextPackage.copyFrom(values);
      return this;
    }

    /**
     * <code>repeated .Achievement List = 1;</code>
     * @return whether the list field is set
     */
    public boolean hasList() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>repeated .Achievement List = 1;</code>
     * @return this
     */
    public Achievements clearList() {
      bitField0_ &= ~0x00000002;
      list.clear();
      return this;
    }

    /**
     * <code>repeated .Achievement List = 1;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableList()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<Achievement> getList() {
      return list;
    }

    /**
     * <code>repeated .Achievement List = 1;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<Achievement> getMutableList() {
      bitField0_ |= 0x00000002;
      return list;
    }

    /**
     * <code>repeated .Achievement List = 1;</code>
     * @param value the list to add
     * @return this
     */
    public Achievements addList(final Achievement value) {
      bitField0_ |= 0x00000002;
      list.add(value);
      return this;
    }

    /**
     * <code>repeated .Achievement List = 1;</code>
     * @param values the list to add
     * @return this
     */
    public Achievements addAllList(final Achievement... values) {
      bitField0_ |= 0x00000002;
      list.addAll(values);
      return this;
    }

    @Override
    public Achievements copyFrom(final Achievements other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        nextPackage.copyFrom(other.nextPackage);
        list.copyFrom(other.list);
      }
      return this;
    }

    @Override
    public Achievements mergeFrom(final Achievements other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      if (other.hasList()) {
        getMutableList().addAll(other.list);
      }
      return this;
    }

    @Override
    public Achievements clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      list.clear();
      return this;
    }

    @Override
    public Achievements clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      list.clearQuick();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof Achievements)) {
        return false;
      }
      Achievements other = (Achievements) o;
      return bitField0_ == other.bitField0_
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage))
        && (!hasList() || list.equals(other.list));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        for (int i = 0; i < list.length(); i++) {
          output.writeRawByte((byte) 10);
          output.writeMessageNoTag(list.get(i));
        }
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += (1 * list.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(list);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public Achievements mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 10) {
              break;
            }
          }
          case 10: {
            // list
            tag = input.readRepeatedMessage(list, tag);
            bitField0_ |= 0x00000002;
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRepeatedMessage(FieldNames.list, list);
      }
      output.endObject();
    }

    @Override
    public Achievements mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 2368702: {
            if (input.isAtField(FieldNames.list)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedMessage(list);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public Achievements clone() {
      return new Achievements().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static Achievements parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new Achievements(), data).checkInitialized();
    }

    public static Achievements parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new Achievements(), input).checkInitialized();
    }

    public static Achievements parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new Achievements(), input).checkInitialized();
    }

    /**
     * @return factory for creating Achievements messages
     */
    public static MessageFactory<Achievements> getFactory() {
      return AchievementsFactory.INSTANCE;
    }

    private enum AchievementsFactory implements MessageFactory<Achievements> {
      INSTANCE;

      @Override
      public Achievements create() {
        return Achievements.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName nextPackage = FieldName.forField("NextPackage");

      static final FieldName list = FieldName.forField("List");
    }
  }

  /**
   * Protobuf type {@code Dictionary}
   */
  public static final class Dictionary extends ProtoMessage<Dictionary> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional uint32 TabId = 1;</code>
     */
    private int tabId;

    /**
     * <code>optional uint32 Index = 2;</code>
     */
    private int index;

    /**
     * <code>optional uint32 Status = 3;</code>
     */
    private int status;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    private Dictionary() {
    }

    /**
     * @return a new empty instance of {@code Dictionary}
     */
    public static Dictionary newInstance() {
      return new Dictionary();
    }

    /**
     * <code>optional uint32 TabId = 1;</code>
     * @return whether the tabId field is set
     */
    public boolean hasTabId() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional uint32 TabId = 1;</code>
     * @return this
     */
    public Dictionary clearTabId() {
      bitField0_ &= ~0x00000001;
      tabId = 0;
      return this;
    }

    /**
     * <code>optional uint32 TabId = 1;</code>
     * @return the tabId
     */
    public int getTabId() {
      return tabId;
    }

    /**
     * <code>optional uint32 TabId = 1;</code>
     * @param value the tabId to set
     * @return this
     */
    public Dictionary setTabId(final int value) {
      bitField0_ |= 0x00000001;
      tabId = value;
      return this;
    }

    /**
     * <code>optional uint32 Index = 2;</code>
     * @return whether the index field is set
     */
    public boolean hasIndex() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional uint32 Index = 2;</code>
     * @return this
     */
    public Dictionary clearIndex() {
      bitField0_ &= ~0x00000002;
      index = 0;
      return this;
    }

    /**
     * <code>optional uint32 Index = 2;</code>
     * @return the index
     */
    public int getIndex() {
      return index;
    }

    /**
     * <code>optional uint32 Index = 2;</code>
     * @param value the index to set
     * @return this
     */
    public Dictionary setIndex(final int value) {
      bitField0_ |= 0x00000002;
      index = value;
      return this;
    }

    /**
     * <code>optional uint32 Status = 3;</code>
     * @return whether the status field is set
     */
    public boolean hasStatus() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional uint32 Status = 3;</code>
     * @return this
     */
    public Dictionary clearStatus() {
      bitField0_ &= ~0x00000004;
      status = 0;
      return this;
    }

    /**
     * <code>optional uint32 Status = 3;</code>
     * @return the status
     */
    public int getStatus() {
      return status;
    }

    /**
     * <code>optional uint32 Status = 3;</code>
     * @param value the status to set
     * @return this
     */
    public Dictionary setStatus(final int value) {
      bitField0_ |= 0x00000004;
      status = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000008) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public Dictionary clearNextPackage() {
      bitField0_ &= ~0x00000008;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000008;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public Dictionary addNextPackage(final byte value) {
      bitField0_ |= 0x00000008;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public Dictionary addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000008;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public Dictionary setNextPackage(final byte... values) {
      bitField0_ |= 0x00000008;
      nextPackage.copyFrom(values);
      return this;
    }

    @Override
    public Dictionary copyFrom(final Dictionary other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        tabId = other.tabId;
        index = other.index;
        status = other.status;
        nextPackage.copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public Dictionary mergeFrom(final Dictionary other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasTabId()) {
        setTabId(other.tabId);
      }
      if (other.hasIndex()) {
        setIndex(other.index);
      }
      if (other.hasStatus()) {
        setStatus(other.status);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public Dictionary clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      tabId = 0;
      index = 0;
      status = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public Dictionary clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof Dictionary)) {
        return false;
      }
      Dictionary other = (Dictionary) o;
      return bitField0_ == other.bitField0_
        && (!hasTabId() || tabId == other.tabId)
        && (!hasIndex() || index == other.index)
        && (!hasStatus() || status == other.status)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt32NoTag(tabId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 16);
        output.writeUInt32NoTag(index);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawByte((byte) 24);
        output.writeUInt32NoTag(status);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(tabId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(index);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(status);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public Dictionary mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            // tabId
            tabId = input.readUInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 16) {
              break;
            }
          }
          case 16: {
            // index
            index = input.readUInt32();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 24) {
              break;
            }
          }
          case 24: {
            // status
            status = input.readUInt32();
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000008;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeUInt32(FieldNames.tabId, tabId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeUInt32(FieldNames.index, index);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeUInt32(FieldNames.status, status);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      output.endObject();
    }

    @Override
    public Dictionary mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 80562032: {
            if (input.isAtField(FieldNames.tabId)) {
              if (!input.trySkipNullValue()) {
                tabId = input.readUInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 70793394: {
            if (input.isAtField(FieldNames.index)) {
              if (!input.trySkipNullValue()) {
                index = input.readUInt32();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1808614382: {
            if (input.isAtField(FieldNames.status)) {
              if (!input.trySkipNullValue()) {
                status = input.readUInt32();
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000008;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public Dictionary clone() {
      return new Dictionary().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static Dictionary parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new Dictionary(), data).checkInitialized();
    }

    public static Dictionary parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new Dictionary(), input).checkInitialized();
    }

    public static Dictionary parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new Dictionary(), input).checkInitialized();
    }

    /**
     * @return factory for creating Dictionary messages
     */
    public static MessageFactory<Dictionary> getFactory() {
      return DictionaryFactory.INSTANCE;
    }

    private enum DictionaryFactory implements MessageFactory<Dictionary> {
      INSTANCE;

      @Override
      public Dictionary create() {
        return Dictionary.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName tabId = FieldName.forField("TabId");

      static final FieldName index = FieldName.forField("Index");

      static final FieldName status = FieldName.forField("Status");

      static final FieldName nextPackage = FieldName.forField("NextPackage");
    }
  }

  /**
   * Protobuf type {@code Dictionaries}
   */
  public static final class Dictionaries extends ProtoMessage<Dictionaries> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    /**
     * <code>repeated .Dictionary List = 1;</code>
     */
    private final RepeatedMessage<Dictionary> list = RepeatedMessage.newEmptyInstance(Dictionary.getFactory());

    private Dictionaries() {
    }

    /**
     * @return a new empty instance of {@code Dictionaries}
     */
    public static Dictionaries newInstance() {
      return new Dictionaries();
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public Dictionaries clearNextPackage() {
      bitField0_ &= ~0x00000001;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000001;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public Dictionaries addNextPackage(final byte value) {
      bitField0_ |= 0x00000001;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public Dictionaries addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000001;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public Dictionaries setNextPackage(final byte... values) {
      bitField0_ |= 0x00000001;
      nextPackage.copyFrom(values);
      return this;
    }

    /**
     * <code>repeated .Dictionary List = 1;</code>
     * @return whether the list field is set
     */
    public boolean hasList() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>repeated .Dictionary List = 1;</code>
     * @return this
     */
    public Dictionaries clearList() {
      bitField0_ &= ~0x00000002;
      list.clear();
      return this;
    }

    /**
     * <code>repeated .Dictionary List = 1;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableList()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<Dictionary> getList() {
      return list;
    }

    /**
     * <code>repeated .Dictionary List = 1;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<Dictionary> getMutableList() {
      bitField0_ |= 0x00000002;
      return list;
    }

    /**
     * <code>repeated .Dictionary List = 1;</code>
     * @param value the list to add
     * @return this
     */
    public Dictionaries addList(final Dictionary value) {
      bitField0_ |= 0x00000002;
      list.add(value);
      return this;
    }

    /**
     * <code>repeated .Dictionary List = 1;</code>
     * @param values the list to add
     * @return this
     */
    public Dictionaries addAllList(final Dictionary... values) {
      bitField0_ |= 0x00000002;
      list.addAll(values);
      return this;
    }

    @Override
    public Dictionaries copyFrom(final Dictionaries other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        nextPackage.copyFrom(other.nextPackage);
        list.copyFrom(other.list);
      }
      return this;
    }

    @Override
    public Dictionaries mergeFrom(final Dictionaries other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      if (other.hasList()) {
        getMutableList().addAll(other.list);
      }
      return this;
    }

    @Override
    public Dictionaries clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      list.clear();
      return this;
    }

    @Override
    public Dictionaries clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      list.clearQuick();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof Dictionaries)) {
        return false;
      }
      Dictionaries other = (Dictionaries) o;
      return bitField0_ == other.bitField0_
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage))
        && (!hasList() || list.equals(other.list));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        for (int i = 0; i < list.length(); i++) {
          output.writeRawByte((byte) 10);
          output.writeMessageNoTag(list.get(i));
        }
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += (1 * list.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(list);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public Dictionaries mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 10) {
              break;
            }
          }
          case 10: {
            // list
            tag = input.readRepeatedMessage(list, tag);
            bitField0_ |= 0x00000002;
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRepeatedMessage(FieldNames.list, list);
      }
      output.endObject();
    }

    @Override
    public Dictionaries mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 2368702: {
            if (input.isAtField(FieldNames.list)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedMessage(list);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public Dictionaries clone() {
      return new Dictionaries().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static Dictionaries parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new Dictionaries(), data).checkInitialized();
    }

    public static Dictionaries parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new Dictionaries(), input).checkInitialized();
    }

    public static Dictionaries parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new Dictionaries(), input).checkInitialized();
    }

    /**
     * @return factory for creating Dictionaries messages
     */
    public static MessageFactory<Dictionaries> getFactory() {
      return DictionariesFactory.INSTANCE;
    }

    private enum DictionariesFactory implements MessageFactory<Dictionaries> {
      INSTANCE;

      @Override
      public Dictionaries create() {
        return Dictionaries.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName nextPackage = FieldName.forField("NextPackage");

      static final FieldName list = FieldName.forField("List");
    }
  }

  /**
   * Protobuf type {@code Event}
   */
  public static final class Event extends ProtoMessage<Event> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional uint32 Id = 1;</code>
     */
    private int id;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    /**
     * <code>repeated uint32 Data = 2;</code>
     */
    private final RepeatedInt data = RepeatedInt.newEmptyInstance();

    private Event() {
    }

    /**
     * @return a new empty instance of {@code Event}
     */
    public static Event newInstance() {
      return new Event();
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @return whether the id field is set
     */
    public boolean hasId() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @return this
     */
    public Event clearId() {
      bitField0_ &= ~0x00000001;
      id = 0;
      return this;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @return the id
     */
    public int getId() {
      return id;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @param value the id to set
     * @return this
     */
    public Event setId(final int value) {
      bitField0_ |= 0x00000001;
      id = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public Event clearNextPackage() {
      bitField0_ &= ~0x00000002;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000002;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public Event addNextPackage(final byte value) {
      bitField0_ |= 0x00000002;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public Event addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000002;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public Event setNextPackage(final byte... values) {
      bitField0_ |= 0x00000002;
      nextPackage.copyFrom(values);
      return this;
    }

    /**
     * <code>repeated uint32 Data = 2;</code>
     * @return whether the data field is set
     */
    public boolean hasData() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>repeated uint32 Data = 2;</code>
     * @return this
     */
    public Event clearData() {
      bitField0_ &= ~0x00000004;
      data.clear();
      return this;
    }

    /**
     * <code>repeated uint32 Data = 2;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableData()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedInt getData() {
      return data;
    }

    /**
     * <code>repeated uint32 Data = 2;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedInt getMutableData() {
      bitField0_ |= 0x00000004;
      return data;
    }

    /**
     * <code>repeated uint32 Data = 2;</code>
     * @param value the data to add
     * @return this
     */
    public Event addData(final int value) {
      bitField0_ |= 0x00000004;
      data.add(value);
      return this;
    }

    /**
     * <code>repeated uint32 Data = 2;</code>
     * @param values the data to add
     * @return this
     */
    public Event addAllData(final int... values) {
      bitField0_ |= 0x00000004;
      data.addAll(values);
      return this;
    }

    @Override
    public Event copyFrom(final Event other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        id = other.id;
        nextPackage.copyFrom(other.nextPackage);
        data.copyFrom(other.data);
      }
      return this;
    }

    @Override
    public Event mergeFrom(final Event other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasId()) {
        setId(other.id);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      if (other.hasData()) {
        getMutableData().addAll(other.data);
      }
      return this;
    }

    @Override
    public Event clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      id = 0;
      nextPackage.clear();
      data.clear();
      return this;
    }

    @Override
    public Event clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      data.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof Event)) {
        return false;
      }
      Event other = (Event) o;
      return bitField0_ == other.bitField0_
        && (!hasId() || id == other.id)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage))
        && (!hasData() || data.equals(other.data));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt32NoTag(id);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        for (int i = 0; i < data.length(); i++) {
          output.writeRawByte((byte) 16);
          output.writeUInt32NoTag(data.array()[i]);
        }
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(id);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += (1 * data.length()) + ProtoSink.computeRepeatedUInt32SizeNoTag(data);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public Event mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            // id
            id = input.readUInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 18) {
              break;
            }
          }
          case 18: {
            // data [packed=true]
            input.readPackedUInt32(data, tag);
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
          case 16: {
            // data [packed=false]
            tag = input.readRepeatedUInt32(data, tag);
            bitField0_ |= 0x00000004;
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeUInt32(FieldNames.id, id);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRepeatedUInt32(FieldNames.data, data);
      }
      output.endObject();
    }

    @Override
    public Event mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 2363: {
            if (input.isAtField(FieldNames.id)) {
              if (!input.trySkipNullValue()) {
                id = input.readUInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 2122698: {
            if (input.isAtField(FieldNames.data)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedUInt32(data);
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public Event clone() {
      return new Event().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static Event parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new Event(), data).checkInitialized();
    }

    public static Event parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new Event(), input).checkInitialized();
    }

    public static Event parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new Event(), input).checkInitialized();
    }

    /**
     * @return factory for creating Event messages
     */
    public static MessageFactory<Event> getFactory() {
      return EventFactory.INSTANCE;
    }

    private enum EventFactory implements MessageFactory<Event> {
      INSTANCE;

      @Override
      public Event create() {
        return Event.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName id = FieldName.forField("Id");

      static final FieldName nextPackage = FieldName.forField("NextPackage");

      static final FieldName data = FieldName.forField("Data");
    }
  }

  /**
   * Protobuf type {@code Events}
   */
  public static final class Events extends ProtoMessage<Events> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    /**
     * <code>repeated .Event List = 1;</code>
     */
    private final RepeatedMessage<Event> list = RepeatedMessage.newEmptyInstance(Event.getFactory());

    private Events() {
    }

    /**
     * @return a new empty instance of {@code Events}
     */
    public static Events newInstance() {
      return new Events();
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public Events clearNextPackage() {
      bitField0_ &= ~0x00000001;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000001;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public Events addNextPackage(final byte value) {
      bitField0_ |= 0x00000001;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public Events addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000001;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public Events setNextPackage(final byte... values) {
      bitField0_ |= 0x00000001;
      nextPackage.copyFrom(values);
      return this;
    }

    /**
     * <code>repeated .Event List = 1;</code>
     * @return whether the list field is set
     */
    public boolean hasList() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>repeated .Event List = 1;</code>
     * @return this
     */
    public Events clearList() {
      bitField0_ &= ~0x00000002;
      list.clear();
      return this;
    }

    /**
     * <code>repeated .Event List = 1;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableList()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<Event> getList() {
      return list;
    }

    /**
     * <code>repeated .Event List = 1;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<Event> getMutableList() {
      bitField0_ |= 0x00000002;
      return list;
    }

    /**
     * <code>repeated .Event List = 1;</code>
     * @param value the list to add
     * @return this
     */
    public Events addList(final Event value) {
      bitField0_ |= 0x00000002;
      list.add(value);
      return this;
    }

    /**
     * <code>repeated .Event List = 1;</code>
     * @param values the list to add
     * @return this
     */
    public Events addAllList(final Event... values) {
      bitField0_ |= 0x00000002;
      list.addAll(values);
      return this;
    }

    @Override
    public Events copyFrom(final Events other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        nextPackage.copyFrom(other.nextPackage);
        list.copyFrom(other.list);
      }
      return this;
    }

    @Override
    public Events mergeFrom(final Events other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      if (other.hasList()) {
        getMutableList().addAll(other.list);
      }
      return this;
    }

    @Override
    public Events clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      list.clear();
      return this;
    }

    @Override
    public Events clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      list.clearQuick();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof Events)) {
        return false;
      }
      Events other = (Events) o;
      return bitField0_ == other.bitField0_
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage))
        && (!hasList() || list.equals(other.list));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        for (int i = 0; i < list.length(); i++) {
          output.writeRawByte((byte) 10);
          output.writeMessageNoTag(list.get(i));
        }
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += (1 * list.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(list);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public Events mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 10) {
              break;
            }
          }
          case 10: {
            // list
            tag = input.readRepeatedMessage(list, tag);
            bitField0_ |= 0x00000002;
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRepeatedMessage(FieldNames.list, list);
      }
      output.endObject();
    }

    @Override
    public Events mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 2368702: {
            if (input.isAtField(FieldNames.list)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedMessage(list);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public Events clone() {
      return new Events().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static Events parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new Events(), data).checkInitialized();
    }

    public static Events parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new Events(), input).checkInitialized();
    }

    public static Events parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new Events(), input).checkInitialized();
    }

    /**
     * @return factory for creating Events messages
     */
    public static MessageFactory<Events> getFactory() {
      return EventsFactory.INSTANCE;
    }

    private enum EventsFactory implements MessageFactory<Events> {
      INSTANCE;

      @Override
      public Events create() {
        return Events.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName nextPackage = FieldName.forField("NextPackage");

      static final FieldName list = FieldName.forField("List");
    }
  }

  /**
   * Protobuf type {@code Mail}
   */
  public static final class Mail extends ProtoMessage<Mail> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional int64 Time = 6;</code>
     */
    private long time;

    /**
     * <code>optional int64 Deadline = 7;</code>
     */
    private long deadline;

    /**
     * <code>optional int64 SurveyId = 14;</code>
     */
    private long surveyId;

    /**
     * <code>optional uint64 Flag = 11;</code>
     */
    private long flag;

    /**
     * <code>optional uint32 Id = 1;</code>
     */
    private int id;

    /**
     * <code>optional uint32 TemplateId = 4;</code>
     */
    private int templateId;

    /**
     * <code>optional bool Read = 8;</code>
     */
    private boolean read;

    /**
     * <code>optional bool Recv = 9;</code>
     */
    private boolean recv;

    /**
     * <code>optional bool Pin = 15;</code>
     */
    private boolean pin;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    /**
     * <code>optional string Subject = 2;</code>
     */
    private final Utf8String subject = Utf8String.newEmptyInstance();

    /**
     * <code>optional string Desc = 3;</code>
     */
    private final Utf8String desc = Utf8String.newEmptyInstance();

    /**
     * <code>optional string Author = 5;</code>
     */
    private final Utf8String author = Utf8String.newEmptyInstance();

    /**
     * <code>repeated .ItemTpl Attachments = 10;</code>
     */
    private final RepeatedMessage<ItemTpl> attachments = RepeatedMessage.newEmptyInstance(ItemTpl.getFactory());

    /**
     * <code>repeated string SubjectArgs = 12;</code>
     */
    private final RepeatedString subjectArgs = RepeatedString.newEmptyInstance();

    /**
     * <code>repeated string DescArgs = 13;</code>
     */
    private final RepeatedString descArgs = RepeatedString.newEmptyInstance();

    private Mail() {
    }

    /**
     * @return a new empty instance of {@code Mail}
     */
    public static Mail newInstance() {
      return new Mail();
    }

    /**
     * <code>optional int64 Time = 6;</code>
     * @return whether the time field is set
     */
    public boolean hasTime() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional int64 Time = 6;</code>
     * @return this
     */
    public Mail clearTime() {
      bitField0_ &= ~0x00000001;
      time = 0L;
      return this;
    }

    /**
     * <code>optional int64 Time = 6;</code>
     * @return the time
     */
    public long getTime() {
      return time;
    }

    /**
     * <code>optional int64 Time = 6;</code>
     * @param value the time to set
     * @return this
     */
    public Mail setTime(final long value) {
      bitField0_ |= 0x00000001;
      time = value;
      return this;
    }

    /**
     * <code>optional int64 Deadline = 7;</code>
     * @return whether the deadline field is set
     */
    public boolean hasDeadline() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional int64 Deadline = 7;</code>
     * @return this
     */
    public Mail clearDeadline() {
      bitField0_ &= ~0x00000002;
      deadline = 0L;
      return this;
    }

    /**
     * <code>optional int64 Deadline = 7;</code>
     * @return the deadline
     */
    public long getDeadline() {
      return deadline;
    }

    /**
     * <code>optional int64 Deadline = 7;</code>
     * @param value the deadline to set
     * @return this
     */
    public Mail setDeadline(final long value) {
      bitField0_ |= 0x00000002;
      deadline = value;
      return this;
    }

    /**
     * <code>optional int64 SurveyId = 14;</code>
     * @return whether the surveyId field is set
     */
    public boolean hasSurveyId() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional int64 SurveyId = 14;</code>
     * @return this
     */
    public Mail clearSurveyId() {
      bitField0_ &= ~0x00000004;
      surveyId = 0L;
      return this;
    }

    /**
     * <code>optional int64 SurveyId = 14;</code>
     * @return the surveyId
     */
    public long getSurveyId() {
      return surveyId;
    }

    /**
     * <code>optional int64 SurveyId = 14;</code>
     * @param value the surveyId to set
     * @return this
     */
    public Mail setSurveyId(final long value) {
      bitField0_ |= 0x00000004;
      surveyId = value;
      return this;
    }

    /**
     * <code>optional uint64 Flag = 11;</code>
     * @return whether the flag field is set
     */
    public boolean hasFlag() {
      return (bitField0_ & 0x00000008) != 0;
    }

    /**
     * <code>optional uint64 Flag = 11;</code>
     * @return this
     */
    public Mail clearFlag() {
      bitField0_ &= ~0x00000008;
      flag = 0L;
      return this;
    }

    /**
     * <code>optional uint64 Flag = 11;</code>
     * @return the flag
     */
    public long getFlag() {
      return flag;
    }

    /**
     * <code>optional uint64 Flag = 11;</code>
     * @param value the flag to set
     * @return this
     */
    public Mail setFlag(final long value) {
      bitField0_ |= 0x00000008;
      flag = value;
      return this;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @return whether the id field is set
     */
    public boolean hasId() {
      return (bitField0_ & 0x00000010) != 0;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @return this
     */
    public Mail clearId() {
      bitField0_ &= ~0x00000010;
      id = 0;
      return this;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @return the id
     */
    public int getId() {
      return id;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @param value the id to set
     * @return this
     */
    public Mail setId(final int value) {
      bitField0_ |= 0x00000010;
      id = value;
      return this;
    }

    /**
     * <code>optional uint32 TemplateId = 4;</code>
     * @return whether the templateId field is set
     */
    public boolean hasTemplateId() {
      return (bitField0_ & 0x00000020) != 0;
    }

    /**
     * <code>optional uint32 TemplateId = 4;</code>
     * @return this
     */
    public Mail clearTemplateId() {
      bitField0_ &= ~0x00000020;
      templateId = 0;
      return this;
    }

    /**
     * <code>optional uint32 TemplateId = 4;</code>
     * @return the templateId
     */
    public int getTemplateId() {
      return templateId;
    }

    /**
     * <code>optional uint32 TemplateId = 4;</code>
     * @param value the templateId to set
     * @return this
     */
    public Mail setTemplateId(final int value) {
      bitField0_ |= 0x00000020;
      templateId = value;
      return this;
    }

    /**
     * <code>optional bool Read = 8;</code>
     * @return whether the read field is set
     */
    public boolean hasRead() {
      return (bitField0_ & 0x00000040) != 0;
    }

    /**
     * <code>optional bool Read = 8;</code>
     * @return this
     */
    public Mail clearRead() {
      bitField0_ &= ~0x00000040;
      read = false;
      return this;
    }

    /**
     * <code>optional bool Read = 8;</code>
     * @return the read
     */
    public boolean getRead() {
      return read;
    }

    /**
     * <code>optional bool Read = 8;</code>
     * @param value the read to set
     * @return this
     */
    public Mail setRead(final boolean value) {
      bitField0_ |= 0x00000040;
      read = value;
      return this;
    }

    /**
     * <code>optional bool Recv = 9;</code>
     * @return whether the recv field is set
     */
    public boolean hasRecv() {
      return (bitField0_ & 0x00000080) != 0;
    }

    /**
     * <code>optional bool Recv = 9;</code>
     * @return this
     */
    public Mail clearRecv() {
      bitField0_ &= ~0x00000080;
      recv = false;
      return this;
    }

    /**
     * <code>optional bool Recv = 9;</code>
     * @return the recv
     */
    public boolean getRecv() {
      return recv;
    }

    /**
     * <code>optional bool Recv = 9;</code>
     * @param value the recv to set
     * @return this
     */
    public Mail setRecv(final boolean value) {
      bitField0_ |= 0x00000080;
      recv = value;
      return this;
    }

    /**
     * <code>optional bool Pin = 15;</code>
     * @return whether the pin field is set
     */
    public boolean hasPin() {
      return (bitField0_ & 0x00000100) != 0;
    }

    /**
     * <code>optional bool Pin = 15;</code>
     * @return this
     */
    public Mail clearPin() {
      bitField0_ &= ~0x00000100;
      pin = false;
      return this;
    }

    /**
     * <code>optional bool Pin = 15;</code>
     * @return the pin
     */
    public boolean getPin() {
      return pin;
    }

    /**
     * <code>optional bool Pin = 15;</code>
     * @param value the pin to set
     * @return this
     */
    public Mail setPin(final boolean value) {
      bitField0_ |= 0x00000100;
      pin = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000200) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public Mail clearNextPackage() {
      bitField0_ &= ~0x00000200;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000200;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public Mail addNextPackage(final byte value) {
      bitField0_ |= 0x00000200;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public Mail addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000200;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public Mail setNextPackage(final byte... values) {
      bitField0_ |= 0x00000200;
      nextPackage.copyFrom(values);
      return this;
    }

    /**
     * <code>optional string Subject = 2;</code>
     * @return whether the subject field is set
     */
    public boolean hasSubject() {
      return (bitField0_ & 0x00000400) != 0;
    }

    /**
     * <code>optional string Subject = 2;</code>
     * @return this
     */
    public Mail clearSubject() {
      bitField0_ &= ~0x00000400;
      subject.clear();
      return this;
    }

    /**
     * <code>optional string Subject = 2;</code>
     * @return the subject
     */
    public java.lang.String getSubject() {
      return subject.getString();
    }

    /**
     * <code>optional string Subject = 2;</code>
     * @return internal {@code Utf8String} representation of subject for reading
     */
    public Utf8String getSubjectBytes() {
      return this.subject;
    }

    /**
     * <code>optional string Subject = 2;</code>
     * @return internal {@code Utf8String} representation of subject for modifications
     */
    public Utf8String getMutableSubjectBytes() {
      bitField0_ |= 0x00000400;
      return this.subject;
    }

    /**
     * <code>optional string Subject = 2;</code>
     * @param value the subject to set
     * @return this
     */
    public Mail setSubject(final CharSequence value) {
      bitField0_ |= 0x00000400;
      subject.copyFrom(value);
      return this;
    }

    /**
     * <code>optional string Subject = 2;</code>
     * @param value the subject to set
     * @return this
     */
    public Mail setSubject(final Utf8String value) {
      bitField0_ |= 0x00000400;
      subject.copyFrom(value);
      return this;
    }

    /**
     * <code>optional string Desc = 3;</code>
     * @return whether the desc field is set
     */
    public boolean hasDesc() {
      return (bitField0_ & 0x00000800) != 0;
    }

    /**
     * <code>optional string Desc = 3;</code>
     * @return this
     */
    public Mail clearDesc() {
      bitField0_ &= ~0x00000800;
      desc.clear();
      return this;
    }

    /**
     * <code>optional string Desc = 3;</code>
     * @return the desc
     */
    public java.lang.String getDesc() {
      return desc.getString();
    }

    /**
     * <code>optional string Desc = 3;</code>
     * @return internal {@code Utf8String} representation of desc for reading
     */
    public Utf8String getDescBytes() {
      return this.desc;
    }

    /**
     * <code>optional string Desc = 3;</code>
     * @return internal {@code Utf8String} representation of desc for modifications
     */
    public Utf8String getMutableDescBytes() {
      bitField0_ |= 0x00000800;
      return this.desc;
    }

    /**
     * <code>optional string Desc = 3;</code>
     * @param value the desc to set
     * @return this
     */
    public Mail setDesc(final CharSequence value) {
      bitField0_ |= 0x00000800;
      desc.copyFrom(value);
      return this;
    }

    /**
     * <code>optional string Desc = 3;</code>
     * @param value the desc to set
     * @return this
     */
    public Mail setDesc(final Utf8String value) {
      bitField0_ |= 0x00000800;
      desc.copyFrom(value);
      return this;
    }

    /**
     * <code>optional string Author = 5;</code>
     * @return whether the author field is set
     */
    public boolean hasAuthor() {
      return (bitField0_ & 0x00001000) != 0;
    }

    /**
     * <code>optional string Author = 5;</code>
     * @return this
     */
    public Mail clearAuthor() {
      bitField0_ &= ~0x00001000;
      author.clear();
      return this;
    }

    /**
     * <code>optional string Author = 5;</code>
     * @return the author
     */
    public java.lang.String getAuthor() {
      return author.getString();
    }

    /**
     * <code>optional string Author = 5;</code>
     * @return internal {@code Utf8String} representation of author for reading
     */
    public Utf8String getAuthorBytes() {
      return this.author;
    }

    /**
     * <code>optional string Author = 5;</code>
     * @return internal {@code Utf8String} representation of author for modifications
     */
    public Utf8String getMutableAuthorBytes() {
      bitField0_ |= 0x00001000;
      return this.author;
    }

    /**
     * <code>optional string Author = 5;</code>
     * @param value the author to set
     * @return this
     */
    public Mail setAuthor(final CharSequence value) {
      bitField0_ |= 0x00001000;
      author.copyFrom(value);
      return this;
    }

    /**
     * <code>optional string Author = 5;</code>
     * @param value the author to set
     * @return this
     */
    public Mail setAuthor(final Utf8String value) {
      bitField0_ |= 0x00001000;
      author.copyFrom(value);
      return this;
    }

    /**
     * <code>repeated .ItemTpl Attachments = 10;</code>
     * @return whether the attachments field is set
     */
    public boolean hasAttachments() {
      return (bitField0_ & 0x00002000) != 0;
    }

    /**
     * <code>repeated .ItemTpl Attachments = 10;</code>
     * @return this
     */
    public Mail clearAttachments() {
      bitField0_ &= ~0x00002000;
      attachments.clear();
      return this;
    }

    /**
     * <code>repeated .ItemTpl Attachments = 10;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableAttachments()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<ItemTpl> getAttachments() {
      return attachments;
    }

    /**
     * <code>repeated .ItemTpl Attachments = 10;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<ItemTpl> getMutableAttachments() {
      bitField0_ |= 0x00002000;
      return attachments;
    }

    /**
     * <code>repeated .ItemTpl Attachments = 10;</code>
     * @param value the attachments to add
     * @return this
     */
    public Mail addAttachments(final ItemTpl value) {
      bitField0_ |= 0x00002000;
      attachments.add(value);
      return this;
    }

    /**
     * <code>repeated .ItemTpl Attachments = 10;</code>
     * @param values the attachments to add
     * @return this
     */
    public Mail addAllAttachments(final ItemTpl... values) {
      bitField0_ |= 0x00002000;
      attachments.addAll(values);
      return this;
    }

    /**
     * <code>repeated string SubjectArgs = 12;</code>
     * @return whether the subjectArgs field is set
     */
    public boolean hasSubjectArgs() {
      return (bitField0_ & 0x00004000) != 0;
    }

    /**
     * <code>repeated string SubjectArgs = 12;</code>
     * @return this
     */
    public Mail clearSubjectArgs() {
      bitField0_ &= ~0x00004000;
      subjectArgs.clear();
      return this;
    }

    /**
     * <code>repeated string SubjectArgs = 12;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableSubjectArgs()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedString getSubjectArgs() {
      return subjectArgs;
    }

    /**
     * <code>repeated string SubjectArgs = 12;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedString getMutableSubjectArgs() {
      bitField0_ |= 0x00004000;
      return subjectArgs;
    }

    /**
     * <code>repeated string SubjectArgs = 12;</code>
     * @param value the subjectArgs to add
     * @return this
     */
    public Mail addSubjectArgs(final CharSequence value) {
      bitField0_ |= 0x00004000;
      subjectArgs.add(value);
      return this;
    }

    /**
     * <code>repeated string SubjectArgs = 12;</code>
     * @param values the subjectArgs to add
     * @return this
     */
    public Mail addAllSubjectArgs(final CharSequence... values) {
      bitField0_ |= 0x00004000;
      subjectArgs.addAll(values);
      return this;
    }

    /**
     * <code>repeated string DescArgs = 13;</code>
     * @return whether the descArgs field is set
     */
    public boolean hasDescArgs() {
      return (bitField0_ & 0x00008000) != 0;
    }

    /**
     * <code>repeated string DescArgs = 13;</code>
     * @return this
     */
    public Mail clearDescArgs() {
      bitField0_ &= ~0x00008000;
      descArgs.clear();
      return this;
    }

    /**
     * <code>repeated string DescArgs = 13;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableDescArgs()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedString getDescArgs() {
      return descArgs;
    }

    /**
     * <code>repeated string DescArgs = 13;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedString getMutableDescArgs() {
      bitField0_ |= 0x00008000;
      return descArgs;
    }

    /**
     * <code>repeated string DescArgs = 13;</code>
     * @param value the descArgs to add
     * @return this
     */
    public Mail addDescArgs(final CharSequence value) {
      bitField0_ |= 0x00008000;
      descArgs.add(value);
      return this;
    }

    /**
     * <code>repeated string DescArgs = 13;</code>
     * @param values the descArgs to add
     * @return this
     */
    public Mail addAllDescArgs(final CharSequence... values) {
      bitField0_ |= 0x00008000;
      descArgs.addAll(values);
      return this;
    }

    @Override
    public Mail copyFrom(final Mail other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        time = other.time;
        deadline = other.deadline;
        surveyId = other.surveyId;
        flag = other.flag;
        id = other.id;
        templateId = other.templateId;
        read = other.read;
        recv = other.recv;
        pin = other.pin;
        nextPackage.copyFrom(other.nextPackage);
        subject.copyFrom(other.subject);
        desc.copyFrom(other.desc);
        author.copyFrom(other.author);
        attachments.copyFrom(other.attachments);
        subjectArgs.copyFrom(other.subjectArgs);
        descArgs.copyFrom(other.descArgs);
      }
      return this;
    }

    @Override
    public Mail mergeFrom(final Mail other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasTime()) {
        setTime(other.time);
      }
      if (other.hasDeadline()) {
        setDeadline(other.deadline);
      }
      if (other.hasSurveyId()) {
        setSurveyId(other.surveyId);
      }
      if (other.hasFlag()) {
        setFlag(other.flag);
      }
      if (other.hasId()) {
        setId(other.id);
      }
      if (other.hasTemplateId()) {
        setTemplateId(other.templateId);
      }
      if (other.hasRead()) {
        setRead(other.read);
      }
      if (other.hasRecv()) {
        setRecv(other.recv);
      }
      if (other.hasPin()) {
        setPin(other.pin);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      if (other.hasSubject()) {
        getMutableSubjectBytes().copyFrom(other.subject);
      }
      if (other.hasDesc()) {
        getMutableDescBytes().copyFrom(other.desc);
      }
      if (other.hasAuthor()) {
        getMutableAuthorBytes().copyFrom(other.author);
      }
      if (other.hasAttachments()) {
        getMutableAttachments().addAll(other.attachments);
      }
      if (other.hasSubjectArgs()) {
        getMutableSubjectArgs().addAll(other.subjectArgs);
      }
      if (other.hasDescArgs()) {
        getMutableDescArgs().addAll(other.descArgs);
      }
      return this;
    }

    @Override
    public Mail clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      time = 0L;
      deadline = 0L;
      surveyId = 0L;
      flag = 0L;
      id = 0;
      templateId = 0;
      read = false;
      recv = false;
      pin = false;
      nextPackage.clear();
      subject.clear();
      desc.clear();
      author.clear();
      attachments.clear();
      subjectArgs.clear();
      descArgs.clear();
      return this;
    }

    @Override
    public Mail clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      subject.clear();
      desc.clear();
      author.clear();
      attachments.clearQuick();
      subjectArgs.clear();
      descArgs.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof Mail)) {
        return false;
      }
      Mail other = (Mail) o;
      return bitField0_ == other.bitField0_
        && (!hasTime() || time == other.time)
        && (!hasDeadline() || deadline == other.deadline)
        && (!hasSurveyId() || surveyId == other.surveyId)
        && (!hasFlag() || flag == other.flag)
        && (!hasId() || id == other.id)
        && (!hasTemplateId() || templateId == other.templateId)
        && (!hasRead() || read == other.read)
        && (!hasRecv() || recv == other.recv)
        && (!hasPin() || pin == other.pin)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage))
        && (!hasSubject() || subject.equals(other.subject))
        && (!hasDesc() || desc.equals(other.desc))
        && (!hasAuthor() || author.equals(other.author))
        && (!hasAttachments() || attachments.equals(other.attachments))
        && (!hasSubjectArgs() || subjectArgs.equals(other.subjectArgs))
        && (!hasDescArgs() || descArgs.equals(other.descArgs));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 48);
        output.writeInt64NoTag(time);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 56);
        output.writeInt64NoTag(deadline);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawByte((byte) 112);
        output.writeInt64NoTag(surveyId);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeRawByte((byte) 88);
        output.writeUInt64NoTag(flag);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt32NoTag(id);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        output.writeRawByte((byte) 32);
        output.writeUInt32NoTag(templateId);
      }
      if ((bitField0_ & 0x00000040) != 0) {
        output.writeRawByte((byte) 64);
        output.writeBoolNoTag(read);
      }
      if ((bitField0_ & 0x00000080) != 0) {
        output.writeRawByte((byte) 72);
        output.writeBoolNoTag(recv);
      }
      if ((bitField0_ & 0x00000100) != 0) {
        output.writeRawByte((byte) 120);
        output.writeBoolNoTag(pin);
      }
      if ((bitField0_ & 0x00000200) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000400) != 0) {
        output.writeRawByte((byte) 18);
        output.writeStringNoTag(subject);
      }
      if ((bitField0_ & 0x00000800) != 0) {
        output.writeRawByte((byte) 26);
        output.writeStringNoTag(desc);
      }
      if ((bitField0_ & 0x00001000) != 0) {
        output.writeRawByte((byte) 42);
        output.writeStringNoTag(author);
      }
      if ((bitField0_ & 0x00002000) != 0) {
        for (int i = 0; i < attachments.length(); i++) {
          output.writeRawByte((byte) 82);
          output.writeMessageNoTag(attachments.get(i));
        }
      }
      if ((bitField0_ & 0x00004000) != 0) {
        for (int i = 0; i < subjectArgs.length(); i++) {
          output.writeRawByte((byte) 98);
          output.writeStringNoTag(subjectArgs.get(i));
        }
      }
      if ((bitField0_ & 0x00008000) != 0) {
        for (int i = 0; i < descArgs.length(); i++) {
          output.writeRawByte((byte) 106);
          output.writeStringNoTag(descArgs.get(i));
        }
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeInt64SizeNoTag(time);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeInt64SizeNoTag(deadline);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 1 + ProtoSink.computeInt64SizeNoTag(surveyId);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        size += 1 + ProtoSink.computeUInt64SizeNoTag(flag);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(id);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(templateId);
      }
      if ((bitField0_ & 0x00000040) != 0) {
        size += 2;
      }
      if ((bitField0_ & 0x00000080) != 0) {
        size += 2;
      }
      if ((bitField0_ & 0x00000100) != 0) {
        size += 2;
      }
      if ((bitField0_ & 0x00000200) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000400) != 0) {
        size += 1 + ProtoSink.computeStringSizeNoTag(subject);
      }
      if ((bitField0_ & 0x00000800) != 0) {
        size += 1 + ProtoSink.computeStringSizeNoTag(desc);
      }
      if ((bitField0_ & 0x00001000) != 0) {
        size += 1 + ProtoSink.computeStringSizeNoTag(author);
      }
      if ((bitField0_ & 0x00002000) != 0) {
        size += (1 * attachments.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(attachments);
      }
      if ((bitField0_ & 0x00004000) != 0) {
        size += (1 * subjectArgs.length()) + ProtoSink.computeRepeatedStringSizeNoTag(subjectArgs);
      }
      if ((bitField0_ & 0x00008000) != 0) {
        size += (1 * descArgs.length()) + ProtoSink.computeRepeatedStringSizeNoTag(descArgs);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public Mail mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 48: {
            // time
            time = input.readInt64();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 56) {
              break;
            }
          }
          case 56: {
            // deadline
            deadline = input.readInt64();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 112) {
              break;
            }
          }
          case 112: {
            // surveyId
            surveyId = input.readInt64();
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 88) {
              break;
            }
          }
          case 88: {
            // flag
            flag = input.readUInt64();
            bitField0_ |= 0x00000008;
            tag = input.readTag();
            if (tag != 8) {
              break;
            }
          }
          case 8: {
            // id
            id = input.readUInt32();
            bitField0_ |= 0x00000010;
            tag = input.readTag();
            if (tag != 32) {
              break;
            }
          }
          case 32: {
            // templateId
            templateId = input.readUInt32();
            bitField0_ |= 0x00000020;
            tag = input.readTag();
            if (tag != 64) {
              break;
            }
          }
          case 64: {
            // read
            read = input.readBool();
            bitField0_ |= 0x00000040;
            tag = input.readTag();
            if (tag != 72) {
              break;
            }
          }
          case 72: {
            // recv
            recv = input.readBool();
            bitField0_ |= 0x00000080;
            tag = input.readTag();
            if (tag != 120) {
              break;
            }
          }
          case 120: {
            // pin
            pin = input.readBool();
            bitField0_ |= 0x00000100;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000200;
            tag = input.readTag();
            if (tag != 18) {
              break;
            }
          }
          case 18: {
            // subject
            input.readString(subject);
            bitField0_ |= 0x00000400;
            tag = input.readTag();
            if (tag != 26) {
              break;
            }
          }
          case 26: {
            // desc
            input.readString(desc);
            bitField0_ |= 0x00000800;
            tag = input.readTag();
            if (tag != 42) {
              break;
            }
          }
          case 42: {
            // author
            input.readString(author);
            bitField0_ |= 0x00001000;
            tag = input.readTag();
            if (tag != 82) {
              break;
            }
          }
          case 82: {
            // attachments
            tag = input.readRepeatedMessage(attachments, tag);
            bitField0_ |= 0x00002000;
            if (tag != 98) {
              break;
            }
          }
          case 98: {
            // subjectArgs
            tag = input.readRepeatedString(subjectArgs, tag);
            bitField0_ |= 0x00004000;
            if (tag != 106) {
              break;
            }
          }
          case 106: {
            // descArgs
            tag = input.readRepeatedString(descArgs, tag);
            bitField0_ |= 0x00008000;
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeInt64(FieldNames.time, time);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeInt64(FieldNames.deadline, deadline);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeInt64(FieldNames.surveyId, surveyId);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeUInt64(FieldNames.flag, flag);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        output.writeUInt32(FieldNames.id, id);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        output.writeUInt32(FieldNames.templateId, templateId);
      }
      if ((bitField0_ & 0x00000040) != 0) {
        output.writeBool(FieldNames.read, read);
      }
      if ((bitField0_ & 0x00000080) != 0) {
        output.writeBool(FieldNames.recv, recv);
      }
      if ((bitField0_ & 0x00000100) != 0) {
        output.writeBool(FieldNames.pin, pin);
      }
      if ((bitField0_ & 0x00000200) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      if ((bitField0_ & 0x00000400) != 0) {
        output.writeString(FieldNames.subject, subject);
      }
      if ((bitField0_ & 0x00000800) != 0) {
        output.writeString(FieldNames.desc, desc);
      }
      if ((bitField0_ & 0x00001000) != 0) {
        output.writeString(FieldNames.author, author);
      }
      if ((bitField0_ & 0x00002000) != 0) {
        output.writeRepeatedMessage(FieldNames.attachments, attachments);
      }
      if ((bitField0_ & 0x00004000) != 0) {
        output.writeRepeatedString(FieldNames.subjectArgs, subjectArgs);
      }
      if ((bitField0_ & 0x00008000) != 0) {
        output.writeRepeatedString(FieldNames.descArgs, descArgs);
      }
      output.endObject();
    }

    @Override
    public Mail mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 2606829: {
            if (input.isAtField(FieldNames.time)) {
              if (!input.trySkipNullValue()) {
                time = input.readInt64();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 568278648: {
            if (input.isAtField(FieldNames.deadline)) {
              if (!input.trySkipNullValue()) {
                deadline = input.readInt64();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1536055755: {
            if (input.isAtField(FieldNames.surveyId)) {
              if (!input.trySkipNullValue()) {
                surveyId = input.readInt64();
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 2192268: {
            if (input.isAtField(FieldNames.flag)) {
              if (!input.trySkipNullValue()) {
                flag = input.readUInt64();
                bitField0_ |= 0x00000008;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 2363: {
            if (input.isAtField(FieldNames.id)) {
              if (!input.trySkipNullValue()) {
                id = input.readUInt32();
                bitField0_ |= 0x00000010;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -997491883: {
            if (input.isAtField(FieldNames.templateId)) {
              if (!input.trySkipNullValue()) {
                templateId = input.readUInt32();
                bitField0_ |= 0x00000020;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 2543030: {
            if (input.isAtField(FieldNames.read)) {
              if (!input.trySkipNullValue()) {
                read = input.readBool();
                bitField0_ |= 0x00000040;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 2543110: {
            if (input.isAtField(FieldNames.recv)) {
              if (!input.trySkipNullValue()) {
                recv = input.readBool();
                bitField0_ |= 0x00000080;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 80245: {
            if (input.isAtField(FieldNames.pin)) {
              if (!input.trySkipNullValue()) {
                pin = input.readBool();
                bitField0_ |= 0x00000100;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000200;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -203231988: {
            if (input.isAtField(FieldNames.subject)) {
              if (!input.trySkipNullValue()) {
                input.readString(subject);
                bitField0_ |= 0x00000400;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 2126513: {
            if (input.isAtField(FieldNames.desc)) {
              if (!input.trySkipNullValue()) {
                input.readString(desc);
                bitField0_ |= 0x00000800;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 1972506027: {
            if (input.isAtField(FieldNames.author)) {
              if (!input.trySkipNullValue()) {
                input.readString(author);
                bitField0_ |= 0x00001000;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 928871312: {
            if (input.isAtField(FieldNames.attachments)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedMessage(attachments);
                bitField0_ |= 0x00002000;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 1064094729: {
            if (input.isAtField(FieldNames.subjectArgs)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedString(subjectArgs);
                bitField0_ |= 0x00004000;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 1081407278: {
            if (input.isAtField(FieldNames.descArgs)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedString(descArgs);
                bitField0_ |= 0x00008000;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public Mail clone() {
      return new Mail().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static Mail parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new Mail(), data).checkInitialized();
    }

    public static Mail parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new Mail(), input).checkInitialized();
    }

    public static Mail parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new Mail(), input).checkInitialized();
    }

    /**
     * @return factory for creating Mail messages
     */
    public static MessageFactory<Mail> getFactory() {
      return MailFactory.INSTANCE;
    }

    private enum MailFactory implements MessageFactory<Mail> {
      INSTANCE;

      @Override
      public Mail create() {
        return Mail.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName time = FieldName.forField("Time");

      static final FieldName deadline = FieldName.forField("Deadline");

      static final FieldName surveyId = FieldName.forField("SurveyId");

      static final FieldName flag = FieldName.forField("Flag");

      static final FieldName id = FieldName.forField("Id");

      static final FieldName templateId = FieldName.forField("TemplateId");

      static final FieldName read = FieldName.forField("Read");

      static final FieldName recv = FieldName.forField("Recv");

      static final FieldName pin = FieldName.forField("Pin");

      static final FieldName nextPackage = FieldName.forField("NextPackage");

      static final FieldName subject = FieldName.forField("Subject");

      static final FieldName desc = FieldName.forField("Desc");

      static final FieldName author = FieldName.forField("Author");

      static final FieldName attachments = FieldName.forField("Attachments");

      static final FieldName subjectArgs = FieldName.forField("SubjectArgs");

      static final FieldName descArgs = FieldName.forField("DescArgs");
    }
  }

  /**
   * Protobuf type {@code Mails}
   */
  public static final class Mails extends ProtoMessage<Mails> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    /**
     * <code>repeated .Mail List = 1;</code>
     */
    private final RepeatedMessage<Mail> list = RepeatedMessage.newEmptyInstance(Mail.getFactory());

    private Mails() {
    }

    /**
     * @return a new empty instance of {@code Mails}
     */
    public static Mails newInstance() {
      return new Mails();
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public Mails clearNextPackage() {
      bitField0_ &= ~0x00000001;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000001;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public Mails addNextPackage(final byte value) {
      bitField0_ |= 0x00000001;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public Mails addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000001;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public Mails setNextPackage(final byte... values) {
      bitField0_ |= 0x00000001;
      nextPackage.copyFrom(values);
      return this;
    }

    /**
     * <code>repeated .Mail List = 1;</code>
     * @return whether the list field is set
     */
    public boolean hasList() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>repeated .Mail List = 1;</code>
     * @return this
     */
    public Mails clearList() {
      bitField0_ &= ~0x00000002;
      list.clear();
      return this;
    }

    /**
     * <code>repeated .Mail List = 1;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableList()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<Mail> getList() {
      return list;
    }

    /**
     * <code>repeated .Mail List = 1;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<Mail> getMutableList() {
      bitField0_ |= 0x00000002;
      return list;
    }

    /**
     * <code>repeated .Mail List = 1;</code>
     * @param value the list to add
     * @return this
     */
    public Mails addList(final Mail value) {
      bitField0_ |= 0x00000002;
      list.add(value);
      return this;
    }

    /**
     * <code>repeated .Mail List = 1;</code>
     * @param values the list to add
     * @return this
     */
    public Mails addAllList(final Mail... values) {
      bitField0_ |= 0x00000002;
      list.addAll(values);
      return this;
    }

    @Override
    public Mails copyFrom(final Mails other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        nextPackage.copyFrom(other.nextPackage);
        list.copyFrom(other.list);
      }
      return this;
    }

    @Override
    public Mails mergeFrom(final Mails other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      if (other.hasList()) {
        getMutableList().addAll(other.list);
      }
      return this;
    }

    @Override
    public Mails clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      list.clear();
      return this;
    }

    @Override
    public Mails clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      list.clearQuick();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof Mails)) {
        return false;
      }
      Mails other = (Mails) o;
      return bitField0_ == other.bitField0_
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage))
        && (!hasList() || list.equals(other.list));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        for (int i = 0; i < list.length(); i++) {
          output.writeRawByte((byte) 10);
          output.writeMessageNoTag(list.get(i));
        }
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += (1 * list.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(list);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public Mails mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 10) {
              break;
            }
          }
          case 10: {
            // list
            tag = input.readRepeatedMessage(list, tag);
            bitField0_ |= 0x00000002;
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRepeatedMessage(FieldNames.list, list);
      }
      output.endObject();
    }

    @Override
    public Mails mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 2368702: {
            if (input.isAtField(FieldNames.list)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedMessage(list);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public Mails clone() {
      return new Mails().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static Mails parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new Mails(), data).checkInitialized();
    }

    public static Mails parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new Mails(), input).checkInitialized();
    }

    public static Mails parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new Mails(), input).checkInitialized();
    }

    /**
     * @return factory for creating Mails messages
     */
    public static MessageFactory<Mails> getFactory() {
      return MailsFactory.INSTANCE;
    }

    private enum MailsFactory implements MessageFactory<Mails> {
      INSTANCE;

      @Override
      public Mails create() {
        return Mails.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName nextPackage = FieldName.forField("NextPackage");

      static final FieldName list = FieldName.forField("List");
    }
  }

  /**
   * Protobuf type {@code MailRequest}
   */
  public static final class MailRequest extends ProtoMessage<MailRequest> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional uint64 Flag = 2;</code>
     */
    private long flag;

    /**
     * <code>optional uint32 Id = 1;</code>
     */
    private int id;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    private MailRequest() {
    }

    /**
     * @return a new empty instance of {@code MailRequest}
     */
    public static MailRequest newInstance() {
      return new MailRequest();
    }

    /**
     * <code>optional uint64 Flag = 2;</code>
     * @return whether the flag field is set
     */
    public boolean hasFlag() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional uint64 Flag = 2;</code>
     * @return this
     */
    public MailRequest clearFlag() {
      bitField0_ &= ~0x00000001;
      flag = 0L;
      return this;
    }

    /**
     * <code>optional uint64 Flag = 2;</code>
     * @return the flag
     */
    public long getFlag() {
      return flag;
    }

    /**
     * <code>optional uint64 Flag = 2;</code>
     * @param value the flag to set
     * @return this
     */
    public MailRequest setFlag(final long value) {
      bitField0_ |= 0x00000001;
      flag = value;
      return this;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @return whether the id field is set
     */
    public boolean hasId() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @return this
     */
    public MailRequest clearId() {
      bitField0_ &= ~0x00000002;
      id = 0;
      return this;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @return the id
     */
    public int getId() {
      return id;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @param value the id to set
     * @return this
     */
    public MailRequest setId(final int value) {
      bitField0_ |= 0x00000002;
      id = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public MailRequest clearNextPackage() {
      bitField0_ &= ~0x00000004;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000004;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public MailRequest addNextPackage(final byte value) {
      bitField0_ |= 0x00000004;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public MailRequest addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000004;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public MailRequest setNextPackage(final byte... values) {
      bitField0_ |= 0x00000004;
      nextPackage.copyFrom(values);
      return this;
    }

    @Override
    public MailRequest copyFrom(final MailRequest other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        flag = other.flag;
        id = other.id;
        nextPackage.copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public MailRequest mergeFrom(final MailRequest other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasFlag()) {
        setFlag(other.flag);
      }
      if (other.hasId()) {
        setId(other.id);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public MailRequest clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      flag = 0L;
      id = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public MailRequest clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof MailRequest)) {
        return false;
      }
      MailRequest other = (MailRequest) o;
      return bitField0_ == other.bitField0_
        && (!hasFlag() || flag == other.flag)
        && (!hasId() || id == other.id)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 16);
        output.writeUInt64NoTag(flag);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt32NoTag(id);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeUInt64SizeNoTag(flag);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(id);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public MailRequest mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 16: {
            // flag
            flag = input.readUInt64();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 8) {
              break;
            }
          }
          case 8: {
            // id
            id = input.readUInt32();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeUInt64(FieldNames.flag, flag);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeUInt32(FieldNames.id, id);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      output.endObject();
    }

    @Override
    public MailRequest mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 2192268: {
            if (input.isAtField(FieldNames.flag)) {
              if (!input.trySkipNullValue()) {
                flag = input.readUInt64();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 2363: {
            if (input.isAtField(FieldNames.id)) {
              if (!input.trySkipNullValue()) {
                id = input.readUInt32();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public MailRequest clone() {
      return new MailRequest().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static MailRequest parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new MailRequest(), data).checkInitialized();
    }

    public static MailRequest parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new MailRequest(), input).checkInitialized();
    }

    public static MailRequest parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new MailRequest(), input).checkInitialized();
    }

    /**
     * @return factory for creating MailRequest messages
     */
    public static MessageFactory<MailRequest> getFactory() {
      return MailRequestFactory.INSTANCE;
    }

    private enum MailRequestFactory implements MessageFactory<MailRequest> {
      INSTANCE;

      @Override
      public MailRequest create() {
        return MailRequest.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName flag = FieldName.forField("Flag");

      static final FieldName id = FieldName.forField("Id");

      static final FieldName nextPackage = FieldName.forField("NextPackage");
    }
  }

  /**
   * Protobuf type {@code MailState}
   */
  public static final class MailState extends ProtoMessage<MailState> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional bool New = 1;</code>
     */
    private boolean new_;

    /**
     * <code>optional bool Revoke = 2;</code>
     */
    private boolean revoke;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    private MailState() {
    }

    /**
     * @return a new empty instance of {@code MailState}
     */
    public static MailState newInstance() {
      return new MailState();
    }

    /**
     * <code>optional bool New = 1;</code>
     * @return whether the new_ field is set
     */
    public boolean hasNew() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional bool New = 1;</code>
     * @return this
     */
    public MailState clearNew() {
      bitField0_ &= ~0x00000001;
      new_ = false;
      return this;
    }

    /**
     * <code>optional bool New = 1;</code>
     * @return the new_
     */
    public boolean getNew() {
      return new_;
    }

    /**
     * <code>optional bool New = 1;</code>
     * @param value the new_ to set
     * @return this
     */
    public MailState setNew(final boolean value) {
      bitField0_ |= 0x00000001;
      new_ = value;
      return this;
    }

    /**
     * <code>optional bool Revoke = 2;</code>
     * @return whether the revoke field is set
     */
    public boolean hasRevoke() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional bool Revoke = 2;</code>
     * @return this
     */
    public MailState clearRevoke() {
      bitField0_ &= ~0x00000002;
      revoke = false;
      return this;
    }

    /**
     * <code>optional bool Revoke = 2;</code>
     * @return the revoke
     */
    public boolean getRevoke() {
      return revoke;
    }

    /**
     * <code>optional bool Revoke = 2;</code>
     * @param value the revoke to set
     * @return this
     */
    public MailState setRevoke(final boolean value) {
      bitField0_ |= 0x00000002;
      revoke = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public MailState clearNextPackage() {
      bitField0_ &= ~0x00000004;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000004;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public MailState addNextPackage(final byte value) {
      bitField0_ |= 0x00000004;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public MailState addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000004;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public MailState setNextPackage(final byte... values) {
      bitField0_ |= 0x00000004;
      nextPackage.copyFrom(values);
      return this;
    }

    @Override
    public MailState copyFrom(final MailState other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        new_ = other.new_;
        revoke = other.revoke;
        nextPackage.copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public MailState mergeFrom(final MailState other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasNew()) {
        setNew(other.new_);
      }
      if (other.hasRevoke()) {
        setRevoke(other.revoke);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public MailState clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      new_ = false;
      revoke = false;
      nextPackage.clear();
      return this;
    }

    @Override
    public MailState clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof MailState)) {
        return false;
      }
      MailState other = (MailState) o;
      return bitField0_ == other.bitField0_
        && (!hasNew() || new_ == other.new_)
        && (!hasRevoke() || revoke == other.revoke)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 8);
        output.writeBoolNoTag(new_);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 16);
        output.writeBoolNoTag(revoke);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 2;
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 2;
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public MailState mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            // new_
            new_ = input.readBool();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 16) {
              break;
            }
          }
          case 16: {
            // revoke
            revoke = input.readBool();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeBool(FieldNames.new_, new_);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeBool(FieldNames.revoke, revoke);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      output.endObject();
    }

    @Override
    public MailState mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 78208: {
            if (input.isAtField(FieldNames.new_)) {
              if (!input.trySkipNullValue()) {
                new_ = input.readBool();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1850475866: {
            if (input.isAtField(FieldNames.revoke)) {
              if (!input.trySkipNullValue()) {
                revoke = input.readBool();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public MailState clone() {
      return new MailState().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static MailState parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new MailState(), data).checkInitialized();
    }

    public static MailState parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new MailState(), input).checkInitialized();
    }

    public static MailState parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new MailState(), input).checkInitialized();
    }

    /**
     * @return factory for creating MailState messages
     */
    public static MessageFactory<MailState> getFactory() {
      return MailStateFactory.INSTANCE;
    }

    private enum MailStateFactory implements MessageFactory<MailState> {
      INSTANCE;

      @Override
      public MailState create() {
        return MailState.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName new_ = FieldName.forField("New");

      static final FieldName revoke = FieldName.forField("Revoke");

      static final FieldName nextPackage = FieldName.forField("NextPackage");
    }
  }

  /**
   * Protobuf type {@code AchievementState}
   */
  public static final class AchievementState extends ProtoMessage<AchievementState> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional bool New = 1;</code>
     */
    private boolean new_;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    private AchievementState() {
    }

    /**
     * @return a new empty instance of {@code AchievementState}
     */
    public static AchievementState newInstance() {
      return new AchievementState();
    }

    /**
     * <code>optional bool New = 1;</code>
     * @return whether the new_ field is set
     */
    public boolean hasNew() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional bool New = 1;</code>
     * @return this
     */
    public AchievementState clearNew() {
      bitField0_ &= ~0x00000001;
      new_ = false;
      return this;
    }

    /**
     * <code>optional bool New = 1;</code>
     * @return the new_
     */
    public boolean getNew() {
      return new_;
    }

    /**
     * <code>optional bool New = 1;</code>
     * @param value the new_ to set
     * @return this
     */
    public AchievementState setNew(final boolean value) {
      bitField0_ |= 0x00000001;
      new_ = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public AchievementState clearNextPackage() {
      bitField0_ &= ~0x00000002;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000002;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public AchievementState addNextPackage(final byte value) {
      bitField0_ |= 0x00000002;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public AchievementState addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000002;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public AchievementState setNextPackage(final byte... values) {
      bitField0_ |= 0x00000002;
      nextPackage.copyFrom(values);
      return this;
    }

    @Override
    public AchievementState copyFrom(final AchievementState other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        new_ = other.new_;
        nextPackage.copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public AchievementState mergeFrom(final AchievementState other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasNew()) {
        setNew(other.new_);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public AchievementState clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      new_ = false;
      nextPackage.clear();
      return this;
    }

    @Override
    public AchievementState clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof AchievementState)) {
        return false;
      }
      AchievementState other = (AchievementState) o;
      return bitField0_ == other.bitField0_
        && (!hasNew() || new_ == other.new_)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 8);
        output.writeBoolNoTag(new_);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 2;
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public AchievementState mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            // new_
            new_ = input.readBool();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeBool(FieldNames.new_, new_);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      output.endObject();
    }

    @Override
    public AchievementState mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 78208: {
            if (input.isAtField(FieldNames.new_)) {
              if (!input.trySkipNullValue()) {
                new_ = input.readBool();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public AchievementState clone() {
      return new AchievementState().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static AchievementState parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new AchievementState(), data).checkInitialized();
    }

    public static AchievementState parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new AchievementState(), input).checkInitialized();
    }

    public static AchievementState parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new AchievementState(), input).checkInitialized();
    }

    /**
     * @return factory for creating AchievementState messages
     */
    public static MessageFactory<AchievementState> getFactory() {
      return AchievementStateFactory.INSTANCE;
    }

    private enum AchievementStateFactory implements MessageFactory<AchievementState> {
      INSTANCE;

      @Override
      public AchievementState create() {
        return AchievementState.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName new_ = FieldName.forField("New");

      static final FieldName nextPackage = FieldName.forField("NextPackage");
    }
  }

  /**
   * Protobuf type {@code FriendState}
   */
  public static final class FriendState extends ProtoMessage<FriendState> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional uint64 Id = 1;</code>
     */
    private long id;

    /**
     * <code>optional uint32 Action = 2;</code>
     */
    private int action;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    private FriendState() {
    }

    /**
     * @return a new empty instance of {@code FriendState}
     */
    public static FriendState newInstance() {
      return new FriendState();
    }

    /**
     * <code>optional uint64 Id = 1;</code>
     * @return whether the id field is set
     */
    public boolean hasId() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional uint64 Id = 1;</code>
     * @return this
     */
    public FriendState clearId() {
      bitField0_ &= ~0x00000001;
      id = 0L;
      return this;
    }

    /**
     * <code>optional uint64 Id = 1;</code>
     * @return the id
     */
    public long getId() {
      return id;
    }

    /**
     * <code>optional uint64 Id = 1;</code>
     * @param value the id to set
     * @return this
     */
    public FriendState setId(final long value) {
      bitField0_ |= 0x00000001;
      id = value;
      return this;
    }

    /**
     * <code>optional uint32 Action = 2;</code>
     * @return whether the action field is set
     */
    public boolean hasAction() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional uint32 Action = 2;</code>
     * @return this
     */
    public FriendState clearAction() {
      bitField0_ &= ~0x00000002;
      action = 0;
      return this;
    }

    /**
     * <code>optional uint32 Action = 2;</code>
     * @return the action
     */
    public int getAction() {
      return action;
    }

    /**
     * <code>optional uint32 Action = 2;</code>
     * @param value the action to set
     * @return this
     */
    public FriendState setAction(final int value) {
      bitField0_ |= 0x00000002;
      action = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public FriendState clearNextPackage() {
      bitField0_ &= ~0x00000004;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000004;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public FriendState addNextPackage(final byte value) {
      bitField0_ |= 0x00000004;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public FriendState addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000004;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public FriendState setNextPackage(final byte... values) {
      bitField0_ |= 0x00000004;
      nextPackage.copyFrom(values);
      return this;
    }

    @Override
    public FriendState copyFrom(final FriendState other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        id = other.id;
        action = other.action;
        nextPackage.copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public FriendState mergeFrom(final FriendState other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasId()) {
        setId(other.id);
      }
      if (other.hasAction()) {
        setAction(other.action);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public FriendState clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      id = 0L;
      action = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public FriendState clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof FriendState)) {
        return false;
      }
      FriendState other = (FriendState) o;
      return bitField0_ == other.bitField0_
        && (!hasId() || id == other.id)
        && (!hasAction() || action == other.action)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt64NoTag(id);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 16);
        output.writeUInt32NoTag(action);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeUInt64SizeNoTag(id);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(action);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public FriendState mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            // id
            id = input.readUInt64();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 16) {
              break;
            }
          }
          case 16: {
            // action
            action = input.readUInt32();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeUInt64(FieldNames.id, id);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeUInt32(FieldNames.action, action);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      output.endObject();
    }

    @Override
    public FriendState mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 2363: {
            if (input.isAtField(FieldNames.id)) {
              if (!input.trySkipNullValue()) {
                id = input.readUInt64();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 1955883606: {
            if (input.isAtField(FieldNames.action)) {
              if (!input.trySkipNullValue()) {
                action = input.readUInt32();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public FriendState clone() {
      return new FriendState().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static FriendState parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new FriendState(), data).checkInitialized();
    }

    public static FriendState parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new FriendState(), input).checkInitialized();
    }

    public static FriendState parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new FriendState(), input).checkInitialized();
    }

    /**
     * @return factory for creating FriendState messages
     */
    public static MessageFactory<FriendState> getFactory() {
      return FriendStateFactory.INSTANCE;
    }

    private enum FriendStateFactory implements MessageFactory<FriendState> {
      INSTANCE;

      @Override
      public FriendState create() {
        return FriendState.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName id = FieldName.forField("Id");

      static final FieldName action = FieldName.forField("Action");

      static final FieldName nextPackage = FieldName.forField("NextPackage");
    }
  }

  /**
   * Protobuf type {@code BattlePassState}
   */
  public static final class BattlePassState extends ProtoMessage<BattlePassState> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional int32 State = 1;</code>
     */
    private int state;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    private BattlePassState() {
    }

    /**
     * @return a new empty instance of {@code BattlePassState}
     */
    public static BattlePassState newInstance() {
      return new BattlePassState();
    }

    /**
     * <code>optional int32 State = 1;</code>
     * @return whether the state field is set
     */
    public boolean hasState() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional int32 State = 1;</code>
     * @return this
     */
    public BattlePassState clearState() {
      bitField0_ &= ~0x00000001;
      state = 0;
      return this;
    }

    /**
     * <code>optional int32 State = 1;</code>
     * @return the state
     */
    public int getState() {
      return state;
    }

    /**
     * <code>optional int32 State = 1;</code>
     * @param value the state to set
     * @return this
     */
    public BattlePassState setState(final int value) {
      bitField0_ |= 0x00000001;
      state = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public BattlePassState clearNextPackage() {
      bitField0_ &= ~0x00000002;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000002;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public BattlePassState addNextPackage(final byte value) {
      bitField0_ |= 0x00000002;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public BattlePassState addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000002;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public BattlePassState setNextPackage(final byte... values) {
      bitField0_ |= 0x00000002;
      nextPackage.copyFrom(values);
      return this;
    }

    @Override
    public BattlePassState copyFrom(final BattlePassState other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        state = other.state;
        nextPackage.copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public BattlePassState mergeFrom(final BattlePassState other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasState()) {
        setState(other.state);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public BattlePassState clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      state = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public BattlePassState clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof BattlePassState)) {
        return false;
      }
      BattlePassState other = (BattlePassState) o;
      return bitField0_ == other.bitField0_
        && (!hasState() || state == other.state)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 8);
        output.writeInt32NoTag(state);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeInt32SizeNoTag(state);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public BattlePassState mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            // state
            state = input.readInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeInt32(FieldNames.state, state);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      output.endObject();
    }

    @Override
    public BattlePassState mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 80204913: {
            if (input.isAtField(FieldNames.state)) {
              if (!input.trySkipNullValue()) {
                state = input.readInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public BattlePassState clone() {
      return new BattlePassState().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static BattlePassState parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new BattlePassState(), data).checkInitialized();
    }

    public static BattlePassState parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new BattlePassState(), input).checkInitialized();
    }

    public static BattlePassState parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new BattlePassState(), input).checkInitialized();
    }

    /**
     * @return factory for creating BattlePassState messages
     */
    public static MessageFactory<BattlePassState> getFactory() {
      return BattlePassStateFactory.INSTANCE;
    }

    private enum BattlePassStateFactory implements MessageFactory<BattlePassState> {
      INSTANCE;

      @Override
      public BattlePassState create() {
        return BattlePassState.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName state = FieldName.forField("State");

      static final FieldName nextPackage = FieldName.forField("NextPackage");
    }
  }

  /**
   * Protobuf type {@code CharAdvanceRewardState}
   */
  public static final class CharAdvanceRewardState extends ProtoMessage<CharAdvanceRewardState> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional uint32 CharId = 1;</code>
     */
    private int charId;

    /**
     * <code>optional bytes Flag = 2;</code>
     */
    private final RepeatedByte flag = RepeatedByte.newEmptyInstance();

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    private CharAdvanceRewardState() {
    }

    /**
     * @return a new empty instance of {@code CharAdvanceRewardState}
     */
    public static CharAdvanceRewardState newInstance() {
      return new CharAdvanceRewardState();
    }

    /**
     * <code>optional uint32 CharId = 1;</code>
     * @return whether the charId field is set
     */
    public boolean hasCharId() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional uint32 CharId = 1;</code>
     * @return this
     */
    public CharAdvanceRewardState clearCharId() {
      bitField0_ &= ~0x00000001;
      charId = 0;
      return this;
    }

    /**
     * <code>optional uint32 CharId = 1;</code>
     * @return the charId
     */
    public int getCharId() {
      return charId;
    }

    /**
     * <code>optional uint32 CharId = 1;</code>
     * @param value the charId to set
     * @return this
     */
    public CharAdvanceRewardState setCharId(final int value) {
      bitField0_ |= 0x00000001;
      charId = value;
      return this;
    }

    /**
     * <code>optional bytes Flag = 2;</code>
     * @return whether the flag field is set
     */
    public boolean hasFlag() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional bytes Flag = 2;</code>
     * @return this
     */
    public CharAdvanceRewardState clearFlag() {
      bitField0_ &= ~0x00000002;
      flag.clear();
      return this;
    }

    /**
     * <code>optional bytes Flag = 2;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableFlag()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getFlag() {
      return flag;
    }

    /**
     * <code>optional bytes Flag = 2;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableFlag() {
      bitField0_ |= 0x00000002;
      return flag;
    }

    /**
     * <code>optional bytes Flag = 2;</code>
     * @param value the flag to add
     * @return this
     */
    public CharAdvanceRewardState addFlag(final byte value) {
      bitField0_ |= 0x00000002;
      flag.add(value);
      return this;
    }

    /**
     * <code>optional bytes Flag = 2;</code>
     * @param values the flag to add
     * @return this
     */
    public CharAdvanceRewardState addAllFlag(final byte... values) {
      bitField0_ |= 0x00000002;
      flag.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes Flag = 2;</code>
     * @param values the flag to set
     * @return this
     */
    public CharAdvanceRewardState setFlag(final byte... values) {
      bitField0_ |= 0x00000002;
      flag.copyFrom(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public CharAdvanceRewardState clearNextPackage() {
      bitField0_ &= ~0x00000004;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000004;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public CharAdvanceRewardState addNextPackage(final byte value) {
      bitField0_ |= 0x00000004;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public CharAdvanceRewardState addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000004;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public CharAdvanceRewardState setNextPackage(final byte... values) {
      bitField0_ |= 0x00000004;
      nextPackage.copyFrom(values);
      return this;
    }

    @Override
    public CharAdvanceRewardState copyFrom(final CharAdvanceRewardState other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        charId = other.charId;
        flag.copyFrom(other.flag);
        nextPackage.copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public CharAdvanceRewardState mergeFrom(final CharAdvanceRewardState other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasCharId()) {
        setCharId(other.charId);
      }
      if (other.hasFlag()) {
        getMutableFlag().copyFrom(other.flag);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public CharAdvanceRewardState clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      charId = 0;
      flag.clear();
      nextPackage.clear();
      return this;
    }

    @Override
    public CharAdvanceRewardState clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      flag.clear();
      nextPackage.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof CharAdvanceRewardState)) {
        return false;
      }
      CharAdvanceRewardState other = (CharAdvanceRewardState) o;
      return bitField0_ == other.bitField0_
        && (!hasCharId() || charId == other.charId)
        && (!hasFlag() || flag.equals(other.flag))
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt32NoTag(charId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 18);
        output.writeBytesNoTag(flag);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(charId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeBytesSizeNoTag(flag);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public CharAdvanceRewardState mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            // charId
            charId = input.readUInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 18) {
              break;
            }
          }
          case 18: {
            // flag
            input.readBytes(flag);
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeUInt32(FieldNames.charId, charId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeBytes(FieldNames.flag, flag);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      output.endObject();
    }

    @Override
    public CharAdvanceRewardState mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 2017200945: {
            if (input.isAtField(FieldNames.charId)) {
              if (!input.trySkipNullValue()) {
                charId = input.readUInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 2192268: {
            if (input.isAtField(FieldNames.flag)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(flag);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public CharAdvanceRewardState clone() {
      return new CharAdvanceRewardState().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static CharAdvanceRewardState parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new CharAdvanceRewardState(), data).checkInitialized();
    }

    public static CharAdvanceRewardState parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new CharAdvanceRewardState(), input).checkInitialized();
    }

    public static CharAdvanceRewardState parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new CharAdvanceRewardState(), input).checkInitialized();
    }

    /**
     * @return factory for creating CharAdvanceRewardState messages
     */
    public static MessageFactory<CharAdvanceRewardState> getFactory() {
      return CharAdvanceRewardStateFactory.INSTANCE;
    }

    private enum CharAdvanceRewardStateFactory implements MessageFactory<CharAdvanceRewardState> {
      INSTANCE;

      @Override
      public CharAdvanceRewardState create() {
        return CharAdvanceRewardState.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName charId = FieldName.forField("CharId");

      static final FieldName flag = FieldName.forField("Flag");

      static final FieldName nextPackage = FieldName.forField("NextPackage");
    }
  }

  /**
   * Protobuf type {@code WorldClassRewardState}
   */
  public static final class WorldClassRewardState extends ProtoMessage<WorldClassRewardState> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional bytes Flag = 1;</code>
     */
    private final RepeatedByte flag = RepeatedByte.newEmptyInstance();

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    private WorldClassRewardState() {
    }

    /**
     * @return a new empty instance of {@code WorldClassRewardState}
     */
    public static WorldClassRewardState newInstance() {
      return new WorldClassRewardState();
    }

    /**
     * <code>optional bytes Flag = 1;</code>
     * @return whether the flag field is set
     */
    public boolean hasFlag() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional bytes Flag = 1;</code>
     * @return this
     */
    public WorldClassRewardState clearFlag() {
      bitField0_ &= ~0x00000001;
      flag.clear();
      return this;
    }

    /**
     * <code>optional bytes Flag = 1;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableFlag()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getFlag() {
      return flag;
    }

    /**
     * <code>optional bytes Flag = 1;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableFlag() {
      bitField0_ |= 0x00000001;
      return flag;
    }

    /**
     * <code>optional bytes Flag = 1;</code>
     * @param value the flag to add
     * @return this
     */
    public WorldClassRewardState addFlag(final byte value) {
      bitField0_ |= 0x00000001;
      flag.add(value);
      return this;
    }

    /**
     * <code>optional bytes Flag = 1;</code>
     * @param values the flag to add
     * @return this
     */
    public WorldClassRewardState addAllFlag(final byte... values) {
      bitField0_ |= 0x00000001;
      flag.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes Flag = 1;</code>
     * @param values the flag to set
     * @return this
     */
    public WorldClassRewardState setFlag(final byte... values) {
      bitField0_ |= 0x00000001;
      flag.copyFrom(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public WorldClassRewardState clearNextPackage() {
      bitField0_ &= ~0x00000002;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000002;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public WorldClassRewardState addNextPackage(final byte value) {
      bitField0_ |= 0x00000002;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public WorldClassRewardState addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000002;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public WorldClassRewardState setNextPackage(final byte... values) {
      bitField0_ |= 0x00000002;
      nextPackage.copyFrom(values);
      return this;
    }

    @Override
    public WorldClassRewardState copyFrom(final WorldClassRewardState other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        flag.copyFrom(other.flag);
        nextPackage.copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public WorldClassRewardState mergeFrom(final WorldClassRewardState other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasFlag()) {
        getMutableFlag().copyFrom(other.flag);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public WorldClassRewardState clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      flag.clear();
      nextPackage.clear();
      return this;
    }

    @Override
    public WorldClassRewardState clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      flag.clear();
      nextPackage.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof WorldClassRewardState)) {
        return false;
      }
      WorldClassRewardState other = (WorldClassRewardState) o;
      return bitField0_ == other.bitField0_
        && (!hasFlag() || flag.equals(other.flag))
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 10);
        output.writeBytesNoTag(flag);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeBytesSizeNoTag(flag);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public WorldClassRewardState mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 10: {
            // flag
            input.readBytes(flag);
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeBytes(FieldNames.flag, flag);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      output.endObject();
    }

    @Override
    public WorldClassRewardState mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 2192268: {
            if (input.isAtField(FieldNames.flag)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(flag);
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public WorldClassRewardState clone() {
      return new WorldClassRewardState().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static WorldClassRewardState parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new WorldClassRewardState(), data).checkInitialized();
    }

    public static WorldClassRewardState parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new WorldClassRewardState(), input).checkInitialized();
    }

    public static WorldClassRewardState parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new WorldClassRewardState(), input).checkInitialized();
    }

    /**
     * @return factory for creating WorldClassRewardState messages
     */
    public static MessageFactory<WorldClassRewardState> getFactory() {
      return WorldClassRewardStateFactory.INSTANCE;
    }

    private enum WorldClassRewardStateFactory implements MessageFactory<WorldClassRewardState> {
      INSTANCE;

      @Override
      public WorldClassRewardState create() {
        return WorldClassRewardState.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName flag = FieldName.forField("Flag");

      static final FieldName nextPackage = FieldName.forField("NextPackage");
    }
  }

  /**
   * Protobuf type {@code FriendEnergyState}
   */
  public static final class FriendEnergyState extends ProtoMessage<FriendEnergyState> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional bool State = 1;</code>
     */
    private boolean state;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    private FriendEnergyState() {
    }

    /**
     * @return a new empty instance of {@code FriendEnergyState}
     */
    public static FriendEnergyState newInstance() {
      return new FriendEnergyState();
    }

    /**
     * <code>optional bool State = 1;</code>
     * @return whether the state field is set
     */
    public boolean hasState() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional bool State = 1;</code>
     * @return this
     */
    public FriendEnergyState clearState() {
      bitField0_ &= ~0x00000001;
      state = false;
      return this;
    }

    /**
     * <code>optional bool State = 1;</code>
     * @return the state
     */
    public boolean getState() {
      return state;
    }

    /**
     * <code>optional bool State = 1;</code>
     * @param value the state to set
     * @return this
     */
    public FriendEnergyState setState(final boolean value) {
      bitField0_ |= 0x00000001;
      state = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public FriendEnergyState clearNextPackage() {
      bitField0_ &= ~0x00000002;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000002;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public FriendEnergyState addNextPackage(final byte value) {
      bitField0_ |= 0x00000002;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public FriendEnergyState addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000002;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public FriendEnergyState setNextPackage(final byte... values) {
      bitField0_ |= 0x00000002;
      nextPackage.copyFrom(values);
      return this;
    }

    @Override
    public FriendEnergyState copyFrom(final FriendEnergyState other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        state = other.state;
        nextPackage.copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public FriendEnergyState mergeFrom(final FriendEnergyState other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasState()) {
        setState(other.state);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public FriendEnergyState clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      state = false;
      nextPackage.clear();
      return this;
    }

    @Override
    public FriendEnergyState clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof FriendEnergyState)) {
        return false;
      }
      FriendEnergyState other = (FriendEnergyState) o;
      return bitField0_ == other.bitField0_
        && (!hasState() || state == other.state)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 8);
        output.writeBoolNoTag(state);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 2;
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public FriendEnergyState mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            // state
            state = input.readBool();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeBool(FieldNames.state, state);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      output.endObject();
    }

    @Override
    public FriendEnergyState mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 80204913: {
            if (input.isAtField(FieldNames.state)) {
              if (!input.trySkipNullValue()) {
                state = input.readBool();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public FriendEnergyState clone() {
      return new FriendEnergyState().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static FriendEnergyState parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new FriendEnergyState(), data).checkInitialized();
    }

    public static FriendEnergyState parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new FriendEnergyState(), input).checkInitialized();
    }

    public static FriendEnergyState parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new FriendEnergyState(), input).checkInitialized();
    }

    /**
     * @return factory for creating FriendEnergyState messages
     */
    public static MessageFactory<FriendEnergyState> getFactory() {
      return FriendEnergyStateFactory.INSTANCE;
    }

    private enum FriendEnergyStateFactory implements MessageFactory<FriendEnergyState> {
      INSTANCE;

      @Override
      public FriendEnergyState create() {
        return FriendEnergyState.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName state = FieldName.forField("State");

      static final FieldName nextPackage = FieldName.forField("NextPackage");
    }
  }

  /**
   * Protobuf type {@code CharAffinityRewardState}
   */
  public static final class CharAffinityRewardState extends ProtoMessage<CharAffinityRewardState> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional uint32 CharId = 1;</code>
     */
    private int charId;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    /**
     * <code>repeated uint32 QuestIds = 2;</code>
     */
    private final RepeatedInt questIds = RepeatedInt.newEmptyInstance();

    private CharAffinityRewardState() {
    }

    /**
     * @return a new empty instance of {@code CharAffinityRewardState}
     */
    public static CharAffinityRewardState newInstance() {
      return new CharAffinityRewardState();
    }

    /**
     * <code>optional uint32 CharId = 1;</code>
     * @return whether the charId field is set
     */
    public boolean hasCharId() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional uint32 CharId = 1;</code>
     * @return this
     */
    public CharAffinityRewardState clearCharId() {
      bitField0_ &= ~0x00000001;
      charId = 0;
      return this;
    }

    /**
     * <code>optional uint32 CharId = 1;</code>
     * @return the charId
     */
    public int getCharId() {
      return charId;
    }

    /**
     * <code>optional uint32 CharId = 1;</code>
     * @param value the charId to set
     * @return this
     */
    public CharAffinityRewardState setCharId(final int value) {
      bitField0_ |= 0x00000001;
      charId = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public CharAffinityRewardState clearNextPackage() {
      bitField0_ &= ~0x00000002;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000002;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public CharAffinityRewardState addNextPackage(final byte value) {
      bitField0_ |= 0x00000002;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public CharAffinityRewardState addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000002;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public CharAffinityRewardState setNextPackage(final byte... values) {
      bitField0_ |= 0x00000002;
      nextPackage.copyFrom(values);
      return this;
    }

    /**
     * <code>repeated uint32 QuestIds = 2;</code>
     * @return whether the questIds field is set
     */
    public boolean hasQuestIds() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>repeated uint32 QuestIds = 2;</code>
     * @return this
     */
    public CharAffinityRewardState clearQuestIds() {
      bitField0_ &= ~0x00000004;
      questIds.clear();
      return this;
    }

    /**
     * <code>repeated uint32 QuestIds = 2;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableQuestIds()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedInt getQuestIds() {
      return questIds;
    }

    /**
     * <code>repeated uint32 QuestIds = 2;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedInt getMutableQuestIds() {
      bitField0_ |= 0x00000004;
      return questIds;
    }

    /**
     * <code>repeated uint32 QuestIds = 2;</code>
     * @param value the questIds to add
     * @return this
     */
    public CharAffinityRewardState addQuestIds(final int value) {
      bitField0_ |= 0x00000004;
      questIds.add(value);
      return this;
    }

    /**
     * <code>repeated uint32 QuestIds = 2;</code>
     * @param values the questIds to add
     * @return this
     */
    public CharAffinityRewardState addAllQuestIds(final int... values) {
      bitField0_ |= 0x00000004;
      questIds.addAll(values);
      return this;
    }

    @Override
    public CharAffinityRewardState copyFrom(final CharAffinityRewardState other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        charId = other.charId;
        nextPackage.copyFrom(other.nextPackage);
        questIds.copyFrom(other.questIds);
      }
      return this;
    }

    @Override
    public CharAffinityRewardState mergeFrom(final CharAffinityRewardState other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasCharId()) {
        setCharId(other.charId);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      if (other.hasQuestIds()) {
        getMutableQuestIds().addAll(other.questIds);
      }
      return this;
    }

    @Override
    public CharAffinityRewardState clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      charId = 0;
      nextPackage.clear();
      questIds.clear();
      return this;
    }

    @Override
    public CharAffinityRewardState clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      questIds.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof CharAffinityRewardState)) {
        return false;
      }
      CharAffinityRewardState other = (CharAffinityRewardState) o;
      return bitField0_ == other.bitField0_
        && (!hasCharId() || charId == other.charId)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage))
        && (!hasQuestIds() || questIds.equals(other.questIds));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt32NoTag(charId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        for (int i = 0; i < questIds.length(); i++) {
          output.writeRawByte((byte) 16);
          output.writeUInt32NoTag(questIds.array()[i]);
        }
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(charId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += (1 * questIds.length()) + ProtoSink.computeRepeatedUInt32SizeNoTag(questIds);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public CharAffinityRewardState mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            // charId
            charId = input.readUInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 18) {
              break;
            }
          }
          case 18: {
            // questIds [packed=true]
            input.readPackedUInt32(questIds, tag);
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
          case 16: {
            // questIds [packed=false]
            tag = input.readRepeatedUInt32(questIds, tag);
            bitField0_ |= 0x00000004;
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeUInt32(FieldNames.charId, charId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRepeatedUInt32(FieldNames.questIds, questIds);
      }
      output.endObject();
    }

    @Override
    public CharAffinityRewardState mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 2017200945: {
            if (input.isAtField(FieldNames.charId)) {
              if (!input.trySkipNullValue()) {
                charId = input.readUInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1101257066: {
            if (input.isAtField(FieldNames.questIds)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedUInt32(questIds);
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public CharAffinityRewardState clone() {
      return new CharAffinityRewardState().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static CharAffinityRewardState parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new CharAffinityRewardState(), data).checkInitialized();
    }

    public static CharAffinityRewardState parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new CharAffinityRewardState(), input).checkInitialized();
    }

    public static CharAffinityRewardState parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new CharAffinityRewardState(), input).checkInitialized();
    }

    /**
     * @return factory for creating CharAffinityRewardState messages
     */
    public static MessageFactory<CharAffinityRewardState> getFactory() {
      return CharAffinityRewardStateFactory.INSTANCE;
    }

    private enum CharAffinityRewardStateFactory implements MessageFactory<CharAffinityRewardState> {
      INSTANCE;

      @Override
      public CharAffinityRewardState create() {
        return CharAffinityRewardState.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName charId = FieldName.forField("CharId");

      static final FieldName nextPackage = FieldName.forField("NextPackage");

      static final FieldName questIds = FieldName.forField("QuestIds");
    }
  }

  /**
   * Protobuf type {@code StarTowerState}
   */
  public static final class StarTowerState extends ProtoMessage<StarTowerState> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional uint64 BuildId = 3;</code>
     */
    private long buildId;

    /**
     * <code>optional uint32 Id = 1;</code>
     */
    private int id;

    /**
     * <code>optional uint32 ReConnection = 2;</code>
     */
    private int reConnection;

    /**
     * <code>optional uint32 Floor = 6;</code>
     */
    private int floor;

    /**
     * <code>optional bool Sweep = 15;</code>
     */
    private boolean sweep;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    /**
     * <code>repeated uint32 CharIds = 4;</code>
     */
    private final RepeatedInt charIds = RepeatedInt.newEmptyInstance();

    private StarTowerState() {
    }

    /**
     * @return a new empty instance of {@code StarTowerState}
     */
    public static StarTowerState newInstance() {
      return new StarTowerState();
    }

    /**
     * <code>optional uint64 BuildId = 3;</code>
     * @return whether the buildId field is set
     */
    public boolean hasBuildId() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional uint64 BuildId = 3;</code>
     * @return this
     */
    public StarTowerState clearBuildId() {
      bitField0_ &= ~0x00000001;
      buildId = 0L;
      return this;
    }

    /**
     * <code>optional uint64 BuildId = 3;</code>
     * @return the buildId
     */
    public long getBuildId() {
      return buildId;
    }

    /**
     * <code>optional uint64 BuildId = 3;</code>
     * @param value the buildId to set
     * @return this
     */
    public StarTowerState setBuildId(final long value) {
      bitField0_ |= 0x00000001;
      buildId = value;
      return this;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @return whether the id field is set
     */
    public boolean hasId() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @return this
     */
    public StarTowerState clearId() {
      bitField0_ &= ~0x00000002;
      id = 0;
      return this;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @return the id
     */
    public int getId() {
      return id;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @param value the id to set
     * @return this
     */
    public StarTowerState setId(final int value) {
      bitField0_ |= 0x00000002;
      id = value;
      return this;
    }

    /**
     * <code>optional uint32 ReConnection = 2;</code>
     * @return whether the reConnection field is set
     */
    public boolean hasReConnection() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional uint32 ReConnection = 2;</code>
     * @return this
     */
    public StarTowerState clearReConnection() {
      bitField0_ &= ~0x00000004;
      reConnection = 0;
      return this;
    }

    /**
     * <code>optional uint32 ReConnection = 2;</code>
     * @return the reConnection
     */
    public int getReConnection() {
      return reConnection;
    }

    /**
     * <code>optional uint32 ReConnection = 2;</code>
     * @param value the reConnection to set
     * @return this
     */
    public StarTowerState setReConnection(final int value) {
      bitField0_ |= 0x00000004;
      reConnection = value;
      return this;
    }

    /**
     * <code>optional uint32 Floor = 6;</code>
     * @return whether the floor field is set
     */
    public boolean hasFloor() {
      return (bitField0_ & 0x00000008) != 0;
    }

    /**
     * <code>optional uint32 Floor = 6;</code>
     * @return this
     */
    public StarTowerState clearFloor() {
      bitField0_ &= ~0x00000008;
      floor = 0;
      return this;
    }

    /**
     * <code>optional uint32 Floor = 6;</code>
     * @return the floor
     */
    public int getFloor() {
      return floor;
    }

    /**
     * <code>optional uint32 Floor = 6;</code>
     * @param value the floor to set
     * @return this
     */
    public StarTowerState setFloor(final int value) {
      bitField0_ |= 0x00000008;
      floor = value;
      return this;
    }

    /**
     * <code>optional bool Sweep = 15;</code>
     * @return whether the sweep field is set
     */
    public boolean hasSweep() {
      return (bitField0_ & 0x00000010) != 0;
    }

    /**
     * <code>optional bool Sweep = 15;</code>
     * @return this
     */
    public StarTowerState clearSweep() {
      bitField0_ &= ~0x00000010;
      sweep = false;
      return this;
    }

    /**
     * <code>optional bool Sweep = 15;</code>
     * @return the sweep
     */
    public boolean getSweep() {
      return sweep;
    }

    /**
     * <code>optional bool Sweep = 15;</code>
     * @param value the sweep to set
     * @return this
     */
    public StarTowerState setSweep(final boolean value) {
      bitField0_ |= 0x00000010;
      sweep = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000020) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public StarTowerState clearNextPackage() {
      bitField0_ &= ~0x00000020;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000020;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public StarTowerState addNextPackage(final byte value) {
      bitField0_ |= 0x00000020;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public StarTowerState addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000020;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public StarTowerState setNextPackage(final byte... values) {
      bitField0_ |= 0x00000020;
      nextPackage.copyFrom(values);
      return this;
    }

    /**
     * <code>repeated uint32 CharIds = 4;</code>
     * @return whether the charIds field is set
     */
    public boolean hasCharIds() {
      return (bitField0_ & 0x00000040) != 0;
    }

    /**
     * <code>repeated uint32 CharIds = 4;</code>
     * @return this
     */
    public StarTowerState clearCharIds() {
      bitField0_ &= ~0x00000040;
      charIds.clear();
      return this;
    }

    /**
     * <code>repeated uint32 CharIds = 4;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableCharIds()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedInt getCharIds() {
      return charIds;
    }

    /**
     * <code>repeated uint32 CharIds = 4;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedInt getMutableCharIds() {
      bitField0_ |= 0x00000040;
      return charIds;
    }

    /**
     * <code>repeated uint32 CharIds = 4;</code>
     * @param value the charIds to add
     * @return this
     */
    public StarTowerState addCharIds(final int value) {
      bitField0_ |= 0x00000040;
      charIds.add(value);
      return this;
    }

    /**
     * <code>repeated uint32 CharIds = 4;</code>
     * @param values the charIds to add
     * @return this
     */
    public StarTowerState addAllCharIds(final int... values) {
      bitField0_ |= 0x00000040;
      charIds.addAll(values);
      return this;
    }

    @Override
    public StarTowerState copyFrom(final StarTowerState other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        buildId = other.buildId;
        id = other.id;
        reConnection = other.reConnection;
        floor = other.floor;
        sweep = other.sweep;
        nextPackage.copyFrom(other.nextPackage);
        charIds.copyFrom(other.charIds);
      }
      return this;
    }

    @Override
    public StarTowerState mergeFrom(final StarTowerState other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasBuildId()) {
        setBuildId(other.buildId);
      }
      if (other.hasId()) {
        setId(other.id);
      }
      if (other.hasReConnection()) {
        setReConnection(other.reConnection);
      }
      if (other.hasFloor()) {
        setFloor(other.floor);
      }
      if (other.hasSweep()) {
        setSweep(other.sweep);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      if (other.hasCharIds()) {
        getMutableCharIds().addAll(other.charIds);
      }
      return this;
    }

    @Override
    public StarTowerState clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      buildId = 0L;
      id = 0;
      reConnection = 0;
      floor = 0;
      sweep = false;
      nextPackage.clear();
      charIds.clear();
      return this;
    }

    @Override
    public StarTowerState clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      charIds.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof StarTowerState)) {
        return false;
      }
      StarTowerState other = (StarTowerState) o;
      return bitField0_ == other.bitField0_
        && (!hasBuildId() || buildId == other.buildId)
        && (!hasId() || id == other.id)
        && (!hasReConnection() || reConnection == other.reConnection)
        && (!hasFloor() || floor == other.floor)
        && (!hasSweep() || sweep == other.sweep)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage))
        && (!hasCharIds() || charIds.equals(other.charIds));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 24);
        output.writeUInt64NoTag(buildId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt32NoTag(id);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawByte((byte) 16);
        output.writeUInt32NoTag(reConnection);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeRawByte((byte) 48);
        output.writeUInt32NoTag(floor);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        output.writeRawByte((byte) 120);
        output.writeBoolNoTag(sweep);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000040) != 0) {
        for (int i = 0; i < charIds.length(); i++) {
          output.writeRawByte((byte) 32);
          output.writeUInt32NoTag(charIds.array()[i]);
        }
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeUInt64SizeNoTag(buildId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(id);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(reConnection);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(floor);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        size += 2;
      }
      if ((bitField0_ & 0x00000020) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000040) != 0) {
        size += (1 * charIds.length()) + ProtoSink.computeRepeatedUInt32SizeNoTag(charIds);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public StarTowerState mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 24: {
            // buildId
            buildId = input.readUInt64();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 8) {
              break;
            }
          }
          case 8: {
            // id
            id = input.readUInt32();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 16) {
              break;
            }
          }
          case 16: {
            // reConnection
            reConnection = input.readUInt32();
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 48) {
              break;
            }
          }
          case 48: {
            // floor
            floor = input.readUInt32();
            bitField0_ |= 0x00000008;
            tag = input.readTag();
            if (tag != 120) {
              break;
            }
          }
          case 120: {
            // sweep
            sweep = input.readBool();
            bitField0_ |= 0x00000010;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000020;
            tag = input.readTag();
            if (tag != 34) {
              break;
            }
          }
          case 34: {
            // charIds [packed=true]
            input.readPackedUInt32(charIds, tag);
            bitField0_ |= 0x00000040;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
          case 32: {
            // charIds [packed=false]
            tag = input.readRepeatedUInt32(charIds, tag);
            bitField0_ |= 0x00000040;
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeUInt64(FieldNames.buildId, buildId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeUInt32(FieldNames.id, id);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeUInt32(FieldNames.reConnection, reConnection);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeUInt32(FieldNames.floor, floor);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        output.writeBool(FieldNames.sweep, sweep);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      if ((bitField0_ & 0x00000040) != 0) {
        output.writeRepeatedUInt32(FieldNames.charIds, charIds);
      }
      output.endObject();
    }

    @Override
    public StarTowerState mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 1895597065: {
            if (input.isAtField(FieldNames.buildId)) {
              if (!input.trySkipNullValue()) {
                buildId = input.readUInt64();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 2363: {
            if (input.isAtField(FieldNames.id)) {
              if (!input.trySkipNullValue()) {
                id = input.readUInt32();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 2109200785: {
            if (input.isAtField(FieldNames.reConnection)) {
              if (!input.trySkipNullValue()) {
                reConnection = input.readUInt32();
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 67974124: {
            if (input.isAtField(FieldNames.floor)) {
              if (!input.trySkipNullValue()) {
                floor = input.readUInt32();
                bitField0_ |= 0x00000008;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 80297676: {
            if (input.isAtField(FieldNames.sweep)) {
              if (!input.trySkipNullValue()) {
                sweep = input.readBool();
                bitField0_ |= 0x00000010;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000020;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1891280030: {
            if (input.isAtField(FieldNames.charIds)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedUInt32(charIds);
                bitField0_ |= 0x00000040;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public StarTowerState clone() {
      return new StarTowerState().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static StarTowerState parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new StarTowerState(), data).checkInitialized();
    }

    public static StarTowerState parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new StarTowerState(), input).checkInitialized();
    }

    public static StarTowerState parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new StarTowerState(), input).checkInitialized();
    }

    /**
     * @return factory for creating StarTowerState messages
     */
    public static MessageFactory<StarTowerState> getFactory() {
      return StarTowerStateFactory.INSTANCE;
    }

    private enum StarTowerStateFactory implements MessageFactory<StarTowerState> {
      INSTANCE;

      @Override
      public StarTowerState create() {
        return StarTowerState.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName buildId = FieldName.forField("BuildId");

      static final FieldName id = FieldName.forField("Id");

      static final FieldName reConnection = FieldName.forField("ReConnection");

      static final FieldName floor = FieldName.forField("Floor");

      static final FieldName sweep = FieldName.forField("Sweep");

      static final FieldName nextPackage = FieldName.forField("NextPackage");

      static final FieldName charIds = FieldName.forField("CharIds");
    }
  }

  /**
   * Protobuf type {@code StarTowerBookState}
   */
  public static final class StarTowerBookState extends ProtoMessage<StarTowerBookState> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    /**
     * <code>repeated uint32 CharIds = 1;</code>
     */
    private final RepeatedInt charIds = RepeatedInt.newEmptyInstance();

    /**
     * <code>repeated uint32 EventIds = 2;</code>
     */
    private final RepeatedInt eventIds = RepeatedInt.newEmptyInstance();

    /**
     * <code>repeated uint32 Bundles = 3;</code>
     */
    private final RepeatedInt bundles = RepeatedInt.newEmptyInstance();

    private StarTowerBookState() {
    }

    /**
     * @return a new empty instance of {@code StarTowerBookState}
     */
    public static StarTowerBookState newInstance() {
      return new StarTowerBookState();
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public StarTowerBookState clearNextPackage() {
      bitField0_ &= ~0x00000001;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000001;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public StarTowerBookState addNextPackage(final byte value) {
      bitField0_ |= 0x00000001;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public StarTowerBookState addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000001;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public StarTowerBookState setNextPackage(final byte... values) {
      bitField0_ |= 0x00000001;
      nextPackage.copyFrom(values);
      return this;
    }

    /**
     * <code>repeated uint32 CharIds = 1;</code>
     * @return whether the charIds field is set
     */
    public boolean hasCharIds() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>repeated uint32 CharIds = 1;</code>
     * @return this
     */
    public StarTowerBookState clearCharIds() {
      bitField0_ &= ~0x00000002;
      charIds.clear();
      return this;
    }

    /**
     * <code>repeated uint32 CharIds = 1;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableCharIds()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedInt getCharIds() {
      return charIds;
    }

    /**
     * <code>repeated uint32 CharIds = 1;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedInt getMutableCharIds() {
      bitField0_ |= 0x00000002;
      return charIds;
    }

    /**
     * <code>repeated uint32 CharIds = 1;</code>
     * @param value the charIds to add
     * @return this
     */
    public StarTowerBookState addCharIds(final int value) {
      bitField0_ |= 0x00000002;
      charIds.add(value);
      return this;
    }

    /**
     * <code>repeated uint32 CharIds = 1;</code>
     * @param values the charIds to add
     * @return this
     */
    public StarTowerBookState addAllCharIds(final int... values) {
      bitField0_ |= 0x00000002;
      charIds.addAll(values);
      return this;
    }

    /**
     * <code>repeated uint32 EventIds = 2;</code>
     * @return whether the eventIds field is set
     */
    public boolean hasEventIds() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>repeated uint32 EventIds = 2;</code>
     * @return this
     */
    public StarTowerBookState clearEventIds() {
      bitField0_ &= ~0x00000004;
      eventIds.clear();
      return this;
    }

    /**
     * <code>repeated uint32 EventIds = 2;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableEventIds()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedInt getEventIds() {
      return eventIds;
    }

    /**
     * <code>repeated uint32 EventIds = 2;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedInt getMutableEventIds() {
      bitField0_ |= 0x00000004;
      return eventIds;
    }

    /**
     * <code>repeated uint32 EventIds = 2;</code>
     * @param value the eventIds to add
     * @return this
     */
    public StarTowerBookState addEventIds(final int value) {
      bitField0_ |= 0x00000004;
      eventIds.add(value);
      return this;
    }

    /**
     * <code>repeated uint32 EventIds = 2;</code>
     * @param values the eventIds to add
     * @return this
     */
    public StarTowerBookState addAllEventIds(final int... values) {
      bitField0_ |= 0x00000004;
      eventIds.addAll(values);
      return this;
    }

    /**
     * <code>repeated uint32 Bundles = 3;</code>
     * @return whether the bundles field is set
     */
    public boolean hasBundles() {
      return (bitField0_ & 0x00000008) != 0;
    }

    /**
     * <code>repeated uint32 Bundles = 3;</code>
     * @return this
     */
    public StarTowerBookState clearBundles() {
      bitField0_ &= ~0x00000008;
      bundles.clear();
      return this;
    }

    /**
     * <code>repeated uint32 Bundles = 3;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableBundles()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedInt getBundles() {
      return bundles;
    }

    /**
     * <code>repeated uint32 Bundles = 3;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedInt getMutableBundles() {
      bitField0_ |= 0x00000008;
      return bundles;
    }

    /**
     * <code>repeated uint32 Bundles = 3;</code>
     * @param value the bundles to add
     * @return this
     */
    public StarTowerBookState addBundles(final int value) {
      bitField0_ |= 0x00000008;
      bundles.add(value);
      return this;
    }

    /**
     * <code>repeated uint32 Bundles = 3;</code>
     * @param values the bundles to add
     * @return this
     */
    public StarTowerBookState addAllBundles(final int... values) {
      bitField0_ |= 0x00000008;
      bundles.addAll(values);
      return this;
    }

    @Override
    public StarTowerBookState copyFrom(final StarTowerBookState other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        nextPackage.copyFrom(other.nextPackage);
        charIds.copyFrom(other.charIds);
        eventIds.copyFrom(other.eventIds);
        bundles.copyFrom(other.bundles);
      }
      return this;
    }

    @Override
    public StarTowerBookState mergeFrom(final StarTowerBookState other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      if (other.hasCharIds()) {
        getMutableCharIds().addAll(other.charIds);
      }
      if (other.hasEventIds()) {
        getMutableEventIds().addAll(other.eventIds);
      }
      if (other.hasBundles()) {
        getMutableBundles().addAll(other.bundles);
      }
      return this;
    }

    @Override
    public StarTowerBookState clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      charIds.clear();
      eventIds.clear();
      bundles.clear();
      return this;
    }

    @Override
    public StarTowerBookState clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      charIds.clear();
      eventIds.clear();
      bundles.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof StarTowerBookState)) {
        return false;
      }
      StarTowerBookState other = (StarTowerBookState) o;
      return bitField0_ == other.bitField0_
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage))
        && (!hasCharIds() || charIds.equals(other.charIds))
        && (!hasEventIds() || eventIds.equals(other.eventIds))
        && (!hasBundles() || bundles.equals(other.bundles));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        for (int i = 0; i < charIds.length(); i++) {
          output.writeRawByte((byte) 8);
          output.writeUInt32NoTag(charIds.array()[i]);
        }
      }
      if ((bitField0_ & 0x00000004) != 0) {
        for (int i = 0; i < eventIds.length(); i++) {
          output.writeRawByte((byte) 16);
          output.writeUInt32NoTag(eventIds.array()[i]);
        }
      }
      if ((bitField0_ & 0x00000008) != 0) {
        for (int i = 0; i < bundles.length(); i++) {
          output.writeRawByte((byte) 24);
          output.writeUInt32NoTag(bundles.array()[i]);
        }
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += (1 * charIds.length()) + ProtoSink.computeRepeatedUInt32SizeNoTag(charIds);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += (1 * eventIds.length()) + ProtoSink.computeRepeatedUInt32SizeNoTag(eventIds);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        size += (1 * bundles.length()) + ProtoSink.computeRepeatedUInt32SizeNoTag(bundles);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public StarTowerBookState mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 10) {
              break;
            }
          }
          case 10: {
            // charIds [packed=true]
            input.readPackedUInt32(charIds, tag);
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 18) {
              break;
            }
          }
          case 18: {
            // eventIds [packed=true]
            input.readPackedUInt32(eventIds, tag);
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 26) {
              break;
            }
          }
          case 26: {
            // bundles [packed=true]
            input.readPackedUInt32(bundles, tag);
            bitField0_ |= 0x00000008;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
          case 8: {
            // charIds [packed=false]
            tag = input.readRepeatedUInt32(charIds, tag);
            bitField0_ |= 0x00000002;
            break;
          }
          case 16: {
            // eventIds [packed=false]
            tag = input.readRepeatedUInt32(eventIds, tag);
            bitField0_ |= 0x00000004;
            break;
          }
          case 24: {
            // bundles [packed=false]
            tag = input.readRepeatedUInt32(bundles, tag);
            bitField0_ |= 0x00000008;
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRepeatedUInt32(FieldNames.charIds, charIds);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRepeatedUInt32(FieldNames.eventIds, eventIds);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeRepeatedUInt32(FieldNames.bundles, bundles);
      }
      output.endObject();
    }

    @Override
    public StarTowerBookState mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1891280030: {
            if (input.isAtField(FieldNames.charIds)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedUInt32(charIds);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 342741470: {
            if (input.isAtField(FieldNames.eventIds)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedUInt32(eventIds);
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 1899984913: {
            if (input.isAtField(FieldNames.bundles)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedUInt32(bundles);
                bitField0_ |= 0x00000008;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public StarTowerBookState clone() {
      return new StarTowerBookState().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static StarTowerBookState parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new StarTowerBookState(), data).checkInitialized();
    }

    public static StarTowerBookState parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new StarTowerBookState(), input).checkInitialized();
    }

    public static StarTowerBookState parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new StarTowerBookState(), input).checkInitialized();
    }

    /**
     * @return factory for creating StarTowerBookState messages
     */
    public static MessageFactory<StarTowerBookState> getFactory() {
      return StarTowerBookStateFactory.INSTANCE;
    }

    private enum StarTowerBookStateFactory implements MessageFactory<StarTowerBookState> {
      INSTANCE;

      @Override
      public StarTowerBookState create() {
        return StarTowerBookState.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName nextPackage = FieldName.forField("NextPackage");

      static final FieldName charIds = FieldName.forField("CharIds");

      static final FieldName eventIds = FieldName.forField("EventIds");

      static final FieldName bundles = FieldName.forField("Bundles");
    }
  }

  /**
   * Protobuf type {@code StateInfo}
   */
  public static final class StateInfo extends ProtoMessage<StateInfo> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional uint32 InfinityTower = 2;</code>
     */
    private int infinityTower;

    /**
     * <code>optional uint32 VampireSurvivorId = 11;</code>
     */
    private int vampireSurvivorId;

    /**
     * <code>optional bool Friend = 3;</code>
     */
    private boolean friend;

    /**
     * <code>optional bool NpcAffinityReward = 9;</code>
     */
    private boolean npcAffinityReward;

    /**
     * <code>optional bool StorySet = 22;</code>
     */
    private boolean storySet;

    /**
     * <code>optional .MailState Mail = 1;</code>
     */
    private final MailState mail = MailState.newInstance();

    /**
     * <code>optional .BattlePassState BattlePass = 4;</code>
     */
    private final BattlePassState battlePass = BattlePassState.newInstance();

    /**
     * <code>optional .WorldClassRewardState WorldClassReward = 5;</code>
     */
    private final WorldClassRewardState worldClassReward = WorldClassRewardState.newInstance();

    /**
     * <code>optional .FriendEnergyState FriendEnergy = 7;</code>
     */
    private final FriendEnergyState friendEnergy = FriendEnergyState.newInstance();

    /**
     * <code>optional .MallPackageState MallPackage = 10;</code>
     */
    private final MallPackageState mallPackage = MallPackageState.newInstance();

    /**
     * <code>optional .AchievementState Achievement = 15;</code>
     */
    private final AchievementState achievement = AchievementState.newInstance();

    /**
     * <code>optional .QuestState TravelerDuelQuest = 16;</code>
     */
    private final QuestState travelerDuelQuest = QuestState.newInstance();

    /**
     * <code>optional .QuestState TravelerDuelChallengeQuest = 17;</code>
     */
    private final QuestState travelerDuelChallengeQuest = QuestState.newInstance();

    /**
     * <code>optional .StarTowerState StarTower = 18;</code>
     */
    private final StarTowerState starTower = StarTowerState.newInstance();

    /**
     * <code>optional .StarTowerBookState StarTowerBook = 19;</code>
     */
    private final StarTowerBookState starTowerBook = StarTowerBookState.newInstance();

    /**
     * <code>optional .ScoreBossState ScoreBoss = 20;</code>
     */
    private final ScoreBossState scoreBoss = ScoreBossState.newInstance();

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    /**
     * <code>repeated .CharAdvanceRewardState CharAdvanceRewards = 6;</code>
     */
    private final RepeatedMessage<CharAdvanceRewardState> charAdvanceRewards = RepeatedMessage.newEmptyInstance(CharAdvanceRewardState.getFactory());

    /**
     * <code>repeated .CharAffinityRewardState CharAffinityRewards = 8;</code>
     */
    private final RepeatedMessage<CharAffinityRewardState> charAffinityRewards = RepeatedMessage.newEmptyInstance(CharAffinityRewardState.getFactory());

    /**
     * <code>repeated .ActivityState Activities = 21;</code>
     */
    private final RepeatedMessage<ActivityState> activities = RepeatedMessage.newEmptyInstance(ActivityState.getFactory());

    private StateInfo() {
    }

    /**
     * @return a new empty instance of {@code StateInfo}
     */
    public static StateInfo newInstance() {
      return new StateInfo();
    }

    /**
     * <code>optional uint32 InfinityTower = 2;</code>
     * @return whether the infinityTower field is set
     */
    public boolean hasInfinityTower() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional uint32 InfinityTower = 2;</code>
     * @return this
     */
    public StateInfo clearInfinityTower() {
      bitField0_ &= ~0x00000001;
      infinityTower = 0;
      return this;
    }

    /**
     * <code>optional uint32 InfinityTower = 2;</code>
     * @return the infinityTower
     */
    public int getInfinityTower() {
      return infinityTower;
    }

    /**
     * <code>optional uint32 InfinityTower = 2;</code>
     * @param value the infinityTower to set
     * @return this
     */
    public StateInfo setInfinityTower(final int value) {
      bitField0_ |= 0x00000001;
      infinityTower = value;
      return this;
    }

    /**
     * <code>optional uint32 VampireSurvivorId = 11;</code>
     * @return whether the vampireSurvivorId field is set
     */
    public boolean hasVampireSurvivorId() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional uint32 VampireSurvivorId = 11;</code>
     * @return this
     */
    public StateInfo clearVampireSurvivorId() {
      bitField0_ &= ~0x00000002;
      vampireSurvivorId = 0;
      return this;
    }

    /**
     * <code>optional uint32 VampireSurvivorId = 11;</code>
     * @return the vampireSurvivorId
     */
    public int getVampireSurvivorId() {
      return vampireSurvivorId;
    }

    /**
     * <code>optional uint32 VampireSurvivorId = 11;</code>
     * @param value the vampireSurvivorId to set
     * @return this
     */
    public StateInfo setVampireSurvivorId(final int value) {
      bitField0_ |= 0x00000002;
      vampireSurvivorId = value;
      return this;
    }

    /**
     * <code>optional bool Friend = 3;</code>
     * @return whether the friend field is set
     */
    public boolean hasFriend() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional bool Friend = 3;</code>
     * @return this
     */
    public StateInfo clearFriend() {
      bitField0_ &= ~0x00000004;
      friend = false;
      return this;
    }

    /**
     * <code>optional bool Friend = 3;</code>
     * @return the friend
     */
    public boolean getFriend() {
      return friend;
    }

    /**
     * <code>optional bool Friend = 3;</code>
     * @param value the friend to set
     * @return this
     */
    public StateInfo setFriend(final boolean value) {
      bitField0_ |= 0x00000004;
      friend = value;
      return this;
    }

    /**
     * <code>optional bool NpcAffinityReward = 9;</code>
     * @return whether the npcAffinityReward field is set
     */
    public boolean hasNpcAffinityReward() {
      return (bitField0_ & 0x00000008) != 0;
    }

    /**
     * <code>optional bool NpcAffinityReward = 9;</code>
     * @return this
     */
    public StateInfo clearNpcAffinityReward() {
      bitField0_ &= ~0x00000008;
      npcAffinityReward = false;
      return this;
    }

    /**
     * <code>optional bool NpcAffinityReward = 9;</code>
     * @return the npcAffinityReward
     */
    public boolean getNpcAffinityReward() {
      return npcAffinityReward;
    }

    /**
     * <code>optional bool NpcAffinityReward = 9;</code>
     * @param value the npcAffinityReward to set
     * @return this
     */
    public StateInfo setNpcAffinityReward(final boolean value) {
      bitField0_ |= 0x00000008;
      npcAffinityReward = value;
      return this;
    }

    /**
     * <code>optional bool StorySet = 22;</code>
     * @return whether the storySet field is set
     */
    public boolean hasStorySet() {
      return (bitField0_ & 0x00000010) != 0;
    }

    /**
     * <code>optional bool StorySet = 22;</code>
     * @return this
     */
    public StateInfo clearStorySet() {
      bitField0_ &= ~0x00000010;
      storySet = false;
      return this;
    }

    /**
     * <code>optional bool StorySet = 22;</code>
     * @return the storySet
     */
    public boolean getStorySet() {
      return storySet;
    }

    /**
     * <code>optional bool StorySet = 22;</code>
     * @param value the storySet to set
     * @return this
     */
    public StateInfo setStorySet(final boolean value) {
      bitField0_ |= 0x00000010;
      storySet = value;
      return this;
    }

    /**
     * <code>optional .MailState Mail = 1;</code>
     * @return whether the mail field is set
     */
    public boolean hasMail() {
      return (bitField0_ & 0x00000020) != 0;
    }

    /**
     * <code>optional .MailState Mail = 1;</code>
     * @return this
     */
    public StateInfo clearMail() {
      bitField0_ &= ~0x00000020;
      mail.clear();
      return this;
    }

    /**
     * <code>optional .MailState Mail = 1;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableMail()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public MailState getMail() {
      return mail;
    }

    /**
     * <code>optional .MailState Mail = 1;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public MailState getMutableMail() {
      bitField0_ |= 0x00000020;
      return mail;
    }

    /**
     * <code>optional .MailState Mail = 1;</code>
     * @param value the mail to set
     * @return this
     */
    public StateInfo setMail(final MailState value) {
      bitField0_ |= 0x00000020;
      mail.copyFrom(value);
      return this;
    }

    /**
     * <code>optional .BattlePassState BattlePass = 4;</code>
     * @return whether the battlePass field is set
     */
    public boolean hasBattlePass() {
      return (bitField0_ & 0x00000040) != 0;
    }

    /**
     * <code>optional .BattlePassState BattlePass = 4;</code>
     * @return this
     */
    public StateInfo clearBattlePass() {
      bitField0_ &= ~0x00000040;
      battlePass.clear();
      return this;
    }

    /**
     * <code>optional .BattlePassState BattlePass = 4;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableBattlePass()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public BattlePassState getBattlePass() {
      return battlePass;
    }

    /**
     * <code>optional .BattlePassState BattlePass = 4;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public BattlePassState getMutableBattlePass() {
      bitField0_ |= 0x00000040;
      return battlePass;
    }

    /**
     * <code>optional .BattlePassState BattlePass = 4;</code>
     * @param value the battlePass to set
     * @return this
     */
    public StateInfo setBattlePass(final BattlePassState value) {
      bitField0_ |= 0x00000040;
      battlePass.copyFrom(value);
      return this;
    }

    /**
     * <code>optional .WorldClassRewardState WorldClassReward = 5;</code>
     * @return whether the worldClassReward field is set
     */
    public boolean hasWorldClassReward() {
      return (bitField0_ & 0x00000080) != 0;
    }

    /**
     * <code>optional .WorldClassRewardState WorldClassReward = 5;</code>
     * @return this
     */
    public StateInfo clearWorldClassReward() {
      bitField0_ &= ~0x00000080;
      worldClassReward.clear();
      return this;
    }

    /**
     * <code>optional .WorldClassRewardState WorldClassReward = 5;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableWorldClassReward()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public WorldClassRewardState getWorldClassReward() {
      return worldClassReward;
    }

    /**
     * <code>optional .WorldClassRewardState WorldClassReward = 5;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public WorldClassRewardState getMutableWorldClassReward() {
      bitField0_ |= 0x00000080;
      return worldClassReward;
    }

    /**
     * <code>optional .WorldClassRewardState WorldClassReward = 5;</code>
     * @param value the worldClassReward to set
     * @return this
     */
    public StateInfo setWorldClassReward(final WorldClassRewardState value) {
      bitField0_ |= 0x00000080;
      worldClassReward.copyFrom(value);
      return this;
    }

    /**
     * <code>optional .FriendEnergyState FriendEnergy = 7;</code>
     * @return whether the friendEnergy field is set
     */
    public boolean hasFriendEnergy() {
      return (bitField0_ & 0x00000100) != 0;
    }

    /**
     * <code>optional .FriendEnergyState FriendEnergy = 7;</code>
     * @return this
     */
    public StateInfo clearFriendEnergy() {
      bitField0_ &= ~0x00000100;
      friendEnergy.clear();
      return this;
    }

    /**
     * <code>optional .FriendEnergyState FriendEnergy = 7;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableFriendEnergy()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public FriendEnergyState getFriendEnergy() {
      return friendEnergy;
    }

    /**
     * <code>optional .FriendEnergyState FriendEnergy = 7;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public FriendEnergyState getMutableFriendEnergy() {
      bitField0_ |= 0x00000100;
      return friendEnergy;
    }

    /**
     * <code>optional .FriendEnergyState FriendEnergy = 7;</code>
     * @param value the friendEnergy to set
     * @return this
     */
    public StateInfo setFriendEnergy(final FriendEnergyState value) {
      bitField0_ |= 0x00000100;
      friendEnergy.copyFrom(value);
      return this;
    }

    /**
     * <code>optional .MallPackageState MallPackage = 10;</code>
     * @return whether the mallPackage field is set
     */
    public boolean hasMallPackage() {
      return (bitField0_ & 0x00000200) != 0;
    }

    /**
     * <code>optional .MallPackageState MallPackage = 10;</code>
     * @return this
     */
    public StateInfo clearMallPackage() {
      bitField0_ &= ~0x00000200;
      mallPackage.clear();
      return this;
    }

    /**
     * <code>optional .MallPackageState MallPackage = 10;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableMallPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public MallPackageState getMallPackage() {
      return mallPackage;
    }

    /**
     * <code>optional .MallPackageState MallPackage = 10;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public MallPackageState getMutableMallPackage() {
      bitField0_ |= 0x00000200;
      return mallPackage;
    }

    /**
     * <code>optional .MallPackageState MallPackage = 10;</code>
     * @param value the mallPackage to set
     * @return this
     */
    public StateInfo setMallPackage(final MallPackageState value) {
      bitField0_ |= 0x00000200;
      mallPackage.copyFrom(value);
      return this;
    }

    /**
     * <code>optional .AchievementState Achievement = 15;</code>
     * @return whether the achievement field is set
     */
    public boolean hasAchievement() {
      return (bitField0_ & 0x00000400) != 0;
    }

    /**
     * <code>optional .AchievementState Achievement = 15;</code>
     * @return this
     */
    public StateInfo clearAchievement() {
      bitField0_ &= ~0x00000400;
      achievement.clear();
      return this;
    }

    /**
     * <code>optional .AchievementState Achievement = 15;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableAchievement()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public AchievementState getAchievement() {
      return achievement;
    }

    /**
     * <code>optional .AchievementState Achievement = 15;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public AchievementState getMutableAchievement() {
      bitField0_ |= 0x00000400;
      return achievement;
    }

    /**
     * <code>optional .AchievementState Achievement = 15;</code>
     * @param value the achievement to set
     * @return this
     */
    public StateInfo setAchievement(final AchievementState value) {
      bitField0_ |= 0x00000400;
      achievement.copyFrom(value);
      return this;
    }

    /**
     * <code>optional .QuestState TravelerDuelQuest = 16;</code>
     * @return whether the travelerDuelQuest field is set
     */
    public boolean hasTravelerDuelQuest() {
      return (bitField0_ & 0x00000800) != 0;
    }

    /**
     * <code>optional .QuestState TravelerDuelQuest = 16;</code>
     * @return this
     */
    public StateInfo clearTravelerDuelQuest() {
      bitField0_ &= ~0x00000800;
      travelerDuelQuest.clear();
      return this;
    }

    /**
     * <code>optional .QuestState TravelerDuelQuest = 16;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableTravelerDuelQuest()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public QuestState getTravelerDuelQuest() {
      return travelerDuelQuest;
    }

    /**
     * <code>optional .QuestState TravelerDuelQuest = 16;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public QuestState getMutableTravelerDuelQuest() {
      bitField0_ |= 0x00000800;
      return travelerDuelQuest;
    }

    /**
     * <code>optional .QuestState TravelerDuelQuest = 16;</code>
     * @param value the travelerDuelQuest to set
     * @return this
     */
    public StateInfo setTravelerDuelQuest(final QuestState value) {
      bitField0_ |= 0x00000800;
      travelerDuelQuest.copyFrom(value);
      return this;
    }

    /**
     * <code>optional .QuestState TravelerDuelChallengeQuest = 17;</code>
     * @return whether the travelerDuelChallengeQuest field is set
     */
    public boolean hasTravelerDuelChallengeQuest() {
      return (bitField0_ & 0x00001000) != 0;
    }

    /**
     * <code>optional .QuestState TravelerDuelChallengeQuest = 17;</code>
     * @return this
     */
    public StateInfo clearTravelerDuelChallengeQuest() {
      bitField0_ &= ~0x00001000;
      travelerDuelChallengeQuest.clear();
      return this;
    }

    /**
     * <code>optional .QuestState TravelerDuelChallengeQuest = 17;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableTravelerDuelChallengeQuest()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public QuestState getTravelerDuelChallengeQuest() {
      return travelerDuelChallengeQuest;
    }

    /**
     * <code>optional .QuestState TravelerDuelChallengeQuest = 17;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public QuestState getMutableTravelerDuelChallengeQuest() {
      bitField0_ |= 0x00001000;
      return travelerDuelChallengeQuest;
    }

    /**
     * <code>optional .QuestState TravelerDuelChallengeQuest = 17;</code>
     * @param value the travelerDuelChallengeQuest to set
     * @return this
     */
    public StateInfo setTravelerDuelChallengeQuest(final QuestState value) {
      bitField0_ |= 0x00001000;
      travelerDuelChallengeQuest.copyFrom(value);
      return this;
    }

    /**
     * <code>optional .StarTowerState StarTower = 18;</code>
     * @return whether the starTower field is set
     */
    public boolean hasStarTower() {
      return (bitField0_ & 0x00002000) != 0;
    }

    /**
     * <code>optional .StarTowerState StarTower = 18;</code>
     * @return this
     */
    public StateInfo clearStarTower() {
      bitField0_ &= ~0x00002000;
      starTower.clear();
      return this;
    }

    /**
     * <code>optional .StarTowerState StarTower = 18;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableStarTower()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public StarTowerState getStarTower() {
      return starTower;
    }

    /**
     * <code>optional .StarTowerState StarTower = 18;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public StarTowerState getMutableStarTower() {
      bitField0_ |= 0x00002000;
      return starTower;
    }

    /**
     * <code>optional .StarTowerState StarTower = 18;</code>
     * @param value the starTower to set
     * @return this
     */
    public StateInfo setStarTower(final StarTowerState value) {
      bitField0_ |= 0x00002000;
      starTower.copyFrom(value);
      return this;
    }

    /**
     * <code>optional .StarTowerBookState StarTowerBook = 19;</code>
     * @return whether the starTowerBook field is set
     */
    public boolean hasStarTowerBook() {
      return (bitField0_ & 0x00004000) != 0;
    }

    /**
     * <code>optional .StarTowerBookState StarTowerBook = 19;</code>
     * @return this
     */
    public StateInfo clearStarTowerBook() {
      bitField0_ &= ~0x00004000;
      starTowerBook.clear();
      return this;
    }

    /**
     * <code>optional .StarTowerBookState StarTowerBook = 19;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableStarTowerBook()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public StarTowerBookState getStarTowerBook() {
      return starTowerBook;
    }

    /**
     * <code>optional .StarTowerBookState StarTowerBook = 19;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public StarTowerBookState getMutableStarTowerBook() {
      bitField0_ |= 0x00004000;
      return starTowerBook;
    }

    /**
     * <code>optional .StarTowerBookState StarTowerBook = 19;</code>
     * @param value the starTowerBook to set
     * @return this
     */
    public StateInfo setStarTowerBook(final StarTowerBookState value) {
      bitField0_ |= 0x00004000;
      starTowerBook.copyFrom(value);
      return this;
    }

    /**
     * <code>optional .ScoreBossState ScoreBoss = 20;</code>
     * @return whether the scoreBoss field is set
     */
    public boolean hasScoreBoss() {
      return (bitField0_ & 0x00008000) != 0;
    }

    /**
     * <code>optional .ScoreBossState ScoreBoss = 20;</code>
     * @return this
     */
    public StateInfo clearScoreBoss() {
      bitField0_ &= ~0x00008000;
      scoreBoss.clear();
      return this;
    }

    /**
     * <code>optional .ScoreBossState ScoreBoss = 20;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableScoreBoss()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public ScoreBossState getScoreBoss() {
      return scoreBoss;
    }

    /**
     * <code>optional .ScoreBossState ScoreBoss = 20;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public ScoreBossState getMutableScoreBoss() {
      bitField0_ |= 0x00008000;
      return scoreBoss;
    }

    /**
     * <code>optional .ScoreBossState ScoreBoss = 20;</code>
     * @param value the scoreBoss to set
     * @return this
     */
    public StateInfo setScoreBoss(final ScoreBossState value) {
      bitField0_ |= 0x00008000;
      scoreBoss.copyFrom(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00010000) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public StateInfo clearNextPackage() {
      bitField0_ &= ~0x00010000;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00010000;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public StateInfo addNextPackage(final byte value) {
      bitField0_ |= 0x00010000;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public StateInfo addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00010000;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public StateInfo setNextPackage(final byte... values) {
      bitField0_ |= 0x00010000;
      nextPackage.copyFrom(values);
      return this;
    }

    /**
     * <code>repeated .CharAdvanceRewardState CharAdvanceRewards = 6;</code>
     * @return whether the charAdvanceRewards field is set
     */
    public boolean hasCharAdvanceRewards() {
      return (bitField0_ & 0x00020000) != 0;
    }

    /**
     * <code>repeated .CharAdvanceRewardState CharAdvanceRewards = 6;</code>
     * @return this
     */
    public StateInfo clearCharAdvanceRewards() {
      bitField0_ &= ~0x00020000;
      charAdvanceRewards.clear();
      return this;
    }

    /**
     * <code>repeated .CharAdvanceRewardState CharAdvanceRewards = 6;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableCharAdvanceRewards()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<CharAdvanceRewardState> getCharAdvanceRewards() {
      return charAdvanceRewards;
    }

    /**
     * <code>repeated .CharAdvanceRewardState CharAdvanceRewards = 6;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<CharAdvanceRewardState> getMutableCharAdvanceRewards() {
      bitField0_ |= 0x00020000;
      return charAdvanceRewards;
    }

    /**
     * <code>repeated .CharAdvanceRewardState CharAdvanceRewards = 6;</code>
     * @param value the charAdvanceRewards to add
     * @return this
     */
    public StateInfo addCharAdvanceRewards(final CharAdvanceRewardState value) {
      bitField0_ |= 0x00020000;
      charAdvanceRewards.add(value);
      return this;
    }

    /**
     * <code>repeated .CharAdvanceRewardState CharAdvanceRewards = 6;</code>
     * @param values the charAdvanceRewards to add
     * @return this
     */
    public StateInfo addAllCharAdvanceRewards(final CharAdvanceRewardState... values) {
      bitField0_ |= 0x00020000;
      charAdvanceRewards.addAll(values);
      return this;
    }

    /**
     * <code>repeated .CharAffinityRewardState CharAffinityRewards = 8;</code>
     * @return whether the charAffinityRewards field is set
     */
    public boolean hasCharAffinityRewards() {
      return (bitField0_ & 0x00040000) != 0;
    }

    /**
     * <code>repeated .CharAffinityRewardState CharAffinityRewards = 8;</code>
     * @return this
     */
    public StateInfo clearCharAffinityRewards() {
      bitField0_ &= ~0x00040000;
      charAffinityRewards.clear();
      return this;
    }

    /**
     * <code>repeated .CharAffinityRewardState CharAffinityRewards = 8;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableCharAffinityRewards()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<CharAffinityRewardState> getCharAffinityRewards() {
      return charAffinityRewards;
    }

    /**
     * <code>repeated .CharAffinityRewardState CharAffinityRewards = 8;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<CharAffinityRewardState> getMutableCharAffinityRewards() {
      bitField0_ |= 0x00040000;
      return charAffinityRewards;
    }

    /**
     * <code>repeated .CharAffinityRewardState CharAffinityRewards = 8;</code>
     * @param value the charAffinityRewards to add
     * @return this
     */
    public StateInfo addCharAffinityRewards(final CharAffinityRewardState value) {
      bitField0_ |= 0x00040000;
      charAffinityRewards.add(value);
      return this;
    }

    /**
     * <code>repeated .CharAffinityRewardState CharAffinityRewards = 8;</code>
     * @param values the charAffinityRewards to add
     * @return this
     */
    public StateInfo addAllCharAffinityRewards(final CharAffinityRewardState... values) {
      bitField0_ |= 0x00040000;
      charAffinityRewards.addAll(values);
      return this;
    }

    /**
     * <code>repeated .ActivityState Activities = 21;</code>
     * @return whether the activities field is set
     */
    public boolean hasActivities() {
      return (bitField0_ & 0x00080000) != 0;
    }

    /**
     * <code>repeated .ActivityState Activities = 21;</code>
     * @return this
     */
    public StateInfo clearActivities() {
      bitField0_ &= ~0x00080000;
      activities.clear();
      return this;
    }

    /**
     * <code>repeated .ActivityState Activities = 21;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableActivities()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<ActivityState> getActivities() {
      return activities;
    }

    /**
     * <code>repeated .ActivityState Activities = 21;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<ActivityState> getMutableActivities() {
      bitField0_ |= 0x00080000;
      return activities;
    }

    /**
     * <code>repeated .ActivityState Activities = 21;</code>
     * @param value the activities to add
     * @return this
     */
    public StateInfo addActivities(final ActivityState value) {
      bitField0_ |= 0x00080000;
      activities.add(value);
      return this;
    }

    /**
     * <code>repeated .ActivityState Activities = 21;</code>
     * @param values the activities to add
     * @return this
     */
    public StateInfo addAllActivities(final ActivityState... values) {
      bitField0_ |= 0x00080000;
      activities.addAll(values);
      return this;
    }

    @Override
    public StateInfo copyFrom(final StateInfo other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        infinityTower = other.infinityTower;
        vampireSurvivorId = other.vampireSurvivorId;
        friend = other.friend;
        npcAffinityReward = other.npcAffinityReward;
        storySet = other.storySet;
        mail.copyFrom(other.mail);
        battlePass.copyFrom(other.battlePass);
        worldClassReward.copyFrom(other.worldClassReward);
        friendEnergy.copyFrom(other.friendEnergy);
        mallPackage.copyFrom(other.mallPackage);
        achievement.copyFrom(other.achievement);
        travelerDuelQuest.copyFrom(other.travelerDuelQuest);
        travelerDuelChallengeQuest.copyFrom(other.travelerDuelChallengeQuest);
        starTower.copyFrom(other.starTower);
        starTowerBook.copyFrom(other.starTowerBook);
        scoreBoss.copyFrom(other.scoreBoss);
        nextPackage.copyFrom(other.nextPackage);
        charAdvanceRewards.copyFrom(other.charAdvanceRewards);
        charAffinityRewards.copyFrom(other.charAffinityRewards);
        activities.copyFrom(other.activities);
      }
      return this;
    }

    @Override
    public StateInfo mergeFrom(final StateInfo other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasInfinityTower()) {
        setInfinityTower(other.infinityTower);
      }
      if (other.hasVampireSurvivorId()) {
        setVampireSurvivorId(other.vampireSurvivorId);
      }
      if (other.hasFriend()) {
        setFriend(other.friend);
      }
      if (other.hasNpcAffinityReward()) {
        setNpcAffinityReward(other.npcAffinityReward);
      }
      if (other.hasStorySet()) {
        setStorySet(other.storySet);
      }
      if (other.hasMail()) {
        getMutableMail().mergeFrom(other.mail);
      }
      if (other.hasBattlePass()) {
        getMutableBattlePass().mergeFrom(other.battlePass);
      }
      if (other.hasWorldClassReward()) {
        getMutableWorldClassReward().mergeFrom(other.worldClassReward);
      }
      if (other.hasFriendEnergy()) {
        getMutableFriendEnergy().mergeFrom(other.friendEnergy);
      }
      if (other.hasMallPackage()) {
        getMutableMallPackage().mergeFrom(other.mallPackage);
      }
      if (other.hasAchievement()) {
        getMutableAchievement().mergeFrom(other.achievement);
      }
      if (other.hasTravelerDuelQuest()) {
        getMutableTravelerDuelQuest().mergeFrom(other.travelerDuelQuest);
      }
      if (other.hasTravelerDuelChallengeQuest()) {
        getMutableTravelerDuelChallengeQuest().mergeFrom(other.travelerDuelChallengeQuest);
      }
      if (other.hasStarTower()) {
        getMutableStarTower().mergeFrom(other.starTower);
      }
      if (other.hasStarTowerBook()) {
        getMutableStarTowerBook().mergeFrom(other.starTowerBook);
      }
      if (other.hasScoreBoss()) {
        getMutableScoreBoss().mergeFrom(other.scoreBoss);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      if (other.hasCharAdvanceRewards()) {
        getMutableCharAdvanceRewards().addAll(other.charAdvanceRewards);
      }
      if (other.hasCharAffinityRewards()) {
        getMutableCharAffinityRewards().addAll(other.charAffinityRewards);
      }
      if (other.hasActivities()) {
        getMutableActivities().addAll(other.activities);
      }
      return this;
    }

    @Override
    public StateInfo clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      infinityTower = 0;
      vampireSurvivorId = 0;
      friend = false;
      npcAffinityReward = false;
      storySet = false;
      mail.clear();
      battlePass.clear();
      worldClassReward.clear();
      friendEnergy.clear();
      mallPackage.clear();
      achievement.clear();
      travelerDuelQuest.clear();
      travelerDuelChallengeQuest.clear();
      starTower.clear();
      starTowerBook.clear();
      scoreBoss.clear();
      nextPackage.clear();
      charAdvanceRewards.clear();
      charAffinityRewards.clear();
      activities.clear();
      return this;
    }

    @Override
    public StateInfo clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      mail.clearQuick();
      battlePass.clearQuick();
      worldClassReward.clearQuick();
      friendEnergy.clearQuick();
      mallPackage.clearQuick();
      achievement.clearQuick();
      travelerDuelQuest.clearQuick();
      travelerDuelChallengeQuest.clearQuick();
      starTower.clearQuick();
      starTowerBook.clearQuick();
      scoreBoss.clearQuick();
      nextPackage.clear();
      charAdvanceRewards.clearQuick();
      charAffinityRewards.clearQuick();
      activities.clearQuick();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof StateInfo)) {
        return false;
      }
      StateInfo other = (StateInfo) o;
      return bitField0_ == other.bitField0_
        && (!hasInfinityTower() || infinityTower == other.infinityTower)
        && (!hasVampireSurvivorId() || vampireSurvivorId == other.vampireSurvivorId)
        && (!hasFriend() || friend == other.friend)
        && (!hasNpcAffinityReward() || npcAffinityReward == other.npcAffinityReward)
        && (!hasStorySet() || storySet == other.storySet)
        && (!hasMail() || mail.equals(other.mail))
        && (!hasBattlePass() || battlePass.equals(other.battlePass))
        && (!hasWorldClassReward() || worldClassReward.equals(other.worldClassReward))
        && (!hasFriendEnergy() || friendEnergy.equals(other.friendEnergy))
        && (!hasMallPackage() || mallPackage.equals(other.mallPackage))
        && (!hasAchievement() || achievement.equals(other.achievement))
        && (!hasTravelerDuelQuest() || travelerDuelQuest.equals(other.travelerDuelQuest))
        && (!hasTravelerDuelChallengeQuest() || travelerDuelChallengeQuest.equals(other.travelerDuelChallengeQuest))
        && (!hasStarTower() || starTower.equals(other.starTower))
        && (!hasStarTowerBook() || starTowerBook.equals(other.starTowerBook))
        && (!hasScoreBoss() || scoreBoss.equals(other.scoreBoss))
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage))
        && (!hasCharAdvanceRewards() || charAdvanceRewards.equals(other.charAdvanceRewards))
        && (!hasCharAffinityRewards() || charAffinityRewards.equals(other.charAffinityRewards))
        && (!hasActivities() || activities.equals(other.activities));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 16);
        output.writeUInt32NoTag(infinityTower);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 88);
        output.writeUInt32NoTag(vampireSurvivorId);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawByte((byte) 24);
        output.writeBoolNoTag(friend);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeRawByte((byte) 72);
        output.writeBoolNoTag(npcAffinityReward);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        output.writeRawLittleEndian16((short) 432);
        output.writeBoolNoTag(storySet);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        output.writeRawByte((byte) 10);
        output.writeMessageNoTag(mail);
      }
      if ((bitField0_ & 0x00000040) != 0) {
        output.writeRawByte((byte) 34);
        output.writeMessageNoTag(battlePass);
      }
      if ((bitField0_ & 0x00000080) != 0) {
        output.writeRawByte((byte) 42);
        output.writeMessageNoTag(worldClassReward);
      }
      if ((bitField0_ & 0x00000100) != 0) {
        output.writeRawByte((byte) 58);
        output.writeMessageNoTag(friendEnergy);
      }
      if ((bitField0_ & 0x00000200) != 0) {
        output.writeRawByte((byte) 82);
        output.writeMessageNoTag(mallPackage);
      }
      if ((bitField0_ & 0x00000400) != 0) {
        output.writeRawByte((byte) 122);
        output.writeMessageNoTag(achievement);
      }
      if ((bitField0_ & 0x00000800) != 0) {
        output.writeRawLittleEndian16((short) 386);
        output.writeMessageNoTag(travelerDuelQuest);
      }
      if ((bitField0_ & 0x00001000) != 0) {
        output.writeRawLittleEndian16((short) 394);
        output.writeMessageNoTag(travelerDuelChallengeQuest);
      }
      if ((bitField0_ & 0x00002000) != 0) {
        output.writeRawLittleEndian16((short) 402);
        output.writeMessageNoTag(starTower);
      }
      if ((bitField0_ & 0x00004000) != 0) {
        output.writeRawLittleEndian16((short) 410);
        output.writeMessageNoTag(starTowerBook);
      }
      if ((bitField0_ & 0x00008000) != 0) {
        output.writeRawLittleEndian16((short) 418);
        output.writeMessageNoTag(scoreBoss);
      }
      if ((bitField0_ & 0x00010000) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00020000) != 0) {
        for (int i = 0; i < charAdvanceRewards.length(); i++) {
          output.writeRawByte((byte) 50);
          output.writeMessageNoTag(charAdvanceRewards.get(i));
        }
      }
      if ((bitField0_ & 0x00040000) != 0) {
        for (int i = 0; i < charAffinityRewards.length(); i++) {
          output.writeRawByte((byte) 66);
          output.writeMessageNoTag(charAffinityRewards.get(i));
        }
      }
      if ((bitField0_ & 0x00080000) != 0) {
        for (int i = 0; i < activities.length(); i++) {
          output.writeRawLittleEndian16((short) 426);
          output.writeMessageNoTag(activities.get(i));
        }
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(infinityTower);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(vampireSurvivorId);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 2;
      }
      if ((bitField0_ & 0x00000008) != 0) {
        size += 2;
      }
      if ((bitField0_ & 0x00000010) != 0) {
        size += 3;
      }
      if ((bitField0_ & 0x00000020) != 0) {
        size += 1 + ProtoSink.computeMessageSizeNoTag(mail);
      }
      if ((bitField0_ & 0x00000040) != 0) {
        size += 1 + ProtoSink.computeMessageSizeNoTag(battlePass);
      }
      if ((bitField0_ & 0x00000080) != 0) {
        size += 1 + ProtoSink.computeMessageSizeNoTag(worldClassReward);
      }
      if ((bitField0_ & 0x00000100) != 0) {
        size += 1 + ProtoSink.computeMessageSizeNoTag(friendEnergy);
      }
      if ((bitField0_ & 0x00000200) != 0) {
        size += 1 + ProtoSink.computeMessageSizeNoTag(mallPackage);
      }
      if ((bitField0_ & 0x00000400) != 0) {
        size += 1 + ProtoSink.computeMessageSizeNoTag(achievement);
      }
      if ((bitField0_ & 0x00000800) != 0) {
        size += 2 + ProtoSink.computeMessageSizeNoTag(travelerDuelQuest);
      }
      if ((bitField0_ & 0x00001000) != 0) {
        size += 2 + ProtoSink.computeMessageSizeNoTag(travelerDuelChallengeQuest);
      }
      if ((bitField0_ & 0x00002000) != 0) {
        size += 2 + ProtoSink.computeMessageSizeNoTag(starTower);
      }
      if ((bitField0_ & 0x00004000) != 0) {
        size += 2 + ProtoSink.computeMessageSizeNoTag(starTowerBook);
      }
      if ((bitField0_ & 0x00008000) != 0) {
        size += 2 + ProtoSink.computeMessageSizeNoTag(scoreBoss);
      }
      if ((bitField0_ & 0x00010000) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00020000) != 0) {
        size += (1 * charAdvanceRewards.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(charAdvanceRewards);
      }
      if ((bitField0_ & 0x00040000) != 0) {
        size += (1 * charAffinityRewards.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(charAffinityRewards);
      }
      if ((bitField0_ & 0x00080000) != 0) {
        size += (2 * activities.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(activities);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public StateInfo mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 16: {
            // infinityTower
            infinityTower = input.readUInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 88) {
              break;
            }
          }
          case 88: {
            // vampireSurvivorId
            vampireSurvivorId = input.readUInt32();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 24) {
              break;
            }
          }
          case 24: {
            // friend
            friend = input.readBool();
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 72) {
              break;
            }
          }
          case 72: {
            // npcAffinityReward
            npcAffinityReward = input.readBool();
            bitField0_ |= 0x00000008;
            tag = input.readTag();
            if (tag != 176) {
              break;
            }
          }
          case 176: {
            // storySet
            storySet = input.readBool();
            bitField0_ |= 0x00000010;
            tag = input.readTag();
            if (tag != 10) {
              break;
            }
          }
          case 10: {
            // mail
            input.readMessage(mail);
            bitField0_ |= 0x00000020;
            tag = input.readTag();
            if (tag != 34) {
              break;
            }
          }
          case 34: {
            // battlePass
            input.readMessage(battlePass);
            bitField0_ |= 0x00000040;
            tag = input.readTag();
            if (tag != 42) {
              break;
            }
          }
          case 42: {
            // worldClassReward
            input.readMessage(worldClassReward);
            bitField0_ |= 0x00000080;
            tag = input.readTag();
            if (tag != 58) {
              break;
            }
          }
          case 58: {
            // friendEnergy
            input.readMessage(friendEnergy);
            bitField0_ |= 0x00000100;
            tag = input.readTag();
            if (tag != 82) {
              break;
            }
          }
          case 82: {
            // mallPackage
            input.readMessage(mallPackage);
            bitField0_ |= 0x00000200;
            tag = input.readTag();
            if (tag != 122) {
              break;
            }
          }
          case 122: {
            // achievement
            input.readMessage(achievement);
            bitField0_ |= 0x00000400;
            tag = input.readTag();
            if (tag != 130) {
              break;
            }
          }
          case 130: {
            // travelerDuelQuest
            input.readMessage(travelerDuelQuest);
            bitField0_ |= 0x00000800;
            tag = input.readTag();
            if (tag != 138) {
              break;
            }
          }
          case 138: {
            // travelerDuelChallengeQuest
            input.readMessage(travelerDuelChallengeQuest);
            bitField0_ |= 0x00001000;
            tag = input.readTag();
            if (tag != 146) {
              break;
            }
          }
          case 146: {
            // starTower
            input.readMessage(starTower);
            bitField0_ |= 0x00002000;
            tag = input.readTag();
            if (tag != 154) {
              break;
            }
          }
          case 154: {
            // starTowerBook
            input.readMessage(starTowerBook);
            bitField0_ |= 0x00004000;
            tag = input.readTag();
            if (tag != 162) {
              break;
            }
          }
          case 162: {
            // scoreBoss
            input.readMessage(scoreBoss);
            bitField0_ |= 0x00008000;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00010000;
            tag = input.readTag();
            if (tag != 50) {
              break;
            }
          }
          case 50: {
            // charAdvanceRewards
            tag = input.readRepeatedMessage(charAdvanceRewards, tag);
            bitField0_ |= 0x00020000;
            if (tag != 66) {
              break;
            }
          }
          case 66: {
            // charAffinityRewards
            tag = input.readRepeatedMessage(charAffinityRewards, tag);
            bitField0_ |= 0x00040000;
            if (tag != 170) {
              break;
            }
          }
          case 170: {
            // activities
            tag = input.readRepeatedMessage(activities, tag);
            bitField0_ |= 0x00080000;
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeUInt32(FieldNames.infinityTower, infinityTower);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeUInt32(FieldNames.vampireSurvivorId, vampireSurvivorId);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeBool(FieldNames.friend, friend);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeBool(FieldNames.npcAffinityReward, npcAffinityReward);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        output.writeBool(FieldNames.storySet, storySet);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        output.writeMessage(FieldNames.mail, mail);
      }
      if ((bitField0_ & 0x00000040) != 0) {
        output.writeMessage(FieldNames.battlePass, battlePass);
      }
      if ((bitField0_ & 0x00000080) != 0) {
        output.writeMessage(FieldNames.worldClassReward, worldClassReward);
      }
      if ((bitField0_ & 0x00000100) != 0) {
        output.writeMessage(FieldNames.friendEnergy, friendEnergy);
      }
      if ((bitField0_ & 0x00000200) != 0) {
        output.writeMessage(FieldNames.mallPackage, mallPackage);
      }
      if ((bitField0_ & 0x00000400) != 0) {
        output.writeMessage(FieldNames.achievement, achievement);
      }
      if ((bitField0_ & 0x00000800) != 0) {
        output.writeMessage(FieldNames.travelerDuelQuest, travelerDuelQuest);
      }
      if ((bitField0_ & 0x00001000) != 0) {
        output.writeMessage(FieldNames.travelerDuelChallengeQuest, travelerDuelChallengeQuest);
      }
      if ((bitField0_ & 0x00002000) != 0) {
        output.writeMessage(FieldNames.starTower, starTower);
      }
      if ((bitField0_ & 0x00004000) != 0) {
        output.writeMessage(FieldNames.starTowerBook, starTowerBook);
      }
      if ((bitField0_ & 0x00008000) != 0) {
        output.writeMessage(FieldNames.scoreBoss, scoreBoss);
      }
      if ((bitField0_ & 0x00010000) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      if ((bitField0_ & 0x00020000) != 0) {
        output.writeRepeatedMessage(FieldNames.charAdvanceRewards, charAdvanceRewards);
      }
      if ((bitField0_ & 0x00040000) != 0) {
        output.writeRepeatedMessage(FieldNames.charAffinityRewards, charAffinityRewards);
      }
      if ((bitField0_ & 0x00080000) != 0) {
        output.writeRepeatedMessage(FieldNames.activities, activities);
      }
      output.endObject();
    }

    @Override
    public StateInfo mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case -212544095: {
            if (input.isAtField(FieldNames.infinityTower)) {
              if (!input.trySkipNullValue()) {
                infinityTower = input.readUInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -113673409: {
            if (input.isAtField(FieldNames.vampireSurvivorId)) {
              if (!input.trySkipNullValue()) {
                vampireSurvivorId = input.readUInt32();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 2112550590: {
            if (input.isAtField(FieldNames.friend)) {
              if (!input.trySkipNullValue()) {
                friend = input.readBool();
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -206209128: {
            if (input.isAtField(FieldNames.npcAffinityReward)) {
              if (!input.trySkipNullValue()) {
                npcAffinityReward = input.readBool();
                bitField0_ |= 0x00000008;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 1782386509: {
            if (input.isAtField(FieldNames.storySet)) {
              if (!input.trySkipNullValue()) {
                storySet = input.readBool();
                bitField0_ |= 0x00000010;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 2390487: {
            if (input.isAtField(FieldNames.mail)) {
              if (!input.trySkipNullValue()) {
                input.readMessage(mail);
                bitField0_ |= 0x00000020;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -247928567: {
            if (input.isAtField(FieldNames.battlePass)) {
              if (!input.trySkipNullValue()) {
                input.readMessage(battlePass);
                bitField0_ |= 0x00000040;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 137440245: {
            if (input.isAtField(FieldNames.worldClassReward)) {
              if (!input.trySkipNullValue()) {
                input.readMessage(worldClassReward);
                bitField0_ |= 0x00000080;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -499740954: {
            if (input.isAtField(FieldNames.friendEnergy)) {
              if (!input.trySkipNullValue()) {
                input.readMessage(friendEnergy);
                bitField0_ |= 0x00000100;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -342282382: {
            if (input.isAtField(FieldNames.mallPackage)) {
              if (!input.trySkipNullValue()) {
                input.readMessage(mallPackage);
                bitField0_ |= 0x00000200;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -879479025: {
            if (input.isAtField(FieldNames.achievement)) {
              if (!input.trySkipNullValue()) {
                input.readMessage(achievement);
                bitField0_ |= 0x00000400;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 1787165987: {
            if (input.isAtField(FieldNames.travelerDuelQuest)) {
              if (!input.trySkipNullValue()) {
                input.readMessage(travelerDuelQuest);
                bitField0_ |= 0x00000800;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 1732134686: {
            if (input.isAtField(FieldNames.travelerDuelChallengeQuest)) {
              if (!input.trySkipNullValue()) {
                input.readMessage(travelerDuelChallengeQuest);
                bitField0_ |= 0x00001000;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -154061897: {
            if (input.isAtField(FieldNames.starTower)) {
              if (!input.trySkipNullValue()) {
                input.readMessage(starTower);
                bitField0_ |= 0x00002000;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -13488320: {
            if (input.isAtField(FieldNames.starTowerBook)) {
              if (!input.trySkipNullValue()) {
                input.readMessage(starTowerBook);
                bitField0_ |= 0x00004000;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -162564865: {
            if (input.isAtField(FieldNames.scoreBoss)) {
              if (!input.trySkipNullValue()) {
                input.readMessage(scoreBoss);
                bitField0_ |= 0x00008000;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00010000;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 484629848: {
            if (input.isAtField(FieldNames.charAdvanceRewards)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedMessage(charAdvanceRewards);
                bitField0_ |= 0x00020000;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -889520506: {
            if (input.isAtField(FieldNames.charAffinityRewards)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedMessage(charAffinityRewards);
                bitField0_ |= 0x00040000;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -252897267: {
            if (input.isAtField(FieldNames.activities)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedMessage(activities);
                bitField0_ |= 0x00080000;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public StateInfo clone() {
      return new StateInfo().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static StateInfo parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new StateInfo(), data).checkInitialized();
    }

    public static StateInfo parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new StateInfo(), input).checkInitialized();
    }

    public static StateInfo parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new StateInfo(), input).checkInitialized();
    }

    /**
     * @return factory for creating StateInfo messages
     */
    public static MessageFactory<StateInfo> getFactory() {
      return StateInfoFactory.INSTANCE;
    }

    private enum StateInfoFactory implements MessageFactory<StateInfo> {
      INSTANCE;

      @Override
      public StateInfo create() {
        return StateInfo.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName infinityTower = FieldName.forField("InfinityTower");

      static final FieldName vampireSurvivorId = FieldName.forField("VampireSurvivorId");

      static final FieldName friend = FieldName.forField("Friend");

      static final FieldName npcAffinityReward = FieldName.forField("NpcAffinityReward");

      static final FieldName storySet = FieldName.forField("StorySet");

      static final FieldName mail = FieldName.forField("Mail");

      static final FieldName battlePass = FieldName.forField("BattlePass");

      static final FieldName worldClassReward = FieldName.forField("WorldClassReward");

      static final FieldName friendEnergy = FieldName.forField("FriendEnergy");

      static final FieldName mallPackage = FieldName.forField("MallPackage");

      static final FieldName achievement = FieldName.forField("Achievement");

      static final FieldName travelerDuelQuest = FieldName.forField("TravelerDuelQuest");

      static final FieldName travelerDuelChallengeQuest = FieldName.forField("TravelerDuelChallengeQuest");

      static final FieldName starTower = FieldName.forField("StarTower");

      static final FieldName starTowerBook = FieldName.forField("StarTowerBook");

      static final FieldName scoreBoss = FieldName.forField("ScoreBoss");

      static final FieldName nextPackage = FieldName.forField("NextPackage");

      static final FieldName charAdvanceRewards = FieldName.forField("CharAdvanceRewards");

      static final FieldName charAffinityRewards = FieldName.forField("CharAffinityRewards");

      static final FieldName activities = FieldName.forField("Activities");
    }
  }

  /**
   * Protobuf type {@code ItemTpl}
   */
  public static final class ItemTpl extends ProtoMessage<ItemTpl> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional int32 Qty = 2;</code>
     */
    private int qty;

    /**
     * <code>optional uint32 Tid = 1;</code>
     */
    private int tid;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    private ItemTpl() {
    }

    /**
     * @return a new empty instance of {@code ItemTpl}
     */
    public static ItemTpl newInstance() {
      return new ItemTpl();
    }

    /**
     * <code>optional int32 Qty = 2;</code>
     * @return whether the qty field is set
     */
    public boolean hasQty() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional int32 Qty = 2;</code>
     * @return this
     */
    public ItemTpl clearQty() {
      bitField0_ &= ~0x00000001;
      qty = 0;
      return this;
    }

    /**
     * <code>optional int32 Qty = 2;</code>
     * @return the qty
     */
    public int getQty() {
      return qty;
    }

    /**
     * <code>optional int32 Qty = 2;</code>
     * @param value the qty to set
     * @return this
     */
    public ItemTpl setQty(final int value) {
      bitField0_ |= 0x00000001;
      qty = value;
      return this;
    }

    /**
     * <code>optional uint32 Tid = 1;</code>
     * @return whether the tid field is set
     */
    public boolean hasTid() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional uint32 Tid = 1;</code>
     * @return this
     */
    public ItemTpl clearTid() {
      bitField0_ &= ~0x00000002;
      tid = 0;
      return this;
    }

    /**
     * <code>optional uint32 Tid = 1;</code>
     * @return the tid
     */
    public int getTid() {
      return tid;
    }

    /**
     * <code>optional uint32 Tid = 1;</code>
     * @param value the tid to set
     * @return this
     */
    public ItemTpl setTid(final int value) {
      bitField0_ |= 0x00000002;
      tid = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public ItemTpl clearNextPackage() {
      bitField0_ &= ~0x00000004;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000004;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public ItemTpl addNextPackage(final byte value) {
      bitField0_ |= 0x00000004;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public ItemTpl addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000004;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public ItemTpl setNextPackage(final byte... values) {
      bitField0_ |= 0x00000004;
      nextPackage.copyFrom(values);
      return this;
    }

    @Override
    public ItemTpl copyFrom(final ItemTpl other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        qty = other.qty;
        tid = other.tid;
        nextPackage.copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public ItemTpl mergeFrom(final ItemTpl other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasQty()) {
        setQty(other.qty);
      }
      if (other.hasTid()) {
        setTid(other.tid);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public ItemTpl clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      qty = 0;
      tid = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public ItemTpl clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof ItemTpl)) {
        return false;
      }
      ItemTpl other = (ItemTpl) o;
      return bitField0_ == other.bitField0_
        && (!hasQty() || qty == other.qty)
        && (!hasTid() || tid == other.tid)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 16);
        output.writeInt32NoTag(qty);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt32NoTag(tid);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeInt32SizeNoTag(qty);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(tid);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public ItemTpl mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 16: {
            // qty
            qty = input.readInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 8) {
              break;
            }
          }
          case 8: {
            // tid
            tid = input.readUInt32();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeInt32(FieldNames.qty, qty);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeUInt32(FieldNames.tid, tid);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      output.endObject();
    }

    @Override
    public ItemTpl mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 81558: {
            if (input.isAtField(FieldNames.qty)) {
              if (!input.trySkipNullValue()) {
                qty = input.readInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 84079: {
            if (input.isAtField(FieldNames.tid)) {
              if (!input.trySkipNullValue()) {
                tid = input.readUInt32();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public ItemTpl clone() {
      return new ItemTpl().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static ItemTpl parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new ItemTpl(), data).checkInitialized();
    }

    public static ItemTpl parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new ItemTpl(), input).checkInitialized();
    }

    public static ItemTpl parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new ItemTpl(), input).checkInitialized();
    }

    /**
     * @return factory for creating ItemTpl messages
     */
    public static MessageFactory<ItemTpl> getFactory() {
      return ItemTplFactory.INSTANCE;
    }

    private enum ItemTplFactory implements MessageFactory<ItemTpl> {
      INSTANCE;

      @Override
      public ItemTpl create() {
        return ItemTpl.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName qty = FieldName.forField("Qty");

      static final FieldName tid = FieldName.forField("Tid");

      static final FieldName nextPackage = FieldName.forField("NextPackage");
    }
  }

  /**
   * Protobuf type {@code ItemTpls}
   */
  public static final class ItemTpls extends ProtoMessage<ItemTpls> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    /**
     * <code>repeated .ItemTpl Items = 1;</code>
     */
    private final RepeatedMessage<ItemTpl> items = RepeatedMessage.newEmptyInstance(ItemTpl.getFactory());

    private ItemTpls() {
    }

    /**
     * @return a new empty instance of {@code ItemTpls}
     */
    public static ItemTpls newInstance() {
      return new ItemTpls();
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public ItemTpls clearNextPackage() {
      bitField0_ &= ~0x00000001;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000001;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public ItemTpls addNextPackage(final byte value) {
      bitField0_ |= 0x00000001;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public ItemTpls addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000001;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public ItemTpls setNextPackage(final byte... values) {
      bitField0_ |= 0x00000001;
      nextPackage.copyFrom(values);
      return this;
    }

    /**
     * <code>repeated .ItemTpl Items = 1;</code>
     * @return whether the items field is set
     */
    public boolean hasItems() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>repeated .ItemTpl Items = 1;</code>
     * @return this
     */
    public ItemTpls clearItems() {
      bitField0_ &= ~0x00000002;
      items.clear();
      return this;
    }

    /**
     * <code>repeated .ItemTpl Items = 1;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableItems()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<ItemTpl> getItems() {
      return items;
    }

    /**
     * <code>repeated .ItemTpl Items = 1;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<ItemTpl> getMutableItems() {
      bitField0_ |= 0x00000002;
      return items;
    }

    /**
     * <code>repeated .ItemTpl Items = 1;</code>
     * @param value the items to add
     * @return this
     */
    public ItemTpls addItems(final ItemTpl value) {
      bitField0_ |= 0x00000002;
      items.add(value);
      return this;
    }

    /**
     * <code>repeated .ItemTpl Items = 1;</code>
     * @param values the items to add
     * @return this
     */
    public ItemTpls addAllItems(final ItemTpl... values) {
      bitField0_ |= 0x00000002;
      items.addAll(values);
      return this;
    }

    @Override
    public ItemTpls copyFrom(final ItemTpls other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        nextPackage.copyFrom(other.nextPackage);
        items.copyFrom(other.items);
      }
      return this;
    }

    @Override
    public ItemTpls mergeFrom(final ItemTpls other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      if (other.hasItems()) {
        getMutableItems().addAll(other.items);
      }
      return this;
    }

    @Override
    public ItemTpls clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      items.clear();
      return this;
    }

    @Override
    public ItemTpls clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      items.clearQuick();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof ItemTpls)) {
        return false;
      }
      ItemTpls other = (ItemTpls) o;
      return bitField0_ == other.bitField0_
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage))
        && (!hasItems() || items.equals(other.items));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        for (int i = 0; i < items.length(); i++) {
          output.writeRawByte((byte) 10);
          output.writeMessageNoTag(items.get(i));
        }
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += (1 * items.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(items);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public ItemTpls mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 10) {
              break;
            }
          }
          case 10: {
            // items
            tag = input.readRepeatedMessage(items, tag);
            bitField0_ |= 0x00000002;
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRepeatedMessage(FieldNames.items, items);
      }
      output.endObject();
    }

    @Override
    public ItemTpls mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 70973344: {
            if (input.isAtField(FieldNames.items)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedMessage(items);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public ItemTpls clone() {
      return new ItemTpls().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static ItemTpls parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new ItemTpls(), data).checkInitialized();
    }

    public static ItemTpls parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new ItemTpls(), input).checkInitialized();
    }

    public static ItemTpls parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new ItemTpls(), input).checkInitialized();
    }

    /**
     * @return factory for creating ItemTpls messages
     */
    public static MessageFactory<ItemTpls> getFactory() {
      return ItemTplsFactory.INSTANCE;
    }

    private enum ItemTplsFactory implements MessageFactory<ItemTpls> {
      INSTANCE;

      @Override
      public ItemTpls create() {
        return ItemTpls.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName nextPackage = FieldName.forField("NextPackage");

      static final FieldName items = FieldName.forField("Items");
    }
  }

  /**
   * Protobuf type {@code Item}
   */
  public static final class Item extends ProtoMessage<Item> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional int64 Expire = 4;</code>
     */
    private long expire;

    /**
     * <code>optional uint64 Id = 1;</code>
     */
    private long id;

    /**
     * <code>optional int32 Qty = 3;</code>
     */
    private int qty;

    /**
     * <code>optional uint32 Tid = 2;</code>
     */
    private int tid;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    private Item() {
    }

    /**
     * @return a new empty instance of {@code Item}
     */
    public static Item newInstance() {
      return new Item();
    }

    /**
     * <code>optional int64 Expire = 4;</code>
     * @return whether the expire field is set
     */
    public boolean hasExpire() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional int64 Expire = 4;</code>
     * @return this
     */
    public Item clearExpire() {
      bitField0_ &= ~0x00000001;
      expire = 0L;
      return this;
    }

    /**
     * <code>optional int64 Expire = 4;</code>
     * @return the expire
     */
    public long getExpire() {
      return expire;
    }

    /**
     * <code>optional int64 Expire = 4;</code>
     * @param value the expire to set
     * @return this
     */
    public Item setExpire(final long value) {
      bitField0_ |= 0x00000001;
      expire = value;
      return this;
    }

    /**
     * <code>optional uint64 Id = 1;</code>
     * @return whether the id field is set
     */
    public boolean hasId() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional uint64 Id = 1;</code>
     * @return this
     */
    public Item clearId() {
      bitField0_ &= ~0x00000002;
      id = 0L;
      return this;
    }

    /**
     * <code>optional uint64 Id = 1;</code>
     * @return the id
     */
    public long getId() {
      return id;
    }

    /**
     * <code>optional uint64 Id = 1;</code>
     * @param value the id to set
     * @return this
     */
    public Item setId(final long value) {
      bitField0_ |= 0x00000002;
      id = value;
      return this;
    }

    /**
     * <code>optional int32 Qty = 3;</code>
     * @return whether the qty field is set
     */
    public boolean hasQty() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional int32 Qty = 3;</code>
     * @return this
     */
    public Item clearQty() {
      bitField0_ &= ~0x00000004;
      qty = 0;
      return this;
    }

    /**
     * <code>optional int32 Qty = 3;</code>
     * @return the qty
     */
    public int getQty() {
      return qty;
    }

    /**
     * <code>optional int32 Qty = 3;</code>
     * @param value the qty to set
     * @return this
     */
    public Item setQty(final int value) {
      bitField0_ |= 0x00000004;
      qty = value;
      return this;
    }

    /**
     * <code>optional uint32 Tid = 2;</code>
     * @return whether the tid field is set
     */
    public boolean hasTid() {
      return (bitField0_ & 0x00000008) != 0;
    }

    /**
     * <code>optional uint32 Tid = 2;</code>
     * @return this
     */
    public Item clearTid() {
      bitField0_ &= ~0x00000008;
      tid = 0;
      return this;
    }

    /**
     * <code>optional uint32 Tid = 2;</code>
     * @return the tid
     */
    public int getTid() {
      return tid;
    }

    /**
     * <code>optional uint32 Tid = 2;</code>
     * @param value the tid to set
     * @return this
     */
    public Item setTid(final int value) {
      bitField0_ |= 0x00000008;
      tid = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000010) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public Item clearNextPackage() {
      bitField0_ &= ~0x00000010;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000010;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public Item addNextPackage(final byte value) {
      bitField0_ |= 0x00000010;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public Item addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000010;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public Item setNextPackage(final byte... values) {
      bitField0_ |= 0x00000010;
      nextPackage.copyFrom(values);
      return this;
    }

    @Override
    public Item copyFrom(final Item other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        expire = other.expire;
        id = other.id;
        qty = other.qty;
        tid = other.tid;
        nextPackage.copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public Item mergeFrom(final Item other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasExpire()) {
        setExpire(other.expire);
      }
      if (other.hasId()) {
        setId(other.id);
      }
      if (other.hasQty()) {
        setQty(other.qty);
      }
      if (other.hasTid()) {
        setTid(other.tid);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public Item clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      expire = 0L;
      id = 0L;
      qty = 0;
      tid = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public Item clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof Item)) {
        return false;
      }
      Item other = (Item) o;
      return bitField0_ == other.bitField0_
        && (!hasExpire() || expire == other.expire)
        && (!hasId() || id == other.id)
        && (!hasQty() || qty == other.qty)
        && (!hasTid() || tid == other.tid)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 32);
        output.writeInt64NoTag(expire);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt64NoTag(id);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawByte((byte) 24);
        output.writeInt32NoTag(qty);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeRawByte((byte) 16);
        output.writeUInt32NoTag(tid);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeInt64SizeNoTag(expire);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeUInt64SizeNoTag(id);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 1 + ProtoSink.computeInt32SizeNoTag(qty);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(tid);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public Item mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 32: {
            // expire
            expire = input.readInt64();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 8) {
              break;
            }
          }
          case 8: {
            // id
            id = input.readUInt64();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 24) {
              break;
            }
          }
          case 24: {
            // qty
            qty = input.readInt32();
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 16) {
              break;
            }
          }
          case 16: {
            // tid
            tid = input.readUInt32();
            bitField0_ |= 0x00000008;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000010;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeInt64(FieldNames.expire, expire);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeUInt64(FieldNames.id, id);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeInt32(FieldNames.qty, qty);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeUInt32(FieldNames.tid, tid);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      output.endObject();
    }

    @Override
    public Item mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 2089675071: {
            if (input.isAtField(FieldNames.expire)) {
              if (!input.trySkipNullValue()) {
                expire = input.readInt64();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 2363: {
            if (input.isAtField(FieldNames.id)) {
              if (!input.trySkipNullValue()) {
                id = input.readUInt64();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 81558: {
            if (input.isAtField(FieldNames.qty)) {
              if (!input.trySkipNullValue()) {
                qty = input.readInt32();
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 84079: {
            if (input.isAtField(FieldNames.tid)) {
              if (!input.trySkipNullValue()) {
                tid = input.readUInt32();
                bitField0_ |= 0x00000008;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000010;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public Item clone() {
      return new Item().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static Item parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new Item(), data).checkInitialized();
    }

    public static Item parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new Item(), input).checkInitialized();
    }

    public static Item parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new Item(), input).checkInitialized();
    }

    /**
     * @return factory for creating Item messages
     */
    public static MessageFactory<Item> getFactory() {
      return ItemFactory.INSTANCE;
    }

    private enum ItemFactory implements MessageFactory<Item> {
      INSTANCE;

      @Override
      public Item create() {
        return Item.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName expire = FieldName.forField("Expire");

      static final FieldName id = FieldName.forField("Id");

      static final FieldName qty = FieldName.forField("Qty");

      static final FieldName tid = FieldName.forField("Tid");

      static final FieldName nextPackage = FieldName.forField("NextPackage");
    }
  }

  /**
   * Protobuf type {@code Res}
   */
  public static final class Res extends ProtoMessage<Res> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional int32 Qty = 2;</code>
     */
    private int qty;

    /**
     * <code>optional uint32 Tid = 1;</code>
     */
    private int tid;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    private Res() {
    }

    /**
     * @return a new empty instance of {@code Res}
     */
    public static Res newInstance() {
      return new Res();
    }

    /**
     * <code>optional int32 Qty = 2;</code>
     * @return whether the qty field is set
     */
    public boolean hasQty() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional int32 Qty = 2;</code>
     * @return this
     */
    public Res clearQty() {
      bitField0_ &= ~0x00000001;
      qty = 0;
      return this;
    }

    /**
     * <code>optional int32 Qty = 2;</code>
     * @return the qty
     */
    public int getQty() {
      return qty;
    }

    /**
     * <code>optional int32 Qty = 2;</code>
     * @param value the qty to set
     * @return this
     */
    public Res setQty(final int value) {
      bitField0_ |= 0x00000001;
      qty = value;
      return this;
    }

    /**
     * <code>optional uint32 Tid = 1;</code>
     * @return whether the tid field is set
     */
    public boolean hasTid() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional uint32 Tid = 1;</code>
     * @return this
     */
    public Res clearTid() {
      bitField0_ &= ~0x00000002;
      tid = 0;
      return this;
    }

    /**
     * <code>optional uint32 Tid = 1;</code>
     * @return the tid
     */
    public int getTid() {
      return tid;
    }

    /**
     * <code>optional uint32 Tid = 1;</code>
     * @param value the tid to set
     * @return this
     */
    public Res setTid(final int value) {
      bitField0_ |= 0x00000002;
      tid = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public Res clearNextPackage() {
      bitField0_ &= ~0x00000004;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000004;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public Res addNextPackage(final byte value) {
      bitField0_ |= 0x00000004;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public Res addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000004;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public Res setNextPackage(final byte... values) {
      bitField0_ |= 0x00000004;
      nextPackage.copyFrom(values);
      return this;
    }

    @Override
    public Res copyFrom(final Res other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        qty = other.qty;
        tid = other.tid;
        nextPackage.copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public Res mergeFrom(final Res other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasQty()) {
        setQty(other.qty);
      }
      if (other.hasTid()) {
        setTid(other.tid);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public Res clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      qty = 0;
      tid = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public Res clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof Res)) {
        return false;
      }
      Res other = (Res) o;
      return bitField0_ == other.bitField0_
        && (!hasQty() || qty == other.qty)
        && (!hasTid() || tid == other.tid)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 16);
        output.writeInt32NoTag(qty);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt32NoTag(tid);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeInt32SizeNoTag(qty);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(tid);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public Res mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 16: {
            // qty
            qty = input.readInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 8) {
              break;
            }
          }
          case 8: {
            // tid
            tid = input.readUInt32();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeInt32(FieldNames.qty, qty);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeUInt32(FieldNames.tid, tid);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      output.endObject();
    }

    @Override
    public Res mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 81558: {
            if (input.isAtField(FieldNames.qty)) {
              if (!input.trySkipNullValue()) {
                qty = input.readInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 84079: {
            if (input.isAtField(FieldNames.tid)) {
              if (!input.trySkipNullValue()) {
                tid = input.readUInt32();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public Res clone() {
      return new Res().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static Res parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new Res(), data).checkInitialized();
    }

    public static Res parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new Res(), input).checkInitialized();
    }

    public static Res parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new Res(), input).checkInitialized();
    }

    /**
     * @return factory for creating Res messages
     */
    public static MessageFactory<Res> getFactory() {
      return ResFactory.INSTANCE;
    }

    private enum ResFactory implements MessageFactory<Res> {
      INSTANCE;

      @Override
      public Res create() {
        return Res.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName qty = FieldName.forField("Qty");

      static final FieldName tid = FieldName.forField("Tid");

      static final FieldName nextPackage = FieldName.forField("NextPackage");
    }
  }

  /**
   * Protobuf type {@code Title}
   */
  public static final class Title extends ProtoMessage<Title> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional uint32 TitleId = 1;</code>
     */
    private int titleId;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    private Title() {
    }

    /**
     * @return a new empty instance of {@code Title}
     */
    public static Title newInstance() {
      return new Title();
    }

    /**
     * <code>optional uint32 TitleId = 1;</code>
     * @return whether the titleId field is set
     */
    public boolean hasTitleId() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional uint32 TitleId = 1;</code>
     * @return this
     */
    public Title clearTitleId() {
      bitField0_ &= ~0x00000001;
      titleId = 0;
      return this;
    }

    /**
     * <code>optional uint32 TitleId = 1;</code>
     * @return the titleId
     */
    public int getTitleId() {
      return titleId;
    }

    /**
     * <code>optional uint32 TitleId = 1;</code>
     * @param value the titleId to set
     * @return this
     */
    public Title setTitleId(final int value) {
      bitField0_ |= 0x00000001;
      titleId = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public Title clearNextPackage() {
      bitField0_ &= ~0x00000002;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000002;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public Title addNextPackage(final byte value) {
      bitField0_ |= 0x00000002;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public Title addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000002;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public Title setNextPackage(final byte... values) {
      bitField0_ |= 0x00000002;
      nextPackage.copyFrom(values);
      return this;
    }

    @Override
    public Title copyFrom(final Title other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        titleId = other.titleId;
        nextPackage.copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public Title mergeFrom(final Title other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasTitleId()) {
        setTitleId(other.titleId);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public Title clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      titleId = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public Title clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof Title)) {
        return false;
      }
      Title other = (Title) o;
      return bitField0_ == other.bitField0_
        && (!hasTitleId() || titleId == other.titleId)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt32NoTag(titleId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(titleId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public Title mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            // titleId
            titleId = input.readUInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeUInt32(FieldNames.titleId, titleId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      output.endObject();
    }

    @Override
    public Title mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 357404019: {
            if (input.isAtField(FieldNames.titleId)) {
              if (!input.trySkipNullValue()) {
                titleId = input.readUInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public Title clone() {
      return new Title().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static Title parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new Title(), data).checkInitialized();
    }

    public static Title parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new Title(), input).checkInitialized();
    }

    public static Title parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new Title(), input).checkInitialized();
    }

    /**
     * @return factory for creating Title messages
     */
    public static MessageFactory<Title> getFactory() {
      return TitleFactory.INSTANCE;
    }

    private enum TitleFactory implements MessageFactory<Title> {
      INSTANCE;

      @Override
      public Title create() {
        return Title.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName titleId = FieldName.forField("TitleId");

      static final FieldName nextPackage = FieldName.forField("NextPackage");
    }
  }

  /**
   * Protobuf type {@code Char}
   */
  public static final class Char extends ProtoMessage<Char> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional int64 CreateTime = 127;</code>
     */
    private long createTime;

    /**
     * <code>optional uint32 Tid = 1;</code>
     */
    private int tid;

    /**
     * <code>optional uint32 Exp = 2;</code>
     */
    private int exp;

    /**
     * <code>optional uint32 Level = 9;</code>
     */
    private int level;

    /**
     * <code>optional uint32 Skin = 12;</code>
     */
    private int skin;

    /**
     * <code>optional uint32 AffinityLevel = 13;</code>
     */
    private int affinityLevel;

    /**
     * <code>optional uint32 AffinityExp = 14;</code>
     */
    private int affinityExp;

    /**
     * <code>optional uint32 Advance = 15;</code>
     */
    private int advance;

    /**
     * <code>optional uint32 TalentBackground = 21;</code>
     */
    private int talentBackground;

    /**
     * <code>optional .Quests AffinityQuests = 17;</code>
     */
    private final Quests affinityQuests = Quests.newInstance();

    /**
     * <code>optional .CharGemPresets CharGemPresets = 23;</code>
     */
    private final CharGemPresets charGemPresets = CharGemPresets.newInstance();

    /**
     * <code>optional bytes TalentNodes = 19;</code>
     */
    private final RepeatedByte talentNodes = RepeatedByte.newEmptyInstance();

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    /**
     * <code>repeated uint64 EquipmentIds = 6;</code>
     */
    private final RepeatedLong equipmentIds = RepeatedLong.newEmptyInstance();

    /**
     * <code>repeated uint32 DatingLandmarkIds = 3;</code>
     */
    private final RepeatedInt datingLandmarkIds = RepeatedInt.newEmptyInstance();

    /**
     * <code>repeated uint32 DatingEventIds = 4;</code>
     */
    private final RepeatedInt datingEventIds = RepeatedInt.newEmptyInstance();

    /**
     * <code>repeated uint32 DatingEventRewardIds = 5;</code>
     */
    private final RepeatedInt datingEventRewardIds = RepeatedInt.newEmptyInstance();

    /**
     * <code>repeated uint32 SkillLvs = 10;</code>
     */
    private final RepeatedInt skillLvs = RepeatedInt.newEmptyInstance();

    /**
     * <code>repeated uint32 Plots = 16;</code>
     */
    private final RepeatedInt plots = RepeatedInt.newEmptyInstance();

    /**
     * <code>repeated uint32 ArchiveRewardIds = 20;</code>
     */
    private final RepeatedInt archiveRewardIds = RepeatedInt.newEmptyInstance();

    /**
     * <code>repeated .CharGemSlot CharGemSlots = 22;</code>
     */
    private final RepeatedMessage<CharGemSlot> charGemSlots = RepeatedMessage.newEmptyInstance(CharGemSlot.getFactory());

    private Char() {
    }

    /**
     * @return a new empty instance of {@code Char}
     */
    public static Char newInstance() {
      return new Char();
    }

    /**
     * <code>optional int64 CreateTime = 127;</code>
     * @return whether the createTime field is set
     */
    public boolean hasCreateTime() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional int64 CreateTime = 127;</code>
     * @return this
     */
    public Char clearCreateTime() {
      bitField0_ &= ~0x00000001;
      createTime = 0L;
      return this;
    }

    /**
     * <code>optional int64 CreateTime = 127;</code>
     * @return the createTime
     */
    public long getCreateTime() {
      return createTime;
    }

    /**
     * <code>optional int64 CreateTime = 127;</code>
     * @param value the createTime to set
     * @return this
     */
    public Char setCreateTime(final long value) {
      bitField0_ |= 0x00000001;
      createTime = value;
      return this;
    }

    /**
     * <code>optional uint32 Tid = 1;</code>
     * @return whether the tid field is set
     */
    public boolean hasTid() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional uint32 Tid = 1;</code>
     * @return this
     */
    public Char clearTid() {
      bitField0_ &= ~0x00000002;
      tid = 0;
      return this;
    }

    /**
     * <code>optional uint32 Tid = 1;</code>
     * @return the tid
     */
    public int getTid() {
      return tid;
    }

    /**
     * <code>optional uint32 Tid = 1;</code>
     * @param value the tid to set
     * @return this
     */
    public Char setTid(final int value) {
      bitField0_ |= 0x00000002;
      tid = value;
      return this;
    }

    /**
     * <code>optional uint32 Exp = 2;</code>
     * @return whether the exp field is set
     */
    public boolean hasExp() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional uint32 Exp = 2;</code>
     * @return this
     */
    public Char clearExp() {
      bitField0_ &= ~0x00000004;
      exp = 0;
      return this;
    }

    /**
     * <code>optional uint32 Exp = 2;</code>
     * @return the exp
     */
    public int getExp() {
      return exp;
    }

    /**
     * <code>optional uint32 Exp = 2;</code>
     * @param value the exp to set
     * @return this
     */
    public Char setExp(final int value) {
      bitField0_ |= 0x00000004;
      exp = value;
      return this;
    }

    /**
     * <code>optional uint32 Level = 9;</code>
     * @return whether the level field is set
     */
    public boolean hasLevel() {
      return (bitField0_ & 0x00000008) != 0;
    }

    /**
     * <code>optional uint32 Level = 9;</code>
     * @return this
     */
    public Char clearLevel() {
      bitField0_ &= ~0x00000008;
      level = 0;
      return this;
    }

    /**
     * <code>optional uint32 Level = 9;</code>
     * @return the level
     */
    public int getLevel() {
      return level;
    }

    /**
     * <code>optional uint32 Level = 9;</code>
     * @param value the level to set
     * @return this
     */
    public Char setLevel(final int value) {
      bitField0_ |= 0x00000008;
      level = value;
      return this;
    }

    /**
     * <code>optional uint32 Skin = 12;</code>
     * @return whether the skin field is set
     */
    public boolean hasSkin() {
      return (bitField0_ & 0x00000010) != 0;
    }

    /**
     * <code>optional uint32 Skin = 12;</code>
     * @return this
     */
    public Char clearSkin() {
      bitField0_ &= ~0x00000010;
      skin = 0;
      return this;
    }

    /**
     * <code>optional uint32 Skin = 12;</code>
     * @return the skin
     */
    public int getSkin() {
      return skin;
    }

    /**
     * <code>optional uint32 Skin = 12;</code>
     * @param value the skin to set
     * @return this
     */
    public Char setSkin(final int value) {
      bitField0_ |= 0x00000010;
      skin = value;
      return this;
    }

    /**
     * <code>optional uint32 AffinityLevel = 13;</code>
     * @return whether the affinityLevel field is set
     */
    public boolean hasAffinityLevel() {
      return (bitField0_ & 0x00000020) != 0;
    }

    /**
     * <code>optional uint32 AffinityLevel = 13;</code>
     * @return this
     */
    public Char clearAffinityLevel() {
      bitField0_ &= ~0x00000020;
      affinityLevel = 0;
      return this;
    }

    /**
     * <code>optional uint32 AffinityLevel = 13;</code>
     * @return the affinityLevel
     */
    public int getAffinityLevel() {
      return affinityLevel;
    }

    /**
     * <code>optional uint32 AffinityLevel = 13;</code>
     * @param value the affinityLevel to set
     * @return this
     */
    public Char setAffinityLevel(final int value) {
      bitField0_ |= 0x00000020;
      affinityLevel = value;
      return this;
    }

    /**
     * <code>optional uint32 AffinityExp = 14;</code>
     * @return whether the affinityExp field is set
     */
    public boolean hasAffinityExp() {
      return (bitField0_ & 0x00000040) != 0;
    }

    /**
     * <code>optional uint32 AffinityExp = 14;</code>
     * @return this
     */
    public Char clearAffinityExp() {
      bitField0_ &= ~0x00000040;
      affinityExp = 0;
      return this;
    }

    /**
     * <code>optional uint32 AffinityExp = 14;</code>
     * @return the affinityExp
     */
    public int getAffinityExp() {
      return affinityExp;
    }

    /**
     * <code>optional uint32 AffinityExp = 14;</code>
     * @param value the affinityExp to set
     * @return this
     */
    public Char setAffinityExp(final int value) {
      bitField0_ |= 0x00000040;
      affinityExp = value;
      return this;
    }

    /**
     * <code>optional uint32 Advance = 15;</code>
     * @return whether the advance field is set
     */
    public boolean hasAdvance() {
      return (bitField0_ & 0x00000080) != 0;
    }

    /**
     * <code>optional uint32 Advance = 15;</code>
     * @return this
     */
    public Char clearAdvance() {
      bitField0_ &= ~0x00000080;
      advance = 0;
      return this;
    }

    /**
     * <code>optional uint32 Advance = 15;</code>
     * @return the advance
     */
    public int getAdvance() {
      return advance;
    }

    /**
     * <code>optional uint32 Advance = 15;</code>
     * @param value the advance to set
     * @return this
     */
    public Char setAdvance(final int value) {
      bitField0_ |= 0x00000080;
      advance = value;
      return this;
    }

    /**
     * <code>optional uint32 TalentBackground = 21;</code>
     * @return whether the talentBackground field is set
     */
    public boolean hasTalentBackground() {
      return (bitField0_ & 0x00000100) != 0;
    }

    /**
     * <code>optional uint32 TalentBackground = 21;</code>
     * @return this
     */
    public Char clearTalentBackground() {
      bitField0_ &= ~0x00000100;
      talentBackground = 0;
      return this;
    }

    /**
     * <code>optional uint32 TalentBackground = 21;</code>
     * @return the talentBackground
     */
    public int getTalentBackground() {
      return talentBackground;
    }

    /**
     * <code>optional uint32 TalentBackground = 21;</code>
     * @param value the talentBackground to set
     * @return this
     */
    public Char setTalentBackground(final int value) {
      bitField0_ |= 0x00000100;
      talentBackground = value;
      return this;
    }

    /**
     * <code>optional .Quests AffinityQuests = 17;</code>
     * @return whether the affinityQuests field is set
     */
    public boolean hasAffinityQuests() {
      return (bitField0_ & 0x00000200) != 0;
    }

    /**
     * <code>optional .Quests AffinityQuests = 17;</code>
     * @return this
     */
    public Char clearAffinityQuests() {
      bitField0_ &= ~0x00000200;
      affinityQuests.clear();
      return this;
    }

    /**
     * <code>optional .Quests AffinityQuests = 17;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableAffinityQuests()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public Quests getAffinityQuests() {
      return affinityQuests;
    }

    /**
     * <code>optional .Quests AffinityQuests = 17;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public Quests getMutableAffinityQuests() {
      bitField0_ |= 0x00000200;
      return affinityQuests;
    }

    /**
     * <code>optional .Quests AffinityQuests = 17;</code>
     * @param value the affinityQuests to set
     * @return this
     */
    public Char setAffinityQuests(final Quests value) {
      bitField0_ |= 0x00000200;
      affinityQuests.copyFrom(value);
      return this;
    }

    /**
     * <code>optional .CharGemPresets CharGemPresets = 23;</code>
     * @return whether the charGemPresets field is set
     */
    public boolean hasCharGemPresets() {
      return (bitField0_ & 0x00000400) != 0;
    }

    /**
     * <code>optional .CharGemPresets CharGemPresets = 23;</code>
     * @return this
     */
    public Char clearCharGemPresets() {
      bitField0_ &= ~0x00000400;
      charGemPresets.clear();
      return this;
    }

    /**
     * <code>optional .CharGemPresets CharGemPresets = 23;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableCharGemPresets()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public CharGemPresets getCharGemPresets() {
      return charGemPresets;
    }

    /**
     * <code>optional .CharGemPresets CharGemPresets = 23;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public CharGemPresets getMutableCharGemPresets() {
      bitField0_ |= 0x00000400;
      return charGemPresets;
    }

    /**
     * <code>optional .CharGemPresets CharGemPresets = 23;</code>
     * @param value the charGemPresets to set
     * @return this
     */
    public Char setCharGemPresets(final CharGemPresets value) {
      bitField0_ |= 0x00000400;
      charGemPresets.copyFrom(value);
      return this;
    }

    /**
     * <code>optional bytes TalentNodes = 19;</code>
     * @return whether the talentNodes field is set
     */
    public boolean hasTalentNodes() {
      return (bitField0_ & 0x00000800) != 0;
    }

    /**
     * <code>optional bytes TalentNodes = 19;</code>
     * @return this
     */
    public Char clearTalentNodes() {
      bitField0_ &= ~0x00000800;
      talentNodes.clear();
      return this;
    }

    /**
     * <code>optional bytes TalentNodes = 19;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableTalentNodes()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getTalentNodes() {
      return talentNodes;
    }

    /**
     * <code>optional bytes TalentNodes = 19;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableTalentNodes() {
      bitField0_ |= 0x00000800;
      return talentNodes;
    }

    /**
     * <code>optional bytes TalentNodes = 19;</code>
     * @param value the talentNodes to add
     * @return this
     */
    public Char addTalentNodes(final byte value) {
      bitField0_ |= 0x00000800;
      talentNodes.add(value);
      return this;
    }

    /**
     * <code>optional bytes TalentNodes = 19;</code>
     * @param values the talentNodes to add
     * @return this
     */
    public Char addAllTalentNodes(final byte... values) {
      bitField0_ |= 0x00000800;
      talentNodes.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes TalentNodes = 19;</code>
     * @param values the talentNodes to set
     * @return this
     */
    public Char setTalentNodes(final byte... values) {
      bitField0_ |= 0x00000800;
      talentNodes.copyFrom(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00001000) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public Char clearNextPackage() {
      bitField0_ &= ~0x00001000;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00001000;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public Char addNextPackage(final byte value) {
      bitField0_ |= 0x00001000;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public Char addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00001000;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public Char setNextPackage(final byte... values) {
      bitField0_ |= 0x00001000;
      nextPackage.copyFrom(values);
      return this;
    }

    /**
     * <code>repeated uint64 EquipmentIds = 6;</code>
     * @return whether the equipmentIds field is set
     */
    public boolean hasEquipmentIds() {
      return (bitField0_ & 0x00002000) != 0;
    }

    /**
     * <code>repeated uint64 EquipmentIds = 6;</code>
     * @return this
     */
    public Char clearEquipmentIds() {
      bitField0_ &= ~0x00002000;
      equipmentIds.clear();
      return this;
    }

    /**
     * <code>repeated uint64 EquipmentIds = 6;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableEquipmentIds()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedLong getEquipmentIds() {
      return equipmentIds;
    }

    /**
     * <code>repeated uint64 EquipmentIds = 6;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedLong getMutableEquipmentIds() {
      bitField0_ |= 0x00002000;
      return equipmentIds;
    }

    /**
     * <code>repeated uint64 EquipmentIds = 6;</code>
     * @param value the equipmentIds to add
     * @return this
     */
    public Char addEquipmentIds(final long value) {
      bitField0_ |= 0x00002000;
      equipmentIds.add(value);
      return this;
    }

    /**
     * <code>repeated uint64 EquipmentIds = 6;</code>
     * @param values the equipmentIds to add
     * @return this
     */
    public Char addAllEquipmentIds(final long... values) {
      bitField0_ |= 0x00002000;
      equipmentIds.addAll(values);
      return this;
    }

    /**
     * <code>repeated uint32 DatingLandmarkIds = 3;</code>
     * @return whether the datingLandmarkIds field is set
     */
    public boolean hasDatingLandmarkIds() {
      return (bitField0_ & 0x00004000) != 0;
    }

    /**
     * <code>repeated uint32 DatingLandmarkIds = 3;</code>
     * @return this
     */
    public Char clearDatingLandmarkIds() {
      bitField0_ &= ~0x00004000;
      datingLandmarkIds.clear();
      return this;
    }

    /**
     * <code>repeated uint32 DatingLandmarkIds = 3;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableDatingLandmarkIds()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedInt getDatingLandmarkIds() {
      return datingLandmarkIds;
    }

    /**
     * <code>repeated uint32 DatingLandmarkIds = 3;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedInt getMutableDatingLandmarkIds() {
      bitField0_ |= 0x00004000;
      return datingLandmarkIds;
    }

    /**
     * <code>repeated uint32 DatingLandmarkIds = 3;</code>
     * @param value the datingLandmarkIds to add
     * @return this
     */
    public Char addDatingLandmarkIds(final int value) {
      bitField0_ |= 0x00004000;
      datingLandmarkIds.add(value);
      return this;
    }

    /**
     * <code>repeated uint32 DatingLandmarkIds = 3;</code>
     * @param values the datingLandmarkIds to add
     * @return this
     */
    public Char addAllDatingLandmarkIds(final int... values) {
      bitField0_ |= 0x00004000;
      datingLandmarkIds.addAll(values);
      return this;
    }

    /**
     * <code>repeated uint32 DatingEventIds = 4;</code>
     * @return whether the datingEventIds field is set
     */
    public boolean hasDatingEventIds() {
      return (bitField0_ & 0x00008000) != 0;
    }

    /**
     * <code>repeated uint32 DatingEventIds = 4;</code>
     * @return this
     */
    public Char clearDatingEventIds() {
      bitField0_ &= ~0x00008000;
      datingEventIds.clear();
      return this;
    }

    /**
     * <code>repeated uint32 DatingEventIds = 4;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableDatingEventIds()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedInt getDatingEventIds() {
      return datingEventIds;
    }

    /**
     * <code>repeated uint32 DatingEventIds = 4;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedInt getMutableDatingEventIds() {
      bitField0_ |= 0x00008000;
      return datingEventIds;
    }

    /**
     * <code>repeated uint32 DatingEventIds = 4;</code>
     * @param value the datingEventIds to add
     * @return this
     */
    public Char addDatingEventIds(final int value) {
      bitField0_ |= 0x00008000;
      datingEventIds.add(value);
      return this;
    }

    /**
     * <code>repeated uint32 DatingEventIds = 4;</code>
     * @param values the datingEventIds to add
     * @return this
     */
    public Char addAllDatingEventIds(final int... values) {
      bitField0_ |= 0x00008000;
      datingEventIds.addAll(values);
      return this;
    }

    /**
     * <code>repeated uint32 DatingEventRewardIds = 5;</code>
     * @return whether the datingEventRewardIds field is set
     */
    public boolean hasDatingEventRewardIds() {
      return (bitField0_ & 0x00010000) != 0;
    }

    /**
     * <code>repeated uint32 DatingEventRewardIds = 5;</code>
     * @return this
     */
    public Char clearDatingEventRewardIds() {
      bitField0_ &= ~0x00010000;
      datingEventRewardIds.clear();
      return this;
    }

    /**
     * <code>repeated uint32 DatingEventRewardIds = 5;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableDatingEventRewardIds()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedInt getDatingEventRewardIds() {
      return datingEventRewardIds;
    }

    /**
     * <code>repeated uint32 DatingEventRewardIds = 5;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedInt getMutableDatingEventRewardIds() {
      bitField0_ |= 0x00010000;
      return datingEventRewardIds;
    }

    /**
     * <code>repeated uint32 DatingEventRewardIds = 5;</code>
     * @param value the datingEventRewardIds to add
     * @return this
     */
    public Char addDatingEventRewardIds(final int value) {
      bitField0_ |= 0x00010000;
      datingEventRewardIds.add(value);
      return this;
    }

    /**
     * <code>repeated uint32 DatingEventRewardIds = 5;</code>
     * @param values the datingEventRewardIds to add
     * @return this
     */
    public Char addAllDatingEventRewardIds(final int... values) {
      bitField0_ |= 0x00010000;
      datingEventRewardIds.addAll(values);
      return this;
    }

    /**
     * <code>repeated uint32 SkillLvs = 10;</code>
     * @return whether the skillLvs field is set
     */
    public boolean hasSkillLvs() {
      return (bitField0_ & 0x00020000) != 0;
    }

    /**
     * <code>repeated uint32 SkillLvs = 10;</code>
     * @return this
     */
    public Char clearSkillLvs() {
      bitField0_ &= ~0x00020000;
      skillLvs.clear();
      return this;
    }

    /**
     * <code>repeated uint32 SkillLvs = 10;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableSkillLvs()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedInt getSkillLvs() {
      return skillLvs;
    }

    /**
     * <code>repeated uint32 SkillLvs = 10;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedInt getMutableSkillLvs() {
      bitField0_ |= 0x00020000;
      return skillLvs;
    }

    /**
     * <code>repeated uint32 SkillLvs = 10;</code>
     * @param value the skillLvs to add
     * @return this
     */
    public Char addSkillLvs(final int value) {
      bitField0_ |= 0x00020000;
      skillLvs.add(value);
      return this;
    }

    /**
     * <code>repeated uint32 SkillLvs = 10;</code>
     * @param values the skillLvs to add
     * @return this
     */
    public Char addAllSkillLvs(final int... values) {
      bitField0_ |= 0x00020000;
      skillLvs.addAll(values);
      return this;
    }

    /**
     * <code>repeated uint32 Plots = 16;</code>
     * @return whether the plots field is set
     */
    public boolean hasPlots() {
      return (bitField0_ & 0x00040000) != 0;
    }

    /**
     * <code>repeated uint32 Plots = 16;</code>
     * @return this
     */
    public Char clearPlots() {
      bitField0_ &= ~0x00040000;
      plots.clear();
      return this;
    }

    /**
     * <code>repeated uint32 Plots = 16;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutablePlots()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedInt getPlots() {
      return plots;
    }

    /**
     * <code>repeated uint32 Plots = 16;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedInt getMutablePlots() {
      bitField0_ |= 0x00040000;
      return plots;
    }

    /**
     * <code>repeated uint32 Plots = 16;</code>
     * @param value the plots to add
     * @return this
     */
    public Char addPlots(final int value) {
      bitField0_ |= 0x00040000;
      plots.add(value);
      return this;
    }

    /**
     * <code>repeated uint32 Plots = 16;</code>
     * @param values the plots to add
     * @return this
     */
    public Char addAllPlots(final int... values) {
      bitField0_ |= 0x00040000;
      plots.addAll(values);
      return this;
    }

    /**
     * <code>repeated uint32 ArchiveRewardIds = 20;</code>
     * @return whether the archiveRewardIds field is set
     */
    public boolean hasArchiveRewardIds() {
      return (bitField0_ & 0x00080000) != 0;
    }

    /**
     * <code>repeated uint32 ArchiveRewardIds = 20;</code>
     * @return this
     */
    public Char clearArchiveRewardIds() {
      bitField0_ &= ~0x00080000;
      archiveRewardIds.clear();
      return this;
    }

    /**
     * <code>repeated uint32 ArchiveRewardIds = 20;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableArchiveRewardIds()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedInt getArchiveRewardIds() {
      return archiveRewardIds;
    }

    /**
     * <code>repeated uint32 ArchiveRewardIds = 20;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedInt getMutableArchiveRewardIds() {
      bitField0_ |= 0x00080000;
      return archiveRewardIds;
    }

    /**
     * <code>repeated uint32 ArchiveRewardIds = 20;</code>
     * @param value the archiveRewardIds to add
     * @return this
     */
    public Char addArchiveRewardIds(final int value) {
      bitField0_ |= 0x00080000;
      archiveRewardIds.add(value);
      return this;
    }

    /**
     * <code>repeated uint32 ArchiveRewardIds = 20;</code>
     * @param values the archiveRewardIds to add
     * @return this
     */
    public Char addAllArchiveRewardIds(final int... values) {
      bitField0_ |= 0x00080000;
      archiveRewardIds.addAll(values);
      return this;
    }

    /**
     * <code>repeated .CharGemSlot CharGemSlots = 22;</code>
     * @return whether the charGemSlots field is set
     */
    public boolean hasCharGemSlots() {
      return (bitField0_ & 0x00100000) != 0;
    }

    /**
     * <code>repeated .CharGemSlot CharGemSlots = 22;</code>
     * @return this
     */
    public Char clearCharGemSlots() {
      bitField0_ &= ~0x00100000;
      charGemSlots.clear();
      return this;
    }

    /**
     * <code>repeated .CharGemSlot CharGemSlots = 22;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableCharGemSlots()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<CharGemSlot> getCharGemSlots() {
      return charGemSlots;
    }

    /**
     * <code>repeated .CharGemSlot CharGemSlots = 22;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<CharGemSlot> getMutableCharGemSlots() {
      bitField0_ |= 0x00100000;
      return charGemSlots;
    }

    /**
     * <code>repeated .CharGemSlot CharGemSlots = 22;</code>
     * @param value the charGemSlots to add
     * @return this
     */
    public Char addCharGemSlots(final CharGemSlot value) {
      bitField0_ |= 0x00100000;
      charGemSlots.add(value);
      return this;
    }

    /**
     * <code>repeated .CharGemSlot CharGemSlots = 22;</code>
     * @param values the charGemSlots to add
     * @return this
     */
    public Char addAllCharGemSlots(final CharGemSlot... values) {
      bitField0_ |= 0x00100000;
      charGemSlots.addAll(values);
      return this;
    }

    @Override
    public Char copyFrom(final Char other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        createTime = other.createTime;
        tid = other.tid;
        exp = other.exp;
        level = other.level;
        skin = other.skin;
        affinityLevel = other.affinityLevel;
        affinityExp = other.affinityExp;
        advance = other.advance;
        talentBackground = other.talentBackground;
        affinityQuests.copyFrom(other.affinityQuests);
        charGemPresets.copyFrom(other.charGemPresets);
        talentNodes.copyFrom(other.talentNodes);
        nextPackage.copyFrom(other.nextPackage);
        equipmentIds.copyFrom(other.equipmentIds);
        datingLandmarkIds.copyFrom(other.datingLandmarkIds);
        datingEventIds.copyFrom(other.datingEventIds);
        datingEventRewardIds.copyFrom(other.datingEventRewardIds);
        skillLvs.copyFrom(other.skillLvs);
        plots.copyFrom(other.plots);
        archiveRewardIds.copyFrom(other.archiveRewardIds);
        charGemSlots.copyFrom(other.charGemSlots);
      }
      return this;
    }

    @Override
    public Char mergeFrom(final Char other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasCreateTime()) {
        setCreateTime(other.createTime);
      }
      if (other.hasTid()) {
        setTid(other.tid);
      }
      if (other.hasExp()) {
        setExp(other.exp);
      }
      if (other.hasLevel()) {
        setLevel(other.level);
      }
      if (other.hasSkin()) {
        setSkin(other.skin);
      }
      if (other.hasAffinityLevel()) {
        setAffinityLevel(other.affinityLevel);
      }
      if (other.hasAffinityExp()) {
        setAffinityExp(other.affinityExp);
      }
      if (other.hasAdvance()) {
        setAdvance(other.advance);
      }
      if (other.hasTalentBackground()) {
        setTalentBackground(other.talentBackground);
      }
      if (other.hasAffinityQuests()) {
        getMutableAffinityQuests().mergeFrom(other.affinityQuests);
      }
      if (other.hasCharGemPresets()) {
        getMutableCharGemPresets().mergeFrom(other.charGemPresets);
      }
      if (other.hasTalentNodes()) {
        getMutableTalentNodes().copyFrom(other.talentNodes);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      if (other.hasEquipmentIds()) {
        getMutableEquipmentIds().addAll(other.equipmentIds);
      }
      if (other.hasDatingLandmarkIds()) {
        getMutableDatingLandmarkIds().addAll(other.datingLandmarkIds);
      }
      if (other.hasDatingEventIds()) {
        getMutableDatingEventIds().addAll(other.datingEventIds);
      }
      if (other.hasDatingEventRewardIds()) {
        getMutableDatingEventRewardIds().addAll(other.datingEventRewardIds);
      }
      if (other.hasSkillLvs()) {
        getMutableSkillLvs().addAll(other.skillLvs);
      }
      if (other.hasPlots()) {
        getMutablePlots().addAll(other.plots);
      }
      if (other.hasArchiveRewardIds()) {
        getMutableArchiveRewardIds().addAll(other.archiveRewardIds);
      }
      if (other.hasCharGemSlots()) {
        getMutableCharGemSlots().addAll(other.charGemSlots);
      }
      return this;
    }

    @Override
    public Char clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      createTime = 0L;
      tid = 0;
      exp = 0;
      level = 0;
      skin = 0;
      affinityLevel = 0;
      affinityExp = 0;
      advance = 0;
      talentBackground = 0;
      affinityQuests.clear();
      charGemPresets.clear();
      talentNodes.clear();
      nextPackage.clear();
      equipmentIds.clear();
      datingLandmarkIds.clear();
      datingEventIds.clear();
      datingEventRewardIds.clear();
      skillLvs.clear();
      plots.clear();
      archiveRewardIds.clear();
      charGemSlots.clear();
      return this;
    }

    @Override
    public Char clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      affinityQuests.clearQuick();
      charGemPresets.clearQuick();
      talentNodes.clear();
      nextPackage.clear();
      equipmentIds.clear();
      datingLandmarkIds.clear();
      datingEventIds.clear();
      datingEventRewardIds.clear();
      skillLvs.clear();
      plots.clear();
      archiveRewardIds.clear();
      charGemSlots.clearQuick();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof Char)) {
        return false;
      }
      Char other = (Char) o;
      return bitField0_ == other.bitField0_
        && (!hasCreateTime() || createTime == other.createTime)
        && (!hasTid() || tid == other.tid)
        && (!hasExp() || exp == other.exp)
        && (!hasLevel() || level == other.level)
        && (!hasSkin() || skin == other.skin)
        && (!hasAffinityLevel() || affinityLevel == other.affinityLevel)
        && (!hasAffinityExp() || affinityExp == other.affinityExp)
        && (!hasAdvance() || advance == other.advance)
        && (!hasTalentBackground() || talentBackground == other.talentBackground)
        && (!hasAffinityQuests() || affinityQuests.equals(other.affinityQuests))
        && (!hasCharGemPresets() || charGemPresets.equals(other.charGemPresets))
        && (!hasTalentNodes() || talentNodes.equals(other.talentNodes))
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage))
        && (!hasEquipmentIds() || equipmentIds.equals(other.equipmentIds))
        && (!hasDatingLandmarkIds() || datingLandmarkIds.equals(other.datingLandmarkIds))
        && (!hasDatingEventIds() || datingEventIds.equals(other.datingEventIds))
        && (!hasDatingEventRewardIds() || datingEventRewardIds.equals(other.datingEventRewardIds))
        && (!hasSkillLvs() || skillLvs.equals(other.skillLvs))
        && (!hasPlots() || plots.equals(other.plots))
        && (!hasArchiveRewardIds() || archiveRewardIds.equals(other.archiveRewardIds))
        && (!hasCharGemSlots() || charGemSlots.equals(other.charGemSlots));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawLittleEndian16((short) 2040);
        output.writeInt64NoTag(createTime);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt32NoTag(tid);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawByte((byte) 16);
        output.writeUInt32NoTag(exp);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeRawByte((byte) 72);
        output.writeUInt32NoTag(level);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        output.writeRawByte((byte) 96);
        output.writeUInt32NoTag(skin);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        output.writeRawByte((byte) 104);
        output.writeUInt32NoTag(affinityLevel);
      }
      if ((bitField0_ & 0x00000040) != 0) {
        output.writeRawByte((byte) 112);
        output.writeUInt32NoTag(affinityExp);
      }
      if ((bitField0_ & 0x00000080) != 0) {
        output.writeRawByte((byte) 120);
        output.writeUInt32NoTag(advance);
      }
      if ((bitField0_ & 0x00000100) != 0) {
        output.writeRawLittleEndian16((short) 424);
        output.writeUInt32NoTag(talentBackground);
      }
      if ((bitField0_ & 0x00000200) != 0) {
        output.writeRawLittleEndian16((short) 394);
        output.writeMessageNoTag(affinityQuests);
      }
      if ((bitField0_ & 0x00000400) != 0) {
        output.writeRawLittleEndian16((short) 442);
        output.writeMessageNoTag(charGemPresets);
      }
      if ((bitField0_ & 0x00000800) != 0) {
        output.writeRawLittleEndian16((short) 410);
        output.writeBytesNoTag(talentNodes);
      }
      if ((bitField0_ & 0x00001000) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00002000) != 0) {
        for (int i = 0; i < equipmentIds.length(); i++) {
          output.writeRawByte((byte) 48);
          output.writeUInt64NoTag(equipmentIds.array()[i]);
        }
      }
      if ((bitField0_ & 0x00004000) != 0) {
        for (int i = 0; i < datingLandmarkIds.length(); i++) {
          output.writeRawByte((byte) 24);
          output.writeUInt32NoTag(datingLandmarkIds.array()[i]);
        }
      }
      if ((bitField0_ & 0x00008000) != 0) {
        for (int i = 0; i < datingEventIds.length(); i++) {
          output.writeRawByte((byte) 32);
          output.writeUInt32NoTag(datingEventIds.array()[i]);
        }
      }
      if ((bitField0_ & 0x00010000) != 0) {
        for (int i = 0; i < datingEventRewardIds.length(); i++) {
          output.writeRawByte((byte) 40);
          output.writeUInt32NoTag(datingEventRewardIds.array()[i]);
        }
      }
      if ((bitField0_ & 0x00020000) != 0) {
        for (int i = 0; i < skillLvs.length(); i++) {
          output.writeRawByte((byte) 80);
          output.writeUInt32NoTag(skillLvs.array()[i]);
        }
      }
      if ((bitField0_ & 0x00040000) != 0) {
        for (int i = 0; i < plots.length(); i++) {
          output.writeRawLittleEndian16((short) 384);
          output.writeUInt32NoTag(plots.array()[i]);
        }
      }
      if ((bitField0_ & 0x00080000) != 0) {
        for (int i = 0; i < archiveRewardIds.length(); i++) {
          output.writeRawLittleEndian16((short) 416);
          output.writeUInt32NoTag(archiveRewardIds.array()[i]);
        }
      }
      if ((bitField0_ & 0x00100000) != 0) {
        for (int i = 0; i < charGemSlots.length(); i++) {
          output.writeRawLittleEndian16((short) 434);
          output.writeMessageNoTag(charGemSlots.get(i));
        }
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 2 + ProtoSink.computeInt64SizeNoTag(createTime);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(tid);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(exp);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(level);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(skin);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(affinityLevel);
      }
      if ((bitField0_ & 0x00000040) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(affinityExp);
      }
      if ((bitField0_ & 0x00000080) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(advance);
      }
      if ((bitField0_ & 0x00000100) != 0) {
        size += 2 + ProtoSink.computeUInt32SizeNoTag(talentBackground);
      }
      if ((bitField0_ & 0x00000200) != 0) {
        size += 2 + ProtoSink.computeMessageSizeNoTag(affinityQuests);
      }
      if ((bitField0_ & 0x00000400) != 0) {
        size += 2 + ProtoSink.computeMessageSizeNoTag(charGemPresets);
      }
      if ((bitField0_ & 0x00000800) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(talentNodes);
      }
      if ((bitField0_ & 0x00001000) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00002000) != 0) {
        size += (1 * equipmentIds.length()) + ProtoSink.computeRepeatedUInt64SizeNoTag(equipmentIds);
      }
      if ((bitField0_ & 0x00004000) != 0) {
        size += (1 * datingLandmarkIds.length()) + ProtoSink.computeRepeatedUInt32SizeNoTag(datingLandmarkIds);
      }
      if ((bitField0_ & 0x00008000) != 0) {
        size += (1 * datingEventIds.length()) + ProtoSink.computeRepeatedUInt32SizeNoTag(datingEventIds);
      }
      if ((bitField0_ & 0x00010000) != 0) {
        size += (1 * datingEventRewardIds.length()) + ProtoSink.computeRepeatedUInt32SizeNoTag(datingEventRewardIds);
      }
      if ((bitField0_ & 0x00020000) != 0) {
        size += (1 * skillLvs.length()) + ProtoSink.computeRepeatedUInt32SizeNoTag(skillLvs);
      }
      if ((bitField0_ & 0x00040000) != 0) {
        size += (2 * plots.length()) + ProtoSink.computeRepeatedUInt32SizeNoTag(plots);
      }
      if ((bitField0_ & 0x00080000) != 0) {
        size += (2 * archiveRewardIds.length()) + ProtoSink.computeRepeatedUInt32SizeNoTag(archiveRewardIds);
      }
      if ((bitField0_ & 0x00100000) != 0) {
        size += (2 * charGemSlots.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(charGemSlots);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public Char mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 1016: {
            // createTime
            createTime = input.readInt64();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 8) {
              break;
            }
          }
          case 8: {
            // tid
            tid = input.readUInt32();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 16) {
              break;
            }
          }
          case 16: {
            // exp
            exp = input.readUInt32();
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 72) {
              break;
            }
          }
          case 72: {
            // level
            level = input.readUInt32();
            bitField0_ |= 0x00000008;
            tag = input.readTag();
            if (tag != 96) {
              break;
            }
          }
          case 96: {
            // skin
            skin = input.readUInt32();
            bitField0_ |= 0x00000010;
            tag = input.readTag();
            if (tag != 104) {
              break;
            }
          }
          case 104: {
            // affinityLevel
            affinityLevel = input.readUInt32();
            bitField0_ |= 0x00000020;
            tag = input.readTag();
            if (tag != 112) {
              break;
            }
          }
          case 112: {
            // affinityExp
            affinityExp = input.readUInt32();
            bitField0_ |= 0x00000040;
            tag = input.readTag();
            if (tag != 120) {
              break;
            }
          }
          case 120: {
            // advance
            advance = input.readUInt32();
            bitField0_ |= 0x00000080;
            tag = input.readTag();
            if (tag != 168) {
              break;
            }
          }
          case 168: {
            // talentBackground
            talentBackground = input.readUInt32();
            bitField0_ |= 0x00000100;
            tag = input.readTag();
            if (tag != 138) {
              break;
            }
          }
          case 138: {
            // affinityQuests
            input.readMessage(affinityQuests);
            bitField0_ |= 0x00000200;
            tag = input.readTag();
            if (tag != 186) {
              break;
            }
          }
          case 186: {
            // charGemPresets
            input.readMessage(charGemPresets);
            bitField0_ |= 0x00000400;
            tag = input.readTag();
            if (tag != 154) {
              break;
            }
          }
          case 154: {
            // talentNodes
            input.readBytes(talentNodes);
            bitField0_ |= 0x00000800;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00001000;
            tag = input.readTag();
            if (tag != 50) {
              break;
            }
          }
          case 50: {
            // equipmentIds [packed=true]
            input.readPackedUInt64(equipmentIds, tag);
            bitField0_ |= 0x00002000;
            tag = input.readTag();
            if (tag != 26) {
              break;
            }
          }
          case 26: {
            // datingLandmarkIds [packed=true]
            input.readPackedUInt32(datingLandmarkIds, tag);
            bitField0_ |= 0x00004000;
            tag = input.readTag();
            if (tag != 34) {
              break;
            }
          }
          case 34: {
            // datingEventIds [packed=true]
            input.readPackedUInt32(datingEventIds, tag);
            bitField0_ |= 0x00008000;
            tag = input.readTag();
            if (tag != 42) {
              break;
            }
          }
          case 42: {
            // datingEventRewardIds [packed=true]
            input.readPackedUInt32(datingEventRewardIds, tag);
            bitField0_ |= 0x00010000;
            tag = input.readTag();
            if (tag != 82) {
              break;
            }
          }
          case 82: {
            // skillLvs [packed=true]
            input.readPackedUInt32(skillLvs, tag);
            bitField0_ |= 0x00020000;
            tag = input.readTag();
            if (tag != 130) {
              break;
            }
          }
          case 130: {
            // plots [packed=true]
            input.readPackedUInt32(plots, tag);
            bitField0_ |= 0x00040000;
            tag = input.readTag();
            if (tag != 162) {
              break;
            }
          }
          case 162: {
            // archiveRewardIds [packed=true]
            input.readPackedUInt32(archiveRewardIds, tag);
            bitField0_ |= 0x00080000;
            tag = input.readTag();
            if (tag != 178) {
              break;
            }
          }
          case 178: {
            // charGemSlots
            tag = input.readRepeatedMessage(charGemSlots, tag);
            bitField0_ |= 0x00100000;
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
          case 48: {
            // equipmentIds [packed=false]
            tag = input.readRepeatedUInt64(equipmentIds, tag);
            bitField0_ |= 0x00002000;
            break;
          }
          case 24: {
            // datingLandmarkIds [packed=false]
            tag = input.readRepeatedUInt32(datingLandmarkIds, tag);
            bitField0_ |= 0x00004000;
            break;
          }
          case 32: {
            // datingEventIds [packed=false]
            tag = input.readRepeatedUInt32(datingEventIds, tag);
            bitField0_ |= 0x00008000;
            break;
          }
          case 40: {
            // datingEventRewardIds [packed=false]
            tag = input.readRepeatedUInt32(datingEventRewardIds, tag);
            bitField0_ |= 0x00010000;
            break;
          }
          case 80: {
            // skillLvs [packed=false]
            tag = input.readRepeatedUInt32(skillLvs, tag);
            bitField0_ |= 0x00020000;
            break;
          }
          case 128: {
            // plots [packed=false]
            tag = input.readRepeatedUInt32(plots, tag);
            bitField0_ |= 0x00040000;
            break;
          }
          case 160: {
            // archiveRewardIds [packed=false]
            tag = input.readRepeatedUInt32(archiveRewardIds, tag);
            bitField0_ |= 0x00080000;
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeInt64(FieldNames.createTime, createTime);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeUInt32(FieldNames.tid, tid);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeUInt32(FieldNames.exp, exp);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeUInt32(FieldNames.level, level);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        output.writeUInt32(FieldNames.skin, skin);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        output.writeUInt32(FieldNames.affinityLevel, affinityLevel);
      }
      if ((bitField0_ & 0x00000040) != 0) {
        output.writeUInt32(FieldNames.affinityExp, affinityExp);
      }
      if ((bitField0_ & 0x00000080) != 0) {
        output.writeUInt32(FieldNames.advance, advance);
      }
      if ((bitField0_ & 0x00000100) != 0) {
        output.writeUInt32(FieldNames.talentBackground, talentBackground);
      }
      if ((bitField0_ & 0x00000200) != 0) {
        output.writeMessage(FieldNames.affinityQuests, affinityQuests);
      }
      if ((bitField0_ & 0x00000400) != 0) {
        output.writeMessage(FieldNames.charGemPresets, charGemPresets);
      }
      if ((bitField0_ & 0x00000800) != 0) {
        output.writeBytes(FieldNames.talentNodes, talentNodes);
      }
      if ((bitField0_ & 0x00001000) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      if ((bitField0_ & 0x00002000) != 0) {
        output.writeRepeatedUInt64(FieldNames.equipmentIds, equipmentIds);
      }
      if ((bitField0_ & 0x00004000) != 0) {
        output.writeRepeatedUInt32(FieldNames.datingLandmarkIds, datingLandmarkIds);
      }
      if ((bitField0_ & 0x00008000) != 0) {
        output.writeRepeatedUInt32(FieldNames.datingEventIds, datingEventIds);
      }
      if ((bitField0_ & 0x00010000) != 0) {
        output.writeRepeatedUInt32(FieldNames.datingEventRewardIds, datingEventRewardIds);
      }
      if ((bitField0_ & 0x00020000) != 0) {
        output.writeRepeatedUInt32(FieldNames.skillLvs, skillLvs);
      }
      if ((bitField0_ & 0x00040000) != 0) {
        output.writeRepeatedUInt32(FieldNames.plots, plots);
      }
      if ((bitField0_ & 0x00080000) != 0) {
        output.writeRepeatedUInt32(FieldNames.archiveRewardIds, archiveRewardIds);
      }
      if ((bitField0_ & 0x00100000) != 0) {
        output.writeRepeatedMessage(FieldNames.charGemSlots, charGemSlots);
      }
      output.endObject();
    }

    @Override
    public Char mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case -932289015: {
            if (input.isAtField(FieldNames.createTime)) {
              if (!input.trySkipNullValue()) {
                createTime = input.readInt64();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 84079: {
            if (input.isAtField(FieldNames.tid)) {
              if (!input.trySkipNullValue()) {
                tid = input.readUInt32();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 70141: {
            if (input.isAtField(FieldNames.exp)) {
              if (!input.trySkipNullValue()) {
                exp = input.readUInt32();
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 73313124: {
            if (input.isAtField(FieldNames.level)) {
              if (!input.trySkipNullValue()) {
                level = input.readUInt32();
                bitField0_ |= 0x00000008;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 2578845: {
            if (input.isAtField(FieldNames.skin)) {
              if (!input.trySkipNullValue()) {
                skin = input.readUInt32();
                bitField0_ |= 0x00000010;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 1094331164: {
            if (input.isAtField(FieldNames.affinityLevel)) {
              if (!input.trySkipNullValue()) {
                affinityLevel = input.readUInt32();
                bitField0_ |= 0x00000020;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 1185488821: {
            if (input.isAtField(FieldNames.affinityExp)) {
              if (!input.trySkipNullValue()) {
                affinityExp = input.readUInt32();
                bitField0_ |= 0x00000040;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 533086306: {
            if (input.isAtField(FieldNames.advance)) {
              if (!input.trySkipNullValue()) {
                advance = input.readUInt32();
                bitField0_ |= 0x00000080;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 1621290842: {
            if (input.isAtField(FieldNames.talentBackground)) {
              if (!input.trySkipNullValue()) {
                talentBackground = input.readUInt32();
                bitField0_ |= 0x00000100;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -278042823: {
            if (input.isAtField(FieldNames.affinityQuests)) {
              if (!input.trySkipNullValue()) {
                input.readMessage(affinityQuests);
                bitField0_ |= 0x00000200;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 82576187: {
            if (input.isAtField(FieldNames.charGemPresets)) {
              if (!input.trySkipNullValue()) {
                input.readMessage(charGemPresets);
                bitField0_ |= 0x00000400;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 2029178117: {
            if (input.isAtField(FieldNames.talentNodes)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(talentNodes);
                bitField0_ |= 0x00000800;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00001000;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -325125526: {
            if (input.isAtField(FieldNames.equipmentIds)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedUInt64(equipmentIds);
                bitField0_ |= 0x00002000;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 346678869: {
            if (input.isAtField(FieldNames.datingLandmarkIds)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedUInt32(datingLandmarkIds);
                bitField0_ |= 0x00004000;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1604297751: {
            if (input.isAtField(FieldNames.datingEventIds)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedUInt32(datingEventIds);
                bitField0_ |= 0x00008000;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -220649094: {
            if (input.isAtField(FieldNames.datingEventRewardIds)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedUInt32(datingEventRewardIds);
                bitField0_ |= 0x00010000;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2087888840: {
            if (input.isAtField(FieldNames.skillLvs)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedUInt32(skillLvs);
                bitField0_ |= 0x00020000;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 77209490: {
            if (input.isAtField(FieldNames.plots)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedUInt32(plots);
                bitField0_ |= 0x00040000;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 1858210439: {
            if (input.isAtField(FieldNames.archiveRewardIds)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedUInt32(archiveRewardIds);
                bitField0_ |= 0x00080000;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2084461124: {
            if (input.isAtField(FieldNames.charGemSlots)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedMessage(charGemSlots);
                bitField0_ |= 0x00100000;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public Char clone() {
      return new Char().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static Char parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new Char(), data).checkInitialized();
    }

    public static Char parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new Char(), input).checkInitialized();
    }

    public static Char parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new Char(), input).checkInitialized();
    }

    /**
     * @return factory for creating Char messages
     */
    public static MessageFactory<Char> getFactory() {
      return CharFactory.INSTANCE;
    }

    private enum CharFactory implements MessageFactory<Char> {
      INSTANCE;

      @Override
      public Char create() {
        return Char.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName createTime = FieldName.forField("CreateTime");

      static final FieldName tid = FieldName.forField("Tid");

      static final FieldName exp = FieldName.forField("Exp");

      static final FieldName level = FieldName.forField("Level");

      static final FieldName skin = FieldName.forField("Skin");

      static final FieldName affinityLevel = FieldName.forField("AffinityLevel");

      static final FieldName affinityExp = FieldName.forField("AffinityExp");

      static final FieldName advance = FieldName.forField("Advance");

      static final FieldName talentBackground = FieldName.forField("TalentBackground");

      static final FieldName affinityQuests = FieldName.forField("AffinityQuests");

      static final FieldName charGemPresets = FieldName.forField("CharGemPresets");

      static final FieldName talentNodes = FieldName.forField("TalentNodes");

      static final FieldName nextPackage = FieldName.forField("NextPackage");

      static final FieldName equipmentIds = FieldName.forField("EquipmentIds");

      static final FieldName datingLandmarkIds = FieldName.forField("DatingLandmarkIds");

      static final FieldName datingEventIds = FieldName.forField("DatingEventIds");

      static final FieldName datingEventRewardIds = FieldName.forField("DatingEventRewardIds");

      static final FieldName skillLvs = FieldName.forField("SkillLvs");

      static final FieldName plots = FieldName.forField("Plots");

      static final FieldName archiveRewardIds = FieldName.forField("ArchiveRewardIds");

      static final FieldName charGemSlots = FieldName.forField("CharGemSlots");
    }
  }

  /**
   * Protobuf type {@code Energy}
   */
  public static final class Energy extends ProtoMessage<Energy> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional int64 UpdateTime = 4;</code>
     */
    private long updateTime;

    /**
     * <code>optional int64 NextDuration = 5;</code>
     */
    private long nextDuration;

    /**
     * <code>optional uint32 Primary = 1;</code>
     */
    private int primary;

    /**
     * <code>optional uint32 Secondary = 2;</code>
     */
    private int secondary;

    /**
     * <code>optional bool IsPrimary = 3;</code>
     */
    private boolean isPrimary;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    private Energy() {
    }

    /**
     * @return a new empty instance of {@code Energy}
     */
    public static Energy newInstance() {
      return new Energy();
    }

    /**
     * <code>optional int64 UpdateTime = 4;</code>
     * @return whether the updateTime field is set
     */
    public boolean hasUpdateTime() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional int64 UpdateTime = 4;</code>
     * @return this
     */
    public Energy clearUpdateTime() {
      bitField0_ &= ~0x00000001;
      updateTime = 0L;
      return this;
    }

    /**
     * <code>optional int64 UpdateTime = 4;</code>
     * @return the updateTime
     */
    public long getUpdateTime() {
      return updateTime;
    }

    /**
     * <code>optional int64 UpdateTime = 4;</code>
     * @param value the updateTime to set
     * @return this
     */
    public Energy setUpdateTime(final long value) {
      bitField0_ |= 0x00000001;
      updateTime = value;
      return this;
    }

    /**
     * <code>optional int64 NextDuration = 5;</code>
     * @return whether the nextDuration field is set
     */
    public boolean hasNextDuration() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional int64 NextDuration = 5;</code>
     * @return this
     */
    public Energy clearNextDuration() {
      bitField0_ &= ~0x00000002;
      nextDuration = 0L;
      return this;
    }

    /**
     * <code>optional int64 NextDuration = 5;</code>
     * @return the nextDuration
     */
    public long getNextDuration() {
      return nextDuration;
    }

    /**
     * <code>optional int64 NextDuration = 5;</code>
     * @param value the nextDuration to set
     * @return this
     */
    public Energy setNextDuration(final long value) {
      bitField0_ |= 0x00000002;
      nextDuration = value;
      return this;
    }

    /**
     * <code>optional uint32 Primary = 1;</code>
     * @return whether the primary field is set
     */
    public boolean hasPrimary() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional uint32 Primary = 1;</code>
     * @return this
     */
    public Energy clearPrimary() {
      bitField0_ &= ~0x00000004;
      primary = 0;
      return this;
    }

    /**
     * <code>optional uint32 Primary = 1;</code>
     * @return the primary
     */
    public int getPrimary() {
      return primary;
    }

    /**
     * <code>optional uint32 Primary = 1;</code>
     * @param value the primary to set
     * @return this
     */
    public Energy setPrimary(final int value) {
      bitField0_ |= 0x00000004;
      primary = value;
      return this;
    }

    /**
     * <code>optional uint32 Secondary = 2;</code>
     * @return whether the secondary field is set
     */
    public boolean hasSecondary() {
      return (bitField0_ & 0x00000008) != 0;
    }

    /**
     * <code>optional uint32 Secondary = 2;</code>
     * @return this
     */
    public Energy clearSecondary() {
      bitField0_ &= ~0x00000008;
      secondary = 0;
      return this;
    }

    /**
     * <code>optional uint32 Secondary = 2;</code>
     * @return the secondary
     */
    public int getSecondary() {
      return secondary;
    }

    /**
     * <code>optional uint32 Secondary = 2;</code>
     * @param value the secondary to set
     * @return this
     */
    public Energy setSecondary(final int value) {
      bitField0_ |= 0x00000008;
      secondary = value;
      return this;
    }

    /**
     * <code>optional bool IsPrimary = 3;</code>
     * @return whether the isPrimary field is set
     */
    public boolean hasIsPrimary() {
      return (bitField0_ & 0x00000010) != 0;
    }

    /**
     * <code>optional bool IsPrimary = 3;</code>
     * @return this
     */
    public Energy clearIsPrimary() {
      bitField0_ &= ~0x00000010;
      isPrimary = false;
      return this;
    }

    /**
     * <code>optional bool IsPrimary = 3;</code>
     * @return the isPrimary
     */
    public boolean getIsPrimary() {
      return isPrimary;
    }

    /**
     * <code>optional bool IsPrimary = 3;</code>
     * @param value the isPrimary to set
     * @return this
     */
    public Energy setIsPrimary(final boolean value) {
      bitField0_ |= 0x00000010;
      isPrimary = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000020) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public Energy clearNextPackage() {
      bitField0_ &= ~0x00000020;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000020;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public Energy addNextPackage(final byte value) {
      bitField0_ |= 0x00000020;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public Energy addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000020;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public Energy setNextPackage(final byte... values) {
      bitField0_ |= 0x00000020;
      nextPackage.copyFrom(values);
      return this;
    }

    @Override
    public Energy copyFrom(final Energy other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        updateTime = other.updateTime;
        nextDuration = other.nextDuration;
        primary = other.primary;
        secondary = other.secondary;
        isPrimary = other.isPrimary;
        nextPackage.copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public Energy mergeFrom(final Energy other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasUpdateTime()) {
        setUpdateTime(other.updateTime);
      }
      if (other.hasNextDuration()) {
        setNextDuration(other.nextDuration);
      }
      if (other.hasPrimary()) {
        setPrimary(other.primary);
      }
      if (other.hasSecondary()) {
        setSecondary(other.secondary);
      }
      if (other.hasIsPrimary()) {
        setIsPrimary(other.isPrimary);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public Energy clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      updateTime = 0L;
      nextDuration = 0L;
      primary = 0;
      secondary = 0;
      isPrimary = false;
      nextPackage.clear();
      return this;
    }

    @Override
    public Energy clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof Energy)) {
        return false;
      }
      Energy other = (Energy) o;
      return bitField0_ == other.bitField0_
        && (!hasUpdateTime() || updateTime == other.updateTime)
        && (!hasNextDuration() || nextDuration == other.nextDuration)
        && (!hasPrimary() || primary == other.primary)
        && (!hasSecondary() || secondary == other.secondary)
        && (!hasIsPrimary() || isPrimary == other.isPrimary)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 32);
        output.writeInt64NoTag(updateTime);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 40);
        output.writeInt64NoTag(nextDuration);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt32NoTag(primary);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeRawByte((byte) 16);
        output.writeUInt32NoTag(secondary);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        output.writeRawByte((byte) 24);
        output.writeBoolNoTag(isPrimary);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeInt64SizeNoTag(updateTime);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeInt64SizeNoTag(nextDuration);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(primary);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(secondary);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        size += 2;
      }
      if ((bitField0_ & 0x00000020) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public Energy mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 32: {
            // updateTime
            updateTime = input.readInt64();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 40) {
              break;
            }
          }
          case 40: {
            // nextDuration
            nextDuration = input.readInt64();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 8) {
              break;
            }
          }
          case 8: {
            // primary
            primary = input.readUInt32();
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 16) {
              break;
            }
          }
          case 16: {
            // secondary
            secondary = input.readUInt32();
            bitField0_ |= 0x00000008;
            tag = input.readTag();
            if (tag != 24) {
              break;
            }
          }
          case 24: {
            // isPrimary
            isPrimary = input.readBool();
            bitField0_ |= 0x00000010;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000020;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeInt64(FieldNames.updateTime, updateTime);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeInt64(FieldNames.nextDuration, nextDuration);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeUInt32(FieldNames.primary, primary);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeUInt32(FieldNames.secondary, secondary);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        output.writeBool(FieldNames.isPrimary, isPrimary);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      output.endObject();
    }

    @Override
    public Energy mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 1697533782: {
            if (input.isAtField(FieldNames.updateTime)) {
              if (!input.trySkipNullValue()) {
                updateTime = input.readInt64();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 1424551367: {
            if (input.isAtField(FieldNames.nextDuration)) {
              if (!input.trySkipNullValue()) {
                nextDuration = input.readInt64();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 1349887458: {
            if (input.isAtField(FieldNames.primary)) {
              if (!input.trySkipNullValue()) {
                primary = input.readUInt32();
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 1186369876: {
            if (input.isAtField(FieldNames.secondary)) {
              if (!input.trySkipNullValue()) {
                secondary = input.readUInt32();
                bitField0_ |= 0x00000008;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 1109423448: {
            if (input.isAtField(FieldNames.isPrimary)) {
              if (!input.trySkipNullValue()) {
                isPrimary = input.readBool();
                bitField0_ |= 0x00000010;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000020;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public Energy clone() {
      return new Energy().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static Energy parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new Energy(), data).checkInitialized();
    }

    public static Energy parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new Energy(), input).checkInitialized();
    }

    public static Energy parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new Energy(), input).checkInitialized();
    }

    /**
     * @return factory for creating Energy messages
     */
    public static MessageFactory<Energy> getFactory() {
      return EnergyFactory.INSTANCE;
    }

    private enum EnergyFactory implements MessageFactory<Energy> {
      INSTANCE;

      @Override
      public Energy create() {
        return Energy.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName updateTime = FieldName.forField("UpdateTime");

      static final FieldName nextDuration = FieldName.forField("NextDuration");

      static final FieldName primary = FieldName.forField("Primary");

      static final FieldName secondary = FieldName.forField("Secondary");

      static final FieldName isPrimary = FieldName.forField("IsPrimary");

      static final FieldName nextPackage = FieldName.forField("NextPackage");
    }
  }

  /**
   * Protobuf type {@code WorldClass}
   */
  public static final class WorldClass extends ProtoMessage<WorldClass> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional int32 ExpChange = 2;</code>
     */
    private int expChange;

    /**
     * <code>optional uint32 AddClass = 1;</code>
     */
    private int addClass;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    private WorldClass() {
    }

    /**
     * @return a new empty instance of {@code WorldClass}
     */
    public static WorldClass newInstance() {
      return new WorldClass();
    }

    /**
     * <code>optional int32 ExpChange = 2;</code>
     * @return whether the expChange field is set
     */
    public boolean hasExpChange() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional int32 ExpChange = 2;</code>
     * @return this
     */
    public WorldClass clearExpChange() {
      bitField0_ &= ~0x00000001;
      expChange = 0;
      return this;
    }

    /**
     * <code>optional int32 ExpChange = 2;</code>
     * @return the expChange
     */
    public int getExpChange() {
      return expChange;
    }

    /**
     * <code>optional int32 ExpChange = 2;</code>
     * @param value the expChange to set
     * @return this
     */
    public WorldClass setExpChange(final int value) {
      bitField0_ |= 0x00000001;
      expChange = value;
      return this;
    }

    /**
     * <code>optional uint32 AddClass = 1;</code>
     * @return whether the addClass field is set
     */
    public boolean hasAddClass() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional uint32 AddClass = 1;</code>
     * @return this
     */
    public WorldClass clearAddClass() {
      bitField0_ &= ~0x00000002;
      addClass = 0;
      return this;
    }

    /**
     * <code>optional uint32 AddClass = 1;</code>
     * @return the addClass
     */
    public int getAddClass() {
      return addClass;
    }

    /**
     * <code>optional uint32 AddClass = 1;</code>
     * @param value the addClass to set
     * @return this
     */
    public WorldClass setAddClass(final int value) {
      bitField0_ |= 0x00000002;
      addClass = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public WorldClass clearNextPackage() {
      bitField0_ &= ~0x00000004;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000004;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public WorldClass addNextPackage(final byte value) {
      bitField0_ |= 0x00000004;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public WorldClass addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000004;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public WorldClass setNextPackage(final byte... values) {
      bitField0_ |= 0x00000004;
      nextPackage.copyFrom(values);
      return this;
    }

    @Override
    public WorldClass copyFrom(final WorldClass other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        expChange = other.expChange;
        addClass = other.addClass;
        nextPackage.copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public WorldClass mergeFrom(final WorldClass other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasExpChange()) {
        setExpChange(other.expChange);
      }
      if (other.hasAddClass()) {
        setAddClass(other.addClass);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public WorldClass clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      expChange = 0;
      addClass = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public WorldClass clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof WorldClass)) {
        return false;
      }
      WorldClass other = (WorldClass) o;
      return bitField0_ == other.bitField0_
        && (!hasExpChange() || expChange == other.expChange)
        && (!hasAddClass() || addClass == other.addClass)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 16);
        output.writeInt32NoTag(expChange);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt32NoTag(addClass);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeInt32SizeNoTag(expChange);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(addClass);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public WorldClass mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 16: {
            // expChange
            expChange = input.readInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 8) {
              break;
            }
          }
          case 8: {
            // addClass
            addClass = input.readUInt32();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeInt32(FieldNames.expChange, expChange);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeUInt32(FieldNames.addClass, addClass);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      output.endObject();
    }

    @Override
    public WorldClass mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 1156898829: {
            if (input.isAtField(FieldNames.expChange)) {
              if (!input.trySkipNullValue()) {
                expChange = input.readInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1197285001: {
            if (input.isAtField(FieldNames.addClass)) {
              if (!input.trySkipNullValue()) {
                addClass = input.readUInt32();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public WorldClass clone() {
      return new WorldClass().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static WorldClass parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new WorldClass(), data).checkInitialized();
    }

    public static WorldClass parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new WorldClass(), input).checkInitialized();
    }

    public static WorldClass parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new WorldClass(), input).checkInitialized();
    }

    /**
     * @return factory for creating WorldClass messages
     */
    public static MessageFactory<WorldClass> getFactory() {
      return WorldClassFactory.INSTANCE;
    }

    private enum WorldClassFactory implements MessageFactory<WorldClass> {
      INSTANCE;

      @Override
      public WorldClass create() {
        return WorldClass.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName expChange = FieldName.forField("ExpChange");

      static final FieldName addClass = FieldName.forField("AddClass");

      static final FieldName nextPackage = FieldName.forField("NextPackage");
    }
  }

  /**
   * Protobuf type {@code Equipment}
   */
  public static final class Equipment extends ProtoMessage<Equipment> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional int32 Qty = 2;</code>
     */
    private int qty;

    /**
     * <code>optional .EquipmentInfo Info = 1;</code>
     */
    private final EquipmentInfo info = EquipmentInfo.newInstance();

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    private Equipment() {
    }

    /**
     * @return a new empty instance of {@code Equipment}
     */
    public static Equipment newInstance() {
      return new Equipment();
    }

    /**
     * <code>optional int32 Qty = 2;</code>
     * @return whether the qty field is set
     */
    public boolean hasQty() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional int32 Qty = 2;</code>
     * @return this
     */
    public Equipment clearQty() {
      bitField0_ &= ~0x00000001;
      qty = 0;
      return this;
    }

    /**
     * <code>optional int32 Qty = 2;</code>
     * @return the qty
     */
    public int getQty() {
      return qty;
    }

    /**
     * <code>optional int32 Qty = 2;</code>
     * @param value the qty to set
     * @return this
     */
    public Equipment setQty(final int value) {
      bitField0_ |= 0x00000001;
      qty = value;
      return this;
    }

    /**
     * <code>optional .EquipmentInfo Info = 1;</code>
     * @return whether the info field is set
     */
    public boolean hasInfo() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional .EquipmentInfo Info = 1;</code>
     * @return this
     */
    public Equipment clearInfo() {
      bitField0_ &= ~0x00000002;
      info.clear();
      return this;
    }

    /**
     * <code>optional .EquipmentInfo Info = 1;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableInfo()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public EquipmentInfo getInfo() {
      return info;
    }

    /**
     * <code>optional .EquipmentInfo Info = 1;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public EquipmentInfo getMutableInfo() {
      bitField0_ |= 0x00000002;
      return info;
    }

    /**
     * <code>optional .EquipmentInfo Info = 1;</code>
     * @param value the info to set
     * @return this
     */
    public Equipment setInfo(final EquipmentInfo value) {
      bitField0_ |= 0x00000002;
      info.copyFrom(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public Equipment clearNextPackage() {
      bitField0_ &= ~0x00000004;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000004;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public Equipment addNextPackage(final byte value) {
      bitField0_ |= 0x00000004;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public Equipment addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000004;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public Equipment setNextPackage(final byte... values) {
      bitField0_ |= 0x00000004;
      nextPackage.copyFrom(values);
      return this;
    }

    @Override
    public Equipment copyFrom(final Equipment other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        qty = other.qty;
        info.copyFrom(other.info);
        nextPackage.copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public Equipment mergeFrom(final Equipment other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasQty()) {
        setQty(other.qty);
      }
      if (other.hasInfo()) {
        getMutableInfo().mergeFrom(other.info);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public Equipment clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      qty = 0;
      info.clear();
      nextPackage.clear();
      return this;
    }

    @Override
    public Equipment clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      info.clearQuick();
      nextPackage.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof Equipment)) {
        return false;
      }
      Equipment other = (Equipment) o;
      return bitField0_ == other.bitField0_
        && (!hasQty() || qty == other.qty)
        && (!hasInfo() || info.equals(other.info))
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 16);
        output.writeInt32NoTag(qty);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 10);
        output.writeMessageNoTag(info);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeInt32SizeNoTag(qty);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeMessageSizeNoTag(info);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public Equipment mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 16: {
            // qty
            qty = input.readInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 10) {
              break;
            }
          }
          case 10: {
            // info
            input.readMessage(info);
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeInt32(FieldNames.qty, qty);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeMessage(FieldNames.info, info);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      output.endObject();
    }

    @Override
    public Equipment mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 81558: {
            if (input.isAtField(FieldNames.qty)) {
              if (!input.trySkipNullValue()) {
                qty = input.readInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 2283726: {
            if (input.isAtField(FieldNames.info)) {
              if (!input.trySkipNullValue()) {
                input.readMessage(info);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public Equipment clone() {
      return new Equipment().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static Equipment parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new Equipment(), data).checkInitialized();
    }

    public static Equipment parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new Equipment(), input).checkInitialized();
    }

    public static Equipment parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new Equipment(), input).checkInitialized();
    }

    /**
     * @return factory for creating Equipment messages
     */
    public static MessageFactory<Equipment> getFactory() {
      return EquipmentFactory.INSTANCE;
    }

    private enum EquipmentFactory implements MessageFactory<Equipment> {
      INSTANCE;

      @Override
      public Equipment create() {
        return Equipment.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName qty = FieldName.forField("Qty");

      static final FieldName info = FieldName.forField("Info");

      static final FieldName nextPackage = FieldName.forField("NextPackage");
    }
  }

  /**
   * Protobuf type {@code Disc}
   */
  public static final class Disc extends ProtoMessage<Disc> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional int64 CreateTime = 15;</code>
     */
    private long createTime;

    /**
     * <code>optional uint32 Id = 1;</code>
     */
    private int id;

    /**
     * <code>optional uint32 Level = 2;</code>
     */
    private int level;

    /**
     * <code>optional uint32 Exp = 3;</code>
     */
    private int exp;

    /**
     * <code>optional uint32 Phase = 4;</code>
     */
    private int phase;

    /**
     * <code>optional uint32 Star = 5;</code>
     */
    private int star;

    /**
     * <code>optional bool Read = 6;</code>
     */
    private boolean read;

    /**
     * <code>optional bool Avg = 7;</code>
     */
    private boolean avg;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    private Disc() {
    }

    /**
     * @return a new empty instance of {@code Disc}
     */
    public static Disc newInstance() {
      return new Disc();
    }

    /**
     * <code>optional int64 CreateTime = 15;</code>
     * @return whether the createTime field is set
     */
    public boolean hasCreateTime() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional int64 CreateTime = 15;</code>
     * @return this
     */
    public Disc clearCreateTime() {
      bitField0_ &= ~0x00000001;
      createTime = 0L;
      return this;
    }

    /**
     * <code>optional int64 CreateTime = 15;</code>
     * @return the createTime
     */
    public long getCreateTime() {
      return createTime;
    }

    /**
     * <code>optional int64 CreateTime = 15;</code>
     * @param value the createTime to set
     * @return this
     */
    public Disc setCreateTime(final long value) {
      bitField0_ |= 0x00000001;
      createTime = value;
      return this;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @return whether the id field is set
     */
    public boolean hasId() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @return this
     */
    public Disc clearId() {
      bitField0_ &= ~0x00000002;
      id = 0;
      return this;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @return the id
     */
    public int getId() {
      return id;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @param value the id to set
     * @return this
     */
    public Disc setId(final int value) {
      bitField0_ |= 0x00000002;
      id = value;
      return this;
    }

    /**
     * <code>optional uint32 Level = 2;</code>
     * @return whether the level field is set
     */
    public boolean hasLevel() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional uint32 Level = 2;</code>
     * @return this
     */
    public Disc clearLevel() {
      bitField0_ &= ~0x00000004;
      level = 0;
      return this;
    }

    /**
     * <code>optional uint32 Level = 2;</code>
     * @return the level
     */
    public int getLevel() {
      return level;
    }

    /**
     * <code>optional uint32 Level = 2;</code>
     * @param value the level to set
     * @return this
     */
    public Disc setLevel(final int value) {
      bitField0_ |= 0x00000004;
      level = value;
      return this;
    }

    /**
     * <code>optional uint32 Exp = 3;</code>
     * @return whether the exp field is set
     */
    public boolean hasExp() {
      return (bitField0_ & 0x00000008) != 0;
    }

    /**
     * <code>optional uint32 Exp = 3;</code>
     * @return this
     */
    public Disc clearExp() {
      bitField0_ &= ~0x00000008;
      exp = 0;
      return this;
    }

    /**
     * <code>optional uint32 Exp = 3;</code>
     * @return the exp
     */
    public int getExp() {
      return exp;
    }

    /**
     * <code>optional uint32 Exp = 3;</code>
     * @param value the exp to set
     * @return this
     */
    public Disc setExp(final int value) {
      bitField0_ |= 0x00000008;
      exp = value;
      return this;
    }

    /**
     * <code>optional uint32 Phase = 4;</code>
     * @return whether the phase field is set
     */
    public boolean hasPhase() {
      return (bitField0_ & 0x00000010) != 0;
    }

    /**
     * <code>optional uint32 Phase = 4;</code>
     * @return this
     */
    public Disc clearPhase() {
      bitField0_ &= ~0x00000010;
      phase = 0;
      return this;
    }

    /**
     * <code>optional uint32 Phase = 4;</code>
     * @return the phase
     */
    public int getPhase() {
      return phase;
    }

    /**
     * <code>optional uint32 Phase = 4;</code>
     * @param value the phase to set
     * @return this
     */
    public Disc setPhase(final int value) {
      bitField0_ |= 0x00000010;
      phase = value;
      return this;
    }

    /**
     * <code>optional uint32 Star = 5;</code>
     * @return whether the star field is set
     */
    public boolean hasStar() {
      return (bitField0_ & 0x00000020) != 0;
    }

    /**
     * <code>optional uint32 Star = 5;</code>
     * @return this
     */
    public Disc clearStar() {
      bitField0_ &= ~0x00000020;
      star = 0;
      return this;
    }

    /**
     * <code>optional uint32 Star = 5;</code>
     * @return the star
     */
    public int getStar() {
      return star;
    }

    /**
     * <code>optional uint32 Star = 5;</code>
     * @param value the star to set
     * @return this
     */
    public Disc setStar(final int value) {
      bitField0_ |= 0x00000020;
      star = value;
      return this;
    }

    /**
     * <code>optional bool Read = 6;</code>
     * @return whether the read field is set
     */
    public boolean hasRead() {
      return (bitField0_ & 0x00000040) != 0;
    }

    /**
     * <code>optional bool Read = 6;</code>
     * @return this
     */
    public Disc clearRead() {
      bitField0_ &= ~0x00000040;
      read = false;
      return this;
    }

    /**
     * <code>optional bool Read = 6;</code>
     * @return the read
     */
    public boolean getRead() {
      return read;
    }

    /**
     * <code>optional bool Read = 6;</code>
     * @param value the read to set
     * @return this
     */
    public Disc setRead(final boolean value) {
      bitField0_ |= 0x00000040;
      read = value;
      return this;
    }

    /**
     * <code>optional bool Avg = 7;</code>
     * @return whether the avg field is set
     */
    public boolean hasAvg() {
      return (bitField0_ & 0x00000080) != 0;
    }

    /**
     * <code>optional bool Avg = 7;</code>
     * @return this
     */
    public Disc clearAvg() {
      bitField0_ &= ~0x00000080;
      avg = false;
      return this;
    }

    /**
     * <code>optional bool Avg = 7;</code>
     * @return the avg
     */
    public boolean getAvg() {
      return avg;
    }

    /**
     * <code>optional bool Avg = 7;</code>
     * @param value the avg to set
     * @return this
     */
    public Disc setAvg(final boolean value) {
      bitField0_ |= 0x00000080;
      avg = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000100) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public Disc clearNextPackage() {
      bitField0_ &= ~0x00000100;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000100;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public Disc addNextPackage(final byte value) {
      bitField0_ |= 0x00000100;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public Disc addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000100;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public Disc setNextPackage(final byte... values) {
      bitField0_ |= 0x00000100;
      nextPackage.copyFrom(values);
      return this;
    }

    @Override
    public Disc copyFrom(final Disc other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        createTime = other.createTime;
        id = other.id;
        level = other.level;
        exp = other.exp;
        phase = other.phase;
        star = other.star;
        read = other.read;
        avg = other.avg;
        nextPackage.copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public Disc mergeFrom(final Disc other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasCreateTime()) {
        setCreateTime(other.createTime);
      }
      if (other.hasId()) {
        setId(other.id);
      }
      if (other.hasLevel()) {
        setLevel(other.level);
      }
      if (other.hasExp()) {
        setExp(other.exp);
      }
      if (other.hasPhase()) {
        setPhase(other.phase);
      }
      if (other.hasStar()) {
        setStar(other.star);
      }
      if (other.hasRead()) {
        setRead(other.read);
      }
      if (other.hasAvg()) {
        setAvg(other.avg);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public Disc clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      createTime = 0L;
      id = 0;
      level = 0;
      exp = 0;
      phase = 0;
      star = 0;
      read = false;
      avg = false;
      nextPackage.clear();
      return this;
    }

    @Override
    public Disc clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof Disc)) {
        return false;
      }
      Disc other = (Disc) o;
      return bitField0_ == other.bitField0_
        && (!hasCreateTime() || createTime == other.createTime)
        && (!hasId() || id == other.id)
        && (!hasLevel() || level == other.level)
        && (!hasExp() || exp == other.exp)
        && (!hasPhase() || phase == other.phase)
        && (!hasStar() || star == other.star)
        && (!hasRead() || read == other.read)
        && (!hasAvg() || avg == other.avg)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 120);
        output.writeInt64NoTag(createTime);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt32NoTag(id);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawByte((byte) 16);
        output.writeUInt32NoTag(level);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeRawByte((byte) 24);
        output.writeUInt32NoTag(exp);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        output.writeRawByte((byte) 32);
        output.writeUInt32NoTag(phase);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        output.writeRawByte((byte) 40);
        output.writeUInt32NoTag(star);
      }
      if ((bitField0_ & 0x00000040) != 0) {
        output.writeRawByte((byte) 48);
        output.writeBoolNoTag(read);
      }
      if ((bitField0_ & 0x00000080) != 0) {
        output.writeRawByte((byte) 56);
        output.writeBoolNoTag(avg);
      }
      if ((bitField0_ & 0x00000100) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeInt64SizeNoTag(createTime);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(id);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(level);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(exp);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(phase);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(star);
      }
      if ((bitField0_ & 0x00000040) != 0) {
        size += 2;
      }
      if ((bitField0_ & 0x00000080) != 0) {
        size += 2;
      }
      if ((bitField0_ & 0x00000100) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public Disc mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 120: {
            // createTime
            createTime = input.readInt64();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 8) {
              break;
            }
          }
          case 8: {
            // id
            id = input.readUInt32();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 16) {
              break;
            }
          }
          case 16: {
            // level
            level = input.readUInt32();
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 24) {
              break;
            }
          }
          case 24: {
            // exp
            exp = input.readUInt32();
            bitField0_ |= 0x00000008;
            tag = input.readTag();
            if (tag != 32) {
              break;
            }
          }
          case 32: {
            // phase
            phase = input.readUInt32();
            bitField0_ |= 0x00000010;
            tag = input.readTag();
            if (tag != 40) {
              break;
            }
          }
          case 40: {
            // star
            star = input.readUInt32();
            bitField0_ |= 0x00000020;
            tag = input.readTag();
            if (tag != 48) {
              break;
            }
          }
          case 48: {
            // read
            read = input.readBool();
            bitField0_ |= 0x00000040;
            tag = input.readTag();
            if (tag != 56) {
              break;
            }
          }
          case 56: {
            // avg
            avg = input.readBool();
            bitField0_ |= 0x00000080;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000100;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeInt64(FieldNames.createTime, createTime);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeUInt32(FieldNames.id, id);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeUInt32(FieldNames.level, level);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeUInt32(FieldNames.exp, exp);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        output.writeUInt32(FieldNames.phase, phase);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        output.writeUInt32(FieldNames.star, star);
      }
      if ((bitField0_ & 0x00000040) != 0) {
        output.writeBool(FieldNames.read, read);
      }
      if ((bitField0_ & 0x00000080) != 0) {
        output.writeBool(FieldNames.avg, avg);
      }
      if ((bitField0_ & 0x00000100) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      output.endObject();
    }

    @Override
    public Disc mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case -932289015: {
            if (input.isAtField(FieldNames.createTime)) {
              if (!input.trySkipNullValue()) {
                createTime = input.readInt64();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 2363: {
            if (input.isAtField(FieldNames.id)) {
              if (!input.trySkipNullValue()) {
                id = input.readUInt32();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 73313124: {
            if (input.isAtField(FieldNames.level)) {
              if (!input.trySkipNullValue()) {
                level = input.readUInt32();
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 70141: {
            if (input.isAtField(FieldNames.exp)) {
              if (!input.trySkipNullValue()) {
                exp = input.readUInt32();
                bitField0_ |= 0x00000008;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 77076827: {
            if (input.isAtField(FieldNames.phase)) {
              if (!input.trySkipNullValue()) {
                phase = input.readUInt32();
                bitField0_ |= 0x00000010;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 2587250: {
            if (input.isAtField(FieldNames.star)) {
              if (!input.trySkipNullValue()) {
                star = input.readUInt32();
                bitField0_ |= 0x00000020;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 2543030: {
            if (input.isAtField(FieldNames.read)) {
              if (!input.trySkipNullValue()) {
                read = input.readBool();
                bitField0_ |= 0x00000040;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 66226: {
            if (input.isAtField(FieldNames.avg)) {
              if (!input.trySkipNullValue()) {
                avg = input.readBool();
                bitField0_ |= 0x00000080;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000100;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public Disc clone() {
      return new Disc().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static Disc parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new Disc(), data).checkInitialized();
    }

    public static Disc parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new Disc(), input).checkInitialized();
    }

    public static Disc parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new Disc(), input).checkInitialized();
    }

    /**
     * @return factory for creating Disc messages
     */
    public static MessageFactory<Disc> getFactory() {
      return DiscFactory.INSTANCE;
    }

    private enum DiscFactory implements MessageFactory<Disc> {
      INSTANCE;

      @Override
      public Disc create() {
        return Disc.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName createTime = FieldName.forField("CreateTime");

      static final FieldName id = FieldName.forField("Id");

      static final FieldName level = FieldName.forField("Level");

      static final FieldName exp = FieldName.forField("Exp");

      static final FieldName phase = FieldName.forField("Phase");

      static final FieldName star = FieldName.forField("Star");

      static final FieldName read = FieldName.forField("Read");

      static final FieldName avg = FieldName.forField("Avg");

      static final FieldName nextPackage = FieldName.forField("NextPackage");
    }
  }

  /**
   * Protobuf type {@code Transform}
   */
  public static final class Transform extends ProtoMessage<Transform> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    /**
     * <code>repeated .ItemTpl Src = 1;</code>
     */
    private final RepeatedMessage<ItemTpl> src = RepeatedMessage.newEmptyInstance(ItemTpl.getFactory());

    /**
     * <code>repeated .ItemTpl Dst = 2;</code>
     */
    private final RepeatedMessage<ItemTpl> dst = RepeatedMessage.newEmptyInstance(ItemTpl.getFactory());

    private Transform() {
    }

    /**
     * @return a new empty instance of {@code Transform}
     */
    public static Transform newInstance() {
      return new Transform();
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public Transform clearNextPackage() {
      bitField0_ &= ~0x00000001;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000001;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public Transform addNextPackage(final byte value) {
      bitField0_ |= 0x00000001;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public Transform addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000001;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public Transform setNextPackage(final byte... values) {
      bitField0_ |= 0x00000001;
      nextPackage.copyFrom(values);
      return this;
    }

    /**
     * <code>repeated .ItemTpl Src = 1;</code>
     * @return whether the src field is set
     */
    public boolean hasSrc() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>repeated .ItemTpl Src = 1;</code>
     * @return this
     */
    public Transform clearSrc() {
      bitField0_ &= ~0x00000002;
      src.clear();
      return this;
    }

    /**
     * <code>repeated .ItemTpl Src = 1;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableSrc()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<ItemTpl> getSrc() {
      return src;
    }

    /**
     * <code>repeated .ItemTpl Src = 1;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<ItemTpl> getMutableSrc() {
      bitField0_ |= 0x00000002;
      return src;
    }

    /**
     * <code>repeated .ItemTpl Src = 1;</code>
     * @param value the src to add
     * @return this
     */
    public Transform addSrc(final ItemTpl value) {
      bitField0_ |= 0x00000002;
      src.add(value);
      return this;
    }

    /**
     * <code>repeated .ItemTpl Src = 1;</code>
     * @param values the src to add
     * @return this
     */
    public Transform addAllSrc(final ItemTpl... values) {
      bitField0_ |= 0x00000002;
      src.addAll(values);
      return this;
    }

    /**
     * <code>repeated .ItemTpl Dst = 2;</code>
     * @return whether the dst field is set
     */
    public boolean hasDst() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>repeated .ItemTpl Dst = 2;</code>
     * @return this
     */
    public Transform clearDst() {
      bitField0_ &= ~0x00000004;
      dst.clear();
      return this;
    }

    /**
     * <code>repeated .ItemTpl Dst = 2;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableDst()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<ItemTpl> getDst() {
      return dst;
    }

    /**
     * <code>repeated .ItemTpl Dst = 2;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<ItemTpl> getMutableDst() {
      bitField0_ |= 0x00000004;
      return dst;
    }

    /**
     * <code>repeated .ItemTpl Dst = 2;</code>
     * @param value the dst to add
     * @return this
     */
    public Transform addDst(final ItemTpl value) {
      bitField0_ |= 0x00000004;
      dst.add(value);
      return this;
    }

    /**
     * <code>repeated .ItemTpl Dst = 2;</code>
     * @param values the dst to add
     * @return this
     */
    public Transform addAllDst(final ItemTpl... values) {
      bitField0_ |= 0x00000004;
      dst.addAll(values);
      return this;
    }

    @Override
    public Transform copyFrom(final Transform other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        nextPackage.copyFrom(other.nextPackage);
        src.copyFrom(other.src);
        dst.copyFrom(other.dst);
      }
      return this;
    }

    @Override
    public Transform mergeFrom(final Transform other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      if (other.hasSrc()) {
        getMutableSrc().addAll(other.src);
      }
      if (other.hasDst()) {
        getMutableDst().addAll(other.dst);
      }
      return this;
    }

    @Override
    public Transform clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      src.clear();
      dst.clear();
      return this;
    }

    @Override
    public Transform clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      src.clearQuick();
      dst.clearQuick();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof Transform)) {
        return false;
      }
      Transform other = (Transform) o;
      return bitField0_ == other.bitField0_
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage))
        && (!hasSrc() || src.equals(other.src))
        && (!hasDst() || dst.equals(other.dst));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        for (int i = 0; i < src.length(); i++) {
          output.writeRawByte((byte) 10);
          output.writeMessageNoTag(src.get(i));
        }
      }
      if ((bitField0_ & 0x00000004) != 0) {
        for (int i = 0; i < dst.length(); i++) {
          output.writeRawByte((byte) 18);
          output.writeMessageNoTag(dst.get(i));
        }
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += (1 * src.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(src);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += (1 * dst.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(dst);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public Transform mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 10) {
              break;
            }
          }
          case 10: {
            // src
            tag = input.readRepeatedMessage(src, tag);
            bitField0_ |= 0x00000002;
            if (tag != 18) {
              break;
            }
          }
          case 18: {
            // dst
            tag = input.readRepeatedMessage(dst, tag);
            bitField0_ |= 0x00000004;
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRepeatedMessage(FieldNames.src, src);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRepeatedMessage(FieldNames.dst, dst);
      }
      output.endObject();
    }

    @Override
    public Transform mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 83396: {
            if (input.isAtField(FieldNames.src)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedMessage(src);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 69029: {
            if (input.isAtField(FieldNames.dst)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedMessage(dst);
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public Transform clone() {
      return new Transform().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static Transform parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new Transform(), data).checkInitialized();
    }

    public static Transform parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new Transform(), input).checkInitialized();
    }

    public static Transform parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new Transform(), input).checkInitialized();
    }

    /**
     * @return factory for creating Transform messages
     */
    public static MessageFactory<Transform> getFactory() {
      return TransformFactory.INSTANCE;
    }

    private enum TransformFactory implements MessageFactory<Transform> {
      INSTANCE;

      @Override
      public Transform create() {
        return Transform.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName nextPackage = FieldName.forField("NextPackage");

      static final FieldName src = FieldName.forField("Src");

      static final FieldName dst = FieldName.forField("Dst");
    }
  }

  /**
   * Protobuf type {@code HeadIcon}
   */
  public static final class HeadIcon extends ProtoMessage<HeadIcon> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional uint32 Tid = 1;</code>
     */
    private int tid;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    private HeadIcon() {
    }

    /**
     * @return a new empty instance of {@code HeadIcon}
     */
    public static HeadIcon newInstance() {
      return new HeadIcon();
    }

    /**
     * <code>optional uint32 Tid = 1;</code>
     * @return whether the tid field is set
     */
    public boolean hasTid() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional uint32 Tid = 1;</code>
     * @return this
     */
    public HeadIcon clearTid() {
      bitField0_ &= ~0x00000001;
      tid = 0;
      return this;
    }

    /**
     * <code>optional uint32 Tid = 1;</code>
     * @return the tid
     */
    public int getTid() {
      return tid;
    }

    /**
     * <code>optional uint32 Tid = 1;</code>
     * @param value the tid to set
     * @return this
     */
    public HeadIcon setTid(final int value) {
      bitField0_ |= 0x00000001;
      tid = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public HeadIcon clearNextPackage() {
      bitField0_ &= ~0x00000002;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000002;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public HeadIcon addNextPackage(final byte value) {
      bitField0_ |= 0x00000002;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public HeadIcon addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000002;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public HeadIcon setNextPackage(final byte... values) {
      bitField0_ |= 0x00000002;
      nextPackage.copyFrom(values);
      return this;
    }

    @Override
    public HeadIcon copyFrom(final HeadIcon other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        tid = other.tid;
        nextPackage.copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public HeadIcon mergeFrom(final HeadIcon other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasTid()) {
        setTid(other.tid);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public HeadIcon clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      tid = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public HeadIcon clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof HeadIcon)) {
        return false;
      }
      HeadIcon other = (HeadIcon) o;
      return bitField0_ == other.bitField0_
        && (!hasTid() || tid == other.tid)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt32NoTag(tid);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(tid);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public HeadIcon mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            // tid
            tid = input.readUInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeUInt32(FieldNames.tid, tid);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      output.endObject();
    }

    @Override
    public HeadIcon mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 84079: {
            if (input.isAtField(FieldNames.tid)) {
              if (!input.trySkipNullValue()) {
                tid = input.readUInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public HeadIcon clone() {
      return new HeadIcon().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static HeadIcon parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new HeadIcon(), data).checkInitialized();
    }

    public static HeadIcon parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new HeadIcon(), input).checkInitialized();
    }

    public static HeadIcon parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new HeadIcon(), input).checkInitialized();
    }

    /**
     * @return factory for creating HeadIcon messages
     */
    public static MessageFactory<HeadIcon> getFactory() {
      return HeadIconFactory.INSTANCE;
    }

    private enum HeadIconFactory implements MessageFactory<HeadIcon> {
      INSTANCE;

      @Override
      public HeadIcon create() {
        return HeadIcon.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName tid = FieldName.forField("Tid");

      static final FieldName nextPackage = FieldName.forField("NextPackage");
    }
  }

  /**
   * Protobuf type {@code AcqInfo}
   */
  public static final class AcqInfo extends ProtoMessage<AcqInfo> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional uint32 Tid = 1;</code>
     */
    private int tid;

    /**
     * <code>optional uint32 Begin = 2;</code>
     */
    private int begin;

    /**
     * <code>optional uint32 Count = 3;</code>
     */
    private int count;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    private AcqInfo() {
    }

    /**
     * @return a new empty instance of {@code AcqInfo}
     */
    public static AcqInfo newInstance() {
      return new AcqInfo();
    }

    /**
     * <code>optional uint32 Tid = 1;</code>
     * @return whether the tid field is set
     */
    public boolean hasTid() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional uint32 Tid = 1;</code>
     * @return this
     */
    public AcqInfo clearTid() {
      bitField0_ &= ~0x00000001;
      tid = 0;
      return this;
    }

    /**
     * <code>optional uint32 Tid = 1;</code>
     * @return the tid
     */
    public int getTid() {
      return tid;
    }

    /**
     * <code>optional uint32 Tid = 1;</code>
     * @param value the tid to set
     * @return this
     */
    public AcqInfo setTid(final int value) {
      bitField0_ |= 0x00000001;
      tid = value;
      return this;
    }

    /**
     * <code>optional uint32 Begin = 2;</code>
     * @return whether the begin field is set
     */
    public boolean hasBegin() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional uint32 Begin = 2;</code>
     * @return this
     */
    public AcqInfo clearBegin() {
      bitField0_ &= ~0x00000002;
      begin = 0;
      return this;
    }

    /**
     * <code>optional uint32 Begin = 2;</code>
     * @return the begin
     */
    public int getBegin() {
      return begin;
    }

    /**
     * <code>optional uint32 Begin = 2;</code>
     * @param value the begin to set
     * @return this
     */
    public AcqInfo setBegin(final int value) {
      bitField0_ |= 0x00000002;
      begin = value;
      return this;
    }

    /**
     * <code>optional uint32 Count = 3;</code>
     * @return whether the count field is set
     */
    public boolean hasCount() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional uint32 Count = 3;</code>
     * @return this
     */
    public AcqInfo clearCount() {
      bitField0_ &= ~0x00000004;
      count = 0;
      return this;
    }

    /**
     * <code>optional uint32 Count = 3;</code>
     * @return the count
     */
    public int getCount() {
      return count;
    }

    /**
     * <code>optional uint32 Count = 3;</code>
     * @param value the count to set
     * @return this
     */
    public AcqInfo setCount(final int value) {
      bitField0_ |= 0x00000004;
      count = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000008) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public AcqInfo clearNextPackage() {
      bitField0_ &= ~0x00000008;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000008;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public AcqInfo addNextPackage(final byte value) {
      bitField0_ |= 0x00000008;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public AcqInfo addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000008;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public AcqInfo setNextPackage(final byte... values) {
      bitField0_ |= 0x00000008;
      nextPackage.copyFrom(values);
      return this;
    }

    @Override
    public AcqInfo copyFrom(final AcqInfo other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        tid = other.tid;
        begin = other.begin;
        count = other.count;
        nextPackage.copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public AcqInfo mergeFrom(final AcqInfo other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasTid()) {
        setTid(other.tid);
      }
      if (other.hasBegin()) {
        setBegin(other.begin);
      }
      if (other.hasCount()) {
        setCount(other.count);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public AcqInfo clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      tid = 0;
      begin = 0;
      count = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public AcqInfo clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof AcqInfo)) {
        return false;
      }
      AcqInfo other = (AcqInfo) o;
      return bitField0_ == other.bitField0_
        && (!hasTid() || tid == other.tid)
        && (!hasBegin() || begin == other.begin)
        && (!hasCount() || count == other.count)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt32NoTag(tid);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 16);
        output.writeUInt32NoTag(begin);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawByte((byte) 24);
        output.writeUInt32NoTag(count);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(tid);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(begin);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(count);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public AcqInfo mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            // tid
            tid = input.readUInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 16) {
              break;
            }
          }
          case 16: {
            // begin
            begin = input.readUInt32();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 24) {
              break;
            }
          }
          case 24: {
            // count
            count = input.readUInt32();
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000008;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeUInt32(FieldNames.tid, tid);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeUInt32(FieldNames.begin, begin);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeUInt32(FieldNames.count, count);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      output.endObject();
    }

    @Override
    public AcqInfo mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 84079: {
            if (input.isAtField(FieldNames.tid)) {
              if (!input.trySkipNullValue()) {
                tid = input.readUInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 64063625: {
            if (input.isAtField(FieldNames.begin)) {
              if (!input.trySkipNullValue()) {
                begin = input.readUInt32();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 65298671: {
            if (input.isAtField(FieldNames.count)) {
              if (!input.trySkipNullValue()) {
                count = input.readUInt32();
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000008;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public AcqInfo clone() {
      return new AcqInfo().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static AcqInfo parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new AcqInfo(), data).checkInitialized();
    }

    public static AcqInfo parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new AcqInfo(), input).checkInitialized();
    }

    public static AcqInfo parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new AcqInfo(), input).checkInitialized();
    }

    /**
     * @return factory for creating AcqInfo messages
     */
    public static MessageFactory<AcqInfo> getFactory() {
      return AcqInfoFactory.INSTANCE;
    }

    private enum AcqInfoFactory implements MessageFactory<AcqInfo> {
      INSTANCE;

      @Override
      public AcqInfo create() {
        return AcqInfo.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName tid = FieldName.forField("Tid");

      static final FieldName begin = FieldName.forField("Begin");

      static final FieldName count = FieldName.forField("Count");

      static final FieldName nextPackage = FieldName.forField("NextPackage");
    }
  }

  /**
   * Protobuf type {@code Acquire}
   */
  public static final class Acquire extends ProtoMessage<Acquire> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    /**
     * <code>repeated .AcqInfo List = 1;</code>
     */
    private final RepeatedMessage<AcqInfo> list = RepeatedMessage.newEmptyInstance(AcqInfo.getFactory());

    private Acquire() {
    }

    /**
     * @return a new empty instance of {@code Acquire}
     */
    public static Acquire newInstance() {
      return new Acquire();
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public Acquire clearNextPackage() {
      bitField0_ &= ~0x00000001;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000001;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public Acquire addNextPackage(final byte value) {
      bitField0_ |= 0x00000001;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public Acquire addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000001;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public Acquire setNextPackage(final byte... values) {
      bitField0_ |= 0x00000001;
      nextPackage.copyFrom(values);
      return this;
    }

    /**
     * <code>repeated .AcqInfo List = 1;</code>
     * @return whether the list field is set
     */
    public boolean hasList() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>repeated .AcqInfo List = 1;</code>
     * @return this
     */
    public Acquire clearList() {
      bitField0_ &= ~0x00000002;
      list.clear();
      return this;
    }

    /**
     * <code>repeated .AcqInfo List = 1;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableList()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<AcqInfo> getList() {
      return list;
    }

    /**
     * <code>repeated .AcqInfo List = 1;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<AcqInfo> getMutableList() {
      bitField0_ |= 0x00000002;
      return list;
    }

    /**
     * <code>repeated .AcqInfo List = 1;</code>
     * @param value the list to add
     * @return this
     */
    public Acquire addList(final AcqInfo value) {
      bitField0_ |= 0x00000002;
      list.add(value);
      return this;
    }

    /**
     * <code>repeated .AcqInfo List = 1;</code>
     * @param values the list to add
     * @return this
     */
    public Acquire addAllList(final AcqInfo... values) {
      bitField0_ |= 0x00000002;
      list.addAll(values);
      return this;
    }

    @Override
    public Acquire copyFrom(final Acquire other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        nextPackage.copyFrom(other.nextPackage);
        list.copyFrom(other.list);
      }
      return this;
    }

    @Override
    public Acquire mergeFrom(final Acquire other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      if (other.hasList()) {
        getMutableList().addAll(other.list);
      }
      return this;
    }

    @Override
    public Acquire clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      list.clear();
      return this;
    }

    @Override
    public Acquire clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      list.clearQuick();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof Acquire)) {
        return false;
      }
      Acquire other = (Acquire) o;
      return bitField0_ == other.bitField0_
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage))
        && (!hasList() || list.equals(other.list));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        for (int i = 0; i < list.length(); i++) {
          output.writeRawByte((byte) 10);
          output.writeMessageNoTag(list.get(i));
        }
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += (1 * list.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(list);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public Acquire mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 10) {
              break;
            }
          }
          case 10: {
            // list
            tag = input.readRepeatedMessage(list, tag);
            bitField0_ |= 0x00000002;
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRepeatedMessage(FieldNames.list, list);
      }
      output.endObject();
    }

    @Override
    public Acquire mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 2368702: {
            if (input.isAtField(FieldNames.list)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedMessage(list);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public Acquire clone() {
      return new Acquire().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static Acquire parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new Acquire(), data).checkInitialized();
    }

    public static Acquire parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new Acquire(), input).checkInitialized();
    }

    public static Acquire parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new Acquire(), input).checkInitialized();
    }

    /**
     * @return factory for creating Acquire messages
     */
    public static MessageFactory<Acquire> getFactory() {
      return AcquireFactory.INSTANCE;
    }

    private enum AcquireFactory implements MessageFactory<Acquire> {
      INSTANCE;

      @Override
      public Acquire create() {
        return Acquire.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName nextPackage = FieldName.forField("NextPackage");

      static final FieldName list = FieldName.forField("List");
    }
  }

  /**
   * Protobuf type {@code Honor}
   */
  public static final class Honor extends ProtoMessage<Honor> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional uint32 NewId = 1;</code>
     */
    private int newId;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    private Honor() {
    }

    /**
     * @return a new empty instance of {@code Honor}
     */
    public static Honor newInstance() {
      return new Honor();
    }

    /**
     * <code>optional uint32 NewId = 1;</code>
     * @return whether the newId field is set
     */
    public boolean hasNewId() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional uint32 NewId = 1;</code>
     * @return this
     */
    public Honor clearNewId() {
      bitField0_ &= ~0x00000001;
      newId = 0;
      return this;
    }

    /**
     * <code>optional uint32 NewId = 1;</code>
     * @return the newId
     */
    public int getNewId() {
      return newId;
    }

    /**
     * <code>optional uint32 NewId = 1;</code>
     * @param value the newId to set
     * @return this
     */
    public Honor setNewId(final int value) {
      bitField0_ |= 0x00000001;
      newId = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public Honor clearNextPackage() {
      bitField0_ &= ~0x00000002;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000002;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public Honor addNextPackage(final byte value) {
      bitField0_ |= 0x00000002;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public Honor addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000002;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public Honor setNextPackage(final byte... values) {
      bitField0_ |= 0x00000002;
      nextPackage.copyFrom(values);
      return this;
    }

    @Override
    public Honor copyFrom(final Honor other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        newId = other.newId;
        nextPackage.copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public Honor mergeFrom(final Honor other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasNewId()) {
        setNewId(other.newId);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public Honor clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      newId = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public Honor clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof Honor)) {
        return false;
      }
      Honor other = (Honor) o;
      return bitField0_ == other.bitField0_
        && (!hasNewId() || newId == other.newId)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt32NoTag(newId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(newId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public Honor mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            // newId
            newId = input.readUInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeUInt32(FieldNames.newId, newId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      output.endObject();
    }

    @Override
    public Honor mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 75160251: {
            if (input.isAtField(FieldNames.newId)) {
              if (!input.trySkipNullValue()) {
                newId = input.readUInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public Honor clone() {
      return new Honor().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static Honor parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new Honor(), data).checkInitialized();
    }

    public static Honor parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new Honor(), input).checkInitialized();
    }

    public static Honor parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new Honor(), input).checkInitialized();
    }

    /**
     * @return factory for creating Honor messages
     */
    public static MessageFactory<Honor> getFactory() {
      return HonorFactory.INSTANCE;
    }

    private enum HonorFactory implements MessageFactory<Honor> {
      INSTANCE;

      @Override
      public Honor create() {
        return Honor.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName newId = FieldName.forField("NewId");

      static final FieldName nextPackage = FieldName.forField("NextPackage");
    }
  }

  /**
   * Protobuf type {@code ChangeInfo}
   */
  public static final class ChangeInfo extends ProtoMessage<ChangeInfo> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    /**
     * <code>repeated .Any Props = 1;</code>
     */
    private final RepeatedMessage<AnyOuterClass.Any> props = RepeatedMessage.newEmptyInstance(AnyOuterClass.Any.getFactory());

    private ChangeInfo() {
    }

    /**
     * @return a new empty instance of {@code ChangeInfo}
     */
    public static ChangeInfo newInstance() {
      return new ChangeInfo();
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public ChangeInfo clearNextPackage() {
      bitField0_ &= ~0x00000001;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000001;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public ChangeInfo addNextPackage(final byte value) {
      bitField0_ |= 0x00000001;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public ChangeInfo addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000001;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public ChangeInfo setNextPackage(final byte... values) {
      bitField0_ |= 0x00000001;
      nextPackage.copyFrom(values);
      return this;
    }

    /**
     * <code>repeated .Any Props = 1;</code>
     * @return whether the props field is set
     */
    public boolean hasProps() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>repeated .Any Props = 1;</code>
     * @return this
     */
    public ChangeInfo clearProps() {
      bitField0_ &= ~0x00000002;
      props.clear();
      return this;
    }

    /**
     * <code>repeated .Any Props = 1;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableProps()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<AnyOuterClass.Any> getProps() {
      return props;
    }

    /**
     * <code>repeated .Any Props = 1;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<AnyOuterClass.Any> getMutableProps() {
      bitField0_ |= 0x00000002;
      return props;
    }

    /**
     * <code>repeated .Any Props = 1;</code>
     * @param value the props to add
     * @return this
     */
    public ChangeInfo addProps(final AnyOuterClass.Any value) {
      bitField0_ |= 0x00000002;
      props.add(value);
      return this;
    }

    /**
     * <code>repeated .Any Props = 1;</code>
     * @param values the props to add
     * @return this
     */
    public ChangeInfo addAllProps(final AnyOuterClass.Any... values) {
      bitField0_ |= 0x00000002;
      props.addAll(values);
      return this;
    }

    @Override
    public ChangeInfo copyFrom(final ChangeInfo other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        nextPackage.copyFrom(other.nextPackage);
        props.copyFrom(other.props);
      }
      return this;
    }

    @Override
    public ChangeInfo mergeFrom(final ChangeInfo other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      if (other.hasProps()) {
        getMutableProps().addAll(other.props);
      }
      return this;
    }

    @Override
    public ChangeInfo clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      props.clear();
      return this;
    }

    @Override
    public ChangeInfo clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      props.clearQuick();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof ChangeInfo)) {
        return false;
      }
      ChangeInfo other = (ChangeInfo) o;
      return bitField0_ == other.bitField0_
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage))
        && (!hasProps() || props.equals(other.props));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        for (int i = 0; i < props.length(); i++) {
          output.writeRawByte((byte) 10);
          output.writeMessageNoTag(props.get(i));
        }
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += (1 * props.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(props);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public ChangeInfo mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 10) {
              break;
            }
          }
          case 10: {
            // props
            tag = input.readRepeatedMessage(props, tag);
            bitField0_ |= 0x00000002;
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRepeatedMessage(FieldNames.props, props);
      }
      output.endObject();
    }

    @Override
    public ChangeInfo mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 77388112: {
            if (input.isAtField(FieldNames.props)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedMessage(props);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public ChangeInfo clone() {
      return new ChangeInfo().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static ChangeInfo parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new ChangeInfo(), data).checkInitialized();
    }

    public static ChangeInfo parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new ChangeInfo(), input).checkInitialized();
    }

    public static ChangeInfo parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new ChangeInfo(), input).checkInitialized();
    }

    /**
     * @return factory for creating ChangeInfo messages
     */
    public static MessageFactory<ChangeInfo> getFactory() {
      return ChangeInfoFactory.INSTANCE;
    }

    private enum ChangeInfoFactory implements MessageFactory<ChangeInfo> {
      INSTANCE;

      @Override
      public ChangeInfo create() {
        return ChangeInfo.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName nextPackage = FieldName.forField("NextPackage");

      static final FieldName props = FieldName.forField("Props");
    }
  }

  /**
   * Protobuf type {@code FormationInfo}
   */
  public static final class FormationInfo extends ProtoMessage<FormationInfo> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional uint32 Number = 1;</code>
     */
    private int number;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    /**
     * <code>repeated uint32 CharIds = 2;</code>
     */
    private final RepeatedInt charIds = RepeatedInt.newEmptyInstance();

    /**
     * <code>repeated uint32 DiscIds = 3;</code>
     */
    private final RepeatedInt discIds = RepeatedInt.newEmptyInstance();

    private FormationInfo() {
    }

    /**
     * @return a new empty instance of {@code FormationInfo}
     */
    public static FormationInfo newInstance() {
      return new FormationInfo();
    }

    /**
     * <code>optional uint32 Number = 1;</code>
     * @return whether the number field is set
     */
    public boolean hasNumber() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional uint32 Number = 1;</code>
     * @return this
     */
    public FormationInfo clearNumber() {
      bitField0_ &= ~0x00000001;
      number = 0;
      return this;
    }

    /**
     * <code>optional uint32 Number = 1;</code>
     * @return the number
     */
    public int getNumber() {
      return number;
    }

    /**
     * <code>optional uint32 Number = 1;</code>
     * @param value the number to set
     * @return this
     */
    public FormationInfo setNumber(final int value) {
      bitField0_ |= 0x00000001;
      number = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public FormationInfo clearNextPackage() {
      bitField0_ &= ~0x00000002;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000002;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public FormationInfo addNextPackage(final byte value) {
      bitField0_ |= 0x00000002;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public FormationInfo addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000002;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public FormationInfo setNextPackage(final byte... values) {
      bitField0_ |= 0x00000002;
      nextPackage.copyFrom(values);
      return this;
    }

    /**
     * <code>repeated uint32 CharIds = 2;</code>
     * @return whether the charIds field is set
     */
    public boolean hasCharIds() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>repeated uint32 CharIds = 2;</code>
     * @return this
     */
    public FormationInfo clearCharIds() {
      bitField0_ &= ~0x00000004;
      charIds.clear();
      return this;
    }

    /**
     * <code>repeated uint32 CharIds = 2;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableCharIds()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedInt getCharIds() {
      return charIds;
    }

    /**
     * <code>repeated uint32 CharIds = 2;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedInt getMutableCharIds() {
      bitField0_ |= 0x00000004;
      return charIds;
    }

    /**
     * <code>repeated uint32 CharIds = 2;</code>
     * @param value the charIds to add
     * @return this
     */
    public FormationInfo addCharIds(final int value) {
      bitField0_ |= 0x00000004;
      charIds.add(value);
      return this;
    }

    /**
     * <code>repeated uint32 CharIds = 2;</code>
     * @param values the charIds to add
     * @return this
     */
    public FormationInfo addAllCharIds(final int... values) {
      bitField0_ |= 0x00000004;
      charIds.addAll(values);
      return this;
    }

    /**
     * <code>repeated uint32 DiscIds = 3;</code>
     * @return whether the discIds field is set
     */
    public boolean hasDiscIds() {
      return (bitField0_ & 0x00000008) != 0;
    }

    /**
     * <code>repeated uint32 DiscIds = 3;</code>
     * @return this
     */
    public FormationInfo clearDiscIds() {
      bitField0_ &= ~0x00000008;
      discIds.clear();
      return this;
    }

    /**
     * <code>repeated uint32 DiscIds = 3;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableDiscIds()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedInt getDiscIds() {
      return discIds;
    }

    /**
     * <code>repeated uint32 DiscIds = 3;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedInt getMutableDiscIds() {
      bitField0_ |= 0x00000008;
      return discIds;
    }

    /**
     * <code>repeated uint32 DiscIds = 3;</code>
     * @param value the discIds to add
     * @return this
     */
    public FormationInfo addDiscIds(final int value) {
      bitField0_ |= 0x00000008;
      discIds.add(value);
      return this;
    }

    /**
     * <code>repeated uint32 DiscIds = 3;</code>
     * @param values the discIds to add
     * @return this
     */
    public FormationInfo addAllDiscIds(final int... values) {
      bitField0_ |= 0x00000008;
      discIds.addAll(values);
      return this;
    }

    @Override
    public FormationInfo copyFrom(final FormationInfo other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        number = other.number;
        nextPackage.copyFrom(other.nextPackage);
        charIds.copyFrom(other.charIds);
        discIds.copyFrom(other.discIds);
      }
      return this;
    }

    @Override
    public FormationInfo mergeFrom(final FormationInfo other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasNumber()) {
        setNumber(other.number);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      if (other.hasCharIds()) {
        getMutableCharIds().addAll(other.charIds);
      }
      if (other.hasDiscIds()) {
        getMutableDiscIds().addAll(other.discIds);
      }
      return this;
    }

    @Override
    public FormationInfo clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      number = 0;
      nextPackage.clear();
      charIds.clear();
      discIds.clear();
      return this;
    }

    @Override
    public FormationInfo clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      charIds.clear();
      discIds.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof FormationInfo)) {
        return false;
      }
      FormationInfo other = (FormationInfo) o;
      return bitField0_ == other.bitField0_
        && (!hasNumber() || number == other.number)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage))
        && (!hasCharIds() || charIds.equals(other.charIds))
        && (!hasDiscIds() || discIds.equals(other.discIds));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt32NoTag(number);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        for (int i = 0; i < charIds.length(); i++) {
          output.writeRawByte((byte) 16);
          output.writeUInt32NoTag(charIds.array()[i]);
        }
      }
      if ((bitField0_ & 0x00000008) != 0) {
        for (int i = 0; i < discIds.length(); i++) {
          output.writeRawByte((byte) 24);
          output.writeUInt32NoTag(discIds.array()[i]);
        }
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(number);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += (1 * charIds.length()) + ProtoSink.computeRepeatedUInt32SizeNoTag(charIds);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        size += (1 * discIds.length()) + ProtoSink.computeRepeatedUInt32SizeNoTag(discIds);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public FormationInfo mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            // number
            number = input.readUInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 18) {
              break;
            }
          }
          case 18: {
            // charIds [packed=true]
            input.readPackedUInt32(charIds, tag);
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 26) {
              break;
            }
          }
          case 26: {
            // discIds [packed=true]
            input.readPackedUInt32(discIds, tag);
            bitField0_ |= 0x00000008;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
          case 16: {
            // charIds [packed=false]
            tag = input.readRepeatedUInt32(charIds, tag);
            bitField0_ |= 0x00000004;
            break;
          }
          case 24: {
            // discIds [packed=false]
            tag = input.readRepeatedUInt32(discIds, tag);
            bitField0_ |= 0x00000008;
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeUInt32(FieldNames.number, number);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRepeatedUInt32(FieldNames.charIds, charIds);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeRepeatedUInt32(FieldNames.discIds, discIds);
      }
      output.endObject();
    }

    @Override
    public FormationInfo mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case -1950496919: {
            if (input.isAtField(FieldNames.number)) {
              if (!input.trySkipNullValue()) {
                number = input.readUInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1891280030: {
            if (input.isAtField(FieldNames.charIds)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedUInt32(charIds);
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -958970685: {
            if (input.isAtField(FieldNames.discIds)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedUInt32(discIds);
                bitField0_ |= 0x00000008;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public FormationInfo clone() {
      return new FormationInfo().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static FormationInfo parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new FormationInfo(), data).checkInitialized();
    }

    public static FormationInfo parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new FormationInfo(), input).checkInitialized();
    }

    public static FormationInfo parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new FormationInfo(), input).checkInitialized();
    }

    /**
     * @return factory for creating FormationInfo messages
     */
    public static MessageFactory<FormationInfo> getFactory() {
      return FormationInfoFactory.INSTANCE;
    }

    private enum FormationInfoFactory implements MessageFactory<FormationInfo> {
      INSTANCE;

      @Override
      public FormationInfo create() {
        return FormationInfo.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName number = FieldName.forField("Number");

      static final FieldName nextPackage = FieldName.forField("NextPackage");

      static final FieldName charIds = FieldName.forField("CharIds");

      static final FieldName discIds = FieldName.forField("DiscIds");
    }
  }

  /**
   * Protobuf type {@code FormationRecord}
   */
  public static final class FormationRecord extends ProtoMessage<FormationRecord> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional uint32 GroupId = 1;</code>
     */
    private int groupId;

    /**
     * <code>optional uint32 Number = 2;</code>
     */
    private int number;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    private FormationRecord() {
    }

    /**
     * @return a new empty instance of {@code FormationRecord}
     */
    public static FormationRecord newInstance() {
      return new FormationRecord();
    }

    /**
     * <code>optional uint32 GroupId = 1;</code>
     * @return whether the groupId field is set
     */
    public boolean hasGroupId() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional uint32 GroupId = 1;</code>
     * @return this
     */
    public FormationRecord clearGroupId() {
      bitField0_ &= ~0x00000001;
      groupId = 0;
      return this;
    }

    /**
     * <code>optional uint32 GroupId = 1;</code>
     * @return the groupId
     */
    public int getGroupId() {
      return groupId;
    }

    /**
     * <code>optional uint32 GroupId = 1;</code>
     * @param value the groupId to set
     * @return this
     */
    public FormationRecord setGroupId(final int value) {
      bitField0_ |= 0x00000001;
      groupId = value;
      return this;
    }

    /**
     * <code>optional uint32 Number = 2;</code>
     * @return whether the number field is set
     */
    public boolean hasNumber() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional uint32 Number = 2;</code>
     * @return this
     */
    public FormationRecord clearNumber() {
      bitField0_ &= ~0x00000002;
      number = 0;
      return this;
    }

    /**
     * <code>optional uint32 Number = 2;</code>
     * @return the number
     */
    public int getNumber() {
      return number;
    }

    /**
     * <code>optional uint32 Number = 2;</code>
     * @param value the number to set
     * @return this
     */
    public FormationRecord setNumber(final int value) {
      bitField0_ |= 0x00000002;
      number = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public FormationRecord clearNextPackage() {
      bitField0_ &= ~0x00000004;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000004;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public FormationRecord addNextPackage(final byte value) {
      bitField0_ |= 0x00000004;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public FormationRecord addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000004;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public FormationRecord setNextPackage(final byte... values) {
      bitField0_ |= 0x00000004;
      nextPackage.copyFrom(values);
      return this;
    }

    @Override
    public FormationRecord copyFrom(final FormationRecord other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        groupId = other.groupId;
        number = other.number;
        nextPackage.copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public FormationRecord mergeFrom(final FormationRecord other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasGroupId()) {
        setGroupId(other.groupId);
      }
      if (other.hasNumber()) {
        setNumber(other.number);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public FormationRecord clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      groupId = 0;
      number = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public FormationRecord clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof FormationRecord)) {
        return false;
      }
      FormationRecord other = (FormationRecord) o;
      return bitField0_ == other.bitField0_
        && (!hasGroupId() || groupId == other.groupId)
        && (!hasNumber() || number == other.number)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt32NoTag(groupId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 16);
        output.writeUInt32NoTag(number);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(groupId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(number);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public FormationRecord mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            // groupId
            groupId = input.readUInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 16) {
              break;
            }
          }
          case 16: {
            // number
            number = input.readUInt32();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeUInt32(FieldNames.groupId, groupId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeUInt32(FieldNames.number, number);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      output.endObject();
    }

    @Override
    public FormationRecord mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 1958081498: {
            if (input.isAtField(FieldNames.groupId)) {
              if (!input.trySkipNullValue()) {
                groupId = input.readUInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1950496919: {
            if (input.isAtField(FieldNames.number)) {
              if (!input.trySkipNullValue()) {
                number = input.readUInt32();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public FormationRecord clone() {
      return new FormationRecord().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static FormationRecord parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new FormationRecord(), data).checkInitialized();
    }

    public static FormationRecord parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new FormationRecord(), input).checkInitialized();
    }

    public static FormationRecord parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new FormationRecord(), input).checkInitialized();
    }

    /**
     * @return factory for creating FormationRecord messages
     */
    public static MessageFactory<FormationRecord> getFactory() {
      return FormationRecordFactory.INSTANCE;
    }

    private enum FormationRecordFactory implements MessageFactory<FormationRecord> {
      INSTANCE;

      @Override
      public FormationRecord create() {
        return FormationRecord.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName groupId = FieldName.forField("GroupId");

      static final FieldName number = FieldName.forField("Number");

      static final FieldName nextPackage = FieldName.forField("NextPackage");
    }
  }

  /**
   * Protobuf type {@code TowerFormation}
   */
  public static final class TowerFormation extends ProtoMessage<TowerFormation> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    /**
     * <code>repeated .FormationInfo Info = 1;</code>
     */
    private final RepeatedMessage<FormationInfo> info = RepeatedMessage.newEmptyInstance(FormationInfo.getFactory());

    /**
     * <code>repeated .FormationRecord Record = 2;</code>
     */
    private final RepeatedMessage<FormationRecord> record = RepeatedMessage.newEmptyInstance(FormationRecord.getFactory());

    private TowerFormation() {
    }

    /**
     * @return a new empty instance of {@code TowerFormation}
     */
    public static TowerFormation newInstance() {
      return new TowerFormation();
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public TowerFormation clearNextPackage() {
      bitField0_ &= ~0x00000001;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000001;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public TowerFormation addNextPackage(final byte value) {
      bitField0_ |= 0x00000001;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public TowerFormation addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000001;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public TowerFormation setNextPackage(final byte... values) {
      bitField0_ |= 0x00000001;
      nextPackage.copyFrom(values);
      return this;
    }

    /**
     * <code>repeated .FormationInfo Info = 1;</code>
     * @return whether the info field is set
     */
    public boolean hasInfo() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>repeated .FormationInfo Info = 1;</code>
     * @return this
     */
    public TowerFormation clearInfo() {
      bitField0_ &= ~0x00000002;
      info.clear();
      return this;
    }

    /**
     * <code>repeated .FormationInfo Info = 1;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableInfo()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<FormationInfo> getInfo() {
      return info;
    }

    /**
     * <code>repeated .FormationInfo Info = 1;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<FormationInfo> getMutableInfo() {
      bitField0_ |= 0x00000002;
      return info;
    }

    /**
     * <code>repeated .FormationInfo Info = 1;</code>
     * @param value the info to add
     * @return this
     */
    public TowerFormation addInfo(final FormationInfo value) {
      bitField0_ |= 0x00000002;
      info.add(value);
      return this;
    }

    /**
     * <code>repeated .FormationInfo Info = 1;</code>
     * @param values the info to add
     * @return this
     */
    public TowerFormation addAllInfo(final FormationInfo... values) {
      bitField0_ |= 0x00000002;
      info.addAll(values);
      return this;
    }

    /**
     * <code>repeated .FormationRecord Record = 2;</code>
     * @return whether the record field is set
     */
    public boolean hasRecord() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>repeated .FormationRecord Record = 2;</code>
     * @return this
     */
    public TowerFormation clearRecord() {
      bitField0_ &= ~0x00000004;
      record.clear();
      return this;
    }

    /**
     * <code>repeated .FormationRecord Record = 2;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableRecord()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<FormationRecord> getRecord() {
      return record;
    }

    /**
     * <code>repeated .FormationRecord Record = 2;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<FormationRecord> getMutableRecord() {
      bitField0_ |= 0x00000004;
      return record;
    }

    /**
     * <code>repeated .FormationRecord Record = 2;</code>
     * @param value the record to add
     * @return this
     */
    public TowerFormation addRecord(final FormationRecord value) {
      bitField0_ |= 0x00000004;
      record.add(value);
      return this;
    }

    /**
     * <code>repeated .FormationRecord Record = 2;</code>
     * @param values the record to add
     * @return this
     */
    public TowerFormation addAllRecord(final FormationRecord... values) {
      bitField0_ |= 0x00000004;
      record.addAll(values);
      return this;
    }

    @Override
    public TowerFormation copyFrom(final TowerFormation other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        nextPackage.copyFrom(other.nextPackage);
        info.copyFrom(other.info);
        record.copyFrom(other.record);
      }
      return this;
    }

    @Override
    public TowerFormation mergeFrom(final TowerFormation other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      if (other.hasInfo()) {
        getMutableInfo().addAll(other.info);
      }
      if (other.hasRecord()) {
        getMutableRecord().addAll(other.record);
      }
      return this;
    }

    @Override
    public TowerFormation clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      info.clear();
      record.clear();
      return this;
    }

    @Override
    public TowerFormation clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      info.clearQuick();
      record.clearQuick();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof TowerFormation)) {
        return false;
      }
      TowerFormation other = (TowerFormation) o;
      return bitField0_ == other.bitField0_
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage))
        && (!hasInfo() || info.equals(other.info))
        && (!hasRecord() || record.equals(other.record));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        for (int i = 0; i < info.length(); i++) {
          output.writeRawByte((byte) 10);
          output.writeMessageNoTag(info.get(i));
        }
      }
      if ((bitField0_ & 0x00000004) != 0) {
        for (int i = 0; i < record.length(); i++) {
          output.writeRawByte((byte) 18);
          output.writeMessageNoTag(record.get(i));
        }
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += (1 * info.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(info);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += (1 * record.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(record);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public TowerFormation mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 10) {
              break;
            }
          }
          case 10: {
            // info
            tag = input.readRepeatedMessage(info, tag);
            bitField0_ |= 0x00000002;
            if (tag != 18) {
              break;
            }
          }
          case 18: {
            // record
            tag = input.readRepeatedMessage(record, tag);
            bitField0_ |= 0x00000004;
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRepeatedMessage(FieldNames.info, info);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRepeatedMessage(FieldNames.record, record);
      }
      output.endObject();
    }

    @Override
    public TowerFormation mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 2283726: {
            if (input.isAtField(FieldNames.info)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedMessage(info);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1851041679: {
            if (input.isAtField(FieldNames.record)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedMessage(record);
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public TowerFormation clone() {
      return new TowerFormation().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static TowerFormation parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new TowerFormation(), data).checkInitialized();
    }

    public static TowerFormation parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new TowerFormation(), input).checkInitialized();
    }

    public static TowerFormation parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new TowerFormation(), input).checkInitialized();
    }

    /**
     * @return factory for creating TowerFormation messages
     */
    public static MessageFactory<TowerFormation> getFactory() {
      return TowerFormationFactory.INSTANCE;
    }

    private enum TowerFormationFactory implements MessageFactory<TowerFormation> {
      INSTANCE;

      @Override
      public TowerFormation create() {
        return TowerFormation.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName nextPackage = FieldName.forField("NextPackage");

      static final FieldName info = FieldName.forField("Info");

      static final FieldName record = FieldName.forField("Record");
    }
  }

  /**
   * Protobuf type {@code StoryChoice}
   */
  public static final class StoryChoice extends ProtoMessage<StoryChoice> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional uint32 Group = 1;</code>
     */
    private int group;

    /**
     * <code>optional uint32 Value = 2;</code>
     */
    private int value_;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    private StoryChoice() {
    }

    /**
     * @return a new empty instance of {@code StoryChoice}
     */
    public static StoryChoice newInstance() {
      return new StoryChoice();
    }

    /**
     * <code>optional uint32 Group = 1;</code>
     * @return whether the group field is set
     */
    public boolean hasGroup() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional uint32 Group = 1;</code>
     * @return this
     */
    public StoryChoice clearGroup() {
      bitField0_ &= ~0x00000001;
      group = 0;
      return this;
    }

    /**
     * <code>optional uint32 Group = 1;</code>
     * @return the group
     */
    public int getGroup() {
      return group;
    }

    /**
     * <code>optional uint32 Group = 1;</code>
     * @param value the group to set
     * @return this
     */
    public StoryChoice setGroup(final int value) {
      bitField0_ |= 0x00000001;
      group = value;
      return this;
    }

    /**
     * <code>optional uint32 Value = 2;</code>
     * @return whether the value_ field is set
     */
    public boolean hasValue() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional uint32 Value = 2;</code>
     * @return this
     */
    public StoryChoice clearValue() {
      bitField0_ &= ~0x00000002;
      value_ = 0;
      return this;
    }

    /**
     * <code>optional uint32 Value = 2;</code>
     * @return the value_
     */
    public int getValue() {
      return value_;
    }

    /**
     * <code>optional uint32 Value = 2;</code>
     * @param value the value_ to set
     * @return this
     */
    public StoryChoice setValue(final int value) {
      bitField0_ |= 0x00000002;
      value_ = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public StoryChoice clearNextPackage() {
      bitField0_ &= ~0x00000004;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000004;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public StoryChoice addNextPackage(final byte value) {
      bitField0_ |= 0x00000004;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public StoryChoice addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000004;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public StoryChoice setNextPackage(final byte... values) {
      bitField0_ |= 0x00000004;
      nextPackage.copyFrom(values);
      return this;
    }

    @Override
    public StoryChoice copyFrom(final StoryChoice other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        group = other.group;
        value_ = other.value_;
        nextPackage.copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public StoryChoice mergeFrom(final StoryChoice other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasGroup()) {
        setGroup(other.group);
      }
      if (other.hasValue()) {
        setValue(other.value_);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public StoryChoice clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      group = 0;
      value_ = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public StoryChoice clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof StoryChoice)) {
        return false;
      }
      StoryChoice other = (StoryChoice) o;
      return bitField0_ == other.bitField0_
        && (!hasGroup() || group == other.group)
        && (!hasValue() || value_ == other.value_)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt32NoTag(group);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 16);
        output.writeUInt32NoTag(value_);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(group);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(value_);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public StoryChoice mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            // group
            group = input.readUInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 16) {
              break;
            }
          }
          case 16: {
            // value_
            value_ = input.readUInt32();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeUInt32(FieldNames.group, group);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeUInt32(FieldNames.value_, value_);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      output.endObject();
    }

    @Override
    public StoryChoice mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 69076575: {
            if (input.isAtField(FieldNames.group)) {
              if (!input.trySkipNullValue()) {
                group = input.readUInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 82420049: {
            if (input.isAtField(FieldNames.value_)) {
              if (!input.trySkipNullValue()) {
                value_ = input.readUInt32();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public StoryChoice clone() {
      return new StoryChoice().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static StoryChoice parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new StoryChoice(), data).checkInitialized();
    }

    public static StoryChoice parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new StoryChoice(), input).checkInitialized();
    }

    public static StoryChoice parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new StoryChoice(), input).checkInitialized();
    }

    /**
     * @return factory for creating StoryChoice messages
     */
    public static MessageFactory<StoryChoice> getFactory() {
      return StoryChoiceFactory.INSTANCE;
    }

    private enum StoryChoiceFactory implements MessageFactory<StoryChoice> {
      INSTANCE;

      @Override
      public StoryChoice create() {
        return StoryChoice.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName group = FieldName.forField("Group");

      static final FieldName value_ = FieldName.forField("Value");

      static final FieldName nextPackage = FieldName.forField("NextPackage");
    }
  }

  /**
   * Protobuf type {@code Story}
   */
  public static final class Story extends ProtoMessage<Story> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional uint32 Idx = 1;</code>
     */
    private int idx;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    /**
     * <code>repeated .StoryChoice Major = 2;</code>
     */
    private final RepeatedMessage<StoryChoice> major = RepeatedMessage.newEmptyInstance(StoryChoice.getFactory());

    /**
     * <code>repeated .StoryChoice Personality = 3;</code>
     */
    private final RepeatedMessage<StoryChoice> personality = RepeatedMessage.newEmptyInstance(StoryChoice.getFactory());

    private Story() {
    }

    /**
     * @return a new empty instance of {@code Story}
     */
    public static Story newInstance() {
      return new Story();
    }

    /**
     * <code>optional uint32 Idx = 1;</code>
     * @return whether the idx field is set
     */
    public boolean hasIdx() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional uint32 Idx = 1;</code>
     * @return this
     */
    public Story clearIdx() {
      bitField0_ &= ~0x00000001;
      idx = 0;
      return this;
    }

    /**
     * <code>optional uint32 Idx = 1;</code>
     * @return the idx
     */
    public int getIdx() {
      return idx;
    }

    /**
     * <code>optional uint32 Idx = 1;</code>
     * @param value the idx to set
     * @return this
     */
    public Story setIdx(final int value) {
      bitField0_ |= 0x00000001;
      idx = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public Story clearNextPackage() {
      bitField0_ &= ~0x00000002;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000002;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public Story addNextPackage(final byte value) {
      bitField0_ |= 0x00000002;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public Story addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000002;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public Story setNextPackage(final byte... values) {
      bitField0_ |= 0x00000002;
      nextPackage.copyFrom(values);
      return this;
    }

    /**
     * <code>repeated .StoryChoice Major = 2;</code>
     * @return whether the major field is set
     */
    public boolean hasMajor() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>repeated .StoryChoice Major = 2;</code>
     * @return this
     */
    public Story clearMajor() {
      bitField0_ &= ~0x00000004;
      major.clear();
      return this;
    }

    /**
     * <code>repeated .StoryChoice Major = 2;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableMajor()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<StoryChoice> getMajor() {
      return major;
    }

    /**
     * <code>repeated .StoryChoice Major = 2;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<StoryChoice> getMutableMajor() {
      bitField0_ |= 0x00000004;
      return major;
    }

    /**
     * <code>repeated .StoryChoice Major = 2;</code>
     * @param value the major to add
     * @return this
     */
    public Story addMajor(final StoryChoice value) {
      bitField0_ |= 0x00000004;
      major.add(value);
      return this;
    }

    /**
     * <code>repeated .StoryChoice Major = 2;</code>
     * @param values the major to add
     * @return this
     */
    public Story addAllMajor(final StoryChoice... values) {
      bitField0_ |= 0x00000004;
      major.addAll(values);
      return this;
    }

    /**
     * <code>repeated .StoryChoice Personality = 3;</code>
     * @return whether the personality field is set
     */
    public boolean hasPersonality() {
      return (bitField0_ & 0x00000008) != 0;
    }

    /**
     * <code>repeated .StoryChoice Personality = 3;</code>
     * @return this
     */
    public Story clearPersonality() {
      bitField0_ &= ~0x00000008;
      personality.clear();
      return this;
    }

    /**
     * <code>repeated .StoryChoice Personality = 3;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutablePersonality()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<StoryChoice> getPersonality() {
      return personality;
    }

    /**
     * <code>repeated .StoryChoice Personality = 3;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<StoryChoice> getMutablePersonality() {
      bitField0_ |= 0x00000008;
      return personality;
    }

    /**
     * <code>repeated .StoryChoice Personality = 3;</code>
     * @param value the personality to add
     * @return this
     */
    public Story addPersonality(final StoryChoice value) {
      bitField0_ |= 0x00000008;
      personality.add(value);
      return this;
    }

    /**
     * <code>repeated .StoryChoice Personality = 3;</code>
     * @param values the personality to add
     * @return this
     */
    public Story addAllPersonality(final StoryChoice... values) {
      bitField0_ |= 0x00000008;
      personality.addAll(values);
      return this;
    }

    @Override
    public Story copyFrom(final Story other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        idx = other.idx;
        nextPackage.copyFrom(other.nextPackage);
        major.copyFrom(other.major);
        personality.copyFrom(other.personality);
      }
      return this;
    }

    @Override
    public Story mergeFrom(final Story other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasIdx()) {
        setIdx(other.idx);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      if (other.hasMajor()) {
        getMutableMajor().addAll(other.major);
      }
      if (other.hasPersonality()) {
        getMutablePersonality().addAll(other.personality);
      }
      return this;
    }

    @Override
    public Story clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      idx = 0;
      nextPackage.clear();
      major.clear();
      personality.clear();
      return this;
    }

    @Override
    public Story clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      major.clearQuick();
      personality.clearQuick();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof Story)) {
        return false;
      }
      Story other = (Story) o;
      return bitField0_ == other.bitField0_
        && (!hasIdx() || idx == other.idx)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage))
        && (!hasMajor() || major.equals(other.major))
        && (!hasPersonality() || personality.equals(other.personality));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt32NoTag(idx);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        for (int i = 0; i < major.length(); i++) {
          output.writeRawByte((byte) 18);
          output.writeMessageNoTag(major.get(i));
        }
      }
      if ((bitField0_ & 0x00000008) != 0) {
        for (int i = 0; i < personality.length(); i++) {
          output.writeRawByte((byte) 26);
          output.writeMessageNoTag(personality.get(i));
        }
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(idx);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += (1 * major.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(major);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        size += (1 * personality.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(personality);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public Story mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            // idx
            idx = input.readUInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 18) {
              break;
            }
          }
          case 18: {
            // major
            tag = input.readRepeatedMessage(major, tag);
            bitField0_ |= 0x00000004;
            if (tag != 26) {
              break;
            }
          }
          case 26: {
            // personality
            tag = input.readRepeatedMessage(personality, tag);
            bitField0_ |= 0x00000008;
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeUInt32(FieldNames.idx, idx);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRepeatedMessage(FieldNames.major, major);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeRepeatedMessage(FieldNames.personality, personality);
      }
      output.endObject();
    }

    @Override
    public Story mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 73373: {
            if (input.isAtField(FieldNames.idx)) {
              if (!input.trySkipNullValue()) {
                idx = input.readUInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 74106265: {
            if (input.isAtField(FieldNames.major)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedMessage(major);
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 1243902542: {
            if (input.isAtField(FieldNames.personality)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedMessage(personality);
                bitField0_ |= 0x00000008;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public Story clone() {
      return new Story().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static Story parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new Story(), data).checkInitialized();
    }

    public static Story parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new Story(), input).checkInitialized();
    }

    public static Story parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new Story(), input).checkInitialized();
    }

    /**
     * @return factory for creating Story messages
     */
    public static MessageFactory<Story> getFactory() {
      return StoryFactory.INSTANCE;
    }

    private enum StoryFactory implements MessageFactory<Story> {
      INSTANCE;

      @Override
      public Story create() {
        return Story.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName idx = FieldName.forField("Idx");

      static final FieldName nextPackage = FieldName.forField("NextPackage");

      static final FieldName major = FieldName.forField("Major");

      static final FieldName personality = FieldName.forField("Personality");
    }
  }

  /**
   * Protobuf type {@code StoryInfo}
   */
  public static final class StoryInfo extends ProtoMessage<StoryInfo> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional uint64 BuildId = 3;</code>
     */
    private long buildId;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    /**
     * <code>repeated uint32 Evidences = 1;</code>
     */
    private final RepeatedInt evidences = RepeatedInt.newEmptyInstance();

    /**
     * <code>repeated .Story Stories = 2;</code>
     */
    private final RepeatedMessage<Story> stories = RepeatedMessage.newEmptyInstance(Story.getFactory());

    private StoryInfo() {
    }

    /**
     * @return a new empty instance of {@code StoryInfo}
     */
    public static StoryInfo newInstance() {
      return new StoryInfo();
    }

    /**
     * <code>optional uint64 BuildId = 3;</code>
     * @return whether the buildId field is set
     */
    public boolean hasBuildId() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional uint64 BuildId = 3;</code>
     * @return this
     */
    public StoryInfo clearBuildId() {
      bitField0_ &= ~0x00000001;
      buildId = 0L;
      return this;
    }

    /**
     * <code>optional uint64 BuildId = 3;</code>
     * @return the buildId
     */
    public long getBuildId() {
      return buildId;
    }

    /**
     * <code>optional uint64 BuildId = 3;</code>
     * @param value the buildId to set
     * @return this
     */
    public StoryInfo setBuildId(final long value) {
      bitField0_ |= 0x00000001;
      buildId = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public StoryInfo clearNextPackage() {
      bitField0_ &= ~0x00000002;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000002;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public StoryInfo addNextPackage(final byte value) {
      bitField0_ |= 0x00000002;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public StoryInfo addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000002;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public StoryInfo setNextPackage(final byte... values) {
      bitField0_ |= 0x00000002;
      nextPackage.copyFrom(values);
      return this;
    }

    /**
     * <code>repeated uint32 Evidences = 1;</code>
     * @return whether the evidences field is set
     */
    public boolean hasEvidences() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>repeated uint32 Evidences = 1;</code>
     * @return this
     */
    public StoryInfo clearEvidences() {
      bitField0_ &= ~0x00000004;
      evidences.clear();
      return this;
    }

    /**
     * <code>repeated uint32 Evidences = 1;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableEvidences()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedInt getEvidences() {
      return evidences;
    }

    /**
     * <code>repeated uint32 Evidences = 1;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedInt getMutableEvidences() {
      bitField0_ |= 0x00000004;
      return evidences;
    }

    /**
     * <code>repeated uint32 Evidences = 1;</code>
     * @param value the evidences to add
     * @return this
     */
    public StoryInfo addEvidences(final int value) {
      bitField0_ |= 0x00000004;
      evidences.add(value);
      return this;
    }

    /**
     * <code>repeated uint32 Evidences = 1;</code>
     * @param values the evidences to add
     * @return this
     */
    public StoryInfo addAllEvidences(final int... values) {
      bitField0_ |= 0x00000004;
      evidences.addAll(values);
      return this;
    }

    /**
     * <code>repeated .Story Stories = 2;</code>
     * @return whether the stories field is set
     */
    public boolean hasStories() {
      return (bitField0_ & 0x00000008) != 0;
    }

    /**
     * <code>repeated .Story Stories = 2;</code>
     * @return this
     */
    public StoryInfo clearStories() {
      bitField0_ &= ~0x00000008;
      stories.clear();
      return this;
    }

    /**
     * <code>repeated .Story Stories = 2;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableStories()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<Story> getStories() {
      return stories;
    }

    /**
     * <code>repeated .Story Stories = 2;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<Story> getMutableStories() {
      bitField0_ |= 0x00000008;
      return stories;
    }

    /**
     * <code>repeated .Story Stories = 2;</code>
     * @param value the stories to add
     * @return this
     */
    public StoryInfo addStories(final Story value) {
      bitField0_ |= 0x00000008;
      stories.add(value);
      return this;
    }

    /**
     * <code>repeated .Story Stories = 2;</code>
     * @param values the stories to add
     * @return this
     */
    public StoryInfo addAllStories(final Story... values) {
      bitField0_ |= 0x00000008;
      stories.addAll(values);
      return this;
    }

    @Override
    public StoryInfo copyFrom(final StoryInfo other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        buildId = other.buildId;
        nextPackage.copyFrom(other.nextPackage);
        evidences.copyFrom(other.evidences);
        stories.copyFrom(other.stories);
      }
      return this;
    }

    @Override
    public StoryInfo mergeFrom(final StoryInfo other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasBuildId()) {
        setBuildId(other.buildId);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      if (other.hasEvidences()) {
        getMutableEvidences().addAll(other.evidences);
      }
      if (other.hasStories()) {
        getMutableStories().addAll(other.stories);
      }
      return this;
    }

    @Override
    public StoryInfo clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      buildId = 0L;
      nextPackage.clear();
      evidences.clear();
      stories.clear();
      return this;
    }

    @Override
    public StoryInfo clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      evidences.clear();
      stories.clearQuick();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof StoryInfo)) {
        return false;
      }
      StoryInfo other = (StoryInfo) o;
      return bitField0_ == other.bitField0_
        && (!hasBuildId() || buildId == other.buildId)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage))
        && (!hasEvidences() || evidences.equals(other.evidences))
        && (!hasStories() || stories.equals(other.stories));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 24);
        output.writeUInt64NoTag(buildId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        for (int i = 0; i < evidences.length(); i++) {
          output.writeRawByte((byte) 8);
          output.writeUInt32NoTag(evidences.array()[i]);
        }
      }
      if ((bitField0_ & 0x00000008) != 0) {
        for (int i = 0; i < stories.length(); i++) {
          output.writeRawByte((byte) 18);
          output.writeMessageNoTag(stories.get(i));
        }
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeUInt64SizeNoTag(buildId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += (1 * evidences.length()) + ProtoSink.computeRepeatedUInt32SizeNoTag(evidences);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        size += (1 * stories.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(stories);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public StoryInfo mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 24: {
            // buildId
            buildId = input.readUInt64();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 10) {
              break;
            }
          }
          case 10: {
            // evidences [packed=true]
            input.readPackedUInt32(evidences, tag);
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 18) {
              break;
            }
          }
          case 18: {
            // stories
            tag = input.readRepeatedMessage(stories, tag);
            bitField0_ |= 0x00000008;
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
          case 8: {
            // evidences [packed=false]
            tag = input.readRepeatedUInt32(evidences, tag);
            bitField0_ |= 0x00000004;
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeUInt64(FieldNames.buildId, buildId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRepeatedUInt32(FieldNames.evidences, evidences);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeRepeatedMessage(FieldNames.stories, stories);
      }
      output.endObject();
    }

    @Override
    public StoryInfo mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 1895597065: {
            if (input.isAtField(FieldNames.buildId)) {
              if (!input.trySkipNullValue()) {
                buildId = input.readUInt64();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 991055068: {
            if (input.isAtField(FieldNames.evidences)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedUInt32(evidences);
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -219613133: {
            if (input.isAtField(FieldNames.stories)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedMessage(stories);
                bitField0_ |= 0x00000008;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public StoryInfo clone() {
      return new StoryInfo().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static StoryInfo parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new StoryInfo(), data).checkInitialized();
    }

    public static StoryInfo parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new StoryInfo(), input).checkInitialized();
    }

    public static StoryInfo parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new StoryInfo(), input).checkInitialized();
    }

    /**
     * @return factory for creating StoryInfo messages
     */
    public static MessageFactory<StoryInfo> getFactory() {
      return StoryInfoFactory.INSTANCE;
    }

    private enum StoryInfoFactory implements MessageFactory<StoryInfo> {
      INSTANCE;

      @Override
      public StoryInfo create() {
        return StoryInfo.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName buildId = FieldName.forField("BuildId");

      static final FieldName nextPackage = FieldName.forField("NextPackage");

      static final FieldName evidences = FieldName.forField("Evidences");

      static final FieldName stories = FieldName.forField("Stories");
    }
  }

  /**
   * Protobuf type {@code RoomRestored}
   */
  public static final class RoomRestored extends ProtoMessage<RoomRestored> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional uint32 RoomId = 1;</code>
     */
    private int roomId;

    /**
     * <code>optional .ChangeInfo Change = 2;</code>
     */
    private final ChangeInfo change = ChangeInfo.newInstance();

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    private RoomRestored() {
    }

    /**
     * @return a new empty instance of {@code RoomRestored}
     */
    public static RoomRestored newInstance() {
      return new RoomRestored();
    }

    /**
     * <code>optional uint32 RoomId = 1;</code>
     * @return whether the roomId field is set
     */
    public boolean hasRoomId() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional uint32 RoomId = 1;</code>
     * @return this
     */
    public RoomRestored clearRoomId() {
      bitField0_ &= ~0x00000001;
      roomId = 0;
      return this;
    }

    /**
     * <code>optional uint32 RoomId = 1;</code>
     * @return the roomId
     */
    public int getRoomId() {
      return roomId;
    }

    /**
     * <code>optional uint32 RoomId = 1;</code>
     * @param value the roomId to set
     * @return this
     */
    public RoomRestored setRoomId(final int value) {
      bitField0_ |= 0x00000001;
      roomId = value;
      return this;
    }

    /**
     * <code>optional .ChangeInfo Change = 2;</code>
     * @return whether the change field is set
     */
    public boolean hasChange() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional .ChangeInfo Change = 2;</code>
     * @return this
     */
    public RoomRestored clearChange() {
      bitField0_ &= ~0x00000002;
      change.clear();
      return this;
    }

    /**
     * <code>optional .ChangeInfo Change = 2;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableChange()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public ChangeInfo getChange() {
      return change;
    }

    /**
     * <code>optional .ChangeInfo Change = 2;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public ChangeInfo getMutableChange() {
      bitField0_ |= 0x00000002;
      return change;
    }

    /**
     * <code>optional .ChangeInfo Change = 2;</code>
     * @param value the change to set
     * @return this
     */
    public RoomRestored setChange(final ChangeInfo value) {
      bitField0_ |= 0x00000002;
      change.copyFrom(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public RoomRestored clearNextPackage() {
      bitField0_ &= ~0x00000004;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000004;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public RoomRestored addNextPackage(final byte value) {
      bitField0_ |= 0x00000004;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public RoomRestored addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000004;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public RoomRestored setNextPackage(final byte... values) {
      bitField0_ |= 0x00000004;
      nextPackage.copyFrom(values);
      return this;
    }

    @Override
    public RoomRestored copyFrom(final RoomRestored other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        roomId = other.roomId;
        change.copyFrom(other.change);
        nextPackage.copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public RoomRestored mergeFrom(final RoomRestored other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasRoomId()) {
        setRoomId(other.roomId);
      }
      if (other.hasChange()) {
        getMutableChange().mergeFrom(other.change);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public RoomRestored clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      roomId = 0;
      change.clear();
      nextPackage.clear();
      return this;
    }

    @Override
    public RoomRestored clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      change.clearQuick();
      nextPackage.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof RoomRestored)) {
        return false;
      }
      RoomRestored other = (RoomRestored) o;
      return bitField0_ == other.bitField0_
        && (!hasRoomId() || roomId == other.roomId)
        && (!hasChange() || change.equals(other.change))
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt32NoTag(roomId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 18);
        output.writeMessageNoTag(change);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(roomId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeMessageSizeNoTag(change);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public RoomRestored mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            // roomId
            roomId = input.readUInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 18) {
              break;
            }
          }
          case 18: {
            // change
            input.readMessage(change);
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeUInt32(FieldNames.roomId, roomId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeMessage(FieldNames.change, change);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      output.endObject();
    }

    @Override
    public RoomRestored mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case -1841452170: {
            if (input.isAtField(FieldNames.roomId)) {
              if (!input.trySkipNullValue()) {
                roomId = input.readUInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 2017198032: {
            if (input.isAtField(FieldNames.change)) {
              if (!input.trySkipNullValue()) {
                input.readMessage(change);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public RoomRestored clone() {
      return new RoomRestored().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static RoomRestored parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new RoomRestored(), data).checkInitialized();
    }

    public static RoomRestored parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new RoomRestored(), input).checkInitialized();
    }

    public static RoomRestored parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new RoomRestored(), input).checkInitialized();
    }

    /**
     * @return factory for creating RoomRestored messages
     */
    public static MessageFactory<RoomRestored> getFactory() {
      return RoomRestoredFactory.INSTANCE;
    }

    private enum RoomRestoredFactory implements MessageFactory<RoomRestored> {
      INSTANCE;

      @Override
      public RoomRestored create() {
        return RoomRestored.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName roomId = FieldName.forField("RoomId");

      static final FieldName change = FieldName.forField("Change");

      static final FieldName nextPackage = FieldName.forField("NextPackage");
    }
  }

  /**
   * Protobuf type {@code DropPkg}
   */
  public static final class DropPkg extends ProtoMessage<DropPkg> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    /**
     * <code>repeated .ItemTpl Drops = 1;</code>
     */
    private final RepeatedMessage<ItemTpl> drops = RepeatedMessage.newEmptyInstance(ItemTpl.getFactory());

    private DropPkg() {
    }

    /**
     * @return a new empty instance of {@code DropPkg}
     */
    public static DropPkg newInstance() {
      return new DropPkg();
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public DropPkg clearNextPackage() {
      bitField0_ &= ~0x00000001;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000001;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public DropPkg addNextPackage(final byte value) {
      bitField0_ |= 0x00000001;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public DropPkg addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000001;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public DropPkg setNextPackage(final byte... values) {
      bitField0_ |= 0x00000001;
      nextPackage.copyFrom(values);
      return this;
    }

    /**
     * <code>repeated .ItemTpl Drops = 1;</code>
     * @return whether the drops field is set
     */
    public boolean hasDrops() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>repeated .ItemTpl Drops = 1;</code>
     * @return this
     */
    public DropPkg clearDrops() {
      bitField0_ &= ~0x00000002;
      drops.clear();
      return this;
    }

    /**
     * <code>repeated .ItemTpl Drops = 1;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableDrops()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<ItemTpl> getDrops() {
      return drops;
    }

    /**
     * <code>repeated .ItemTpl Drops = 1;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<ItemTpl> getMutableDrops() {
      bitField0_ |= 0x00000002;
      return drops;
    }

    /**
     * <code>repeated .ItemTpl Drops = 1;</code>
     * @param value the drops to add
     * @return this
     */
    public DropPkg addDrops(final ItemTpl value) {
      bitField0_ |= 0x00000002;
      drops.add(value);
      return this;
    }

    /**
     * <code>repeated .ItemTpl Drops = 1;</code>
     * @param values the drops to add
     * @return this
     */
    public DropPkg addAllDrops(final ItemTpl... values) {
      bitField0_ |= 0x00000002;
      drops.addAll(values);
      return this;
    }

    @Override
    public DropPkg copyFrom(final DropPkg other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        nextPackage.copyFrom(other.nextPackage);
        drops.copyFrom(other.drops);
      }
      return this;
    }

    @Override
    public DropPkg mergeFrom(final DropPkg other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      if (other.hasDrops()) {
        getMutableDrops().addAll(other.drops);
      }
      return this;
    }

    @Override
    public DropPkg clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      drops.clear();
      return this;
    }

    @Override
    public DropPkg clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      drops.clearQuick();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof DropPkg)) {
        return false;
      }
      DropPkg other = (DropPkg) o;
      return bitField0_ == other.bitField0_
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage))
        && (!hasDrops() || drops.equals(other.drops));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        for (int i = 0; i < drops.length(); i++) {
          output.writeRawByte((byte) 10);
          output.writeMessageNoTag(drops.get(i));
        }
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += (1 * drops.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(drops);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public DropPkg mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 10) {
              break;
            }
          }
          case 10: {
            // drops
            tag = input.readRepeatedMessage(drops, tag);
            bitField0_ |= 0x00000002;
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRepeatedMessage(FieldNames.drops, drops);
      }
      output.endObject();
    }

    @Override
    public DropPkg mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 66305860: {
            if (input.isAtField(FieldNames.drops)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedMessage(drops);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public DropPkg clone() {
      return new DropPkg().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static DropPkg parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new DropPkg(), data).checkInitialized();
    }

    public static DropPkg parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new DropPkg(), input).checkInitialized();
    }

    public static DropPkg parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new DropPkg(), input).checkInitialized();
    }

    /**
     * @return factory for creating DropPkg messages
     */
    public static MessageFactory<DropPkg> getFactory() {
      return DropPkgFactory.INSTANCE;
    }

    private enum DropPkgFactory implements MessageFactory<DropPkg> {
      INSTANCE;

      @Override
      public DropPkg create() {
        return DropPkg.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName nextPackage = FieldName.forField("NextPackage");

      static final FieldName drops = FieldName.forField("Drops");
    }
  }

  /**
   * Protobuf type {@code MonsterDrop}
   */
  public static final class MonsterDrop extends ProtoMessage<MonsterDrop> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional uint32 MonsterIndex = 1;</code>
     */
    private int monsterIndex;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    /**
     * <code>repeated .DropPkg DropPkgs = 2;</code>
     */
    private final RepeatedMessage<DropPkg> dropPkgs = RepeatedMessage.newEmptyInstance(DropPkg.getFactory());

    private MonsterDrop() {
    }

    /**
     * @return a new empty instance of {@code MonsterDrop}
     */
    public static MonsterDrop newInstance() {
      return new MonsterDrop();
    }

    /**
     * <code>optional uint32 MonsterIndex = 1;</code>
     * @return whether the monsterIndex field is set
     */
    public boolean hasMonsterIndex() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional uint32 MonsterIndex = 1;</code>
     * @return this
     */
    public MonsterDrop clearMonsterIndex() {
      bitField0_ &= ~0x00000001;
      monsterIndex = 0;
      return this;
    }

    /**
     * <code>optional uint32 MonsterIndex = 1;</code>
     * @return the monsterIndex
     */
    public int getMonsterIndex() {
      return monsterIndex;
    }

    /**
     * <code>optional uint32 MonsterIndex = 1;</code>
     * @param value the monsterIndex to set
     * @return this
     */
    public MonsterDrop setMonsterIndex(final int value) {
      bitField0_ |= 0x00000001;
      monsterIndex = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public MonsterDrop clearNextPackage() {
      bitField0_ &= ~0x00000002;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000002;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public MonsterDrop addNextPackage(final byte value) {
      bitField0_ |= 0x00000002;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public MonsterDrop addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000002;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public MonsterDrop setNextPackage(final byte... values) {
      bitField0_ |= 0x00000002;
      nextPackage.copyFrom(values);
      return this;
    }

    /**
     * <code>repeated .DropPkg DropPkgs = 2;</code>
     * @return whether the dropPkgs field is set
     */
    public boolean hasDropPkgs() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>repeated .DropPkg DropPkgs = 2;</code>
     * @return this
     */
    public MonsterDrop clearDropPkgs() {
      bitField0_ &= ~0x00000004;
      dropPkgs.clear();
      return this;
    }

    /**
     * <code>repeated .DropPkg DropPkgs = 2;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableDropPkgs()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<DropPkg> getDropPkgs() {
      return dropPkgs;
    }

    /**
     * <code>repeated .DropPkg DropPkgs = 2;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<DropPkg> getMutableDropPkgs() {
      bitField0_ |= 0x00000004;
      return dropPkgs;
    }

    /**
     * <code>repeated .DropPkg DropPkgs = 2;</code>
     * @param value the dropPkgs to add
     * @return this
     */
    public MonsterDrop addDropPkgs(final DropPkg value) {
      bitField0_ |= 0x00000004;
      dropPkgs.add(value);
      return this;
    }

    /**
     * <code>repeated .DropPkg DropPkgs = 2;</code>
     * @param values the dropPkgs to add
     * @return this
     */
    public MonsterDrop addAllDropPkgs(final DropPkg... values) {
      bitField0_ |= 0x00000004;
      dropPkgs.addAll(values);
      return this;
    }

    @Override
    public MonsterDrop copyFrom(final MonsterDrop other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        monsterIndex = other.monsterIndex;
        nextPackage.copyFrom(other.nextPackage);
        dropPkgs.copyFrom(other.dropPkgs);
      }
      return this;
    }

    @Override
    public MonsterDrop mergeFrom(final MonsterDrop other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasMonsterIndex()) {
        setMonsterIndex(other.monsterIndex);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      if (other.hasDropPkgs()) {
        getMutableDropPkgs().addAll(other.dropPkgs);
      }
      return this;
    }

    @Override
    public MonsterDrop clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      monsterIndex = 0;
      nextPackage.clear();
      dropPkgs.clear();
      return this;
    }

    @Override
    public MonsterDrop clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      dropPkgs.clearQuick();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof MonsterDrop)) {
        return false;
      }
      MonsterDrop other = (MonsterDrop) o;
      return bitField0_ == other.bitField0_
        && (!hasMonsterIndex() || monsterIndex == other.monsterIndex)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage))
        && (!hasDropPkgs() || dropPkgs.equals(other.dropPkgs));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt32NoTag(monsterIndex);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        for (int i = 0; i < dropPkgs.length(); i++) {
          output.writeRawByte((byte) 18);
          output.writeMessageNoTag(dropPkgs.get(i));
        }
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(monsterIndex);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += (1 * dropPkgs.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(dropPkgs);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public MonsterDrop mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            // monsterIndex
            monsterIndex = input.readUInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 18) {
              break;
            }
          }
          case 18: {
            // dropPkgs
            tag = input.readRepeatedMessage(dropPkgs, tag);
            bitField0_ |= 0x00000004;
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeUInt32(FieldNames.monsterIndex, monsterIndex);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRepeatedMessage(FieldNames.dropPkgs, dropPkgs);
      }
      output.endObject();
    }

    @Override
    public MonsterDrop mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 696458552: {
            if (input.isAtField(FieldNames.monsterIndex)) {
              if (!input.trySkipNullValue()) {
                monsterIndex = input.readUInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -368017450: {
            if (input.isAtField(FieldNames.dropPkgs)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedMessage(dropPkgs);
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public MonsterDrop clone() {
      return new MonsterDrop().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static MonsterDrop parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new MonsterDrop(), data).checkInitialized();
    }

    public static MonsterDrop parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new MonsterDrop(), input).checkInitialized();
    }

    public static MonsterDrop parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new MonsterDrop(), input).checkInitialized();
    }

    /**
     * @return factory for creating MonsterDrop messages
     */
    public static MessageFactory<MonsterDrop> getFactory() {
      return MonsterDropFactory.INSTANCE;
    }

    private enum MonsterDropFactory implements MessageFactory<MonsterDrop> {
      INSTANCE;

      @Override
      public MonsterDrop create() {
        return MonsterDrop.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName monsterIndex = FieldName.forField("MonsterIndex");

      static final FieldName nextPackage = FieldName.forField("NextPackage");

      static final FieldName dropPkgs = FieldName.forField("DropPkgs");
    }
  }

  /**
   * Protobuf type {@code WorldClassUpdate}
   */
  public static final class WorldClassUpdate extends ProtoMessage<WorldClassUpdate> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional uint32 Cur = 1;</code>
     */
    private int cur;

    /**
     * <code>optional .ChangeInfo Change = 2;</code>
     */
    private final ChangeInfo change = ChangeInfo.newInstance();

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    private WorldClassUpdate() {
    }

    /**
     * @return a new empty instance of {@code WorldClassUpdate}
     */
    public static WorldClassUpdate newInstance() {
      return new WorldClassUpdate();
    }

    /**
     * <code>optional uint32 Cur = 1;</code>
     * @return whether the cur field is set
     */
    public boolean hasCur() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional uint32 Cur = 1;</code>
     * @return this
     */
    public WorldClassUpdate clearCur() {
      bitField0_ &= ~0x00000001;
      cur = 0;
      return this;
    }

    /**
     * <code>optional uint32 Cur = 1;</code>
     * @return the cur
     */
    public int getCur() {
      return cur;
    }

    /**
     * <code>optional uint32 Cur = 1;</code>
     * @param value the cur to set
     * @return this
     */
    public WorldClassUpdate setCur(final int value) {
      bitField0_ |= 0x00000001;
      cur = value;
      return this;
    }

    /**
     * <code>optional .ChangeInfo Change = 2;</code>
     * @return whether the change field is set
     */
    public boolean hasChange() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional .ChangeInfo Change = 2;</code>
     * @return this
     */
    public WorldClassUpdate clearChange() {
      bitField0_ &= ~0x00000002;
      change.clear();
      return this;
    }

    /**
     * <code>optional .ChangeInfo Change = 2;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableChange()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public ChangeInfo getChange() {
      return change;
    }

    /**
     * <code>optional .ChangeInfo Change = 2;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public ChangeInfo getMutableChange() {
      bitField0_ |= 0x00000002;
      return change;
    }

    /**
     * <code>optional .ChangeInfo Change = 2;</code>
     * @param value the change to set
     * @return this
     */
    public WorldClassUpdate setChange(final ChangeInfo value) {
      bitField0_ |= 0x00000002;
      change.copyFrom(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public WorldClassUpdate clearNextPackage() {
      bitField0_ &= ~0x00000004;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000004;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public WorldClassUpdate addNextPackage(final byte value) {
      bitField0_ |= 0x00000004;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public WorldClassUpdate addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000004;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public WorldClassUpdate setNextPackage(final byte... values) {
      bitField0_ |= 0x00000004;
      nextPackage.copyFrom(values);
      return this;
    }

    @Override
    public WorldClassUpdate copyFrom(final WorldClassUpdate other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        cur = other.cur;
        change.copyFrom(other.change);
        nextPackage.copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public WorldClassUpdate mergeFrom(final WorldClassUpdate other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasCur()) {
        setCur(other.cur);
      }
      if (other.hasChange()) {
        getMutableChange().mergeFrom(other.change);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public WorldClassUpdate clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      cur = 0;
      change.clear();
      nextPackage.clear();
      return this;
    }

    @Override
    public WorldClassUpdate clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      change.clearQuick();
      nextPackage.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof WorldClassUpdate)) {
        return false;
      }
      WorldClassUpdate other = (WorldClassUpdate) o;
      return bitField0_ == other.bitField0_
        && (!hasCur() || cur == other.cur)
        && (!hasChange() || change.equals(other.change))
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt32NoTag(cur);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 18);
        output.writeMessageNoTag(change);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(cur);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeMessageSizeNoTag(change);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public WorldClassUpdate mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            // cur
            cur = input.readUInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 18) {
              break;
            }
          }
          case 18: {
            // change
            input.readMessage(change);
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeUInt32(FieldNames.cur, cur);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeMessage(FieldNames.change, change);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      output.endObject();
    }

    @Override
    public WorldClassUpdate mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 68128: {
            if (input.isAtField(FieldNames.cur)) {
              if (!input.trySkipNullValue()) {
                cur = input.readUInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 2017198032: {
            if (input.isAtField(FieldNames.change)) {
              if (!input.trySkipNullValue()) {
                input.readMessage(change);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public WorldClassUpdate clone() {
      return new WorldClassUpdate().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static WorldClassUpdate parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new WorldClassUpdate(), data).checkInitialized();
    }

    public static WorldClassUpdate parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new WorldClassUpdate(), input).checkInitialized();
    }

    public static WorldClassUpdate parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new WorldClassUpdate(), input).checkInitialized();
    }

    /**
     * @return factory for creating WorldClassUpdate messages
     */
    public static MessageFactory<WorldClassUpdate> getFactory() {
      return WorldClassUpdateFactory.INSTANCE;
    }

    private enum WorldClassUpdateFactory implements MessageFactory<WorldClassUpdate> {
      INSTANCE;

      @Override
      public WorldClassUpdate create() {
        return WorldClassUpdate.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName cur = FieldName.forField("Cur");

      static final FieldName change = FieldName.forField("Change");

      static final FieldName nextPackage = FieldName.forField("NextPackage");
    }
  }

  /**
   * Protobuf type {@code ItemInfo}
   */
  public static final class ItemInfo extends ProtoMessage<ItemInfo> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional uint64 Id = 1;</code>
     */
    private long id;

    /**
     * <code>optional uint32 Tid = 2;</code>
     */
    private int tid;

    /**
     * <code>optional uint32 Qty = 3;</code>
     */
    private int qty;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    private ItemInfo() {
    }

    /**
     * @return a new empty instance of {@code ItemInfo}
     */
    public static ItemInfo newInstance() {
      return new ItemInfo();
    }

    /**
     * <code>optional uint64 Id = 1;</code>
     * @return whether the id field is set
     */
    public boolean hasId() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional uint64 Id = 1;</code>
     * @return this
     */
    public ItemInfo clearId() {
      bitField0_ &= ~0x00000001;
      id = 0L;
      return this;
    }

    /**
     * <code>optional uint64 Id = 1;</code>
     * @return the id
     */
    public long getId() {
      return id;
    }

    /**
     * <code>optional uint64 Id = 1;</code>
     * @param value the id to set
     * @return this
     */
    public ItemInfo setId(final long value) {
      bitField0_ |= 0x00000001;
      id = value;
      return this;
    }

    /**
     * <code>optional uint32 Tid = 2;</code>
     * @return whether the tid field is set
     */
    public boolean hasTid() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional uint32 Tid = 2;</code>
     * @return this
     */
    public ItemInfo clearTid() {
      bitField0_ &= ~0x00000002;
      tid = 0;
      return this;
    }

    /**
     * <code>optional uint32 Tid = 2;</code>
     * @return the tid
     */
    public int getTid() {
      return tid;
    }

    /**
     * <code>optional uint32 Tid = 2;</code>
     * @param value the tid to set
     * @return this
     */
    public ItemInfo setTid(final int value) {
      bitField0_ |= 0x00000002;
      tid = value;
      return this;
    }

    /**
     * <code>optional uint32 Qty = 3;</code>
     * @return whether the qty field is set
     */
    public boolean hasQty() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional uint32 Qty = 3;</code>
     * @return this
     */
    public ItemInfo clearQty() {
      bitField0_ &= ~0x00000004;
      qty = 0;
      return this;
    }

    /**
     * <code>optional uint32 Qty = 3;</code>
     * @return the qty
     */
    public int getQty() {
      return qty;
    }

    /**
     * <code>optional uint32 Qty = 3;</code>
     * @param value the qty to set
     * @return this
     */
    public ItemInfo setQty(final int value) {
      bitField0_ |= 0x00000004;
      qty = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000008) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public ItemInfo clearNextPackage() {
      bitField0_ &= ~0x00000008;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000008;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public ItemInfo addNextPackage(final byte value) {
      bitField0_ |= 0x00000008;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public ItemInfo addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000008;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public ItemInfo setNextPackage(final byte... values) {
      bitField0_ |= 0x00000008;
      nextPackage.copyFrom(values);
      return this;
    }

    @Override
    public ItemInfo copyFrom(final ItemInfo other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        id = other.id;
        tid = other.tid;
        qty = other.qty;
        nextPackage.copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public ItemInfo mergeFrom(final ItemInfo other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasId()) {
        setId(other.id);
      }
      if (other.hasTid()) {
        setTid(other.tid);
      }
      if (other.hasQty()) {
        setQty(other.qty);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public ItemInfo clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      id = 0L;
      tid = 0;
      qty = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public ItemInfo clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof ItemInfo)) {
        return false;
      }
      ItemInfo other = (ItemInfo) o;
      return bitField0_ == other.bitField0_
        && (!hasId() || id == other.id)
        && (!hasTid() || tid == other.tid)
        && (!hasQty() || qty == other.qty)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt64NoTag(id);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 16);
        output.writeUInt32NoTag(tid);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawByte((byte) 24);
        output.writeUInt32NoTag(qty);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeUInt64SizeNoTag(id);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(tid);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(qty);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public ItemInfo mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            // id
            id = input.readUInt64();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 16) {
              break;
            }
          }
          case 16: {
            // tid
            tid = input.readUInt32();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 24) {
              break;
            }
          }
          case 24: {
            // qty
            qty = input.readUInt32();
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000008;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeUInt64(FieldNames.id, id);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeUInt32(FieldNames.tid, tid);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeUInt32(FieldNames.qty, qty);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      output.endObject();
    }

    @Override
    public ItemInfo mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 2363: {
            if (input.isAtField(FieldNames.id)) {
              if (!input.trySkipNullValue()) {
                id = input.readUInt64();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 84079: {
            if (input.isAtField(FieldNames.tid)) {
              if (!input.trySkipNullValue()) {
                tid = input.readUInt32();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 81558: {
            if (input.isAtField(FieldNames.qty)) {
              if (!input.trySkipNullValue()) {
                qty = input.readUInt32();
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000008;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public ItemInfo clone() {
      return new ItemInfo().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static ItemInfo parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new ItemInfo(), data).checkInitialized();
    }

    public static ItemInfo parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new ItemInfo(), input).checkInitialized();
    }

    public static ItemInfo parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new ItemInfo(), input).checkInitialized();
    }

    /**
     * @return factory for creating ItemInfo messages
     */
    public static MessageFactory<ItemInfo> getFactory() {
      return ItemInfoFactory.INSTANCE;
    }

    private enum ItemInfoFactory implements MessageFactory<ItemInfo> {
      INSTANCE;

      @Override
      public ItemInfo create() {
        return ItemInfo.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName id = FieldName.forField("Id");

      static final FieldName tid = FieldName.forField("Tid");

      static final FieldName qty = FieldName.forField("Qty");

      static final FieldName nextPackage = FieldName.forField("NextPackage");
    }
  }

  /**
   * Protobuf type {@code RegionBossLevel}
   */
  public static final class RegionBossLevel extends ProtoMessage<RegionBossLevel> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional uint64 BuildId = 5;</code>
     */
    private long buildId;

    /**
     * <code>optional uint32 Id = 1;</code>
     */
    private int id;

    /**
     * <code>optional uint32 Star = 2;</code>
     */
    private int star;

    /**
     * <code>optional bool First = 3;</code>
     */
    private boolean first;

    /**
     * <code>optional bool ThreeStar = 4;</code>
     */
    private boolean threeStar;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    private RegionBossLevel() {
    }

    /**
     * @return a new empty instance of {@code RegionBossLevel}
     */
    public static RegionBossLevel newInstance() {
      return new RegionBossLevel();
    }

    /**
     * <code>optional uint64 BuildId = 5;</code>
     * @return whether the buildId field is set
     */
    public boolean hasBuildId() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional uint64 BuildId = 5;</code>
     * @return this
     */
    public RegionBossLevel clearBuildId() {
      bitField0_ &= ~0x00000001;
      buildId = 0L;
      return this;
    }

    /**
     * <code>optional uint64 BuildId = 5;</code>
     * @return the buildId
     */
    public long getBuildId() {
      return buildId;
    }

    /**
     * <code>optional uint64 BuildId = 5;</code>
     * @param value the buildId to set
     * @return this
     */
    public RegionBossLevel setBuildId(final long value) {
      bitField0_ |= 0x00000001;
      buildId = value;
      return this;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @return whether the id field is set
     */
    public boolean hasId() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @return this
     */
    public RegionBossLevel clearId() {
      bitField0_ &= ~0x00000002;
      id = 0;
      return this;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @return the id
     */
    public int getId() {
      return id;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @param value the id to set
     * @return this
     */
    public RegionBossLevel setId(final int value) {
      bitField0_ |= 0x00000002;
      id = value;
      return this;
    }

    /**
     * <code>optional uint32 Star = 2;</code>
     * @return whether the star field is set
     */
    public boolean hasStar() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional uint32 Star = 2;</code>
     * @return this
     */
    public RegionBossLevel clearStar() {
      bitField0_ &= ~0x00000004;
      star = 0;
      return this;
    }

    /**
     * <code>optional uint32 Star = 2;</code>
     * @return the star
     */
    public int getStar() {
      return star;
    }

    /**
     * <code>optional uint32 Star = 2;</code>
     * @param value the star to set
     * @return this
     */
    public RegionBossLevel setStar(final int value) {
      bitField0_ |= 0x00000004;
      star = value;
      return this;
    }

    /**
     * <code>optional bool First = 3;</code>
     * @return whether the first field is set
     */
    public boolean hasFirst() {
      return (bitField0_ & 0x00000008) != 0;
    }

    /**
     * <code>optional bool First = 3;</code>
     * @return this
     */
    public RegionBossLevel clearFirst() {
      bitField0_ &= ~0x00000008;
      first = false;
      return this;
    }

    /**
     * <code>optional bool First = 3;</code>
     * @return the first
     */
    public boolean getFirst() {
      return first;
    }

    /**
     * <code>optional bool First = 3;</code>
     * @param value the first to set
     * @return this
     */
    public RegionBossLevel setFirst(final boolean value) {
      bitField0_ |= 0x00000008;
      first = value;
      return this;
    }

    /**
     * <code>optional bool ThreeStar = 4;</code>
     * @return whether the threeStar field is set
     */
    public boolean hasThreeStar() {
      return (bitField0_ & 0x00000010) != 0;
    }

    /**
     * <code>optional bool ThreeStar = 4;</code>
     * @return this
     */
    public RegionBossLevel clearThreeStar() {
      bitField0_ &= ~0x00000010;
      threeStar = false;
      return this;
    }

    /**
     * <code>optional bool ThreeStar = 4;</code>
     * @return the threeStar
     */
    public boolean getThreeStar() {
      return threeStar;
    }

    /**
     * <code>optional bool ThreeStar = 4;</code>
     * @param value the threeStar to set
     * @return this
     */
    public RegionBossLevel setThreeStar(final boolean value) {
      bitField0_ |= 0x00000010;
      threeStar = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000020) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public RegionBossLevel clearNextPackage() {
      bitField0_ &= ~0x00000020;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000020;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public RegionBossLevel addNextPackage(final byte value) {
      bitField0_ |= 0x00000020;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public RegionBossLevel addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000020;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public RegionBossLevel setNextPackage(final byte... values) {
      bitField0_ |= 0x00000020;
      nextPackage.copyFrom(values);
      return this;
    }

    @Override
    public RegionBossLevel copyFrom(final RegionBossLevel other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        buildId = other.buildId;
        id = other.id;
        star = other.star;
        first = other.first;
        threeStar = other.threeStar;
        nextPackage.copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public RegionBossLevel mergeFrom(final RegionBossLevel other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasBuildId()) {
        setBuildId(other.buildId);
      }
      if (other.hasId()) {
        setId(other.id);
      }
      if (other.hasStar()) {
        setStar(other.star);
      }
      if (other.hasFirst()) {
        setFirst(other.first);
      }
      if (other.hasThreeStar()) {
        setThreeStar(other.threeStar);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public RegionBossLevel clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      buildId = 0L;
      id = 0;
      star = 0;
      first = false;
      threeStar = false;
      nextPackage.clear();
      return this;
    }

    @Override
    public RegionBossLevel clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof RegionBossLevel)) {
        return false;
      }
      RegionBossLevel other = (RegionBossLevel) o;
      return bitField0_ == other.bitField0_
        && (!hasBuildId() || buildId == other.buildId)
        && (!hasId() || id == other.id)
        && (!hasStar() || star == other.star)
        && (!hasFirst() || first == other.first)
        && (!hasThreeStar() || threeStar == other.threeStar)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 40);
        output.writeUInt64NoTag(buildId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt32NoTag(id);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawByte((byte) 16);
        output.writeUInt32NoTag(star);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeRawByte((byte) 24);
        output.writeBoolNoTag(first);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        output.writeRawByte((byte) 32);
        output.writeBoolNoTag(threeStar);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeUInt64SizeNoTag(buildId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(id);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(star);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        size += 2;
      }
      if ((bitField0_ & 0x00000010) != 0) {
        size += 2;
      }
      if ((bitField0_ & 0x00000020) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public RegionBossLevel mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 40: {
            // buildId
            buildId = input.readUInt64();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 8) {
              break;
            }
          }
          case 8: {
            // id
            id = input.readUInt32();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 16) {
              break;
            }
          }
          case 16: {
            // star
            star = input.readUInt32();
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 24) {
              break;
            }
          }
          case 24: {
            // first
            first = input.readBool();
            bitField0_ |= 0x00000008;
            tag = input.readTag();
            if (tag != 32) {
              break;
            }
          }
          case 32: {
            // threeStar
            threeStar = input.readBool();
            bitField0_ |= 0x00000010;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000020;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeUInt64(FieldNames.buildId, buildId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeUInt32(FieldNames.id, id);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeUInt32(FieldNames.star, star);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeBool(FieldNames.first, first);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        output.writeBool(FieldNames.threeStar, threeStar);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      output.endObject();
    }

    @Override
    public RegionBossLevel mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 1895597065: {
            if (input.isAtField(FieldNames.buildId)) {
              if (!input.trySkipNullValue()) {
                buildId = input.readUInt64();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 2363: {
            if (input.isAtField(FieldNames.id)) {
              if (!input.trySkipNullValue()) {
                id = input.readUInt32();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 2587250: {
            if (input.isAtField(FieldNames.star)) {
              if (!input.trySkipNullValue()) {
                star = input.readUInt32();
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 67887760: {
            if (input.isAtField(FieldNames.first)) {
              if (!input.trySkipNullValue()) {
                first = input.readBool();
                bitField0_ |= 0x00000008;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 444940528: {
            if (input.isAtField(FieldNames.threeStar)) {
              if (!input.trySkipNullValue()) {
                threeStar = input.readBool();
                bitField0_ |= 0x00000010;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000020;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public RegionBossLevel clone() {
      return new RegionBossLevel().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static RegionBossLevel parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new RegionBossLevel(), data).checkInitialized();
    }

    public static RegionBossLevel parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new RegionBossLevel(), input).checkInitialized();
    }

    public static RegionBossLevel parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new RegionBossLevel(), input).checkInitialized();
    }

    /**
     * @return factory for creating RegionBossLevel messages
     */
    public static MessageFactory<RegionBossLevel> getFactory() {
      return RegionBossLevelFactory.INSTANCE;
    }

    private enum RegionBossLevelFactory implements MessageFactory<RegionBossLevel> {
      INSTANCE;

      @Override
      public RegionBossLevel create() {
        return RegionBossLevel.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName buildId = FieldName.forField("BuildId");

      static final FieldName id = FieldName.forField("Id");

      static final FieldName star = FieldName.forField("Star");

      static final FieldName first = FieldName.forField("First");

      static final FieldName threeStar = FieldName.forField("ThreeStar");

      static final FieldName nextPackage = FieldName.forField("NextPackage");
    }
  }

  /**
   * Protobuf type {@code Friend}
   */
  public static final class Friend extends ProtoMessage<Friend> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional int64 LastLoginTime = 5;</code>
     */
    private long lastLoginTime;

    /**
     * <code>optional uint64 Id = 1;</code>
     */
    private long id;

    /**
     * <code>optional uint32 Hashtag = 3;</code>
     */
    private int hashtag;

    /**
     * <code>optional uint32 HeadIcon = 4;</code>
     */
    private int headIcon;

    /**
     * <code>optional uint32 WorldClass = 6;</code>
     */
    private int worldClass;

    /**
     * <code>optional uint32 TitlePrefix = 7;</code>
     */
    private int titlePrefix;

    /**
     * <code>optional uint32 TitleSuffix = 8;</code>
     */
    private int titleSuffix;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    /**
     * <code>optional string NickName = 2;</code>
     */
    private final Utf8String nickName = Utf8String.newEmptyInstance();

    /**
     * <code>optional string Signature = 9;</code>
     */
    private final Utf8String signature = Utf8String.newEmptyInstance();

    /**
     * <code>repeated .CharShow CharShows = 10;</code>
     */
    private final RepeatedMessage<CharShow> charShows = RepeatedMessage.newEmptyInstance(CharShow.getFactory());

    /**
     * <code>repeated .HonorInfo Honors = 15;</code>
     */
    private final RepeatedMessage<HonorInfo> honors = RepeatedMessage.newEmptyInstance(HonorInfo.getFactory());

    private Friend() {
    }

    /**
     * @return a new empty instance of {@code Friend}
     */
    public static Friend newInstance() {
      return new Friend();
    }

    /**
     * <code>optional int64 LastLoginTime = 5;</code>
     * @return whether the lastLoginTime field is set
     */
    public boolean hasLastLoginTime() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional int64 LastLoginTime = 5;</code>
     * @return this
     */
    public Friend clearLastLoginTime() {
      bitField0_ &= ~0x00000001;
      lastLoginTime = 0L;
      return this;
    }

    /**
     * <code>optional int64 LastLoginTime = 5;</code>
     * @return the lastLoginTime
     */
    public long getLastLoginTime() {
      return lastLoginTime;
    }

    /**
     * <code>optional int64 LastLoginTime = 5;</code>
     * @param value the lastLoginTime to set
     * @return this
     */
    public Friend setLastLoginTime(final long value) {
      bitField0_ |= 0x00000001;
      lastLoginTime = value;
      return this;
    }

    /**
     * <code>optional uint64 Id = 1;</code>
     * @return whether the id field is set
     */
    public boolean hasId() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional uint64 Id = 1;</code>
     * @return this
     */
    public Friend clearId() {
      bitField0_ &= ~0x00000002;
      id = 0L;
      return this;
    }

    /**
     * <code>optional uint64 Id = 1;</code>
     * @return the id
     */
    public long getId() {
      return id;
    }

    /**
     * <code>optional uint64 Id = 1;</code>
     * @param value the id to set
     * @return this
     */
    public Friend setId(final long value) {
      bitField0_ |= 0x00000002;
      id = value;
      return this;
    }

    /**
     * <code>optional uint32 Hashtag = 3;</code>
     * @return whether the hashtag field is set
     */
    public boolean hasHashtag() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional uint32 Hashtag = 3;</code>
     * @return this
     */
    public Friend clearHashtag() {
      bitField0_ &= ~0x00000004;
      hashtag = 0;
      return this;
    }

    /**
     * <code>optional uint32 Hashtag = 3;</code>
     * @return the hashtag
     */
    public int getHashtag() {
      return hashtag;
    }

    /**
     * <code>optional uint32 Hashtag = 3;</code>
     * @param value the hashtag to set
     * @return this
     */
    public Friend setHashtag(final int value) {
      bitField0_ |= 0x00000004;
      hashtag = value;
      return this;
    }

    /**
     * <code>optional uint32 HeadIcon = 4;</code>
     * @return whether the headIcon field is set
     */
    public boolean hasHeadIcon() {
      return (bitField0_ & 0x00000008) != 0;
    }

    /**
     * <code>optional uint32 HeadIcon = 4;</code>
     * @return this
     */
    public Friend clearHeadIcon() {
      bitField0_ &= ~0x00000008;
      headIcon = 0;
      return this;
    }

    /**
     * <code>optional uint32 HeadIcon = 4;</code>
     * @return the headIcon
     */
    public int getHeadIcon() {
      return headIcon;
    }

    /**
     * <code>optional uint32 HeadIcon = 4;</code>
     * @param value the headIcon to set
     * @return this
     */
    public Friend setHeadIcon(final int value) {
      bitField0_ |= 0x00000008;
      headIcon = value;
      return this;
    }

    /**
     * <code>optional uint32 WorldClass = 6;</code>
     * @return whether the worldClass field is set
     */
    public boolean hasWorldClass() {
      return (bitField0_ & 0x00000010) != 0;
    }

    /**
     * <code>optional uint32 WorldClass = 6;</code>
     * @return this
     */
    public Friend clearWorldClass() {
      bitField0_ &= ~0x00000010;
      worldClass = 0;
      return this;
    }

    /**
     * <code>optional uint32 WorldClass = 6;</code>
     * @return the worldClass
     */
    public int getWorldClass() {
      return worldClass;
    }

    /**
     * <code>optional uint32 WorldClass = 6;</code>
     * @param value the worldClass to set
     * @return this
     */
    public Friend setWorldClass(final int value) {
      bitField0_ |= 0x00000010;
      worldClass = value;
      return this;
    }

    /**
     * <code>optional uint32 TitlePrefix = 7;</code>
     * @return whether the titlePrefix field is set
     */
    public boolean hasTitlePrefix() {
      return (bitField0_ & 0x00000020) != 0;
    }

    /**
     * <code>optional uint32 TitlePrefix = 7;</code>
     * @return this
     */
    public Friend clearTitlePrefix() {
      bitField0_ &= ~0x00000020;
      titlePrefix = 0;
      return this;
    }

    /**
     * <code>optional uint32 TitlePrefix = 7;</code>
     * @return the titlePrefix
     */
    public int getTitlePrefix() {
      return titlePrefix;
    }

    /**
     * <code>optional uint32 TitlePrefix = 7;</code>
     * @param value the titlePrefix to set
     * @return this
     */
    public Friend setTitlePrefix(final int value) {
      bitField0_ |= 0x00000020;
      titlePrefix = value;
      return this;
    }

    /**
     * <code>optional uint32 TitleSuffix = 8;</code>
     * @return whether the titleSuffix field is set
     */
    public boolean hasTitleSuffix() {
      return (bitField0_ & 0x00000040) != 0;
    }

    /**
     * <code>optional uint32 TitleSuffix = 8;</code>
     * @return this
     */
    public Friend clearTitleSuffix() {
      bitField0_ &= ~0x00000040;
      titleSuffix = 0;
      return this;
    }

    /**
     * <code>optional uint32 TitleSuffix = 8;</code>
     * @return the titleSuffix
     */
    public int getTitleSuffix() {
      return titleSuffix;
    }

    /**
     * <code>optional uint32 TitleSuffix = 8;</code>
     * @param value the titleSuffix to set
     * @return this
     */
    public Friend setTitleSuffix(final int value) {
      bitField0_ |= 0x00000040;
      titleSuffix = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000080) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public Friend clearNextPackage() {
      bitField0_ &= ~0x00000080;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000080;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public Friend addNextPackage(final byte value) {
      bitField0_ |= 0x00000080;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public Friend addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000080;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public Friend setNextPackage(final byte... values) {
      bitField0_ |= 0x00000080;
      nextPackage.copyFrom(values);
      return this;
    }

    /**
     * <code>optional string NickName = 2;</code>
     * @return whether the nickName field is set
     */
    public boolean hasNickName() {
      return (bitField0_ & 0x00000100) != 0;
    }

    /**
     * <code>optional string NickName = 2;</code>
     * @return this
     */
    public Friend clearNickName() {
      bitField0_ &= ~0x00000100;
      nickName.clear();
      return this;
    }

    /**
     * <code>optional string NickName = 2;</code>
     * @return the nickName
     */
    public java.lang.String getNickName() {
      return nickName.getString();
    }

    /**
     * <code>optional string NickName = 2;</code>
     * @return internal {@code Utf8String} representation of nickName for reading
     */
    public Utf8String getNickNameBytes() {
      return this.nickName;
    }

    /**
     * <code>optional string NickName = 2;</code>
     * @return internal {@code Utf8String} representation of nickName for modifications
     */
    public Utf8String getMutableNickNameBytes() {
      bitField0_ |= 0x00000100;
      return this.nickName;
    }

    /**
     * <code>optional string NickName = 2;</code>
     * @param value the nickName to set
     * @return this
     */
    public Friend setNickName(final CharSequence value) {
      bitField0_ |= 0x00000100;
      nickName.copyFrom(value);
      return this;
    }

    /**
     * <code>optional string NickName = 2;</code>
     * @param value the nickName to set
     * @return this
     */
    public Friend setNickName(final Utf8String value) {
      bitField0_ |= 0x00000100;
      nickName.copyFrom(value);
      return this;
    }

    /**
     * <code>optional string Signature = 9;</code>
     * @return whether the signature field is set
     */
    public boolean hasSignature() {
      return (bitField0_ & 0x00000200) != 0;
    }

    /**
     * <code>optional string Signature = 9;</code>
     * @return this
     */
    public Friend clearSignature() {
      bitField0_ &= ~0x00000200;
      signature.clear();
      return this;
    }

    /**
     * <code>optional string Signature = 9;</code>
     * @return the signature
     */
    public java.lang.String getSignature() {
      return signature.getString();
    }

    /**
     * <code>optional string Signature = 9;</code>
     * @return internal {@code Utf8String} representation of signature for reading
     */
    public Utf8String getSignatureBytes() {
      return this.signature;
    }

    /**
     * <code>optional string Signature = 9;</code>
     * @return internal {@code Utf8String} representation of signature for modifications
     */
    public Utf8String getMutableSignatureBytes() {
      bitField0_ |= 0x00000200;
      return this.signature;
    }

    /**
     * <code>optional string Signature = 9;</code>
     * @param value the signature to set
     * @return this
     */
    public Friend setSignature(final CharSequence value) {
      bitField0_ |= 0x00000200;
      signature.copyFrom(value);
      return this;
    }

    /**
     * <code>optional string Signature = 9;</code>
     * @param value the signature to set
     * @return this
     */
    public Friend setSignature(final Utf8String value) {
      bitField0_ |= 0x00000200;
      signature.copyFrom(value);
      return this;
    }

    /**
     * <code>repeated .CharShow CharShows = 10;</code>
     * @return whether the charShows field is set
     */
    public boolean hasCharShows() {
      return (bitField0_ & 0x00000400) != 0;
    }

    /**
     * <code>repeated .CharShow CharShows = 10;</code>
     * @return this
     */
    public Friend clearCharShows() {
      bitField0_ &= ~0x00000400;
      charShows.clear();
      return this;
    }

    /**
     * <code>repeated .CharShow CharShows = 10;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableCharShows()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<CharShow> getCharShows() {
      return charShows;
    }

    /**
     * <code>repeated .CharShow CharShows = 10;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<CharShow> getMutableCharShows() {
      bitField0_ |= 0x00000400;
      return charShows;
    }

    /**
     * <code>repeated .CharShow CharShows = 10;</code>
     * @param value the charShows to add
     * @return this
     */
    public Friend addCharShows(final CharShow value) {
      bitField0_ |= 0x00000400;
      charShows.add(value);
      return this;
    }

    /**
     * <code>repeated .CharShow CharShows = 10;</code>
     * @param values the charShows to add
     * @return this
     */
    public Friend addAllCharShows(final CharShow... values) {
      bitField0_ |= 0x00000400;
      charShows.addAll(values);
      return this;
    }

    /**
     * <code>repeated .HonorInfo Honors = 15;</code>
     * @return whether the honors field is set
     */
    public boolean hasHonors() {
      return (bitField0_ & 0x00000800) != 0;
    }

    /**
     * <code>repeated .HonorInfo Honors = 15;</code>
     * @return this
     */
    public Friend clearHonors() {
      bitField0_ &= ~0x00000800;
      honors.clear();
      return this;
    }

    /**
     * <code>repeated .HonorInfo Honors = 15;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableHonors()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<HonorInfo> getHonors() {
      return honors;
    }

    /**
     * <code>repeated .HonorInfo Honors = 15;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<HonorInfo> getMutableHonors() {
      bitField0_ |= 0x00000800;
      return honors;
    }

    /**
     * <code>repeated .HonorInfo Honors = 15;</code>
     * @param value the honors to add
     * @return this
     */
    public Friend addHonors(final HonorInfo value) {
      bitField0_ |= 0x00000800;
      honors.add(value);
      return this;
    }

    /**
     * <code>repeated .HonorInfo Honors = 15;</code>
     * @param values the honors to add
     * @return this
     */
    public Friend addAllHonors(final HonorInfo... values) {
      bitField0_ |= 0x00000800;
      honors.addAll(values);
      return this;
    }

    @Override
    public Friend copyFrom(final Friend other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        lastLoginTime = other.lastLoginTime;
        id = other.id;
        hashtag = other.hashtag;
        headIcon = other.headIcon;
        worldClass = other.worldClass;
        titlePrefix = other.titlePrefix;
        titleSuffix = other.titleSuffix;
        nextPackage.copyFrom(other.nextPackage);
        nickName.copyFrom(other.nickName);
        signature.copyFrom(other.signature);
        charShows.copyFrom(other.charShows);
        honors.copyFrom(other.honors);
      }
      return this;
    }

    @Override
    public Friend mergeFrom(final Friend other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasLastLoginTime()) {
        setLastLoginTime(other.lastLoginTime);
      }
      if (other.hasId()) {
        setId(other.id);
      }
      if (other.hasHashtag()) {
        setHashtag(other.hashtag);
      }
      if (other.hasHeadIcon()) {
        setHeadIcon(other.headIcon);
      }
      if (other.hasWorldClass()) {
        setWorldClass(other.worldClass);
      }
      if (other.hasTitlePrefix()) {
        setTitlePrefix(other.titlePrefix);
      }
      if (other.hasTitleSuffix()) {
        setTitleSuffix(other.titleSuffix);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      if (other.hasNickName()) {
        getMutableNickNameBytes().copyFrom(other.nickName);
      }
      if (other.hasSignature()) {
        getMutableSignatureBytes().copyFrom(other.signature);
      }
      if (other.hasCharShows()) {
        getMutableCharShows().addAll(other.charShows);
      }
      if (other.hasHonors()) {
        getMutableHonors().addAll(other.honors);
      }
      return this;
    }

    @Override
    public Friend clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      lastLoginTime = 0L;
      id = 0L;
      hashtag = 0;
      headIcon = 0;
      worldClass = 0;
      titlePrefix = 0;
      titleSuffix = 0;
      nextPackage.clear();
      nickName.clear();
      signature.clear();
      charShows.clear();
      honors.clear();
      return this;
    }

    @Override
    public Friend clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      nickName.clear();
      signature.clear();
      charShows.clearQuick();
      honors.clearQuick();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof Friend)) {
        return false;
      }
      Friend other = (Friend) o;
      return bitField0_ == other.bitField0_
        && (!hasLastLoginTime() || lastLoginTime == other.lastLoginTime)
        && (!hasId() || id == other.id)
        && (!hasHashtag() || hashtag == other.hashtag)
        && (!hasHeadIcon() || headIcon == other.headIcon)
        && (!hasWorldClass() || worldClass == other.worldClass)
        && (!hasTitlePrefix() || titlePrefix == other.titlePrefix)
        && (!hasTitleSuffix() || titleSuffix == other.titleSuffix)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage))
        && (!hasNickName() || nickName.equals(other.nickName))
        && (!hasSignature() || signature.equals(other.signature))
        && (!hasCharShows() || charShows.equals(other.charShows))
        && (!hasHonors() || honors.equals(other.honors));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 40);
        output.writeInt64NoTag(lastLoginTime);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt64NoTag(id);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawByte((byte) 24);
        output.writeUInt32NoTag(hashtag);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeRawByte((byte) 32);
        output.writeUInt32NoTag(headIcon);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        output.writeRawByte((byte) 48);
        output.writeUInt32NoTag(worldClass);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        output.writeRawByte((byte) 56);
        output.writeUInt32NoTag(titlePrefix);
      }
      if ((bitField0_ & 0x00000040) != 0) {
        output.writeRawByte((byte) 64);
        output.writeUInt32NoTag(titleSuffix);
      }
      if ((bitField0_ & 0x00000080) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000100) != 0) {
        output.writeRawByte((byte) 18);
        output.writeStringNoTag(nickName);
      }
      if ((bitField0_ & 0x00000200) != 0) {
        output.writeRawByte((byte) 74);
        output.writeStringNoTag(signature);
      }
      if ((bitField0_ & 0x00000400) != 0) {
        for (int i = 0; i < charShows.length(); i++) {
          output.writeRawByte((byte) 82);
          output.writeMessageNoTag(charShows.get(i));
        }
      }
      if ((bitField0_ & 0x00000800) != 0) {
        for (int i = 0; i < honors.length(); i++) {
          output.writeRawByte((byte) 122);
          output.writeMessageNoTag(honors.get(i));
        }
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeInt64SizeNoTag(lastLoginTime);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeUInt64SizeNoTag(id);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(hashtag);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(headIcon);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(worldClass);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(titlePrefix);
      }
      if ((bitField0_ & 0x00000040) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(titleSuffix);
      }
      if ((bitField0_ & 0x00000080) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000100) != 0) {
        size += 1 + ProtoSink.computeStringSizeNoTag(nickName);
      }
      if ((bitField0_ & 0x00000200) != 0) {
        size += 1 + ProtoSink.computeStringSizeNoTag(signature);
      }
      if ((bitField0_ & 0x00000400) != 0) {
        size += (1 * charShows.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(charShows);
      }
      if ((bitField0_ & 0x00000800) != 0) {
        size += (1 * honors.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(honors);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public Friend mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 40: {
            // lastLoginTime
            lastLoginTime = input.readInt64();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 8) {
              break;
            }
          }
          case 8: {
            // id
            id = input.readUInt64();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 24) {
              break;
            }
          }
          case 24: {
            // hashtag
            hashtag = input.readUInt32();
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 32) {
              break;
            }
          }
          case 32: {
            // headIcon
            headIcon = input.readUInt32();
            bitField0_ |= 0x00000008;
            tag = input.readTag();
            if (tag != 48) {
              break;
            }
          }
          case 48: {
            // worldClass
            worldClass = input.readUInt32();
            bitField0_ |= 0x00000010;
            tag = input.readTag();
            if (tag != 56) {
              break;
            }
          }
          case 56: {
            // titlePrefix
            titlePrefix = input.readUInt32();
            bitField0_ |= 0x00000020;
            tag = input.readTag();
            if (tag != 64) {
              break;
            }
          }
          case 64: {
            // titleSuffix
            titleSuffix = input.readUInt32();
            bitField0_ |= 0x00000040;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000080;
            tag = input.readTag();
            if (tag != 18) {
              break;
            }
          }
          case 18: {
            // nickName
            input.readString(nickName);
            bitField0_ |= 0x00000100;
            tag = input.readTag();
            if (tag != 74) {
              break;
            }
          }
          case 74: {
            // signature
            input.readString(signature);
            bitField0_ |= 0x00000200;
            tag = input.readTag();
            if (tag != 82) {
              break;
            }
          }
          case 82: {
            // charShows
            tag = input.readRepeatedMessage(charShows, tag);
            bitField0_ |= 0x00000400;
            if (tag != 122) {
              break;
            }
          }
          case 122: {
            // honors
            tag = input.readRepeatedMessage(honors, tag);
            bitField0_ |= 0x00000800;
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeInt64(FieldNames.lastLoginTime, lastLoginTime);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeUInt64(FieldNames.id, id);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeUInt32(FieldNames.hashtag, hashtag);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeUInt32(FieldNames.headIcon, headIcon);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        output.writeUInt32(FieldNames.worldClass, worldClass);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        output.writeUInt32(FieldNames.titlePrefix, titlePrefix);
      }
      if ((bitField0_ & 0x00000040) != 0) {
        output.writeUInt32(FieldNames.titleSuffix, titleSuffix);
      }
      if ((bitField0_ & 0x00000080) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      if ((bitField0_ & 0x00000100) != 0) {
        output.writeString(FieldNames.nickName, nickName);
      }
      if ((bitField0_ & 0x00000200) != 0) {
        output.writeString(FieldNames.signature, signature);
      }
      if ((bitField0_ & 0x00000400) != 0) {
        output.writeRepeatedMessage(FieldNames.charShows, charShows);
      }
      if ((bitField0_ & 0x00000800) != 0) {
        output.writeRepeatedMessage(FieldNames.honors, honors);
      }
      output.endObject();
    }

    @Override
    public Friend mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 1580277696: {
            if (input.isAtField(FieldNames.lastLoginTime)) {
              if (!input.trySkipNullValue()) {
                lastLoginTime = input.readInt64();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 2363: {
            if (input.isAtField(FieldNames.id)) {
              if (!input.trySkipNullValue()) {
                id = input.readUInt64();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1932766292: {
            if (input.isAtField(FieldNames.hashtag)) {
              if (!input.trySkipNullValue()) {
                hashtag = input.readUInt32();
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1051463015: {
            if (input.isAtField(FieldNames.headIcon)) {
              if (!input.trySkipNullValue()) {
                headIcon = input.readUInt32();
                bitField0_ |= 0x00000008;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1869617882: {
            if (input.isAtField(FieldNames.worldClass)) {
              if (!input.trySkipNullValue()) {
                worldClass = input.readUInt32();
                bitField0_ |= 0x00000010;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 2096776938: {
            if (input.isAtField(FieldNames.titlePrefix)) {
              if (!input.trySkipNullValue()) {
                titlePrefix = input.readUInt32();
                bitField0_ |= 0x00000020;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2109502551: {
            if (input.isAtField(FieldNames.titleSuffix)) {
              if (!input.trySkipNullValue()) {
                titleSuffix = input.readUInt32();
                bitField0_ |= 0x00000040;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000080;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 134381742: {
            if (input.isAtField(FieldNames.nickName)) {
              if (!input.trySkipNullValue()) {
                input.readString(nickName);
                bitField0_ |= 0x00000100;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1217415016: {
            if (input.isAtField(FieldNames.signature)) {
              if (!input.trySkipNullValue()) {
                input.readString(signature);
                bitField0_ |= 0x00000200;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -739588288: {
            if (input.isAtField(FieldNames.charShows)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedMessage(charShows);
                bitField0_ |= 0x00000400;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2127770263: {
            if (input.isAtField(FieldNames.honors)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedMessage(honors);
                bitField0_ |= 0x00000800;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public Friend clone() {
      return new Friend().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static Friend parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new Friend(), data).checkInitialized();
    }

    public static Friend parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new Friend(), input).checkInitialized();
    }

    public static Friend parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new Friend(), input).checkInitialized();
    }

    /**
     * @return factory for creating Friend messages
     */
    public static MessageFactory<Friend> getFactory() {
      return FriendFactory.INSTANCE;
    }

    private enum FriendFactory implements MessageFactory<Friend> {
      INSTANCE;

      @Override
      public Friend create() {
        return Friend.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName lastLoginTime = FieldName.forField("LastLoginTime");

      static final FieldName id = FieldName.forField("Id");

      static final FieldName hashtag = FieldName.forField("Hashtag");

      static final FieldName headIcon = FieldName.forField("HeadIcon");

      static final FieldName worldClass = FieldName.forField("WorldClass");

      static final FieldName titlePrefix = FieldName.forField("TitlePrefix");

      static final FieldName titleSuffix = FieldName.forField("TitleSuffix");

      static final FieldName nextPackage = FieldName.forField("NextPackage");

      static final FieldName nickName = FieldName.forField("NickName");

      static final FieldName signature = FieldName.forField("Signature");

      static final FieldName charShows = FieldName.forField("CharShows");

      static final FieldName honors = FieldName.forField("Honors");
    }
  }

  /**
   * Protobuf type {@code CharShow}
   */
  public static final class CharShow extends ProtoMessage<CharShow> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional uint32 CharId = 1;</code>
     */
    private int charId;

    /**
     * <code>optional uint32 Level = 2;</code>
     */
    private int level;

    /**
     * <code>optional uint32 Skin = 3;</code>
     */
    private int skin;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    private CharShow() {
    }

    /**
     * @return a new empty instance of {@code CharShow}
     */
    public static CharShow newInstance() {
      return new CharShow();
    }

    /**
     * <code>optional uint32 CharId = 1;</code>
     * @return whether the charId field is set
     */
    public boolean hasCharId() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional uint32 CharId = 1;</code>
     * @return this
     */
    public CharShow clearCharId() {
      bitField0_ &= ~0x00000001;
      charId = 0;
      return this;
    }

    /**
     * <code>optional uint32 CharId = 1;</code>
     * @return the charId
     */
    public int getCharId() {
      return charId;
    }

    /**
     * <code>optional uint32 CharId = 1;</code>
     * @param value the charId to set
     * @return this
     */
    public CharShow setCharId(final int value) {
      bitField0_ |= 0x00000001;
      charId = value;
      return this;
    }

    /**
     * <code>optional uint32 Level = 2;</code>
     * @return whether the level field is set
     */
    public boolean hasLevel() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional uint32 Level = 2;</code>
     * @return this
     */
    public CharShow clearLevel() {
      bitField0_ &= ~0x00000002;
      level = 0;
      return this;
    }

    /**
     * <code>optional uint32 Level = 2;</code>
     * @return the level
     */
    public int getLevel() {
      return level;
    }

    /**
     * <code>optional uint32 Level = 2;</code>
     * @param value the level to set
     * @return this
     */
    public CharShow setLevel(final int value) {
      bitField0_ |= 0x00000002;
      level = value;
      return this;
    }

    /**
     * <code>optional uint32 Skin = 3;</code>
     * @return whether the skin field is set
     */
    public boolean hasSkin() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional uint32 Skin = 3;</code>
     * @return this
     */
    public CharShow clearSkin() {
      bitField0_ &= ~0x00000004;
      skin = 0;
      return this;
    }

    /**
     * <code>optional uint32 Skin = 3;</code>
     * @return the skin
     */
    public int getSkin() {
      return skin;
    }

    /**
     * <code>optional uint32 Skin = 3;</code>
     * @param value the skin to set
     * @return this
     */
    public CharShow setSkin(final int value) {
      bitField0_ |= 0x00000004;
      skin = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000008) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public CharShow clearNextPackage() {
      bitField0_ &= ~0x00000008;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000008;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public CharShow addNextPackage(final byte value) {
      bitField0_ |= 0x00000008;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public CharShow addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000008;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public CharShow setNextPackage(final byte... values) {
      bitField0_ |= 0x00000008;
      nextPackage.copyFrom(values);
      return this;
    }

    @Override
    public CharShow copyFrom(final CharShow other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        charId = other.charId;
        level = other.level;
        skin = other.skin;
        nextPackage.copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public CharShow mergeFrom(final CharShow other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasCharId()) {
        setCharId(other.charId);
      }
      if (other.hasLevel()) {
        setLevel(other.level);
      }
      if (other.hasSkin()) {
        setSkin(other.skin);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public CharShow clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      charId = 0;
      level = 0;
      skin = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public CharShow clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof CharShow)) {
        return false;
      }
      CharShow other = (CharShow) o;
      return bitField0_ == other.bitField0_
        && (!hasCharId() || charId == other.charId)
        && (!hasLevel() || level == other.level)
        && (!hasSkin() || skin == other.skin)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt32NoTag(charId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 16);
        output.writeUInt32NoTag(level);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawByte((byte) 24);
        output.writeUInt32NoTag(skin);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(charId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(level);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(skin);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public CharShow mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            // charId
            charId = input.readUInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 16) {
              break;
            }
          }
          case 16: {
            // level
            level = input.readUInt32();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 24) {
              break;
            }
          }
          case 24: {
            // skin
            skin = input.readUInt32();
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000008;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeUInt32(FieldNames.charId, charId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeUInt32(FieldNames.level, level);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeUInt32(FieldNames.skin, skin);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      output.endObject();
    }

    @Override
    public CharShow mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 2017200945: {
            if (input.isAtField(FieldNames.charId)) {
              if (!input.trySkipNullValue()) {
                charId = input.readUInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 73313124: {
            if (input.isAtField(FieldNames.level)) {
              if (!input.trySkipNullValue()) {
                level = input.readUInt32();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 2578845: {
            if (input.isAtField(FieldNames.skin)) {
              if (!input.trySkipNullValue()) {
                skin = input.readUInt32();
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000008;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public CharShow clone() {
      return new CharShow().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static CharShow parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new CharShow(), data).checkInitialized();
    }

    public static CharShow parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new CharShow(), input).checkInitialized();
    }

    public static CharShow parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new CharShow(), input).checkInitialized();
    }

    /**
     * @return factory for creating CharShow messages
     */
    public static MessageFactory<CharShow> getFactory() {
      return CharShowFactory.INSTANCE;
    }

    private enum CharShowFactory implements MessageFactory<CharShow> {
      INSTANCE;

      @Override
      public CharShow create() {
        return CharShow.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName charId = FieldName.forField("CharId");

      static final FieldName level = FieldName.forField("Level");

      static final FieldName skin = FieldName.forField("Skin");

      static final FieldName nextPackage = FieldName.forField("NextPackage");
    }
  }

  /**
   * Protobuf type {@code FriendDetail}
   */
  public static final class FriendDetail extends ProtoMessage<FriendDetail> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional uint32 GetEnergy = 4;</code>
     */
    private int getEnergy;

    /**
     * <code>optional bool Star = 2;</code>
     */
    private boolean star;

    /**
     * <code>optional bool SendEnergy = 3;</code>
     */
    private boolean sendEnergy;

    /**
     * <code>optional .Friend Base = 1;</code>
     */
    private final Friend base = Friend.newInstance();

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    private FriendDetail() {
    }

    /**
     * @return a new empty instance of {@code FriendDetail}
     */
    public static FriendDetail newInstance() {
      return new FriendDetail();
    }

    /**
     * <code>optional uint32 GetEnergy = 4;</code>
     * @return whether the getEnergy field is set
     */
    public boolean hasGetEnergy() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional uint32 GetEnergy = 4;</code>
     * @return this
     */
    public FriendDetail clearGetEnergy() {
      bitField0_ &= ~0x00000001;
      getEnergy = 0;
      return this;
    }

    /**
     * <code>optional uint32 GetEnergy = 4;</code>
     * @return the getEnergy
     */
    public int getGetEnergy() {
      return getEnergy;
    }

    /**
     * <code>optional uint32 GetEnergy = 4;</code>
     * @param value the getEnergy to set
     * @return this
     */
    public FriendDetail setGetEnergy(final int value) {
      bitField0_ |= 0x00000001;
      getEnergy = value;
      return this;
    }

    /**
     * <code>optional bool Star = 2;</code>
     * @return whether the star field is set
     */
    public boolean hasStar() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional bool Star = 2;</code>
     * @return this
     */
    public FriendDetail clearStar() {
      bitField0_ &= ~0x00000002;
      star = false;
      return this;
    }

    /**
     * <code>optional bool Star = 2;</code>
     * @return the star
     */
    public boolean getStar() {
      return star;
    }

    /**
     * <code>optional bool Star = 2;</code>
     * @param value the star to set
     * @return this
     */
    public FriendDetail setStar(final boolean value) {
      bitField0_ |= 0x00000002;
      star = value;
      return this;
    }

    /**
     * <code>optional bool SendEnergy = 3;</code>
     * @return whether the sendEnergy field is set
     */
    public boolean hasSendEnergy() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional bool SendEnergy = 3;</code>
     * @return this
     */
    public FriendDetail clearSendEnergy() {
      bitField0_ &= ~0x00000004;
      sendEnergy = false;
      return this;
    }

    /**
     * <code>optional bool SendEnergy = 3;</code>
     * @return the sendEnergy
     */
    public boolean getSendEnergy() {
      return sendEnergy;
    }

    /**
     * <code>optional bool SendEnergy = 3;</code>
     * @param value the sendEnergy to set
     * @return this
     */
    public FriendDetail setSendEnergy(final boolean value) {
      bitField0_ |= 0x00000004;
      sendEnergy = value;
      return this;
    }

    /**
     * <code>optional .Friend Base = 1;</code>
     * @return whether the base field is set
     */
    public boolean hasBase() {
      return (bitField0_ & 0x00000008) != 0;
    }

    /**
     * <code>optional .Friend Base = 1;</code>
     * @return this
     */
    public FriendDetail clearBase() {
      bitField0_ &= ~0x00000008;
      base.clear();
      return this;
    }

    /**
     * <code>optional .Friend Base = 1;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableBase()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public Friend getBase() {
      return base;
    }

    /**
     * <code>optional .Friend Base = 1;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public Friend getMutableBase() {
      bitField0_ |= 0x00000008;
      return base;
    }

    /**
     * <code>optional .Friend Base = 1;</code>
     * @param value the base to set
     * @return this
     */
    public FriendDetail setBase(final Friend value) {
      bitField0_ |= 0x00000008;
      base.copyFrom(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000010) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public FriendDetail clearNextPackage() {
      bitField0_ &= ~0x00000010;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000010;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public FriendDetail addNextPackage(final byte value) {
      bitField0_ |= 0x00000010;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public FriendDetail addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000010;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public FriendDetail setNextPackage(final byte... values) {
      bitField0_ |= 0x00000010;
      nextPackage.copyFrom(values);
      return this;
    }

    @Override
    public FriendDetail copyFrom(final FriendDetail other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        getEnergy = other.getEnergy;
        star = other.star;
        sendEnergy = other.sendEnergy;
        base.copyFrom(other.base);
        nextPackage.copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public FriendDetail mergeFrom(final FriendDetail other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasGetEnergy()) {
        setGetEnergy(other.getEnergy);
      }
      if (other.hasStar()) {
        setStar(other.star);
      }
      if (other.hasSendEnergy()) {
        setSendEnergy(other.sendEnergy);
      }
      if (other.hasBase()) {
        getMutableBase().mergeFrom(other.base);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public FriendDetail clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      getEnergy = 0;
      star = false;
      sendEnergy = false;
      base.clear();
      nextPackage.clear();
      return this;
    }

    @Override
    public FriendDetail clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      base.clearQuick();
      nextPackage.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof FriendDetail)) {
        return false;
      }
      FriendDetail other = (FriendDetail) o;
      return bitField0_ == other.bitField0_
        && (!hasGetEnergy() || getEnergy == other.getEnergy)
        && (!hasStar() || star == other.star)
        && (!hasSendEnergy() || sendEnergy == other.sendEnergy)
        && (!hasBase() || base.equals(other.base))
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 32);
        output.writeUInt32NoTag(getEnergy);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 16);
        output.writeBoolNoTag(star);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawByte((byte) 24);
        output.writeBoolNoTag(sendEnergy);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeRawByte((byte) 10);
        output.writeMessageNoTag(base);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(getEnergy);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 2;
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 2;
      }
      if ((bitField0_ & 0x00000008) != 0) {
        size += 1 + ProtoSink.computeMessageSizeNoTag(base);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public FriendDetail mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 32: {
            // getEnergy
            getEnergy = input.readUInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 16) {
              break;
            }
          }
          case 16: {
            // star
            star = input.readBool();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 24) {
              break;
            }
          }
          case 24: {
            // sendEnergy
            sendEnergy = input.readBool();
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 10) {
              break;
            }
          }
          case 10: {
            // base
            input.readMessage(base);
            bitField0_ |= 0x00000008;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000010;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeUInt32(FieldNames.getEnergy, getEnergy);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeBool(FieldNames.star, star);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeBool(FieldNames.sendEnergy, sendEnergy);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeMessage(FieldNames.base, base);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      output.endObject();
    }

    @Override
    public FriendDetail mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case -1893698210: {
            if (input.isAtField(FieldNames.getEnergy)) {
              if (!input.trySkipNullValue()) {
                getEnergy = input.readUInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 2587250: {
            if (input.isAtField(FieldNames.star)) {
              if (!input.trySkipNullValue()) {
                star = input.readBool();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 2071725136: {
            if (input.isAtField(FieldNames.sendEnergy)) {
              if (!input.trySkipNullValue()) {
                sendEnergy = input.readBool();
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 2063089: {
            if (input.isAtField(FieldNames.base)) {
              if (!input.trySkipNullValue()) {
                input.readMessage(base);
                bitField0_ |= 0x00000008;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000010;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public FriendDetail clone() {
      return new FriendDetail().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static FriendDetail parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new FriendDetail(), data).checkInitialized();
    }

    public static FriendDetail parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new FriendDetail(), input).checkInitialized();
    }

    public static FriendDetail parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new FriendDetail(), input).checkInitialized();
    }

    /**
     * @return factory for creating FriendDetail messages
     */
    public static MessageFactory<FriendDetail> getFactory() {
      return FriendDetailFactory.INSTANCE;
    }

    private enum FriendDetailFactory implements MessageFactory<FriendDetail> {
      INSTANCE;

      @Override
      public FriendDetail create() {
        return FriendDetail.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName getEnergy = FieldName.forField("GetEnergy");

      static final FieldName star = FieldName.forField("Star");

      static final FieldName sendEnergy = FieldName.forField("SendEnergy");

      static final FieldName base = FieldName.forField("Base");

      static final FieldName nextPackage = FieldName.forField("NextPackage");
    }
  }

  /**
   * Protobuf type {@code BoughtGoods}
   */
  public static final class BoughtGoods extends ProtoMessage<BoughtGoods> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional uint32 Id = 1;</code>
     */
    private int id;

    /**
     * <code>optional uint32 Number = 2;</code>
     */
    private int number;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    private BoughtGoods() {
    }

    /**
     * @return a new empty instance of {@code BoughtGoods}
     */
    public static BoughtGoods newInstance() {
      return new BoughtGoods();
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @return whether the id field is set
     */
    public boolean hasId() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @return this
     */
    public BoughtGoods clearId() {
      bitField0_ &= ~0x00000001;
      id = 0;
      return this;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @return the id
     */
    public int getId() {
      return id;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @param value the id to set
     * @return this
     */
    public BoughtGoods setId(final int value) {
      bitField0_ |= 0x00000001;
      id = value;
      return this;
    }

    /**
     * <code>optional uint32 Number = 2;</code>
     * @return whether the number field is set
     */
    public boolean hasNumber() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional uint32 Number = 2;</code>
     * @return this
     */
    public BoughtGoods clearNumber() {
      bitField0_ &= ~0x00000002;
      number = 0;
      return this;
    }

    /**
     * <code>optional uint32 Number = 2;</code>
     * @return the number
     */
    public int getNumber() {
      return number;
    }

    /**
     * <code>optional uint32 Number = 2;</code>
     * @param value the number to set
     * @return this
     */
    public BoughtGoods setNumber(final int value) {
      bitField0_ |= 0x00000002;
      number = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public BoughtGoods clearNextPackage() {
      bitField0_ &= ~0x00000004;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000004;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public BoughtGoods addNextPackage(final byte value) {
      bitField0_ |= 0x00000004;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public BoughtGoods addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000004;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public BoughtGoods setNextPackage(final byte... values) {
      bitField0_ |= 0x00000004;
      nextPackage.copyFrom(values);
      return this;
    }

    @Override
    public BoughtGoods copyFrom(final BoughtGoods other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        id = other.id;
        number = other.number;
        nextPackage.copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public BoughtGoods mergeFrom(final BoughtGoods other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasId()) {
        setId(other.id);
      }
      if (other.hasNumber()) {
        setNumber(other.number);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public BoughtGoods clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      id = 0;
      number = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public BoughtGoods clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof BoughtGoods)) {
        return false;
      }
      BoughtGoods other = (BoughtGoods) o;
      return bitField0_ == other.bitField0_
        && (!hasId() || id == other.id)
        && (!hasNumber() || number == other.number)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt32NoTag(id);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 16);
        output.writeUInt32NoTag(number);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(id);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(number);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public BoughtGoods mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            // id
            id = input.readUInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 16) {
              break;
            }
          }
          case 16: {
            // number
            number = input.readUInt32();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeUInt32(FieldNames.id, id);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeUInt32(FieldNames.number, number);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      output.endObject();
    }

    @Override
    public BoughtGoods mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 2363: {
            if (input.isAtField(FieldNames.id)) {
              if (!input.trySkipNullValue()) {
                id = input.readUInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1950496919: {
            if (input.isAtField(FieldNames.number)) {
              if (!input.trySkipNullValue()) {
                number = input.readUInt32();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public BoughtGoods clone() {
      return new BoughtGoods().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static BoughtGoods parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new BoughtGoods(), data).checkInitialized();
    }

    public static BoughtGoods parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new BoughtGoods(), input).checkInitialized();
    }

    public static BoughtGoods parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new BoughtGoods(), input).checkInitialized();
    }

    /**
     * @return factory for creating BoughtGoods messages
     */
    public static MessageFactory<BoughtGoods> getFactory() {
      return BoughtGoodsFactory.INSTANCE;
    }

    private enum BoughtGoodsFactory implements MessageFactory<BoughtGoods> {
      INSTANCE;

      @Override
      public BoughtGoods create() {
        return BoughtGoods.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName id = FieldName.forField("Id");

      static final FieldName number = FieldName.forField("Number");

      static final FieldName nextPackage = FieldName.forField("NextPackage");
    }
  }

  /**
   * Protobuf type {@code ResidentShop}
   */
  public static final class ResidentShop extends ProtoMessage<ResidentShop> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional int64 RefreshTime = 2;</code>
     */
    private long refreshTime;

    /**
     * <code>optional uint32 Id = 1;</code>
     */
    private int id;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    /**
     * <code>repeated .BoughtGoods Infos = 3;</code>
     */
    private final RepeatedMessage<BoughtGoods> infos = RepeatedMessage.newEmptyInstance(BoughtGoods.getFactory());

    private ResidentShop() {
    }

    /**
     * @return a new empty instance of {@code ResidentShop}
     */
    public static ResidentShop newInstance() {
      return new ResidentShop();
    }

    /**
     * <code>optional int64 RefreshTime = 2;</code>
     * @return whether the refreshTime field is set
     */
    public boolean hasRefreshTime() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional int64 RefreshTime = 2;</code>
     * @return this
     */
    public ResidentShop clearRefreshTime() {
      bitField0_ &= ~0x00000001;
      refreshTime = 0L;
      return this;
    }

    /**
     * <code>optional int64 RefreshTime = 2;</code>
     * @return the refreshTime
     */
    public long getRefreshTime() {
      return refreshTime;
    }

    /**
     * <code>optional int64 RefreshTime = 2;</code>
     * @param value the refreshTime to set
     * @return this
     */
    public ResidentShop setRefreshTime(final long value) {
      bitField0_ |= 0x00000001;
      refreshTime = value;
      return this;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @return whether the id field is set
     */
    public boolean hasId() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @return this
     */
    public ResidentShop clearId() {
      bitField0_ &= ~0x00000002;
      id = 0;
      return this;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @return the id
     */
    public int getId() {
      return id;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @param value the id to set
     * @return this
     */
    public ResidentShop setId(final int value) {
      bitField0_ |= 0x00000002;
      id = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public ResidentShop clearNextPackage() {
      bitField0_ &= ~0x00000004;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000004;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public ResidentShop addNextPackage(final byte value) {
      bitField0_ |= 0x00000004;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public ResidentShop addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000004;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public ResidentShop setNextPackage(final byte... values) {
      bitField0_ |= 0x00000004;
      nextPackage.copyFrom(values);
      return this;
    }

    /**
     * <code>repeated .BoughtGoods Infos = 3;</code>
     * @return whether the infos field is set
     */
    public boolean hasInfos() {
      return (bitField0_ & 0x00000008) != 0;
    }

    /**
     * <code>repeated .BoughtGoods Infos = 3;</code>
     * @return this
     */
    public ResidentShop clearInfos() {
      bitField0_ &= ~0x00000008;
      infos.clear();
      return this;
    }

    /**
     * <code>repeated .BoughtGoods Infos = 3;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableInfos()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<BoughtGoods> getInfos() {
      return infos;
    }

    /**
     * <code>repeated .BoughtGoods Infos = 3;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<BoughtGoods> getMutableInfos() {
      bitField0_ |= 0x00000008;
      return infos;
    }

    /**
     * <code>repeated .BoughtGoods Infos = 3;</code>
     * @param value the infos to add
     * @return this
     */
    public ResidentShop addInfos(final BoughtGoods value) {
      bitField0_ |= 0x00000008;
      infos.add(value);
      return this;
    }

    /**
     * <code>repeated .BoughtGoods Infos = 3;</code>
     * @param values the infos to add
     * @return this
     */
    public ResidentShop addAllInfos(final BoughtGoods... values) {
      bitField0_ |= 0x00000008;
      infos.addAll(values);
      return this;
    }

    @Override
    public ResidentShop copyFrom(final ResidentShop other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        refreshTime = other.refreshTime;
        id = other.id;
        nextPackage.copyFrom(other.nextPackage);
        infos.copyFrom(other.infos);
      }
      return this;
    }

    @Override
    public ResidentShop mergeFrom(final ResidentShop other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasRefreshTime()) {
        setRefreshTime(other.refreshTime);
      }
      if (other.hasId()) {
        setId(other.id);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      if (other.hasInfos()) {
        getMutableInfos().addAll(other.infos);
      }
      return this;
    }

    @Override
    public ResidentShop clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      refreshTime = 0L;
      id = 0;
      nextPackage.clear();
      infos.clear();
      return this;
    }

    @Override
    public ResidentShop clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      infos.clearQuick();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof ResidentShop)) {
        return false;
      }
      ResidentShop other = (ResidentShop) o;
      return bitField0_ == other.bitField0_
        && (!hasRefreshTime() || refreshTime == other.refreshTime)
        && (!hasId() || id == other.id)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage))
        && (!hasInfos() || infos.equals(other.infos));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 16);
        output.writeInt64NoTag(refreshTime);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt32NoTag(id);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        for (int i = 0; i < infos.length(); i++) {
          output.writeRawByte((byte) 26);
          output.writeMessageNoTag(infos.get(i));
        }
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeInt64SizeNoTag(refreshTime);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(id);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        size += (1 * infos.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(infos);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public ResidentShop mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 16: {
            // refreshTime
            refreshTime = input.readInt64();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 8) {
              break;
            }
          }
          case 8: {
            // id
            id = input.readUInt32();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 26) {
              break;
            }
          }
          case 26: {
            // infos
            tag = input.readRepeatedMessage(infos, tag);
            bitField0_ |= 0x00000008;
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeInt64(FieldNames.refreshTime, refreshTime);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeUInt32(FieldNames.id, id);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeRepeatedMessage(FieldNames.infos, infos);
      }
      output.endObject();
    }

    @Override
    public ResidentShop mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 280566824: {
            if (input.isAtField(FieldNames.refreshTime)) {
              if (!input.trySkipNullValue()) {
                refreshTime = input.readInt64();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 2363: {
            if (input.isAtField(FieldNames.id)) {
              if (!input.trySkipNullValue()) {
                id = input.readUInt32();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 70795621: {
            if (input.isAtField(FieldNames.infos)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedMessage(infos);
                bitField0_ |= 0x00000008;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public ResidentShop clone() {
      return new ResidentShop().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static ResidentShop parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new ResidentShop(), data).checkInitialized();
    }

    public static ResidentShop parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new ResidentShop(), input).checkInitialized();
    }

    public static ResidentShop parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new ResidentShop(), input).checkInitialized();
    }

    /**
     * @return factory for creating ResidentShop messages
     */
    public static MessageFactory<ResidentShop> getFactory() {
      return ResidentShopFactory.INSTANCE;
    }

    private enum ResidentShopFactory implements MessageFactory<ResidentShop> {
      INSTANCE;

      @Override
      public ResidentShop create() {
        return ResidentShop.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName refreshTime = FieldName.forField("RefreshTime");

      static final FieldName id = FieldName.forField("Id");

      static final FieldName nextPackage = FieldName.forField("NextPackage");

      static final FieldName infos = FieldName.forField("Infos");
    }
  }

  /**
   * Protobuf type {@code HandbookInfo}
   */
  public static final class HandbookInfo extends ProtoMessage<HandbookInfo> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional uint32 Type = 1;</code>
     */
    private int type;

    /**
     * <code>optional bytes Data = 2;</code>
     */
    private final RepeatedByte data = RepeatedByte.newEmptyInstance();

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    private HandbookInfo() {
    }

    /**
     * @return a new empty instance of {@code HandbookInfo}
     */
    public static HandbookInfo newInstance() {
      return new HandbookInfo();
    }

    /**
     * <code>optional uint32 Type = 1;</code>
     * @return whether the type field is set
     */
    public boolean hasType() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional uint32 Type = 1;</code>
     * @return this
     */
    public HandbookInfo clearType() {
      bitField0_ &= ~0x00000001;
      type = 0;
      return this;
    }

    /**
     * <code>optional uint32 Type = 1;</code>
     * @return the type
     */
    public int getType() {
      return type;
    }

    /**
     * <code>optional uint32 Type = 1;</code>
     * @param value the type to set
     * @return this
     */
    public HandbookInfo setType(final int value) {
      bitField0_ |= 0x00000001;
      type = value;
      return this;
    }

    /**
     * <code>optional bytes Data = 2;</code>
     * @return whether the data field is set
     */
    public boolean hasData() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional bytes Data = 2;</code>
     * @return this
     */
    public HandbookInfo clearData() {
      bitField0_ &= ~0x00000002;
      data.clear();
      return this;
    }

    /**
     * <code>optional bytes Data = 2;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableData()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getData() {
      return data;
    }

    /**
     * <code>optional bytes Data = 2;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableData() {
      bitField0_ |= 0x00000002;
      return data;
    }

    /**
     * <code>optional bytes Data = 2;</code>
     * @param value the data to add
     * @return this
     */
    public HandbookInfo addData(final byte value) {
      bitField0_ |= 0x00000002;
      data.add(value);
      return this;
    }

    /**
     * <code>optional bytes Data = 2;</code>
     * @param values the data to add
     * @return this
     */
    public HandbookInfo addAllData(final byte... values) {
      bitField0_ |= 0x00000002;
      data.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes Data = 2;</code>
     * @param values the data to set
     * @return this
     */
    public HandbookInfo setData(final byte... values) {
      bitField0_ |= 0x00000002;
      data.copyFrom(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public HandbookInfo clearNextPackage() {
      bitField0_ &= ~0x00000004;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000004;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public HandbookInfo addNextPackage(final byte value) {
      bitField0_ |= 0x00000004;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public HandbookInfo addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000004;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public HandbookInfo setNextPackage(final byte... values) {
      bitField0_ |= 0x00000004;
      nextPackage.copyFrom(values);
      return this;
    }

    @Override
    public HandbookInfo copyFrom(final HandbookInfo other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        type = other.type;
        data.copyFrom(other.data);
        nextPackage.copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public HandbookInfo mergeFrom(final HandbookInfo other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasType()) {
        setType(other.type);
      }
      if (other.hasData()) {
        getMutableData().copyFrom(other.data);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public HandbookInfo clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      type = 0;
      data.clear();
      nextPackage.clear();
      return this;
    }

    @Override
    public HandbookInfo clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      data.clear();
      nextPackage.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof HandbookInfo)) {
        return false;
      }
      HandbookInfo other = (HandbookInfo) o;
      return bitField0_ == other.bitField0_
        && (!hasType() || type == other.type)
        && (!hasData() || data.equals(other.data))
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt32NoTag(type);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 18);
        output.writeBytesNoTag(data);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(type);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeBytesSizeNoTag(data);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public HandbookInfo mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            // type
            type = input.readUInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 18) {
              break;
            }
          }
          case 18: {
            // data
            input.readBytes(data);
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeUInt32(FieldNames.type, type);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeBytes(FieldNames.data, data);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      output.endObject();
    }

    @Override
    public HandbookInfo mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 2622298: {
            if (input.isAtField(FieldNames.type)) {
              if (!input.trySkipNullValue()) {
                type = input.readUInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 2122698: {
            if (input.isAtField(FieldNames.data)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(data);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public HandbookInfo clone() {
      return new HandbookInfo().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static HandbookInfo parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new HandbookInfo(), data).checkInitialized();
    }

    public static HandbookInfo parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new HandbookInfo(), input).checkInitialized();
    }

    public static HandbookInfo parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new HandbookInfo(), input).checkInitialized();
    }

    /**
     * @return factory for creating HandbookInfo messages
     */
    public static MessageFactory<HandbookInfo> getFactory() {
      return HandbookInfoFactory.INSTANCE;
    }

    private enum HandbookInfoFactory implements MessageFactory<HandbookInfo> {
      INSTANCE;

      @Override
      public HandbookInfo create() {
        return HandbookInfo.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName type = FieldName.forField("Type");

      static final FieldName data = FieldName.forField("Data");

      static final FieldName nextPackage = FieldName.forField("NextPackage");
    }
  }

  /**
   * Protobuf type {@code QuestState}
   */
  public static final class QuestState extends ProtoMessage<QuestState> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional .QuestType Type = 1;</code>
     */
    private int type;

    /**
     * <code>optional bool New = 2;</code>
     */
    private boolean new_;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    private QuestState() {
    }

    /**
     * @return a new empty instance of {@code QuestState}
     */
    public static QuestState newInstance() {
      return new QuestState();
    }

    /**
     * <code>optional .QuestType Type = 1;</code>
     * @return whether the type field is set
     */
    public boolean hasType() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional .QuestType Type = 1;</code>
     * @return this
     */
    public QuestState clearType() {
      bitField0_ &= ~0x00000001;
      type = 0;
      return this;
    }

    /**
     * <code>optional .QuestType Type = 1;</code>
     * @return the type
     */
    public QuestType getType() {
      return QuestType.forNumber(type);
    }

    /**
     * Gets the value of the internal enum store. The result is
     * equivalent to {@link QuestState#getType()}.getNumber().
     *
     * @return numeric wire representation
     */
    public int getTypeValue() {
      return type;
    }

    /**
     * Sets the value of the internal enum store. This does not
     * do any validity checks, so be sure to use appropriate value
     * constants from {@link QuestType}. Setting an invalid value
     * can cause {@link QuestState#getType()} to return null
     *
     * @param value the numeric wire value to set
     * @return this
     */
    public QuestState setTypeValue(final int value) {
      bitField0_ |= 0x00000001;
      type = value;
      return this;
    }

    /**
     * <code>optional .QuestType Type = 1;</code>
     * @param value the type to set
     * @return this
     */
    public QuestState setType(final QuestType value) {
      bitField0_ |= 0x00000001;
      type = value.getNumber();
      return this;
    }

    /**
     * <code>optional bool New = 2;</code>
     * @return whether the new_ field is set
     */
    public boolean hasNew() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional bool New = 2;</code>
     * @return this
     */
    public QuestState clearNew() {
      bitField0_ &= ~0x00000002;
      new_ = false;
      return this;
    }

    /**
     * <code>optional bool New = 2;</code>
     * @return the new_
     */
    public boolean getNew() {
      return new_;
    }

    /**
     * <code>optional bool New = 2;</code>
     * @param value the new_ to set
     * @return this
     */
    public QuestState setNew(final boolean value) {
      bitField0_ |= 0x00000002;
      new_ = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public QuestState clearNextPackage() {
      bitField0_ &= ~0x00000004;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000004;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public QuestState addNextPackage(final byte value) {
      bitField0_ |= 0x00000004;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public QuestState addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000004;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public QuestState setNextPackage(final byte... values) {
      bitField0_ |= 0x00000004;
      nextPackage.copyFrom(values);
      return this;
    }

    @Override
    public QuestState copyFrom(final QuestState other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        type = other.type;
        new_ = other.new_;
        nextPackage.copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public QuestState mergeFrom(final QuestState other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasType()) {
        setTypeValue(other.type);
      }
      if (other.hasNew()) {
        setNew(other.new_);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public QuestState clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      type = 0;
      new_ = false;
      nextPackage.clear();
      return this;
    }

    @Override
    public QuestState clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof QuestState)) {
        return false;
      }
      QuestState other = (QuestState) o;
      return bitField0_ == other.bitField0_
        && (!hasType() || type == other.type)
        && (!hasNew() || new_ == other.new_)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 8);
        output.writeEnumNoTag(type);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 16);
        output.writeBoolNoTag(new_);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeEnumSizeNoTag(type);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 2;
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public QuestState mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            // type
            final int value = input.readInt32();
            if (QuestType.forNumber(value) != null) {
              type = value;
              bitField0_ |= 0x00000001;
            }
            tag = input.readTag();
            if (tag != 16) {
              break;
            }
          }
          case 16: {
            // new_
            new_ = input.readBool();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeEnum(FieldNames.type, type, QuestType.converter());
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeBool(FieldNames.new_, new_);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      output.endObject();
    }

    @Override
    public QuestState mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 2622298: {
            if (input.isAtField(FieldNames.type)) {
              if (!input.trySkipNullValue()) {
                final QuestType value = input.readEnum(QuestType.converter());
                if (value != null) {
                  type = value.getNumber();
                  bitField0_ |= 0x00000001;
                } else {
                  input.skipUnknownEnumValue();
                }
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 78208: {
            if (input.isAtField(FieldNames.new_)) {
              if (!input.trySkipNullValue()) {
                new_ = input.readBool();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public QuestState clone() {
      return new QuestState().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static QuestState parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new QuestState(), data).checkInitialized();
    }

    public static QuestState parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new QuestState(), input).checkInitialized();
    }

    public static QuestState parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new QuestState(), input).checkInitialized();
    }

    /**
     * @return factory for creating QuestState messages
     */
    public static MessageFactory<QuestState> getFactory() {
      return QuestStateFactory.INSTANCE;
    }

    private enum QuestStateFactory implements MessageFactory<QuestState> {
      INSTANCE;

      @Override
      public QuestState create() {
        return QuestState.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName type = FieldName.forField("Type");

      static final FieldName new_ = FieldName.forField("New");

      static final FieldName nextPackage = FieldName.forField("NextPackage");
    }
  }

  /**
   * Protobuf type {@code MallPackageState}
   */
  public static final class MallPackageState extends ProtoMessage<MallPackageState> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional bool New = 1;</code>
     */
    private boolean new_;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    private MallPackageState() {
    }

    /**
     * @return a new empty instance of {@code MallPackageState}
     */
    public static MallPackageState newInstance() {
      return new MallPackageState();
    }

    /**
     * <code>optional bool New = 1;</code>
     * @return whether the new_ field is set
     */
    public boolean hasNew() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional bool New = 1;</code>
     * @return this
     */
    public MallPackageState clearNew() {
      bitField0_ &= ~0x00000001;
      new_ = false;
      return this;
    }

    /**
     * <code>optional bool New = 1;</code>
     * @return the new_
     */
    public boolean getNew() {
      return new_;
    }

    /**
     * <code>optional bool New = 1;</code>
     * @param value the new_ to set
     * @return this
     */
    public MallPackageState setNew(final boolean value) {
      bitField0_ |= 0x00000001;
      new_ = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public MallPackageState clearNextPackage() {
      bitField0_ &= ~0x00000002;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000002;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public MallPackageState addNextPackage(final byte value) {
      bitField0_ |= 0x00000002;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public MallPackageState addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000002;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public MallPackageState setNextPackage(final byte... values) {
      bitField0_ |= 0x00000002;
      nextPackage.copyFrom(values);
      return this;
    }

    @Override
    public MallPackageState copyFrom(final MallPackageState other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        new_ = other.new_;
        nextPackage.copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public MallPackageState mergeFrom(final MallPackageState other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasNew()) {
        setNew(other.new_);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public MallPackageState clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      new_ = false;
      nextPackage.clear();
      return this;
    }

    @Override
    public MallPackageState clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof MallPackageState)) {
        return false;
      }
      MallPackageState other = (MallPackageState) o;
      return bitField0_ == other.bitField0_
        && (!hasNew() || new_ == other.new_)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 8);
        output.writeBoolNoTag(new_);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 2;
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public MallPackageState mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            // new_
            new_ = input.readBool();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeBool(FieldNames.new_, new_);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      output.endObject();
    }

    @Override
    public MallPackageState mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 78208: {
            if (input.isAtField(FieldNames.new_)) {
              if (!input.trySkipNullValue()) {
                new_ = input.readBool();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public MallPackageState clone() {
      return new MallPackageState().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static MallPackageState parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new MallPackageState(), data).checkInitialized();
    }

    public static MallPackageState parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new MallPackageState(), input).checkInitialized();
    }

    public static MallPackageState parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new MallPackageState(), input).checkInitialized();
    }

    /**
     * @return factory for creating MallPackageState messages
     */
    public static MessageFactory<MallPackageState> getFactory() {
      return MallPackageStateFactory.INSTANCE;
    }

    private enum MallPackageStateFactory implements MessageFactory<MallPackageState> {
      INSTANCE;

      @Override
      public MallPackageState create() {
        return MallPackageState.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName new_ = FieldName.forField("New");

      static final FieldName nextPackage = FieldName.forField("NextPackage");
    }
  }

  /**
   * Protobuf type {@code DailyInstance}
   */
  public static final class DailyInstance extends ProtoMessage<DailyInstance> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional uint64 BuildId = 15;</code>
     */
    private long buildId;

    /**
     * <code>optional uint32 Id = 1;</code>
     */
    private int id;

    /**
     * <code>optional uint32 Star = 2;</code>
     */
    private int star;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    private DailyInstance() {
    }

    /**
     * @return a new empty instance of {@code DailyInstance}
     */
    public static DailyInstance newInstance() {
      return new DailyInstance();
    }

    /**
     * <code>optional uint64 BuildId = 15;</code>
     * @return whether the buildId field is set
     */
    public boolean hasBuildId() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional uint64 BuildId = 15;</code>
     * @return this
     */
    public DailyInstance clearBuildId() {
      bitField0_ &= ~0x00000001;
      buildId = 0L;
      return this;
    }

    /**
     * <code>optional uint64 BuildId = 15;</code>
     * @return the buildId
     */
    public long getBuildId() {
      return buildId;
    }

    /**
     * <code>optional uint64 BuildId = 15;</code>
     * @param value the buildId to set
     * @return this
     */
    public DailyInstance setBuildId(final long value) {
      bitField0_ |= 0x00000001;
      buildId = value;
      return this;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @return whether the id field is set
     */
    public boolean hasId() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @return this
     */
    public DailyInstance clearId() {
      bitField0_ &= ~0x00000002;
      id = 0;
      return this;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @return the id
     */
    public int getId() {
      return id;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @param value the id to set
     * @return this
     */
    public DailyInstance setId(final int value) {
      bitField0_ |= 0x00000002;
      id = value;
      return this;
    }

    /**
     * <code>optional uint32 Star = 2;</code>
     * @return whether the star field is set
     */
    public boolean hasStar() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional uint32 Star = 2;</code>
     * @return this
     */
    public DailyInstance clearStar() {
      bitField0_ &= ~0x00000004;
      star = 0;
      return this;
    }

    /**
     * <code>optional uint32 Star = 2;</code>
     * @return the star
     */
    public int getStar() {
      return star;
    }

    /**
     * <code>optional uint32 Star = 2;</code>
     * @param value the star to set
     * @return this
     */
    public DailyInstance setStar(final int value) {
      bitField0_ |= 0x00000004;
      star = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000008) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public DailyInstance clearNextPackage() {
      bitField0_ &= ~0x00000008;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000008;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public DailyInstance addNextPackage(final byte value) {
      bitField0_ |= 0x00000008;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public DailyInstance addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000008;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public DailyInstance setNextPackage(final byte... values) {
      bitField0_ |= 0x00000008;
      nextPackage.copyFrom(values);
      return this;
    }

    @Override
    public DailyInstance copyFrom(final DailyInstance other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        buildId = other.buildId;
        id = other.id;
        star = other.star;
        nextPackage.copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public DailyInstance mergeFrom(final DailyInstance other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasBuildId()) {
        setBuildId(other.buildId);
      }
      if (other.hasId()) {
        setId(other.id);
      }
      if (other.hasStar()) {
        setStar(other.star);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public DailyInstance clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      buildId = 0L;
      id = 0;
      star = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public DailyInstance clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof DailyInstance)) {
        return false;
      }
      DailyInstance other = (DailyInstance) o;
      return bitField0_ == other.bitField0_
        && (!hasBuildId() || buildId == other.buildId)
        && (!hasId() || id == other.id)
        && (!hasStar() || star == other.star)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 120);
        output.writeUInt64NoTag(buildId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt32NoTag(id);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawByte((byte) 16);
        output.writeUInt32NoTag(star);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeUInt64SizeNoTag(buildId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(id);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(star);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public DailyInstance mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 120: {
            // buildId
            buildId = input.readUInt64();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 8) {
              break;
            }
          }
          case 8: {
            // id
            id = input.readUInt32();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 16) {
              break;
            }
          }
          case 16: {
            // star
            star = input.readUInt32();
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000008;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeUInt64(FieldNames.buildId, buildId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeUInt32(FieldNames.id, id);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeUInt32(FieldNames.star, star);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      output.endObject();
    }

    @Override
    public DailyInstance mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 1895597065: {
            if (input.isAtField(FieldNames.buildId)) {
              if (!input.trySkipNullValue()) {
                buildId = input.readUInt64();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 2363: {
            if (input.isAtField(FieldNames.id)) {
              if (!input.trySkipNullValue()) {
                id = input.readUInt32();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 2587250: {
            if (input.isAtField(FieldNames.star)) {
              if (!input.trySkipNullValue()) {
                star = input.readUInt32();
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000008;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public DailyInstance clone() {
      return new DailyInstance().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static DailyInstance parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new DailyInstance(), data).checkInitialized();
    }

    public static DailyInstance parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new DailyInstance(), input).checkInitialized();
    }

    public static DailyInstance parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new DailyInstance(), input).checkInitialized();
    }

    /**
     * @return factory for creating DailyInstance messages
     */
    public static MessageFactory<DailyInstance> getFactory() {
      return DailyInstanceFactory.INSTANCE;
    }

    private enum DailyInstanceFactory implements MessageFactory<DailyInstance> {
      INSTANCE;

      @Override
      public DailyInstance create() {
        return DailyInstance.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName buildId = FieldName.forField("BuildId");

      static final FieldName id = FieldName.forField("Id");

      static final FieldName star = FieldName.forField("Star");

      static final FieldName nextPackage = FieldName.forField("NextPackage");
    }
  }

  /**
   * Protobuf type {@code TravelerDuelBossLevel}
   */
  public static final class TravelerDuelBossLevel extends ProtoMessage<TravelerDuelBossLevel> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional uint64 BuildId = 3;</code>
     */
    private long buildId;

    /**
     * <code>optional uint32 Id = 1;</code>
     */
    private int id;

    /**
     * <code>optional uint32 Star = 2;</code>
     */
    private int star;

    /**
     * <code>optional uint32 Difficulty = 4;</code>
     */
    private int difficulty;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    private TravelerDuelBossLevel() {
    }

    /**
     * @return a new empty instance of {@code TravelerDuelBossLevel}
     */
    public static TravelerDuelBossLevel newInstance() {
      return new TravelerDuelBossLevel();
    }

    /**
     * <code>optional uint64 BuildId = 3;</code>
     * @return whether the buildId field is set
     */
    public boolean hasBuildId() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional uint64 BuildId = 3;</code>
     * @return this
     */
    public TravelerDuelBossLevel clearBuildId() {
      bitField0_ &= ~0x00000001;
      buildId = 0L;
      return this;
    }

    /**
     * <code>optional uint64 BuildId = 3;</code>
     * @return the buildId
     */
    public long getBuildId() {
      return buildId;
    }

    /**
     * <code>optional uint64 BuildId = 3;</code>
     * @param value the buildId to set
     * @return this
     */
    public TravelerDuelBossLevel setBuildId(final long value) {
      bitField0_ |= 0x00000001;
      buildId = value;
      return this;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @return whether the id field is set
     */
    public boolean hasId() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @return this
     */
    public TravelerDuelBossLevel clearId() {
      bitField0_ &= ~0x00000002;
      id = 0;
      return this;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @return the id
     */
    public int getId() {
      return id;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @param value the id to set
     * @return this
     */
    public TravelerDuelBossLevel setId(final int value) {
      bitField0_ |= 0x00000002;
      id = value;
      return this;
    }

    /**
     * <code>optional uint32 Star = 2;</code>
     * @return whether the star field is set
     */
    public boolean hasStar() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional uint32 Star = 2;</code>
     * @return this
     */
    public TravelerDuelBossLevel clearStar() {
      bitField0_ &= ~0x00000004;
      star = 0;
      return this;
    }

    /**
     * <code>optional uint32 Star = 2;</code>
     * @return the star
     */
    public int getStar() {
      return star;
    }

    /**
     * <code>optional uint32 Star = 2;</code>
     * @param value the star to set
     * @return this
     */
    public TravelerDuelBossLevel setStar(final int value) {
      bitField0_ |= 0x00000004;
      star = value;
      return this;
    }

    /**
     * <code>optional uint32 Difficulty = 4;</code>
     * @return whether the difficulty field is set
     */
    public boolean hasDifficulty() {
      return (bitField0_ & 0x00000008) != 0;
    }

    /**
     * <code>optional uint32 Difficulty = 4;</code>
     * @return this
     */
    public TravelerDuelBossLevel clearDifficulty() {
      bitField0_ &= ~0x00000008;
      difficulty = 0;
      return this;
    }

    /**
     * <code>optional uint32 Difficulty = 4;</code>
     * @return the difficulty
     */
    public int getDifficulty() {
      return difficulty;
    }

    /**
     * <code>optional uint32 Difficulty = 4;</code>
     * @param value the difficulty to set
     * @return this
     */
    public TravelerDuelBossLevel setDifficulty(final int value) {
      bitField0_ |= 0x00000008;
      difficulty = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000010) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public TravelerDuelBossLevel clearNextPackage() {
      bitField0_ &= ~0x00000010;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000010;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public TravelerDuelBossLevel addNextPackage(final byte value) {
      bitField0_ |= 0x00000010;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public TravelerDuelBossLevel addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000010;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public TravelerDuelBossLevel setNextPackage(final byte... values) {
      bitField0_ |= 0x00000010;
      nextPackage.copyFrom(values);
      return this;
    }

    @Override
    public TravelerDuelBossLevel copyFrom(final TravelerDuelBossLevel other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        buildId = other.buildId;
        id = other.id;
        star = other.star;
        difficulty = other.difficulty;
        nextPackage.copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public TravelerDuelBossLevel mergeFrom(final TravelerDuelBossLevel other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasBuildId()) {
        setBuildId(other.buildId);
      }
      if (other.hasId()) {
        setId(other.id);
      }
      if (other.hasStar()) {
        setStar(other.star);
      }
      if (other.hasDifficulty()) {
        setDifficulty(other.difficulty);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public TravelerDuelBossLevel clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      buildId = 0L;
      id = 0;
      star = 0;
      difficulty = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public TravelerDuelBossLevel clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof TravelerDuelBossLevel)) {
        return false;
      }
      TravelerDuelBossLevel other = (TravelerDuelBossLevel) o;
      return bitField0_ == other.bitField0_
        && (!hasBuildId() || buildId == other.buildId)
        && (!hasId() || id == other.id)
        && (!hasStar() || star == other.star)
        && (!hasDifficulty() || difficulty == other.difficulty)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 24);
        output.writeUInt64NoTag(buildId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt32NoTag(id);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawByte((byte) 16);
        output.writeUInt32NoTag(star);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeRawByte((byte) 32);
        output.writeUInt32NoTag(difficulty);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeUInt64SizeNoTag(buildId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(id);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(star);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(difficulty);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public TravelerDuelBossLevel mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 24: {
            // buildId
            buildId = input.readUInt64();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 8) {
              break;
            }
          }
          case 8: {
            // id
            id = input.readUInt32();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 16) {
              break;
            }
          }
          case 16: {
            // star
            star = input.readUInt32();
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 32) {
              break;
            }
          }
          case 32: {
            // difficulty
            difficulty = input.readUInt32();
            bitField0_ |= 0x00000008;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000010;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeUInt64(FieldNames.buildId, buildId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeUInt32(FieldNames.id, id);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeUInt32(FieldNames.star, star);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeUInt32(FieldNames.difficulty, difficulty);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      output.endObject();
    }

    @Override
    public TravelerDuelBossLevel mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 1895597065: {
            if (input.isAtField(FieldNames.buildId)) {
              if (!input.trySkipNullValue()) {
                buildId = input.readUInt64();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 2363: {
            if (input.isAtField(FieldNames.id)) {
              if (!input.trySkipNullValue()) {
                id = input.readUInt32();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 2587250: {
            if (input.isAtField(FieldNames.star)) {
              if (!input.trySkipNullValue()) {
                star = input.readUInt32();
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -472001573: {
            if (input.isAtField(FieldNames.difficulty)) {
              if (!input.trySkipNullValue()) {
                difficulty = input.readUInt32();
                bitField0_ |= 0x00000008;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000010;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public TravelerDuelBossLevel clone() {
      return new TravelerDuelBossLevel().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static TravelerDuelBossLevel parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new TravelerDuelBossLevel(), data).checkInitialized();
    }

    public static TravelerDuelBossLevel parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new TravelerDuelBossLevel(), input).checkInitialized();
    }

    public static TravelerDuelBossLevel parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new TravelerDuelBossLevel(), input).checkInitialized();
    }

    /**
     * @return factory for creating TravelerDuelBossLevel messages
     */
    public static MessageFactory<TravelerDuelBossLevel> getFactory() {
      return TravelerDuelBossLevelFactory.INSTANCE;
    }

    private enum TravelerDuelBossLevelFactory implements MessageFactory<TravelerDuelBossLevel> {
      INSTANCE;

      @Override
      public TravelerDuelBossLevel create() {
        return TravelerDuelBossLevel.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName buildId = FieldName.forField("BuildId");

      static final FieldName id = FieldName.forField("Id");

      static final FieldName star = FieldName.forField("Star");

      static final FieldName difficulty = FieldName.forField("Difficulty");

      static final FieldName nextPackage = FieldName.forField("NextPackage");
    }
  }

  /**
   * Protobuf type {@code TravelerDuelChallengeInfo}
   */
  public static final class TravelerDuelChallengeInfo extends ProtoMessage<TravelerDuelChallengeInfo> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional int64 OpenTime = 3;</code>
     */
    private long openTime;

    /**
     * <code>optional int64 CloseTime = 4;</code>
     */
    private long closeTime;

    /**
     * <code>optional uint32 Id = 2;</code>
     */
    private int id;

    /**
     * <code>optional bool Unlock = 1;</code>
     */
    private boolean unlock;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    private TravelerDuelChallengeInfo() {
    }

    /**
     * @return a new empty instance of {@code TravelerDuelChallengeInfo}
     */
    public static TravelerDuelChallengeInfo newInstance() {
      return new TravelerDuelChallengeInfo();
    }

    /**
     * <code>optional int64 OpenTime = 3;</code>
     * @return whether the openTime field is set
     */
    public boolean hasOpenTime() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional int64 OpenTime = 3;</code>
     * @return this
     */
    public TravelerDuelChallengeInfo clearOpenTime() {
      bitField0_ &= ~0x00000001;
      openTime = 0L;
      return this;
    }

    /**
     * <code>optional int64 OpenTime = 3;</code>
     * @return the openTime
     */
    public long getOpenTime() {
      return openTime;
    }

    /**
     * <code>optional int64 OpenTime = 3;</code>
     * @param value the openTime to set
     * @return this
     */
    public TravelerDuelChallengeInfo setOpenTime(final long value) {
      bitField0_ |= 0x00000001;
      openTime = value;
      return this;
    }

    /**
     * <code>optional int64 CloseTime = 4;</code>
     * @return whether the closeTime field is set
     */
    public boolean hasCloseTime() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional int64 CloseTime = 4;</code>
     * @return this
     */
    public TravelerDuelChallengeInfo clearCloseTime() {
      bitField0_ &= ~0x00000002;
      closeTime = 0L;
      return this;
    }

    /**
     * <code>optional int64 CloseTime = 4;</code>
     * @return the closeTime
     */
    public long getCloseTime() {
      return closeTime;
    }

    /**
     * <code>optional int64 CloseTime = 4;</code>
     * @param value the closeTime to set
     * @return this
     */
    public TravelerDuelChallengeInfo setCloseTime(final long value) {
      bitField0_ |= 0x00000002;
      closeTime = value;
      return this;
    }

    /**
     * <code>optional uint32 Id = 2;</code>
     * @return whether the id field is set
     */
    public boolean hasId() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional uint32 Id = 2;</code>
     * @return this
     */
    public TravelerDuelChallengeInfo clearId() {
      bitField0_ &= ~0x00000004;
      id = 0;
      return this;
    }

    /**
     * <code>optional uint32 Id = 2;</code>
     * @return the id
     */
    public int getId() {
      return id;
    }

    /**
     * <code>optional uint32 Id = 2;</code>
     * @param value the id to set
     * @return this
     */
    public TravelerDuelChallengeInfo setId(final int value) {
      bitField0_ |= 0x00000004;
      id = value;
      return this;
    }

    /**
     * <code>optional bool Unlock = 1;</code>
     * @return whether the unlock field is set
     */
    public boolean hasUnlock() {
      return (bitField0_ & 0x00000008) != 0;
    }

    /**
     * <code>optional bool Unlock = 1;</code>
     * @return this
     */
    public TravelerDuelChallengeInfo clearUnlock() {
      bitField0_ &= ~0x00000008;
      unlock = false;
      return this;
    }

    /**
     * <code>optional bool Unlock = 1;</code>
     * @return the unlock
     */
    public boolean getUnlock() {
      return unlock;
    }

    /**
     * <code>optional bool Unlock = 1;</code>
     * @param value the unlock to set
     * @return this
     */
    public TravelerDuelChallengeInfo setUnlock(final boolean value) {
      bitField0_ |= 0x00000008;
      unlock = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000010) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public TravelerDuelChallengeInfo clearNextPackage() {
      bitField0_ &= ~0x00000010;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000010;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public TravelerDuelChallengeInfo addNextPackage(final byte value) {
      bitField0_ |= 0x00000010;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public TravelerDuelChallengeInfo addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000010;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public TravelerDuelChallengeInfo setNextPackage(final byte... values) {
      bitField0_ |= 0x00000010;
      nextPackage.copyFrom(values);
      return this;
    }

    @Override
    public TravelerDuelChallengeInfo copyFrom(final TravelerDuelChallengeInfo other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        openTime = other.openTime;
        closeTime = other.closeTime;
        id = other.id;
        unlock = other.unlock;
        nextPackage.copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public TravelerDuelChallengeInfo mergeFrom(final TravelerDuelChallengeInfo other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasOpenTime()) {
        setOpenTime(other.openTime);
      }
      if (other.hasCloseTime()) {
        setCloseTime(other.closeTime);
      }
      if (other.hasId()) {
        setId(other.id);
      }
      if (other.hasUnlock()) {
        setUnlock(other.unlock);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public TravelerDuelChallengeInfo clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      openTime = 0L;
      closeTime = 0L;
      id = 0;
      unlock = false;
      nextPackage.clear();
      return this;
    }

    @Override
    public TravelerDuelChallengeInfo clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof TravelerDuelChallengeInfo)) {
        return false;
      }
      TravelerDuelChallengeInfo other = (TravelerDuelChallengeInfo) o;
      return bitField0_ == other.bitField0_
        && (!hasOpenTime() || openTime == other.openTime)
        && (!hasCloseTime() || closeTime == other.closeTime)
        && (!hasId() || id == other.id)
        && (!hasUnlock() || unlock == other.unlock)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 24);
        output.writeInt64NoTag(openTime);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 32);
        output.writeInt64NoTag(closeTime);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawByte((byte) 16);
        output.writeUInt32NoTag(id);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeRawByte((byte) 8);
        output.writeBoolNoTag(unlock);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeInt64SizeNoTag(openTime);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeInt64SizeNoTag(closeTime);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(id);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        size += 2;
      }
      if ((bitField0_ & 0x00000010) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public TravelerDuelChallengeInfo mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 24: {
            // openTime
            openTime = input.readInt64();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 32) {
              break;
            }
          }
          case 32: {
            // closeTime
            closeTime = input.readInt64();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 16) {
              break;
            }
          }
          case 16: {
            // id
            id = input.readUInt32();
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 8) {
              break;
            }
          }
          case 8: {
            // unlock
            unlock = input.readBool();
            bitField0_ |= 0x00000008;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000010;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeInt64(FieldNames.openTime, openTime);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeInt64(FieldNames.closeTime, closeTime);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeUInt32(FieldNames.id, id);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeBool(FieldNames.unlock, unlock);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      output.endObject();
    }

    @Override
    public TravelerDuelChallengeInfo mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case -440001449: {
            if (input.isAtField(FieldNames.openTime)) {
              if (!input.trySkipNullValue()) {
                openTime = input.readInt64();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 1521486021: {
            if (input.isAtField(FieldNames.closeTime)) {
              if (!input.trySkipNullValue()) {
                closeTime = input.readInt64();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 2363: {
            if (input.isAtField(FieldNames.id)) {
              if (!input.trySkipNullValue()) {
                id = input.readUInt32();
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1756574876: {
            if (input.isAtField(FieldNames.unlock)) {
              if (!input.trySkipNullValue()) {
                unlock = input.readBool();
                bitField0_ |= 0x00000008;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000010;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public TravelerDuelChallengeInfo clone() {
      return new TravelerDuelChallengeInfo().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static TravelerDuelChallengeInfo parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new TravelerDuelChallengeInfo(), data).checkInitialized();
    }

    public static TravelerDuelChallengeInfo parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new TravelerDuelChallengeInfo(), input).checkInitialized();
    }

    public static TravelerDuelChallengeInfo parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new TravelerDuelChallengeInfo(), input).checkInitialized();
    }

    /**
     * @return factory for creating TravelerDuelChallengeInfo messages
     */
    public static MessageFactory<TravelerDuelChallengeInfo> getFactory() {
      return TravelerDuelChallengeInfoFactory.INSTANCE;
    }

    private enum TravelerDuelChallengeInfoFactory implements MessageFactory<TravelerDuelChallengeInfo> {
      INSTANCE;

      @Override
      public TravelerDuelChallengeInfo create() {
        return TravelerDuelChallengeInfo.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName openTime = FieldName.forField("OpenTime");

      static final FieldName closeTime = FieldName.forField("CloseTime");

      static final FieldName id = FieldName.forField("Id");

      static final FieldName unlock = FieldName.forField("Unlock");

      static final FieldName nextPackage = FieldName.forField("NextPackage");
    }
  }

  /**
   * Protobuf type {@code Activity}
   */
  public static final class Activity extends ProtoMessage<Activity> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional int64 StartTime = 2;</code>
     */
    private long startTime;

    /**
     * <code>optional int64 EndTime = 3;</code>
     */
    private long endTime;

    /**
     * <code>optional uint32 Id = 1;</code>
     */
    private int id;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    private Activity() {
    }

    /**
     * @return a new empty instance of {@code Activity}
     */
    public static Activity newInstance() {
      return new Activity();
    }

    /**
     * <code>optional int64 StartTime = 2;</code>
     * @return whether the startTime field is set
     */
    public boolean hasStartTime() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional int64 StartTime = 2;</code>
     * @return this
     */
    public Activity clearStartTime() {
      bitField0_ &= ~0x00000001;
      startTime = 0L;
      return this;
    }

    /**
     * <code>optional int64 StartTime = 2;</code>
     * @return the startTime
     */
    public long getStartTime() {
      return startTime;
    }

    /**
     * <code>optional int64 StartTime = 2;</code>
     * @param value the startTime to set
     * @return this
     */
    public Activity setStartTime(final long value) {
      bitField0_ |= 0x00000001;
      startTime = value;
      return this;
    }

    /**
     * <code>optional int64 EndTime = 3;</code>
     * @return whether the endTime field is set
     */
    public boolean hasEndTime() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional int64 EndTime = 3;</code>
     * @return this
     */
    public Activity clearEndTime() {
      bitField0_ &= ~0x00000002;
      endTime = 0L;
      return this;
    }

    /**
     * <code>optional int64 EndTime = 3;</code>
     * @return the endTime
     */
    public long getEndTime() {
      return endTime;
    }

    /**
     * <code>optional int64 EndTime = 3;</code>
     * @param value the endTime to set
     * @return this
     */
    public Activity setEndTime(final long value) {
      bitField0_ |= 0x00000002;
      endTime = value;
      return this;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @return whether the id field is set
     */
    public boolean hasId() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @return this
     */
    public Activity clearId() {
      bitField0_ &= ~0x00000004;
      id = 0;
      return this;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @return the id
     */
    public int getId() {
      return id;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @param value the id to set
     * @return this
     */
    public Activity setId(final int value) {
      bitField0_ |= 0x00000004;
      id = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000008) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public Activity clearNextPackage() {
      bitField0_ &= ~0x00000008;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000008;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public Activity addNextPackage(final byte value) {
      bitField0_ |= 0x00000008;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public Activity addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000008;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public Activity setNextPackage(final byte... values) {
      bitField0_ |= 0x00000008;
      nextPackage.copyFrom(values);
      return this;
    }

    @Override
    public Activity copyFrom(final Activity other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        startTime = other.startTime;
        endTime = other.endTime;
        id = other.id;
        nextPackage.copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public Activity mergeFrom(final Activity other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasStartTime()) {
        setStartTime(other.startTime);
      }
      if (other.hasEndTime()) {
        setEndTime(other.endTime);
      }
      if (other.hasId()) {
        setId(other.id);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public Activity clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      startTime = 0L;
      endTime = 0L;
      id = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public Activity clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof Activity)) {
        return false;
      }
      Activity other = (Activity) o;
      return bitField0_ == other.bitField0_
        && (!hasStartTime() || startTime == other.startTime)
        && (!hasEndTime() || endTime == other.endTime)
        && (!hasId() || id == other.id)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 16);
        output.writeInt64NoTag(startTime);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 24);
        output.writeInt64NoTag(endTime);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt32NoTag(id);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeInt64SizeNoTag(startTime);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeInt64SizeNoTag(endTime);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(id);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public Activity mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 16: {
            // startTime
            startTime = input.readInt64();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 24) {
              break;
            }
          }
          case 24: {
            // endTime
            endTime = input.readInt64();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 8) {
              break;
            }
          }
          case 8: {
            // id
            id = input.readUInt32();
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000008;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeInt64(FieldNames.startTime, startTime);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeInt64(FieldNames.endTime, endTime);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeUInt32(FieldNames.id, id);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      output.endObject();
    }

    @Override
    public Activity mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case -125326801: {
            if (input.isAtField(FieldNames.startTime)) {
              if (!input.trySkipNullValue()) {
                startTime = input.readInt64();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 57410088: {
            if (input.isAtField(FieldNames.endTime)) {
              if (!input.trySkipNullValue()) {
                endTime = input.readInt64();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 2363: {
            if (input.isAtField(FieldNames.id)) {
              if (!input.trySkipNullValue()) {
                id = input.readUInt32();
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000008;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public Activity clone() {
      return new Activity().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static Activity parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new Activity(), data).checkInitialized();
    }

    public static Activity parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new Activity(), input).checkInitialized();
    }

    public static Activity parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new Activity(), input).checkInitialized();
    }

    /**
     * @return factory for creating Activity messages
     */
    public static MessageFactory<Activity> getFactory() {
      return ActivityFactory.INSTANCE;
    }

    private enum ActivityFactory implements MessageFactory<Activity> {
      INSTANCE;

      @Override
      public Activity create() {
        return Activity.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName startTime = FieldName.forField("StartTime");

      static final FieldName endTime = FieldName.forField("EndTime");

      static final FieldName id = FieldName.forField("Id");

      static final FieldName nextPackage = FieldName.forField("NextPackage");
    }
  }

  /**
   * Protobuf type {@code ActivityQuest}
   */
  public static final class ActivityQuest extends ProtoMessage<ActivityQuest> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional uint32 Id = 1;</code>
     */
    private int id;

    /**
     * <code>optional uint32 Status = 2;</code>
     */
    private int status;

    /**
     * <code>optional uint32 ActivityId = 3;</code>
     */
    private int activityId;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    /**
     * <code>repeated .QuestProgress Progress = 15;</code>
     */
    private final RepeatedMessage<QuestProgress> progress = RepeatedMessage.newEmptyInstance(QuestProgress.getFactory());

    private ActivityQuest() {
    }

    /**
     * @return a new empty instance of {@code ActivityQuest}
     */
    public static ActivityQuest newInstance() {
      return new ActivityQuest();
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @return whether the id field is set
     */
    public boolean hasId() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @return this
     */
    public ActivityQuest clearId() {
      bitField0_ &= ~0x00000001;
      id = 0;
      return this;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @return the id
     */
    public int getId() {
      return id;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @param value the id to set
     * @return this
     */
    public ActivityQuest setId(final int value) {
      bitField0_ |= 0x00000001;
      id = value;
      return this;
    }

    /**
     * <code>optional uint32 Status = 2;</code>
     * @return whether the status field is set
     */
    public boolean hasStatus() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional uint32 Status = 2;</code>
     * @return this
     */
    public ActivityQuest clearStatus() {
      bitField0_ &= ~0x00000002;
      status = 0;
      return this;
    }

    /**
     * <code>optional uint32 Status = 2;</code>
     * @return the status
     */
    public int getStatus() {
      return status;
    }

    /**
     * <code>optional uint32 Status = 2;</code>
     * @param value the status to set
     * @return this
     */
    public ActivityQuest setStatus(final int value) {
      bitField0_ |= 0x00000002;
      status = value;
      return this;
    }

    /**
     * <code>optional uint32 ActivityId = 3;</code>
     * @return whether the activityId field is set
     */
    public boolean hasActivityId() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional uint32 ActivityId = 3;</code>
     * @return this
     */
    public ActivityQuest clearActivityId() {
      bitField0_ &= ~0x00000004;
      activityId = 0;
      return this;
    }

    /**
     * <code>optional uint32 ActivityId = 3;</code>
     * @return the activityId
     */
    public int getActivityId() {
      return activityId;
    }

    /**
     * <code>optional uint32 ActivityId = 3;</code>
     * @param value the activityId to set
     * @return this
     */
    public ActivityQuest setActivityId(final int value) {
      bitField0_ |= 0x00000004;
      activityId = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000008) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public ActivityQuest clearNextPackage() {
      bitField0_ &= ~0x00000008;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000008;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public ActivityQuest addNextPackage(final byte value) {
      bitField0_ |= 0x00000008;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public ActivityQuest addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000008;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public ActivityQuest setNextPackage(final byte... values) {
      bitField0_ |= 0x00000008;
      nextPackage.copyFrom(values);
      return this;
    }

    /**
     * <code>repeated .QuestProgress Progress = 15;</code>
     * @return whether the progress field is set
     */
    public boolean hasProgress() {
      return (bitField0_ & 0x00000010) != 0;
    }

    /**
     * <code>repeated .QuestProgress Progress = 15;</code>
     * @return this
     */
    public ActivityQuest clearProgress() {
      bitField0_ &= ~0x00000010;
      progress.clear();
      return this;
    }

    /**
     * <code>repeated .QuestProgress Progress = 15;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableProgress()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<QuestProgress> getProgress() {
      return progress;
    }

    /**
     * <code>repeated .QuestProgress Progress = 15;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<QuestProgress> getMutableProgress() {
      bitField0_ |= 0x00000010;
      return progress;
    }

    /**
     * <code>repeated .QuestProgress Progress = 15;</code>
     * @param value the progress to add
     * @return this
     */
    public ActivityQuest addProgress(final QuestProgress value) {
      bitField0_ |= 0x00000010;
      progress.add(value);
      return this;
    }

    /**
     * <code>repeated .QuestProgress Progress = 15;</code>
     * @param values the progress to add
     * @return this
     */
    public ActivityQuest addAllProgress(final QuestProgress... values) {
      bitField0_ |= 0x00000010;
      progress.addAll(values);
      return this;
    }

    @Override
    public ActivityQuest copyFrom(final ActivityQuest other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        id = other.id;
        status = other.status;
        activityId = other.activityId;
        nextPackage.copyFrom(other.nextPackage);
        progress.copyFrom(other.progress);
      }
      return this;
    }

    @Override
    public ActivityQuest mergeFrom(final ActivityQuest other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasId()) {
        setId(other.id);
      }
      if (other.hasStatus()) {
        setStatus(other.status);
      }
      if (other.hasActivityId()) {
        setActivityId(other.activityId);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      if (other.hasProgress()) {
        getMutableProgress().addAll(other.progress);
      }
      return this;
    }

    @Override
    public ActivityQuest clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      id = 0;
      status = 0;
      activityId = 0;
      nextPackage.clear();
      progress.clear();
      return this;
    }

    @Override
    public ActivityQuest clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      progress.clearQuick();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof ActivityQuest)) {
        return false;
      }
      ActivityQuest other = (ActivityQuest) o;
      return bitField0_ == other.bitField0_
        && (!hasId() || id == other.id)
        && (!hasStatus() || status == other.status)
        && (!hasActivityId() || activityId == other.activityId)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage))
        && (!hasProgress() || progress.equals(other.progress));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt32NoTag(id);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 16);
        output.writeUInt32NoTag(status);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawByte((byte) 24);
        output.writeUInt32NoTag(activityId);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        for (int i = 0; i < progress.length(); i++) {
          output.writeRawByte((byte) 122);
          output.writeMessageNoTag(progress.get(i));
        }
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(id);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(status);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(activityId);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        size += (1 * progress.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(progress);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public ActivityQuest mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            // id
            id = input.readUInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 16) {
              break;
            }
          }
          case 16: {
            // status
            status = input.readUInt32();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 24) {
              break;
            }
          }
          case 24: {
            // activityId
            activityId = input.readUInt32();
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000008;
            tag = input.readTag();
            if (tag != 122) {
              break;
            }
          }
          case 122: {
            // progress
            tag = input.readRepeatedMessage(progress, tag);
            bitField0_ |= 0x00000010;
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeUInt32(FieldNames.id, id);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeUInt32(FieldNames.status, status);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeUInt32(FieldNames.activityId, activityId);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        output.writeRepeatedMessage(FieldNames.progress, progress);
      }
      output.endObject();
    }

    @Override
    public ActivityQuest mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 2363: {
            if (input.isAtField(FieldNames.id)) {
              if (!input.trySkipNullValue()) {
                id = input.readUInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1808614382: {
            if (input.isAtField(FieldNames.status)) {
              if (!input.trySkipNullValue()) {
                status = input.readUInt32();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -252882774: {
            if (input.isAtField(FieldNames.activityId)) {
              if (!input.trySkipNullValue()) {
                activityId = input.readUInt32();
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000008;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -936434099: {
            if (input.isAtField(FieldNames.progress)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedMessage(progress);
                bitField0_ |= 0x00000010;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public ActivityQuest clone() {
      return new ActivityQuest().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static ActivityQuest parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new ActivityQuest(), data).checkInitialized();
    }

    public static ActivityQuest parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new ActivityQuest(), input).checkInitialized();
    }

    public static ActivityQuest parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new ActivityQuest(), input).checkInitialized();
    }

    /**
     * @return factory for creating ActivityQuest messages
     */
    public static MessageFactory<ActivityQuest> getFactory() {
      return ActivityQuestFactory.INSTANCE;
    }

    private enum ActivityQuestFactory implements MessageFactory<ActivityQuest> {
      INSTANCE;

      @Override
      public ActivityQuest create() {
        return ActivityQuest.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName id = FieldName.forField("Id");

      static final FieldName status = FieldName.forField("Status");

      static final FieldName activityId = FieldName.forField("ActivityId");

      static final FieldName nextPackage = FieldName.forField("NextPackage");

      static final FieldName progress = FieldName.forField("Progress");
    }
  }

  /**
   * Protobuf type {@code ActivityPeriodic}
   */
  public static final class ActivityPeriodic extends ProtoMessage<ActivityPeriodic> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional uint32 ActivityId = 1;</code>
     */
    private int activityId;

    /**
     * <code>optional bool FinalStatus = 2;</code>
     */
    private boolean finalStatus;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    /**
     * <code>repeated .ActivityQuest Quests = 15;</code>
     */
    private final RepeatedMessage<ActivityQuest> quests = RepeatedMessage.newEmptyInstance(ActivityQuest.getFactory());

    private ActivityPeriodic() {
    }

    /**
     * @return a new empty instance of {@code ActivityPeriodic}
     */
    public static ActivityPeriodic newInstance() {
      return new ActivityPeriodic();
    }

    /**
     * <code>optional uint32 ActivityId = 1;</code>
     * @return whether the activityId field is set
     */
    public boolean hasActivityId() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional uint32 ActivityId = 1;</code>
     * @return this
     */
    public ActivityPeriodic clearActivityId() {
      bitField0_ &= ~0x00000001;
      activityId = 0;
      return this;
    }

    /**
     * <code>optional uint32 ActivityId = 1;</code>
     * @return the activityId
     */
    public int getActivityId() {
      return activityId;
    }

    /**
     * <code>optional uint32 ActivityId = 1;</code>
     * @param value the activityId to set
     * @return this
     */
    public ActivityPeriodic setActivityId(final int value) {
      bitField0_ |= 0x00000001;
      activityId = value;
      return this;
    }

    /**
     * <code>optional bool FinalStatus = 2;</code>
     * @return whether the finalStatus field is set
     */
    public boolean hasFinalStatus() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional bool FinalStatus = 2;</code>
     * @return this
     */
    public ActivityPeriodic clearFinalStatus() {
      bitField0_ &= ~0x00000002;
      finalStatus = false;
      return this;
    }

    /**
     * <code>optional bool FinalStatus = 2;</code>
     * @return the finalStatus
     */
    public boolean getFinalStatus() {
      return finalStatus;
    }

    /**
     * <code>optional bool FinalStatus = 2;</code>
     * @param value the finalStatus to set
     * @return this
     */
    public ActivityPeriodic setFinalStatus(final boolean value) {
      bitField0_ |= 0x00000002;
      finalStatus = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public ActivityPeriodic clearNextPackage() {
      bitField0_ &= ~0x00000004;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000004;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public ActivityPeriodic addNextPackage(final byte value) {
      bitField0_ |= 0x00000004;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public ActivityPeriodic addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000004;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public ActivityPeriodic setNextPackage(final byte... values) {
      bitField0_ |= 0x00000004;
      nextPackage.copyFrom(values);
      return this;
    }

    /**
     * <code>repeated .ActivityQuest Quests = 15;</code>
     * @return whether the quests field is set
     */
    public boolean hasQuests() {
      return (bitField0_ & 0x00000008) != 0;
    }

    /**
     * <code>repeated .ActivityQuest Quests = 15;</code>
     * @return this
     */
    public ActivityPeriodic clearQuests() {
      bitField0_ &= ~0x00000008;
      quests.clear();
      return this;
    }

    /**
     * <code>repeated .ActivityQuest Quests = 15;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableQuests()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<ActivityQuest> getQuests() {
      return quests;
    }

    /**
     * <code>repeated .ActivityQuest Quests = 15;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<ActivityQuest> getMutableQuests() {
      bitField0_ |= 0x00000008;
      return quests;
    }

    /**
     * <code>repeated .ActivityQuest Quests = 15;</code>
     * @param value the quests to add
     * @return this
     */
    public ActivityPeriodic addQuests(final ActivityQuest value) {
      bitField0_ |= 0x00000008;
      quests.add(value);
      return this;
    }

    /**
     * <code>repeated .ActivityQuest Quests = 15;</code>
     * @param values the quests to add
     * @return this
     */
    public ActivityPeriodic addAllQuests(final ActivityQuest... values) {
      bitField0_ |= 0x00000008;
      quests.addAll(values);
      return this;
    }

    @Override
    public ActivityPeriodic copyFrom(final ActivityPeriodic other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        activityId = other.activityId;
        finalStatus = other.finalStatus;
        nextPackage.copyFrom(other.nextPackage);
        quests.copyFrom(other.quests);
      }
      return this;
    }

    @Override
    public ActivityPeriodic mergeFrom(final ActivityPeriodic other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasActivityId()) {
        setActivityId(other.activityId);
      }
      if (other.hasFinalStatus()) {
        setFinalStatus(other.finalStatus);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      if (other.hasQuests()) {
        getMutableQuests().addAll(other.quests);
      }
      return this;
    }

    @Override
    public ActivityPeriodic clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      activityId = 0;
      finalStatus = false;
      nextPackage.clear();
      quests.clear();
      return this;
    }

    @Override
    public ActivityPeriodic clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      quests.clearQuick();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof ActivityPeriodic)) {
        return false;
      }
      ActivityPeriodic other = (ActivityPeriodic) o;
      return bitField0_ == other.bitField0_
        && (!hasActivityId() || activityId == other.activityId)
        && (!hasFinalStatus() || finalStatus == other.finalStatus)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage))
        && (!hasQuests() || quests.equals(other.quests));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt32NoTag(activityId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 16);
        output.writeBoolNoTag(finalStatus);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        for (int i = 0; i < quests.length(); i++) {
          output.writeRawByte((byte) 122);
          output.writeMessageNoTag(quests.get(i));
        }
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(activityId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 2;
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        size += (1 * quests.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(quests);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public ActivityPeriodic mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            // activityId
            activityId = input.readUInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 16) {
              break;
            }
          }
          case 16: {
            // finalStatus
            finalStatus = input.readBool();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 122) {
              break;
            }
          }
          case 122: {
            // quests
            tag = input.readRepeatedMessage(quests, tag);
            bitField0_ |= 0x00000008;
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeUInt32(FieldNames.activityId, activityId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeBool(FieldNames.finalStatus, finalStatus);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeRepeatedMessage(FieldNames.quests, quests);
      }
      output.endObject();
    }

    @Override
    public ActivityPeriodic mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case -252882774: {
            if (input.isAtField(FieldNames.activityId)) {
              if (!input.trySkipNullValue()) {
                activityId = input.readUInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -541739800: {
            if (input.isAtField(FieldNames.finalStatus)) {
              if (!input.trySkipNullValue()) {
                finalStatus = input.readBool();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1864830991: {
            if (input.isAtField(FieldNames.quests)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedMessage(quests);
                bitField0_ |= 0x00000008;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public ActivityPeriodic clone() {
      return new ActivityPeriodic().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static ActivityPeriodic parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new ActivityPeriodic(), data).checkInitialized();
    }

    public static ActivityPeriodic parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new ActivityPeriodic(), input).checkInitialized();
    }

    public static ActivityPeriodic parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new ActivityPeriodic(), input).checkInitialized();
    }

    /**
     * @return factory for creating ActivityPeriodic messages
     */
    public static MessageFactory<ActivityPeriodic> getFactory() {
      return ActivityPeriodicFactory.INSTANCE;
    }

    private enum ActivityPeriodicFactory implements MessageFactory<ActivityPeriodic> {
      INSTANCE;

      @Override
      public ActivityPeriodic create() {
        return ActivityPeriodic.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName activityId = FieldName.forField("ActivityId");

      static final FieldName finalStatus = FieldName.forField("FinalStatus");

      static final FieldName nextPackage = FieldName.forField("NextPackage");

      static final FieldName quests = FieldName.forField("Quests");
    }
  }

  /**
   * Protobuf type {@code ActivityLogin}
   */
  public static final class ActivityLogin extends ProtoMessage<ActivityLogin> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional uint32 ActivityId = 1;</code>
     */
    private int activityId;

    /**
     * <code>optional uint32 Receive = 2;</code>
     */
    private int receive;

    /**
     * <code>optional uint32 Actual = 3;</code>
     */
    private int actual;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    private ActivityLogin() {
    }

    /**
     * @return a new empty instance of {@code ActivityLogin}
     */
    public static ActivityLogin newInstance() {
      return new ActivityLogin();
    }

    /**
     * <code>optional uint32 ActivityId = 1;</code>
     * @return whether the activityId field is set
     */
    public boolean hasActivityId() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional uint32 ActivityId = 1;</code>
     * @return this
     */
    public ActivityLogin clearActivityId() {
      bitField0_ &= ~0x00000001;
      activityId = 0;
      return this;
    }

    /**
     * <code>optional uint32 ActivityId = 1;</code>
     * @return the activityId
     */
    public int getActivityId() {
      return activityId;
    }

    /**
     * <code>optional uint32 ActivityId = 1;</code>
     * @param value the activityId to set
     * @return this
     */
    public ActivityLogin setActivityId(final int value) {
      bitField0_ |= 0x00000001;
      activityId = value;
      return this;
    }

    /**
     * <code>optional uint32 Receive = 2;</code>
     * @return whether the receive field is set
     */
    public boolean hasReceive() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional uint32 Receive = 2;</code>
     * @return this
     */
    public ActivityLogin clearReceive() {
      bitField0_ &= ~0x00000002;
      receive = 0;
      return this;
    }

    /**
     * <code>optional uint32 Receive = 2;</code>
     * @return the receive
     */
    public int getReceive() {
      return receive;
    }

    /**
     * <code>optional uint32 Receive = 2;</code>
     * @param value the receive to set
     * @return this
     */
    public ActivityLogin setReceive(final int value) {
      bitField0_ |= 0x00000002;
      receive = value;
      return this;
    }

    /**
     * <code>optional uint32 Actual = 3;</code>
     * @return whether the actual field is set
     */
    public boolean hasActual() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional uint32 Actual = 3;</code>
     * @return this
     */
    public ActivityLogin clearActual() {
      bitField0_ &= ~0x00000004;
      actual = 0;
      return this;
    }

    /**
     * <code>optional uint32 Actual = 3;</code>
     * @return the actual
     */
    public int getActual() {
      return actual;
    }

    /**
     * <code>optional uint32 Actual = 3;</code>
     * @param value the actual to set
     * @return this
     */
    public ActivityLogin setActual(final int value) {
      bitField0_ |= 0x00000004;
      actual = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000008) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public ActivityLogin clearNextPackage() {
      bitField0_ &= ~0x00000008;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000008;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public ActivityLogin addNextPackage(final byte value) {
      bitField0_ |= 0x00000008;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public ActivityLogin addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000008;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public ActivityLogin setNextPackage(final byte... values) {
      bitField0_ |= 0x00000008;
      nextPackage.copyFrom(values);
      return this;
    }

    @Override
    public ActivityLogin copyFrom(final ActivityLogin other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        activityId = other.activityId;
        receive = other.receive;
        actual = other.actual;
        nextPackage.copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public ActivityLogin mergeFrom(final ActivityLogin other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasActivityId()) {
        setActivityId(other.activityId);
      }
      if (other.hasReceive()) {
        setReceive(other.receive);
      }
      if (other.hasActual()) {
        setActual(other.actual);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public ActivityLogin clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      activityId = 0;
      receive = 0;
      actual = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public ActivityLogin clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof ActivityLogin)) {
        return false;
      }
      ActivityLogin other = (ActivityLogin) o;
      return bitField0_ == other.bitField0_
        && (!hasActivityId() || activityId == other.activityId)
        && (!hasReceive() || receive == other.receive)
        && (!hasActual() || actual == other.actual)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt32NoTag(activityId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 16);
        output.writeUInt32NoTag(receive);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawByte((byte) 24);
        output.writeUInt32NoTag(actual);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(activityId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(receive);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(actual);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public ActivityLogin mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            // activityId
            activityId = input.readUInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 16) {
              break;
            }
          }
          case 16: {
            // receive
            receive = input.readUInt32();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 24) {
              break;
            }
          }
          case 24: {
            // actual
            actual = input.readUInt32();
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000008;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeUInt32(FieldNames.activityId, activityId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeUInt32(FieldNames.receive, receive);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeUInt32(FieldNames.actual, actual);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      output.endObject();
    }

    @Override
    public ActivityLogin mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case -252882774: {
            if (input.isAtField(FieldNames.activityId)) {
              if (!input.trySkipNullValue()) {
                activityId = input.readUInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1548023101: {
            if (input.isAtField(FieldNames.receive)) {
              if (!input.trySkipNullValue()) {
                receive = input.readUInt32();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 1955894702: {
            if (input.isAtField(FieldNames.actual)) {
              if (!input.trySkipNullValue()) {
                actual = input.readUInt32();
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000008;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public ActivityLogin clone() {
      return new ActivityLogin().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static ActivityLogin parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new ActivityLogin(), data).checkInitialized();
    }

    public static ActivityLogin parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new ActivityLogin(), input).checkInitialized();
    }

    public static ActivityLogin parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new ActivityLogin(), input).checkInitialized();
    }

    /**
     * @return factory for creating ActivityLogin messages
     */
    public static MessageFactory<ActivityLogin> getFactory() {
      return ActivityLoginFactory.INSTANCE;
    }

    private enum ActivityLoginFactory implements MessageFactory<ActivityLogin> {
      INSTANCE;

      @Override
      public ActivityLogin create() {
        return ActivityLogin.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName activityId = FieldName.forField("ActivityId");

      static final FieldName receive = FieldName.forField("Receive");

      static final FieldName actual = FieldName.forField("Actual");

      static final FieldName nextPackage = FieldName.forField("NextPackage");
    }
  }

  /**
   * Protobuf type {@code ActivityMining}
   */
  public static final class ActivityMining extends ProtoMessage<ActivityMining> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional uint32 ActivityId = 1;</code>
     */
    private int activityId;

    /**
     * <code>optional uint32 Layer = 2;</code>
     */
    private int layer;

    /**
     * <code>optional uint32 Score = 3;</code>
     */
    private int score;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    /**
     * <code>repeated .ActivityQuest Quests = 11;</code>
     */
    private final RepeatedMessage<ActivityQuest> quests = RepeatedMessage.newEmptyInstance(ActivityQuest.getFactory());

    private ActivityMining() {
    }

    /**
     * @return a new empty instance of {@code ActivityMining}
     */
    public static ActivityMining newInstance() {
      return new ActivityMining();
    }

    /**
     * <code>optional uint32 ActivityId = 1;</code>
     * @return whether the activityId field is set
     */
    public boolean hasActivityId() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional uint32 ActivityId = 1;</code>
     * @return this
     */
    public ActivityMining clearActivityId() {
      bitField0_ &= ~0x00000001;
      activityId = 0;
      return this;
    }

    /**
     * <code>optional uint32 ActivityId = 1;</code>
     * @return the activityId
     */
    public int getActivityId() {
      return activityId;
    }

    /**
     * <code>optional uint32 ActivityId = 1;</code>
     * @param value the activityId to set
     * @return this
     */
    public ActivityMining setActivityId(final int value) {
      bitField0_ |= 0x00000001;
      activityId = value;
      return this;
    }

    /**
     * <code>optional uint32 Layer = 2;</code>
     * @return whether the layer field is set
     */
    public boolean hasLayer() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional uint32 Layer = 2;</code>
     * @return this
     */
    public ActivityMining clearLayer() {
      bitField0_ &= ~0x00000002;
      layer = 0;
      return this;
    }

    /**
     * <code>optional uint32 Layer = 2;</code>
     * @return the layer
     */
    public int getLayer() {
      return layer;
    }

    /**
     * <code>optional uint32 Layer = 2;</code>
     * @param value the layer to set
     * @return this
     */
    public ActivityMining setLayer(final int value) {
      bitField0_ |= 0x00000002;
      layer = value;
      return this;
    }

    /**
     * <code>optional uint32 Score = 3;</code>
     * @return whether the score field is set
     */
    public boolean hasScore() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional uint32 Score = 3;</code>
     * @return this
     */
    public ActivityMining clearScore() {
      bitField0_ &= ~0x00000004;
      score = 0;
      return this;
    }

    /**
     * <code>optional uint32 Score = 3;</code>
     * @return the score
     */
    public int getScore() {
      return score;
    }

    /**
     * <code>optional uint32 Score = 3;</code>
     * @param value the score to set
     * @return this
     */
    public ActivityMining setScore(final int value) {
      bitField0_ |= 0x00000004;
      score = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000008) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public ActivityMining clearNextPackage() {
      bitField0_ &= ~0x00000008;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000008;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public ActivityMining addNextPackage(final byte value) {
      bitField0_ |= 0x00000008;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public ActivityMining addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000008;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public ActivityMining setNextPackage(final byte... values) {
      bitField0_ |= 0x00000008;
      nextPackage.copyFrom(values);
      return this;
    }

    /**
     * <code>repeated .ActivityQuest Quests = 11;</code>
     * @return whether the quests field is set
     */
    public boolean hasQuests() {
      return (bitField0_ & 0x00000010) != 0;
    }

    /**
     * <code>repeated .ActivityQuest Quests = 11;</code>
     * @return this
     */
    public ActivityMining clearQuests() {
      bitField0_ &= ~0x00000010;
      quests.clear();
      return this;
    }

    /**
     * <code>repeated .ActivityQuest Quests = 11;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableQuests()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<ActivityQuest> getQuests() {
      return quests;
    }

    /**
     * <code>repeated .ActivityQuest Quests = 11;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<ActivityQuest> getMutableQuests() {
      bitField0_ |= 0x00000010;
      return quests;
    }

    /**
     * <code>repeated .ActivityQuest Quests = 11;</code>
     * @param value the quests to add
     * @return this
     */
    public ActivityMining addQuests(final ActivityQuest value) {
      bitField0_ |= 0x00000010;
      quests.add(value);
      return this;
    }

    /**
     * <code>repeated .ActivityQuest Quests = 11;</code>
     * @param values the quests to add
     * @return this
     */
    public ActivityMining addAllQuests(final ActivityQuest... values) {
      bitField0_ |= 0x00000010;
      quests.addAll(values);
      return this;
    }

    @Override
    public ActivityMining copyFrom(final ActivityMining other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        activityId = other.activityId;
        layer = other.layer;
        score = other.score;
        nextPackage.copyFrom(other.nextPackage);
        quests.copyFrom(other.quests);
      }
      return this;
    }

    @Override
    public ActivityMining mergeFrom(final ActivityMining other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasActivityId()) {
        setActivityId(other.activityId);
      }
      if (other.hasLayer()) {
        setLayer(other.layer);
      }
      if (other.hasScore()) {
        setScore(other.score);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      if (other.hasQuests()) {
        getMutableQuests().addAll(other.quests);
      }
      return this;
    }

    @Override
    public ActivityMining clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      activityId = 0;
      layer = 0;
      score = 0;
      nextPackage.clear();
      quests.clear();
      return this;
    }

    @Override
    public ActivityMining clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      quests.clearQuick();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof ActivityMining)) {
        return false;
      }
      ActivityMining other = (ActivityMining) o;
      return bitField0_ == other.bitField0_
        && (!hasActivityId() || activityId == other.activityId)
        && (!hasLayer() || layer == other.layer)
        && (!hasScore() || score == other.score)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage))
        && (!hasQuests() || quests.equals(other.quests));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt32NoTag(activityId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 16);
        output.writeUInt32NoTag(layer);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawByte((byte) 24);
        output.writeUInt32NoTag(score);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        for (int i = 0; i < quests.length(); i++) {
          output.writeRawByte((byte) 90);
          output.writeMessageNoTag(quests.get(i));
        }
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(activityId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(layer);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(score);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        size += (1 * quests.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(quests);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public ActivityMining mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            // activityId
            activityId = input.readUInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 16) {
              break;
            }
          }
          case 16: {
            // layer
            layer = input.readUInt32();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 24) {
              break;
            }
          }
          case 24: {
            // score
            score = input.readUInt32();
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000008;
            tag = input.readTag();
            if (tag != 90) {
              break;
            }
          }
          case 90: {
            // quests
            tag = input.readRepeatedMessage(quests, tag);
            bitField0_ |= 0x00000010;
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeUInt32(FieldNames.activityId, activityId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeUInt32(FieldNames.layer, layer);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeUInt32(FieldNames.score, score);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        output.writeRepeatedMessage(FieldNames.quests, quests);
      }
      output.endObject();
    }

    @Override
    public ActivityMining mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case -252882774: {
            if (input.isAtField(FieldNames.activityId)) {
              if (!input.trySkipNullValue()) {
                activityId = input.readUInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 73196849: {
            if (input.isAtField(FieldNames.layer)) {
              if (!input.trySkipNullValue()) {
                layer = input.readUInt32();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 79711858: {
            if (input.isAtField(FieldNames.score)) {
              if (!input.trySkipNullValue()) {
                score = input.readUInt32();
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000008;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1864830991: {
            if (input.isAtField(FieldNames.quests)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedMessage(quests);
                bitField0_ |= 0x00000010;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public ActivityMining clone() {
      return new ActivityMining().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static ActivityMining parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new ActivityMining(), data).checkInitialized();
    }

    public static ActivityMining parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new ActivityMining(), input).checkInitialized();
    }

    public static ActivityMining parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new ActivityMining(), input).checkInitialized();
    }

    /**
     * @return factory for creating ActivityMining messages
     */
    public static MessageFactory<ActivityMining> getFactory() {
      return ActivityMiningFactory.INSTANCE;
    }

    private enum ActivityMiningFactory implements MessageFactory<ActivityMining> {
      INSTANCE;

      @Override
      public ActivityMining create() {
        return ActivityMining.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName activityId = FieldName.forField("ActivityId");

      static final FieldName layer = FieldName.forField("Layer");

      static final FieldName score = FieldName.forField("Score");

      static final FieldName nextPackage = FieldName.forField("NextPackage");

      static final FieldName quests = FieldName.forField("Quests");
    }
  }

  /**
   * Protobuf type {@code ActivityCookieLevel}
   */
  public static final class ActivityCookieLevel extends ProtoMessage<ActivityCookieLevel> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional uint32 ActivityId = 1;</code>
     */
    private int activityId;

    /**
     * <code>optional uint32 LevelId = 2;</code>
     */
    private int levelId;

    /**
     * <code>optional uint32 MaxScore = 3;</code>
     */
    private int maxScore;

    /**
     * <code>optional bool FirstComplete = 4;</code>
     */
    private boolean firstComplete;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    private ActivityCookieLevel() {
    }

    /**
     * @return a new empty instance of {@code ActivityCookieLevel}
     */
    public static ActivityCookieLevel newInstance() {
      return new ActivityCookieLevel();
    }

    /**
     * <code>optional uint32 ActivityId = 1;</code>
     * @return whether the activityId field is set
     */
    public boolean hasActivityId() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional uint32 ActivityId = 1;</code>
     * @return this
     */
    public ActivityCookieLevel clearActivityId() {
      bitField0_ &= ~0x00000001;
      activityId = 0;
      return this;
    }

    /**
     * <code>optional uint32 ActivityId = 1;</code>
     * @return the activityId
     */
    public int getActivityId() {
      return activityId;
    }

    /**
     * <code>optional uint32 ActivityId = 1;</code>
     * @param value the activityId to set
     * @return this
     */
    public ActivityCookieLevel setActivityId(final int value) {
      bitField0_ |= 0x00000001;
      activityId = value;
      return this;
    }

    /**
     * <code>optional uint32 LevelId = 2;</code>
     * @return whether the levelId field is set
     */
    public boolean hasLevelId() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional uint32 LevelId = 2;</code>
     * @return this
     */
    public ActivityCookieLevel clearLevelId() {
      bitField0_ &= ~0x00000002;
      levelId = 0;
      return this;
    }

    /**
     * <code>optional uint32 LevelId = 2;</code>
     * @return the levelId
     */
    public int getLevelId() {
      return levelId;
    }

    /**
     * <code>optional uint32 LevelId = 2;</code>
     * @param value the levelId to set
     * @return this
     */
    public ActivityCookieLevel setLevelId(final int value) {
      bitField0_ |= 0x00000002;
      levelId = value;
      return this;
    }

    /**
     * <code>optional uint32 MaxScore = 3;</code>
     * @return whether the maxScore field is set
     */
    public boolean hasMaxScore() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional uint32 MaxScore = 3;</code>
     * @return this
     */
    public ActivityCookieLevel clearMaxScore() {
      bitField0_ &= ~0x00000004;
      maxScore = 0;
      return this;
    }

    /**
     * <code>optional uint32 MaxScore = 3;</code>
     * @return the maxScore
     */
    public int getMaxScore() {
      return maxScore;
    }

    /**
     * <code>optional uint32 MaxScore = 3;</code>
     * @param value the maxScore to set
     * @return this
     */
    public ActivityCookieLevel setMaxScore(final int value) {
      bitField0_ |= 0x00000004;
      maxScore = value;
      return this;
    }

    /**
     * <code>optional bool FirstComplete = 4;</code>
     * @return whether the firstComplete field is set
     */
    public boolean hasFirstComplete() {
      return (bitField0_ & 0x00000008) != 0;
    }

    /**
     * <code>optional bool FirstComplete = 4;</code>
     * @return this
     */
    public ActivityCookieLevel clearFirstComplete() {
      bitField0_ &= ~0x00000008;
      firstComplete = false;
      return this;
    }

    /**
     * <code>optional bool FirstComplete = 4;</code>
     * @return the firstComplete
     */
    public boolean getFirstComplete() {
      return firstComplete;
    }

    /**
     * <code>optional bool FirstComplete = 4;</code>
     * @param value the firstComplete to set
     * @return this
     */
    public ActivityCookieLevel setFirstComplete(final boolean value) {
      bitField0_ |= 0x00000008;
      firstComplete = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000010) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public ActivityCookieLevel clearNextPackage() {
      bitField0_ &= ~0x00000010;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000010;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public ActivityCookieLevel addNextPackage(final byte value) {
      bitField0_ |= 0x00000010;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public ActivityCookieLevel addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000010;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public ActivityCookieLevel setNextPackage(final byte... values) {
      bitField0_ |= 0x00000010;
      nextPackage.copyFrom(values);
      return this;
    }

    @Override
    public ActivityCookieLevel copyFrom(final ActivityCookieLevel other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        activityId = other.activityId;
        levelId = other.levelId;
        maxScore = other.maxScore;
        firstComplete = other.firstComplete;
        nextPackage.copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public ActivityCookieLevel mergeFrom(final ActivityCookieLevel other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasActivityId()) {
        setActivityId(other.activityId);
      }
      if (other.hasLevelId()) {
        setLevelId(other.levelId);
      }
      if (other.hasMaxScore()) {
        setMaxScore(other.maxScore);
      }
      if (other.hasFirstComplete()) {
        setFirstComplete(other.firstComplete);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public ActivityCookieLevel clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      activityId = 0;
      levelId = 0;
      maxScore = 0;
      firstComplete = false;
      nextPackage.clear();
      return this;
    }

    @Override
    public ActivityCookieLevel clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof ActivityCookieLevel)) {
        return false;
      }
      ActivityCookieLevel other = (ActivityCookieLevel) o;
      return bitField0_ == other.bitField0_
        && (!hasActivityId() || activityId == other.activityId)
        && (!hasLevelId() || levelId == other.levelId)
        && (!hasMaxScore() || maxScore == other.maxScore)
        && (!hasFirstComplete() || firstComplete == other.firstComplete)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt32NoTag(activityId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 16);
        output.writeUInt32NoTag(levelId);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawByte((byte) 24);
        output.writeUInt32NoTag(maxScore);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeRawByte((byte) 32);
        output.writeBoolNoTag(firstComplete);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(activityId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(levelId);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(maxScore);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        size += 2;
      }
      if ((bitField0_ & 0x00000010) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public ActivityCookieLevel mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            // activityId
            activityId = input.readUInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 16) {
              break;
            }
          }
          case 16: {
            // levelId
            levelId = input.readUInt32();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 24) {
              break;
            }
          }
          case 24: {
            // maxScore
            maxScore = input.readUInt32();
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 32) {
              break;
            }
          }
          case 32: {
            // firstComplete
            firstComplete = input.readBool();
            bitField0_ |= 0x00000008;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000010;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeUInt32(FieldNames.activityId, activityId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeUInt32(FieldNames.levelId, levelId);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeUInt32(FieldNames.maxScore, maxScore);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeBool(FieldNames.firstComplete, firstComplete);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      output.endObject();
    }

    @Override
    public ActivityCookieLevel mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case -252882774: {
            if (input.isAtField(FieldNames.activityId)) {
              if (!input.trySkipNullValue()) {
                activityId = input.readUInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 1734437791: {
            if (input.isAtField(FieldNames.levelId)) {
              if (!input.trySkipNullValue()) {
                levelId = input.readUInt32();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 461163438: {
            if (input.isAtField(FieldNames.maxScore)) {
              if (!input.trySkipNullValue()) {
                maxScore = input.readUInt32();
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 2041047017: {
            if (input.isAtField(FieldNames.firstComplete)) {
              if (!input.trySkipNullValue()) {
                firstComplete = input.readBool();
                bitField0_ |= 0x00000008;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000010;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public ActivityCookieLevel clone() {
      return new ActivityCookieLevel().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static ActivityCookieLevel parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new ActivityCookieLevel(), data).checkInitialized();
    }

    public static ActivityCookieLevel parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new ActivityCookieLevel(), input).checkInitialized();
    }

    public static ActivityCookieLevel parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new ActivityCookieLevel(), input).checkInitialized();
    }

    /**
     * @return factory for creating ActivityCookieLevel messages
     */
    public static MessageFactory<ActivityCookieLevel> getFactory() {
      return ActivityCookieLevelFactory.INSTANCE;
    }

    private enum ActivityCookieLevelFactory implements MessageFactory<ActivityCookieLevel> {
      INSTANCE;

      @Override
      public ActivityCookieLevel create() {
        return ActivityCookieLevel.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName activityId = FieldName.forField("ActivityId");

      static final FieldName levelId = FieldName.forField("LevelId");

      static final FieldName maxScore = FieldName.forField("MaxScore");

      static final FieldName firstComplete = FieldName.forField("FirstComplete");

      static final FieldName nextPackage = FieldName.forField("NextPackage");
    }
  }

  /**
   * Protobuf type {@code ActivityCookie}
   */
  public static final class ActivityCookie extends ProtoMessage<ActivityCookie> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional uint32 ActivityId = 1;</code>
     */
    private int activityId;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    /**
     * <code>repeated .ActivityQuest Quests = 11;</code>
     */
    private final RepeatedMessage<ActivityQuest> quests = RepeatedMessage.newEmptyInstance(ActivityQuest.getFactory());

    /**
     * <code>repeated .ActivityCookieLevel Levels = 12;</code>
     */
    private final RepeatedMessage<ActivityCookieLevel> levels = RepeatedMessage.newEmptyInstance(ActivityCookieLevel.getFactory());

    private ActivityCookie() {
    }

    /**
     * @return a new empty instance of {@code ActivityCookie}
     */
    public static ActivityCookie newInstance() {
      return new ActivityCookie();
    }

    /**
     * <code>optional uint32 ActivityId = 1;</code>
     * @return whether the activityId field is set
     */
    public boolean hasActivityId() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional uint32 ActivityId = 1;</code>
     * @return this
     */
    public ActivityCookie clearActivityId() {
      bitField0_ &= ~0x00000001;
      activityId = 0;
      return this;
    }

    /**
     * <code>optional uint32 ActivityId = 1;</code>
     * @return the activityId
     */
    public int getActivityId() {
      return activityId;
    }

    /**
     * <code>optional uint32 ActivityId = 1;</code>
     * @param value the activityId to set
     * @return this
     */
    public ActivityCookie setActivityId(final int value) {
      bitField0_ |= 0x00000001;
      activityId = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public ActivityCookie clearNextPackage() {
      bitField0_ &= ~0x00000002;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000002;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public ActivityCookie addNextPackage(final byte value) {
      bitField0_ |= 0x00000002;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public ActivityCookie addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000002;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public ActivityCookie setNextPackage(final byte... values) {
      bitField0_ |= 0x00000002;
      nextPackage.copyFrom(values);
      return this;
    }

    /**
     * <code>repeated .ActivityQuest Quests = 11;</code>
     * @return whether the quests field is set
     */
    public boolean hasQuests() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>repeated .ActivityQuest Quests = 11;</code>
     * @return this
     */
    public ActivityCookie clearQuests() {
      bitField0_ &= ~0x00000004;
      quests.clear();
      return this;
    }

    /**
     * <code>repeated .ActivityQuest Quests = 11;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableQuests()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<ActivityQuest> getQuests() {
      return quests;
    }

    /**
     * <code>repeated .ActivityQuest Quests = 11;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<ActivityQuest> getMutableQuests() {
      bitField0_ |= 0x00000004;
      return quests;
    }

    /**
     * <code>repeated .ActivityQuest Quests = 11;</code>
     * @param value the quests to add
     * @return this
     */
    public ActivityCookie addQuests(final ActivityQuest value) {
      bitField0_ |= 0x00000004;
      quests.add(value);
      return this;
    }

    /**
     * <code>repeated .ActivityQuest Quests = 11;</code>
     * @param values the quests to add
     * @return this
     */
    public ActivityCookie addAllQuests(final ActivityQuest... values) {
      bitField0_ |= 0x00000004;
      quests.addAll(values);
      return this;
    }

    /**
     * <code>repeated .ActivityCookieLevel Levels = 12;</code>
     * @return whether the levels field is set
     */
    public boolean hasLevels() {
      return (bitField0_ & 0x00000008) != 0;
    }

    /**
     * <code>repeated .ActivityCookieLevel Levels = 12;</code>
     * @return this
     */
    public ActivityCookie clearLevels() {
      bitField0_ &= ~0x00000008;
      levels.clear();
      return this;
    }

    /**
     * <code>repeated .ActivityCookieLevel Levels = 12;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableLevels()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<ActivityCookieLevel> getLevels() {
      return levels;
    }

    /**
     * <code>repeated .ActivityCookieLevel Levels = 12;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<ActivityCookieLevel> getMutableLevels() {
      bitField0_ |= 0x00000008;
      return levels;
    }

    /**
     * <code>repeated .ActivityCookieLevel Levels = 12;</code>
     * @param value the levels to add
     * @return this
     */
    public ActivityCookie addLevels(final ActivityCookieLevel value) {
      bitField0_ |= 0x00000008;
      levels.add(value);
      return this;
    }

    /**
     * <code>repeated .ActivityCookieLevel Levels = 12;</code>
     * @param values the levels to add
     * @return this
     */
    public ActivityCookie addAllLevels(final ActivityCookieLevel... values) {
      bitField0_ |= 0x00000008;
      levels.addAll(values);
      return this;
    }

    @Override
    public ActivityCookie copyFrom(final ActivityCookie other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        activityId = other.activityId;
        nextPackage.copyFrom(other.nextPackage);
        quests.copyFrom(other.quests);
        levels.copyFrom(other.levels);
      }
      return this;
    }

    @Override
    public ActivityCookie mergeFrom(final ActivityCookie other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasActivityId()) {
        setActivityId(other.activityId);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      if (other.hasQuests()) {
        getMutableQuests().addAll(other.quests);
      }
      if (other.hasLevels()) {
        getMutableLevels().addAll(other.levels);
      }
      return this;
    }

    @Override
    public ActivityCookie clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      activityId = 0;
      nextPackage.clear();
      quests.clear();
      levels.clear();
      return this;
    }

    @Override
    public ActivityCookie clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      quests.clearQuick();
      levels.clearQuick();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof ActivityCookie)) {
        return false;
      }
      ActivityCookie other = (ActivityCookie) o;
      return bitField0_ == other.bitField0_
        && (!hasActivityId() || activityId == other.activityId)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage))
        && (!hasQuests() || quests.equals(other.quests))
        && (!hasLevels() || levels.equals(other.levels));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt32NoTag(activityId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        for (int i = 0; i < quests.length(); i++) {
          output.writeRawByte((byte) 90);
          output.writeMessageNoTag(quests.get(i));
        }
      }
      if ((bitField0_ & 0x00000008) != 0) {
        for (int i = 0; i < levels.length(); i++) {
          output.writeRawByte((byte) 98);
          output.writeMessageNoTag(levels.get(i));
        }
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(activityId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += (1 * quests.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(quests);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        size += (1 * levels.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(levels);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public ActivityCookie mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            // activityId
            activityId = input.readUInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 90) {
              break;
            }
          }
          case 90: {
            // quests
            tag = input.readRepeatedMessage(quests, tag);
            bitField0_ |= 0x00000004;
            if (tag != 98) {
              break;
            }
          }
          case 98: {
            // levels
            tag = input.readRepeatedMessage(levels, tag);
            bitField0_ |= 0x00000008;
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeUInt32(FieldNames.activityId, activityId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRepeatedMessage(FieldNames.quests, quests);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeRepeatedMessage(FieldNames.levels, levels);
      }
      output.endObject();
    }

    @Override
    public ActivityCookie mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case -252882774: {
            if (input.isAtField(FieldNames.activityId)) {
              if (!input.trySkipNullValue()) {
                activityId = input.readUInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1864830991: {
            if (input.isAtField(FieldNames.quests)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedMessage(quests);
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2022260337: {
            if (input.isAtField(FieldNames.levels)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedMessage(levels);
                bitField0_ |= 0x00000008;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public ActivityCookie clone() {
      return new ActivityCookie().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static ActivityCookie parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new ActivityCookie(), data).checkInitialized();
    }

    public static ActivityCookie parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new ActivityCookie(), input).checkInitialized();
    }

    public static ActivityCookie parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new ActivityCookie(), input).checkInitialized();
    }

    /**
     * @return factory for creating ActivityCookie messages
     */
    public static MessageFactory<ActivityCookie> getFactory() {
      return ActivityCookieFactory.INSTANCE;
    }

    private enum ActivityCookieFactory implements MessageFactory<ActivityCookie> {
      INSTANCE;

      @Override
      public ActivityCookie create() {
        return ActivityCookie.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName activityId = FieldName.forField("ActivityId");

      static final FieldName nextPackage = FieldName.forField("NextPackage");

      static final FieldName quests = FieldName.forField("Quests");

      static final FieldName levels = FieldName.forField("Levels");
    }
  }

  /**
   * Protobuf type {@code ActivityTowerDefenseLevel}
   */
  public static final class ActivityTowerDefenseLevel extends ProtoMessage<ActivityTowerDefenseLevel> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional uint32 Id = 1;</code>
     */
    private int id;

    /**
     * <code>optional uint32 Star = 2;</code>
     */
    private int star;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    private ActivityTowerDefenseLevel() {
    }

    /**
     * @return a new empty instance of {@code ActivityTowerDefenseLevel}
     */
    public static ActivityTowerDefenseLevel newInstance() {
      return new ActivityTowerDefenseLevel();
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @return whether the id field is set
     */
    public boolean hasId() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @return this
     */
    public ActivityTowerDefenseLevel clearId() {
      bitField0_ &= ~0x00000001;
      id = 0;
      return this;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @return the id
     */
    public int getId() {
      return id;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @param value the id to set
     * @return this
     */
    public ActivityTowerDefenseLevel setId(final int value) {
      bitField0_ |= 0x00000001;
      id = value;
      return this;
    }

    /**
     * <code>optional uint32 Star = 2;</code>
     * @return whether the star field is set
     */
    public boolean hasStar() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional uint32 Star = 2;</code>
     * @return this
     */
    public ActivityTowerDefenseLevel clearStar() {
      bitField0_ &= ~0x00000002;
      star = 0;
      return this;
    }

    /**
     * <code>optional uint32 Star = 2;</code>
     * @return the star
     */
    public int getStar() {
      return star;
    }

    /**
     * <code>optional uint32 Star = 2;</code>
     * @param value the star to set
     * @return this
     */
    public ActivityTowerDefenseLevel setStar(final int value) {
      bitField0_ |= 0x00000002;
      star = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public ActivityTowerDefenseLevel clearNextPackage() {
      bitField0_ &= ~0x00000004;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000004;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public ActivityTowerDefenseLevel addNextPackage(final byte value) {
      bitField0_ |= 0x00000004;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public ActivityTowerDefenseLevel addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000004;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public ActivityTowerDefenseLevel setNextPackage(final byte... values) {
      bitField0_ |= 0x00000004;
      nextPackage.copyFrom(values);
      return this;
    }

    @Override
    public ActivityTowerDefenseLevel copyFrom(final ActivityTowerDefenseLevel other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        id = other.id;
        star = other.star;
        nextPackage.copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public ActivityTowerDefenseLevel mergeFrom(final ActivityTowerDefenseLevel other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasId()) {
        setId(other.id);
      }
      if (other.hasStar()) {
        setStar(other.star);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public ActivityTowerDefenseLevel clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      id = 0;
      star = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public ActivityTowerDefenseLevel clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof ActivityTowerDefenseLevel)) {
        return false;
      }
      ActivityTowerDefenseLevel other = (ActivityTowerDefenseLevel) o;
      return bitField0_ == other.bitField0_
        && (!hasId() || id == other.id)
        && (!hasStar() || star == other.star)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt32NoTag(id);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 16);
        output.writeUInt32NoTag(star);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(id);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(star);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public ActivityTowerDefenseLevel mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            // id
            id = input.readUInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 16) {
              break;
            }
          }
          case 16: {
            // star
            star = input.readUInt32();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeUInt32(FieldNames.id, id);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeUInt32(FieldNames.star, star);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      output.endObject();
    }

    @Override
    public ActivityTowerDefenseLevel mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 2363: {
            if (input.isAtField(FieldNames.id)) {
              if (!input.trySkipNullValue()) {
                id = input.readUInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 2587250: {
            if (input.isAtField(FieldNames.star)) {
              if (!input.trySkipNullValue()) {
                star = input.readUInt32();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public ActivityTowerDefenseLevel clone() {
      return new ActivityTowerDefenseLevel().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static ActivityTowerDefenseLevel parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new ActivityTowerDefenseLevel(), data).checkInitialized();
    }

    public static ActivityTowerDefenseLevel parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new ActivityTowerDefenseLevel(), input).checkInitialized();
    }

    public static ActivityTowerDefenseLevel parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new ActivityTowerDefenseLevel(), input).checkInitialized();
    }

    /**
     * @return factory for creating ActivityTowerDefenseLevel messages
     */
    public static MessageFactory<ActivityTowerDefenseLevel> getFactory() {
      return ActivityTowerDefenseLevelFactory.INSTANCE;
    }

    private enum ActivityTowerDefenseLevelFactory implements MessageFactory<ActivityTowerDefenseLevel> {
      INSTANCE;

      @Override
      public ActivityTowerDefenseLevel create() {
        return ActivityTowerDefenseLevel.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName id = FieldName.forField("Id");

      static final FieldName star = FieldName.forField("Star");

      static final FieldName nextPackage = FieldName.forField("NextPackage");
    }
  }

  /**
   * Protobuf type {@code ActivityTowerDefense}
   */
  public static final class ActivityTowerDefense extends ProtoMessage<ActivityTowerDefense> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional uint32 ActivityId = 1;</code>
     */
    private int activityId;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    /**
     * <code>repeated uint32 Stories = 2;</code>
     */
    private final RepeatedInt stories = RepeatedInt.newEmptyInstance();

    /**
     * <code>repeated .ActivityTowerDefenseLevel Levels = 3;</code>
     */
    private final RepeatedMessage<ActivityTowerDefenseLevel> levels = RepeatedMessage.newEmptyInstance(ActivityTowerDefenseLevel.getFactory());

    /**
     * <code>repeated .ActivityQuest Quests = 11;</code>
     */
    private final RepeatedMessage<ActivityQuest> quests = RepeatedMessage.newEmptyInstance(ActivityQuest.getFactory());

    private ActivityTowerDefense() {
    }

    /**
     * @return a new empty instance of {@code ActivityTowerDefense}
     */
    public static ActivityTowerDefense newInstance() {
      return new ActivityTowerDefense();
    }

    /**
     * <code>optional uint32 ActivityId = 1;</code>
     * @return whether the activityId field is set
     */
    public boolean hasActivityId() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional uint32 ActivityId = 1;</code>
     * @return this
     */
    public ActivityTowerDefense clearActivityId() {
      bitField0_ &= ~0x00000001;
      activityId = 0;
      return this;
    }

    /**
     * <code>optional uint32 ActivityId = 1;</code>
     * @return the activityId
     */
    public int getActivityId() {
      return activityId;
    }

    /**
     * <code>optional uint32 ActivityId = 1;</code>
     * @param value the activityId to set
     * @return this
     */
    public ActivityTowerDefense setActivityId(final int value) {
      bitField0_ |= 0x00000001;
      activityId = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public ActivityTowerDefense clearNextPackage() {
      bitField0_ &= ~0x00000002;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000002;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public ActivityTowerDefense addNextPackage(final byte value) {
      bitField0_ |= 0x00000002;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public ActivityTowerDefense addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000002;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public ActivityTowerDefense setNextPackage(final byte... values) {
      bitField0_ |= 0x00000002;
      nextPackage.copyFrom(values);
      return this;
    }

    /**
     * <code>repeated uint32 Stories = 2;</code>
     * @return whether the stories field is set
     */
    public boolean hasStories() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>repeated uint32 Stories = 2;</code>
     * @return this
     */
    public ActivityTowerDefense clearStories() {
      bitField0_ &= ~0x00000004;
      stories.clear();
      return this;
    }

    /**
     * <code>repeated uint32 Stories = 2;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableStories()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedInt getStories() {
      return stories;
    }

    /**
     * <code>repeated uint32 Stories = 2;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedInt getMutableStories() {
      bitField0_ |= 0x00000004;
      return stories;
    }

    /**
     * <code>repeated uint32 Stories = 2;</code>
     * @param value the stories to add
     * @return this
     */
    public ActivityTowerDefense addStories(final int value) {
      bitField0_ |= 0x00000004;
      stories.add(value);
      return this;
    }

    /**
     * <code>repeated uint32 Stories = 2;</code>
     * @param values the stories to add
     * @return this
     */
    public ActivityTowerDefense addAllStories(final int... values) {
      bitField0_ |= 0x00000004;
      stories.addAll(values);
      return this;
    }

    /**
     * <code>repeated .ActivityTowerDefenseLevel Levels = 3;</code>
     * @return whether the levels field is set
     */
    public boolean hasLevels() {
      return (bitField0_ & 0x00000008) != 0;
    }

    /**
     * <code>repeated .ActivityTowerDefenseLevel Levels = 3;</code>
     * @return this
     */
    public ActivityTowerDefense clearLevels() {
      bitField0_ &= ~0x00000008;
      levels.clear();
      return this;
    }

    /**
     * <code>repeated .ActivityTowerDefenseLevel Levels = 3;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableLevels()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<ActivityTowerDefenseLevel> getLevels() {
      return levels;
    }

    /**
     * <code>repeated .ActivityTowerDefenseLevel Levels = 3;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<ActivityTowerDefenseLevel> getMutableLevels() {
      bitField0_ |= 0x00000008;
      return levels;
    }

    /**
     * <code>repeated .ActivityTowerDefenseLevel Levels = 3;</code>
     * @param value the levels to add
     * @return this
     */
    public ActivityTowerDefense addLevels(final ActivityTowerDefenseLevel value) {
      bitField0_ |= 0x00000008;
      levels.add(value);
      return this;
    }

    /**
     * <code>repeated .ActivityTowerDefenseLevel Levels = 3;</code>
     * @param values the levels to add
     * @return this
     */
    public ActivityTowerDefense addAllLevels(final ActivityTowerDefenseLevel... values) {
      bitField0_ |= 0x00000008;
      levels.addAll(values);
      return this;
    }

    /**
     * <code>repeated .ActivityQuest Quests = 11;</code>
     * @return whether the quests field is set
     */
    public boolean hasQuests() {
      return (bitField0_ & 0x00000010) != 0;
    }

    /**
     * <code>repeated .ActivityQuest Quests = 11;</code>
     * @return this
     */
    public ActivityTowerDefense clearQuests() {
      bitField0_ &= ~0x00000010;
      quests.clear();
      return this;
    }

    /**
     * <code>repeated .ActivityQuest Quests = 11;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableQuests()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<ActivityQuest> getQuests() {
      return quests;
    }

    /**
     * <code>repeated .ActivityQuest Quests = 11;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<ActivityQuest> getMutableQuests() {
      bitField0_ |= 0x00000010;
      return quests;
    }

    /**
     * <code>repeated .ActivityQuest Quests = 11;</code>
     * @param value the quests to add
     * @return this
     */
    public ActivityTowerDefense addQuests(final ActivityQuest value) {
      bitField0_ |= 0x00000010;
      quests.add(value);
      return this;
    }

    /**
     * <code>repeated .ActivityQuest Quests = 11;</code>
     * @param values the quests to add
     * @return this
     */
    public ActivityTowerDefense addAllQuests(final ActivityQuest... values) {
      bitField0_ |= 0x00000010;
      quests.addAll(values);
      return this;
    }

    @Override
    public ActivityTowerDefense copyFrom(final ActivityTowerDefense other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        activityId = other.activityId;
        nextPackage.copyFrom(other.nextPackage);
        stories.copyFrom(other.stories);
        levels.copyFrom(other.levels);
        quests.copyFrom(other.quests);
      }
      return this;
    }

    @Override
    public ActivityTowerDefense mergeFrom(final ActivityTowerDefense other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasActivityId()) {
        setActivityId(other.activityId);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      if (other.hasStories()) {
        getMutableStories().addAll(other.stories);
      }
      if (other.hasLevels()) {
        getMutableLevels().addAll(other.levels);
      }
      if (other.hasQuests()) {
        getMutableQuests().addAll(other.quests);
      }
      return this;
    }

    @Override
    public ActivityTowerDefense clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      activityId = 0;
      nextPackage.clear();
      stories.clear();
      levels.clear();
      quests.clear();
      return this;
    }

    @Override
    public ActivityTowerDefense clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      stories.clear();
      levels.clearQuick();
      quests.clearQuick();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof ActivityTowerDefense)) {
        return false;
      }
      ActivityTowerDefense other = (ActivityTowerDefense) o;
      return bitField0_ == other.bitField0_
        && (!hasActivityId() || activityId == other.activityId)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage))
        && (!hasStories() || stories.equals(other.stories))
        && (!hasLevels() || levels.equals(other.levels))
        && (!hasQuests() || quests.equals(other.quests));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt32NoTag(activityId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        for (int i = 0; i < stories.length(); i++) {
          output.writeRawByte((byte) 16);
          output.writeUInt32NoTag(stories.array()[i]);
        }
      }
      if ((bitField0_ & 0x00000008) != 0) {
        for (int i = 0; i < levels.length(); i++) {
          output.writeRawByte((byte) 26);
          output.writeMessageNoTag(levels.get(i));
        }
      }
      if ((bitField0_ & 0x00000010) != 0) {
        for (int i = 0; i < quests.length(); i++) {
          output.writeRawByte((byte) 90);
          output.writeMessageNoTag(quests.get(i));
        }
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(activityId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += (1 * stories.length()) + ProtoSink.computeRepeatedUInt32SizeNoTag(stories);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        size += (1 * levels.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(levels);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        size += (1 * quests.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(quests);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public ActivityTowerDefense mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            // activityId
            activityId = input.readUInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 18) {
              break;
            }
          }
          case 18: {
            // stories [packed=true]
            input.readPackedUInt32(stories, tag);
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 26) {
              break;
            }
          }
          case 26: {
            // levels
            tag = input.readRepeatedMessage(levels, tag);
            bitField0_ |= 0x00000008;
            if (tag != 90) {
              break;
            }
          }
          case 90: {
            // quests
            tag = input.readRepeatedMessage(quests, tag);
            bitField0_ |= 0x00000010;
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
          case 16: {
            // stories [packed=false]
            tag = input.readRepeatedUInt32(stories, tag);
            bitField0_ |= 0x00000004;
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeUInt32(FieldNames.activityId, activityId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRepeatedUInt32(FieldNames.stories, stories);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeRepeatedMessage(FieldNames.levels, levels);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        output.writeRepeatedMessage(FieldNames.quests, quests);
      }
      output.endObject();
    }

    @Override
    public ActivityTowerDefense mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case -252882774: {
            if (input.isAtField(FieldNames.activityId)) {
              if (!input.trySkipNullValue()) {
                activityId = input.readUInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -219613133: {
            if (input.isAtField(FieldNames.stories)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedUInt32(stories);
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2022260337: {
            if (input.isAtField(FieldNames.levels)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedMessage(levels);
                bitField0_ |= 0x00000008;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1864830991: {
            if (input.isAtField(FieldNames.quests)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedMessage(quests);
                bitField0_ |= 0x00000010;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public ActivityTowerDefense clone() {
      return new ActivityTowerDefense().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static ActivityTowerDefense parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new ActivityTowerDefense(), data).checkInitialized();
    }

    public static ActivityTowerDefense parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new ActivityTowerDefense(), input).checkInitialized();
    }

    public static ActivityTowerDefense parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new ActivityTowerDefense(), input).checkInitialized();
    }

    /**
     * @return factory for creating ActivityTowerDefense messages
     */
    public static MessageFactory<ActivityTowerDefense> getFactory() {
      return ActivityTowerDefenseFactory.INSTANCE;
    }

    private enum ActivityTowerDefenseFactory implements MessageFactory<ActivityTowerDefense> {
      INSTANCE;

      @Override
      public ActivityTowerDefense create() {
        return ActivityTowerDefense.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName activityId = FieldName.forField("ActivityId");

      static final FieldName nextPackage = FieldName.forField("NextPackage");

      static final FieldName stories = FieldName.forField("Stories");

      static final FieldName levels = FieldName.forField("Levels");

      static final FieldName quests = FieldName.forField("Quests");
    }
  }

  /**
   * Protobuf type {@code ActivityTrial}
   */
  public static final class ActivityTrial extends ProtoMessage<ActivityTrial> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    /**
     * <code>repeated uint32 CompletedGroupIds = 1;</code>
     */
    private final RepeatedInt completedGroupIds = RepeatedInt.newEmptyInstance();

    private ActivityTrial() {
    }

    /**
     * @return a new empty instance of {@code ActivityTrial}
     */
    public static ActivityTrial newInstance() {
      return new ActivityTrial();
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public ActivityTrial clearNextPackage() {
      bitField0_ &= ~0x00000001;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000001;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public ActivityTrial addNextPackage(final byte value) {
      bitField0_ |= 0x00000001;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public ActivityTrial addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000001;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public ActivityTrial setNextPackage(final byte... values) {
      bitField0_ |= 0x00000001;
      nextPackage.copyFrom(values);
      return this;
    }

    /**
     * <code>repeated uint32 CompletedGroupIds = 1;</code>
     * @return whether the completedGroupIds field is set
     */
    public boolean hasCompletedGroupIds() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>repeated uint32 CompletedGroupIds = 1;</code>
     * @return this
     */
    public ActivityTrial clearCompletedGroupIds() {
      bitField0_ &= ~0x00000002;
      completedGroupIds.clear();
      return this;
    }

    /**
     * <code>repeated uint32 CompletedGroupIds = 1;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableCompletedGroupIds()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedInt getCompletedGroupIds() {
      return completedGroupIds;
    }

    /**
     * <code>repeated uint32 CompletedGroupIds = 1;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedInt getMutableCompletedGroupIds() {
      bitField0_ |= 0x00000002;
      return completedGroupIds;
    }

    /**
     * <code>repeated uint32 CompletedGroupIds = 1;</code>
     * @param value the completedGroupIds to add
     * @return this
     */
    public ActivityTrial addCompletedGroupIds(final int value) {
      bitField0_ |= 0x00000002;
      completedGroupIds.add(value);
      return this;
    }

    /**
     * <code>repeated uint32 CompletedGroupIds = 1;</code>
     * @param values the completedGroupIds to add
     * @return this
     */
    public ActivityTrial addAllCompletedGroupIds(final int... values) {
      bitField0_ |= 0x00000002;
      completedGroupIds.addAll(values);
      return this;
    }

    @Override
    public ActivityTrial copyFrom(final ActivityTrial other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        nextPackage.copyFrom(other.nextPackage);
        completedGroupIds.copyFrom(other.completedGroupIds);
      }
      return this;
    }

    @Override
    public ActivityTrial mergeFrom(final ActivityTrial other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      if (other.hasCompletedGroupIds()) {
        getMutableCompletedGroupIds().addAll(other.completedGroupIds);
      }
      return this;
    }

    @Override
    public ActivityTrial clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      completedGroupIds.clear();
      return this;
    }

    @Override
    public ActivityTrial clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      completedGroupIds.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof ActivityTrial)) {
        return false;
      }
      ActivityTrial other = (ActivityTrial) o;
      return bitField0_ == other.bitField0_
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage))
        && (!hasCompletedGroupIds() || completedGroupIds.equals(other.completedGroupIds));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        for (int i = 0; i < completedGroupIds.length(); i++) {
          output.writeRawByte((byte) 8);
          output.writeUInt32NoTag(completedGroupIds.array()[i]);
        }
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += (1 * completedGroupIds.length()) + ProtoSink.computeRepeatedUInt32SizeNoTag(completedGroupIds);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public ActivityTrial mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 10) {
              break;
            }
          }
          case 10: {
            // completedGroupIds [packed=true]
            input.readPackedUInt32(completedGroupIds, tag);
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
          case 8: {
            // completedGroupIds [packed=false]
            tag = input.readRepeatedUInt32(completedGroupIds, tag);
            bitField0_ |= 0x00000002;
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRepeatedUInt32(FieldNames.completedGroupIds, completedGroupIds);
      }
      output.endObject();
    }

    @Override
    public ActivityTrial mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1947974908: {
            if (input.isAtField(FieldNames.completedGroupIds)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedUInt32(completedGroupIds);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public ActivityTrial clone() {
      return new ActivityTrial().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static ActivityTrial parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new ActivityTrial(), data).checkInitialized();
    }

    public static ActivityTrial parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new ActivityTrial(), input).checkInitialized();
    }

    public static ActivityTrial parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new ActivityTrial(), input).checkInitialized();
    }

    /**
     * @return factory for creating ActivityTrial messages
     */
    public static MessageFactory<ActivityTrial> getFactory() {
      return ActivityTrialFactory.INSTANCE;
    }

    private enum ActivityTrialFactory implements MessageFactory<ActivityTrial> {
      INSTANCE;

      @Override
      public ActivityTrial create() {
        return ActivityTrial.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName nextPackage = FieldName.forField("NextPackage");

      static final FieldName completedGroupIds = FieldName.forField("CompletedGroupIds");
    }
  }

  /**
   * Protobuf type {@code ActivityCG}
   */
  public static final class ActivityCG extends ProtoMessage<ActivityCG> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional bool Read = 1;</code>
     */
    private boolean read;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    private ActivityCG() {
    }

    /**
     * @return a new empty instance of {@code ActivityCG}
     */
    public static ActivityCG newInstance() {
      return new ActivityCG();
    }

    /**
     * <code>optional bool Read = 1;</code>
     * @return whether the read field is set
     */
    public boolean hasRead() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional bool Read = 1;</code>
     * @return this
     */
    public ActivityCG clearRead() {
      bitField0_ &= ~0x00000001;
      read = false;
      return this;
    }

    /**
     * <code>optional bool Read = 1;</code>
     * @return the read
     */
    public boolean getRead() {
      return read;
    }

    /**
     * <code>optional bool Read = 1;</code>
     * @param value the read to set
     * @return this
     */
    public ActivityCG setRead(final boolean value) {
      bitField0_ |= 0x00000001;
      read = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public ActivityCG clearNextPackage() {
      bitField0_ &= ~0x00000002;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000002;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public ActivityCG addNextPackage(final byte value) {
      bitField0_ |= 0x00000002;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public ActivityCG addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000002;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public ActivityCG setNextPackage(final byte... values) {
      bitField0_ |= 0x00000002;
      nextPackage.copyFrom(values);
      return this;
    }

    @Override
    public ActivityCG copyFrom(final ActivityCG other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        read = other.read;
        nextPackage.copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public ActivityCG mergeFrom(final ActivityCG other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasRead()) {
        setRead(other.read);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public ActivityCG clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      read = false;
      nextPackage.clear();
      return this;
    }

    @Override
    public ActivityCG clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof ActivityCG)) {
        return false;
      }
      ActivityCG other = (ActivityCG) o;
      return bitField0_ == other.bitField0_
        && (!hasRead() || read == other.read)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 8);
        output.writeBoolNoTag(read);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 2;
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public ActivityCG mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            // read
            read = input.readBool();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeBool(FieldNames.read, read);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      output.endObject();
    }

    @Override
    public ActivityCG mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 2543030: {
            if (input.isAtField(FieldNames.read)) {
              if (!input.trySkipNullValue()) {
                read = input.readBool();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public ActivityCG clone() {
      return new ActivityCG().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static ActivityCG parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new ActivityCG(), data).checkInitialized();
    }

    public static ActivityCG parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new ActivityCG(), input).checkInitialized();
    }

    public static ActivityCG parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new ActivityCG(), input).checkInitialized();
    }

    /**
     * @return factory for creating ActivityCG messages
     */
    public static MessageFactory<ActivityCG> getFactory() {
      return ActivityCGFactory.INSTANCE;
    }

    private enum ActivityCGFactory implements MessageFactory<ActivityCG> {
      INSTANCE;

      @Override
      public ActivityCG create() {
        return ActivityCG.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName read = FieldName.forField("Read");

      static final FieldName nextPackage = FieldName.forField("NextPackage");
    }
  }

  /**
   * Protobuf type {@code ActivityLevel}
   */
  public static final class ActivityLevel extends ProtoMessage<ActivityLevel> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional uint64 BuildId = 3;</code>
     */
    private long buildId;

    /**
     * <code>optional uint32 Id = 1;</code>
     */
    private int id;

    /**
     * <code>optional uint32 Star = 2;</code>
     */
    private int star;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    private ActivityLevel() {
    }

    /**
     * @return a new empty instance of {@code ActivityLevel}
     */
    public static ActivityLevel newInstance() {
      return new ActivityLevel();
    }

    /**
     * <code>optional uint64 BuildId = 3;</code>
     * @return whether the buildId field is set
     */
    public boolean hasBuildId() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional uint64 BuildId = 3;</code>
     * @return this
     */
    public ActivityLevel clearBuildId() {
      bitField0_ &= ~0x00000001;
      buildId = 0L;
      return this;
    }

    /**
     * <code>optional uint64 BuildId = 3;</code>
     * @return the buildId
     */
    public long getBuildId() {
      return buildId;
    }

    /**
     * <code>optional uint64 BuildId = 3;</code>
     * @param value the buildId to set
     * @return this
     */
    public ActivityLevel setBuildId(final long value) {
      bitField0_ |= 0x00000001;
      buildId = value;
      return this;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @return whether the id field is set
     */
    public boolean hasId() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @return this
     */
    public ActivityLevel clearId() {
      bitField0_ &= ~0x00000002;
      id = 0;
      return this;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @return the id
     */
    public int getId() {
      return id;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @param value the id to set
     * @return this
     */
    public ActivityLevel setId(final int value) {
      bitField0_ |= 0x00000002;
      id = value;
      return this;
    }

    /**
     * <code>optional uint32 Star = 2;</code>
     * @return whether the star field is set
     */
    public boolean hasStar() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional uint32 Star = 2;</code>
     * @return this
     */
    public ActivityLevel clearStar() {
      bitField0_ &= ~0x00000004;
      star = 0;
      return this;
    }

    /**
     * <code>optional uint32 Star = 2;</code>
     * @return the star
     */
    public int getStar() {
      return star;
    }

    /**
     * <code>optional uint32 Star = 2;</code>
     * @param value the star to set
     * @return this
     */
    public ActivityLevel setStar(final int value) {
      bitField0_ |= 0x00000004;
      star = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000008) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public ActivityLevel clearNextPackage() {
      bitField0_ &= ~0x00000008;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000008;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public ActivityLevel addNextPackage(final byte value) {
      bitField0_ |= 0x00000008;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public ActivityLevel addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000008;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public ActivityLevel setNextPackage(final byte... values) {
      bitField0_ |= 0x00000008;
      nextPackage.copyFrom(values);
      return this;
    }

    @Override
    public ActivityLevel copyFrom(final ActivityLevel other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        buildId = other.buildId;
        id = other.id;
        star = other.star;
        nextPackage.copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public ActivityLevel mergeFrom(final ActivityLevel other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasBuildId()) {
        setBuildId(other.buildId);
      }
      if (other.hasId()) {
        setId(other.id);
      }
      if (other.hasStar()) {
        setStar(other.star);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public ActivityLevel clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      buildId = 0L;
      id = 0;
      star = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public ActivityLevel clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof ActivityLevel)) {
        return false;
      }
      ActivityLevel other = (ActivityLevel) o;
      return bitField0_ == other.bitField0_
        && (!hasBuildId() || buildId == other.buildId)
        && (!hasId() || id == other.id)
        && (!hasStar() || star == other.star)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 24);
        output.writeUInt64NoTag(buildId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt32NoTag(id);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawByte((byte) 16);
        output.writeUInt32NoTag(star);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeUInt64SizeNoTag(buildId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(id);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(star);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public ActivityLevel mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 24: {
            // buildId
            buildId = input.readUInt64();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 8) {
              break;
            }
          }
          case 8: {
            // id
            id = input.readUInt32();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 16) {
              break;
            }
          }
          case 16: {
            // star
            star = input.readUInt32();
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000008;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeUInt64(FieldNames.buildId, buildId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeUInt32(FieldNames.id, id);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeUInt32(FieldNames.star, star);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      output.endObject();
    }

    @Override
    public ActivityLevel mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 1895597065: {
            if (input.isAtField(FieldNames.buildId)) {
              if (!input.trySkipNullValue()) {
                buildId = input.readUInt64();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 2363: {
            if (input.isAtField(FieldNames.id)) {
              if (!input.trySkipNullValue()) {
                id = input.readUInt32();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 2587250: {
            if (input.isAtField(FieldNames.star)) {
              if (!input.trySkipNullValue()) {
                star = input.readUInt32();
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000008;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public ActivityLevel clone() {
      return new ActivityLevel().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static ActivityLevel parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new ActivityLevel(), data).checkInitialized();
    }

    public static ActivityLevel parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new ActivityLevel(), input).checkInitialized();
    }

    public static ActivityLevel parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new ActivityLevel(), input).checkInitialized();
    }

    /**
     * @return factory for creating ActivityLevel messages
     */
    public static MessageFactory<ActivityLevel> getFactory() {
      return ActivityLevelFactory.INSTANCE;
    }

    private enum ActivityLevelFactory implements MessageFactory<ActivityLevel> {
      INSTANCE;

      @Override
      public ActivityLevel create() {
        return ActivityLevel.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName buildId = FieldName.forField("BuildId");

      static final FieldName id = FieldName.forField("Id");

      static final FieldName star = FieldName.forField("Star");

      static final FieldName nextPackage = FieldName.forField("NextPackage");
    }
  }

  /**
   * Protobuf type {@code ActivityLevels}
   */
  public static final class ActivityLevels extends ProtoMessage<ActivityLevels> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    /**
     * <code>repeated .ActivityLevel levels = 1;</code>
     */
    private final RepeatedMessage<ActivityLevel> levels = RepeatedMessage.newEmptyInstance(ActivityLevel.getFactory());

    private ActivityLevels() {
    }

    /**
     * @return a new empty instance of {@code ActivityLevels}
     */
    public static ActivityLevels newInstance() {
      return new ActivityLevels();
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public ActivityLevels clearNextPackage() {
      bitField0_ &= ~0x00000001;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000001;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public ActivityLevels addNextPackage(final byte value) {
      bitField0_ |= 0x00000001;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public ActivityLevels addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000001;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public ActivityLevels setNextPackage(final byte... values) {
      bitField0_ |= 0x00000001;
      nextPackage.copyFrom(values);
      return this;
    }

    /**
     * <code>repeated .ActivityLevel levels = 1;</code>
     * @return whether the levels field is set
     */
    public boolean hasLevels() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>repeated .ActivityLevel levels = 1;</code>
     * @return this
     */
    public ActivityLevels clearLevels() {
      bitField0_ &= ~0x00000002;
      levels.clear();
      return this;
    }

    /**
     * <code>repeated .ActivityLevel levels = 1;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableLevels()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<ActivityLevel> getLevels() {
      return levels;
    }

    /**
     * <code>repeated .ActivityLevel levels = 1;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<ActivityLevel> getMutableLevels() {
      bitField0_ |= 0x00000002;
      return levels;
    }

    /**
     * <code>repeated .ActivityLevel levels = 1;</code>
     * @param value the levels to add
     * @return this
     */
    public ActivityLevels addLevels(final ActivityLevel value) {
      bitField0_ |= 0x00000002;
      levels.add(value);
      return this;
    }

    /**
     * <code>repeated .ActivityLevel levels = 1;</code>
     * @param values the levels to add
     * @return this
     */
    public ActivityLevels addAllLevels(final ActivityLevel... values) {
      bitField0_ |= 0x00000002;
      levels.addAll(values);
      return this;
    }

    @Override
    public ActivityLevels copyFrom(final ActivityLevels other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        nextPackage.copyFrom(other.nextPackage);
        levels.copyFrom(other.levels);
      }
      return this;
    }

    @Override
    public ActivityLevels mergeFrom(final ActivityLevels other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      if (other.hasLevels()) {
        getMutableLevels().addAll(other.levels);
      }
      return this;
    }

    @Override
    public ActivityLevels clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      levels.clear();
      return this;
    }

    @Override
    public ActivityLevels clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      levels.clearQuick();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof ActivityLevels)) {
        return false;
      }
      ActivityLevels other = (ActivityLevels) o;
      return bitField0_ == other.bitField0_
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage))
        && (!hasLevels() || levels.equals(other.levels));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        for (int i = 0; i < levels.length(); i++) {
          output.writeRawByte((byte) 10);
          output.writeMessageNoTag(levels.get(i));
        }
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += (1 * levels.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(levels);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public ActivityLevels mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 10) {
              break;
            }
          }
          case 10: {
            // levels
            tag = input.readRepeatedMessage(levels, tag);
            bitField0_ |= 0x00000002;
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRepeatedMessage(FieldNames.levels, levels);
      }
      output.endObject();
    }

    @Override
    public ActivityLevels mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1106127505: {
            if (input.isAtField(FieldNames.levels)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedMessage(levels);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public ActivityLevels clone() {
      return new ActivityLevels().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static ActivityLevels parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new ActivityLevels(), data).checkInitialized();
    }

    public static ActivityLevels parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new ActivityLevels(), input).checkInitialized();
    }

    public static ActivityLevels parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new ActivityLevels(), input).checkInitialized();
    }

    /**
     * @return factory for creating ActivityLevels messages
     */
    public static MessageFactory<ActivityLevels> getFactory() {
      return ActivityLevelsFactory.INSTANCE;
    }

    private enum ActivityLevelsFactory implements MessageFactory<ActivityLevels> {
      INSTANCE;

      @Override
      public ActivityLevels create() {
        return ActivityLevels.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName nextPackage = FieldName.forField("NextPackage");

      static final FieldName levels = FieldName.forField("levels");
    }
  }

  /**
   * Protobuf type {@code ActivityAvg}
   */
  public static final class ActivityAvg extends ProtoMessage<ActivityAvg> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    /**
     * <code>repeated uint32 RewardIds = 1;</code>
     */
    private final RepeatedInt rewardIds = RepeatedInt.newEmptyInstance();

    private ActivityAvg() {
    }

    /**
     * @return a new empty instance of {@code ActivityAvg}
     */
    public static ActivityAvg newInstance() {
      return new ActivityAvg();
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public ActivityAvg clearNextPackage() {
      bitField0_ &= ~0x00000001;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000001;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public ActivityAvg addNextPackage(final byte value) {
      bitField0_ |= 0x00000001;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public ActivityAvg addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000001;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public ActivityAvg setNextPackage(final byte... values) {
      bitField0_ |= 0x00000001;
      nextPackage.copyFrom(values);
      return this;
    }

    /**
     * <code>repeated uint32 RewardIds = 1;</code>
     * @return whether the rewardIds field is set
     */
    public boolean hasRewardIds() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>repeated uint32 RewardIds = 1;</code>
     * @return this
     */
    public ActivityAvg clearRewardIds() {
      bitField0_ &= ~0x00000002;
      rewardIds.clear();
      return this;
    }

    /**
     * <code>repeated uint32 RewardIds = 1;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableRewardIds()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedInt getRewardIds() {
      return rewardIds;
    }

    /**
     * <code>repeated uint32 RewardIds = 1;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedInt getMutableRewardIds() {
      bitField0_ |= 0x00000002;
      return rewardIds;
    }

    /**
     * <code>repeated uint32 RewardIds = 1;</code>
     * @param value the rewardIds to add
     * @return this
     */
    public ActivityAvg addRewardIds(final int value) {
      bitField0_ |= 0x00000002;
      rewardIds.add(value);
      return this;
    }

    /**
     * <code>repeated uint32 RewardIds = 1;</code>
     * @param values the rewardIds to add
     * @return this
     */
    public ActivityAvg addAllRewardIds(final int... values) {
      bitField0_ |= 0x00000002;
      rewardIds.addAll(values);
      return this;
    }

    @Override
    public ActivityAvg copyFrom(final ActivityAvg other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        nextPackage.copyFrom(other.nextPackage);
        rewardIds.copyFrom(other.rewardIds);
      }
      return this;
    }

    @Override
    public ActivityAvg mergeFrom(final ActivityAvg other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      if (other.hasRewardIds()) {
        getMutableRewardIds().addAll(other.rewardIds);
      }
      return this;
    }

    @Override
    public ActivityAvg clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      rewardIds.clear();
      return this;
    }

    @Override
    public ActivityAvg clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      rewardIds.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof ActivityAvg)) {
        return false;
      }
      ActivityAvg other = (ActivityAvg) o;
      return bitField0_ == other.bitField0_
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage))
        && (!hasRewardIds() || rewardIds.equals(other.rewardIds));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        for (int i = 0; i < rewardIds.length(); i++) {
          output.writeRawByte((byte) 8);
          output.writeUInt32NoTag(rewardIds.array()[i]);
        }
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += (1 * rewardIds.length()) + ProtoSink.computeRepeatedUInt32SizeNoTag(rewardIds);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public ActivityAvg mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 10) {
              break;
            }
          }
          case 10: {
            // rewardIds [packed=true]
            input.readPackedUInt32(rewardIds, tag);
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
          case 8: {
            // rewardIds [packed=false]
            tag = input.readRepeatedUInt32(rewardIds, tag);
            bitField0_ |= 0x00000002;
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRepeatedUInt32(FieldNames.rewardIds, rewardIds);
      }
      output.endObject();
    }

    @Override
    public ActivityAvg mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1128076055: {
            if (input.isAtField(FieldNames.rewardIds)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedUInt32(rewardIds);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public ActivityAvg clone() {
      return new ActivityAvg().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static ActivityAvg parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new ActivityAvg(), data).checkInitialized();
    }

    public static ActivityAvg parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new ActivityAvg(), input).checkInitialized();
    }

    public static ActivityAvg parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new ActivityAvg(), input).checkInitialized();
    }

    /**
     * @return factory for creating ActivityAvg messages
     */
    public static MessageFactory<ActivityAvg> getFactory() {
      return ActivityAvgFactory.INSTANCE;
    }

    private enum ActivityAvgFactory implements MessageFactory<ActivityAvg> {
      INSTANCE;

      @Override
      public ActivityAvg create() {
        return ActivityAvg.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName nextPackage = FieldName.forField("NextPackage");

      static final FieldName rewardIds = FieldName.forField("RewardIds");
    }
  }

  /**
   * Protobuf type {@code AffinityInfo}
   */
  public static final class AffinityInfo extends ProtoMessage<AffinityInfo> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional uint32 CharId = 1;</code>
     */
    private int charId;

    /**
     * <code>optional uint32 AffinityLevel = 2;</code>
     */
    private int affinityLevel;

    /**
     * <code>optional uint32 AffinityExp = 3;</code>
     */
    private int affinityExp;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    /**
     * <code>repeated .ItemTpl Rewards = 4;</code>
     */
    private final RepeatedMessage<ItemTpl> rewards = RepeatedMessage.newEmptyInstance(ItemTpl.getFactory());

    private AffinityInfo() {
    }

    /**
     * @return a new empty instance of {@code AffinityInfo}
     */
    public static AffinityInfo newInstance() {
      return new AffinityInfo();
    }

    /**
     * <code>optional uint32 CharId = 1;</code>
     * @return whether the charId field is set
     */
    public boolean hasCharId() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional uint32 CharId = 1;</code>
     * @return this
     */
    public AffinityInfo clearCharId() {
      bitField0_ &= ~0x00000001;
      charId = 0;
      return this;
    }

    /**
     * <code>optional uint32 CharId = 1;</code>
     * @return the charId
     */
    public int getCharId() {
      return charId;
    }

    /**
     * <code>optional uint32 CharId = 1;</code>
     * @param value the charId to set
     * @return this
     */
    public AffinityInfo setCharId(final int value) {
      bitField0_ |= 0x00000001;
      charId = value;
      return this;
    }

    /**
     * <code>optional uint32 AffinityLevel = 2;</code>
     * @return whether the affinityLevel field is set
     */
    public boolean hasAffinityLevel() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional uint32 AffinityLevel = 2;</code>
     * @return this
     */
    public AffinityInfo clearAffinityLevel() {
      bitField0_ &= ~0x00000002;
      affinityLevel = 0;
      return this;
    }

    /**
     * <code>optional uint32 AffinityLevel = 2;</code>
     * @return the affinityLevel
     */
    public int getAffinityLevel() {
      return affinityLevel;
    }

    /**
     * <code>optional uint32 AffinityLevel = 2;</code>
     * @param value the affinityLevel to set
     * @return this
     */
    public AffinityInfo setAffinityLevel(final int value) {
      bitField0_ |= 0x00000002;
      affinityLevel = value;
      return this;
    }

    /**
     * <code>optional uint32 AffinityExp = 3;</code>
     * @return whether the affinityExp field is set
     */
    public boolean hasAffinityExp() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional uint32 AffinityExp = 3;</code>
     * @return this
     */
    public AffinityInfo clearAffinityExp() {
      bitField0_ &= ~0x00000004;
      affinityExp = 0;
      return this;
    }

    /**
     * <code>optional uint32 AffinityExp = 3;</code>
     * @return the affinityExp
     */
    public int getAffinityExp() {
      return affinityExp;
    }

    /**
     * <code>optional uint32 AffinityExp = 3;</code>
     * @param value the affinityExp to set
     * @return this
     */
    public AffinityInfo setAffinityExp(final int value) {
      bitField0_ |= 0x00000004;
      affinityExp = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000008) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public AffinityInfo clearNextPackage() {
      bitField0_ &= ~0x00000008;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000008;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public AffinityInfo addNextPackage(final byte value) {
      bitField0_ |= 0x00000008;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public AffinityInfo addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000008;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public AffinityInfo setNextPackage(final byte... values) {
      bitField0_ |= 0x00000008;
      nextPackage.copyFrom(values);
      return this;
    }

    /**
     * <code>repeated .ItemTpl Rewards = 4;</code>
     * @return whether the rewards field is set
     */
    public boolean hasRewards() {
      return (bitField0_ & 0x00000010) != 0;
    }

    /**
     * <code>repeated .ItemTpl Rewards = 4;</code>
     * @return this
     */
    public AffinityInfo clearRewards() {
      bitField0_ &= ~0x00000010;
      rewards.clear();
      return this;
    }

    /**
     * <code>repeated .ItemTpl Rewards = 4;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableRewards()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<ItemTpl> getRewards() {
      return rewards;
    }

    /**
     * <code>repeated .ItemTpl Rewards = 4;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<ItemTpl> getMutableRewards() {
      bitField0_ |= 0x00000010;
      return rewards;
    }

    /**
     * <code>repeated .ItemTpl Rewards = 4;</code>
     * @param value the rewards to add
     * @return this
     */
    public AffinityInfo addRewards(final ItemTpl value) {
      bitField0_ |= 0x00000010;
      rewards.add(value);
      return this;
    }

    /**
     * <code>repeated .ItemTpl Rewards = 4;</code>
     * @param values the rewards to add
     * @return this
     */
    public AffinityInfo addAllRewards(final ItemTpl... values) {
      bitField0_ |= 0x00000010;
      rewards.addAll(values);
      return this;
    }

    @Override
    public AffinityInfo copyFrom(final AffinityInfo other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        charId = other.charId;
        affinityLevel = other.affinityLevel;
        affinityExp = other.affinityExp;
        nextPackage.copyFrom(other.nextPackage);
        rewards.copyFrom(other.rewards);
      }
      return this;
    }

    @Override
    public AffinityInfo mergeFrom(final AffinityInfo other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasCharId()) {
        setCharId(other.charId);
      }
      if (other.hasAffinityLevel()) {
        setAffinityLevel(other.affinityLevel);
      }
      if (other.hasAffinityExp()) {
        setAffinityExp(other.affinityExp);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      if (other.hasRewards()) {
        getMutableRewards().addAll(other.rewards);
      }
      return this;
    }

    @Override
    public AffinityInfo clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      charId = 0;
      affinityLevel = 0;
      affinityExp = 0;
      nextPackage.clear();
      rewards.clear();
      return this;
    }

    @Override
    public AffinityInfo clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      rewards.clearQuick();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof AffinityInfo)) {
        return false;
      }
      AffinityInfo other = (AffinityInfo) o;
      return bitField0_ == other.bitField0_
        && (!hasCharId() || charId == other.charId)
        && (!hasAffinityLevel() || affinityLevel == other.affinityLevel)
        && (!hasAffinityExp() || affinityExp == other.affinityExp)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage))
        && (!hasRewards() || rewards.equals(other.rewards));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt32NoTag(charId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 16);
        output.writeUInt32NoTag(affinityLevel);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawByte((byte) 24);
        output.writeUInt32NoTag(affinityExp);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        for (int i = 0; i < rewards.length(); i++) {
          output.writeRawByte((byte) 34);
          output.writeMessageNoTag(rewards.get(i));
        }
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(charId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(affinityLevel);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(affinityExp);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        size += (1 * rewards.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(rewards);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public AffinityInfo mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            // charId
            charId = input.readUInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 16) {
              break;
            }
          }
          case 16: {
            // affinityLevel
            affinityLevel = input.readUInt32();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 24) {
              break;
            }
          }
          case 24: {
            // affinityExp
            affinityExp = input.readUInt32();
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000008;
            tag = input.readTag();
            if (tag != 34) {
              break;
            }
          }
          case 34: {
            // rewards
            tag = input.readRepeatedMessage(rewards, tag);
            bitField0_ |= 0x00000010;
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeUInt32(FieldNames.charId, charId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeUInt32(FieldNames.affinityLevel, affinityLevel);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeUInt32(FieldNames.affinityExp, affinityExp);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        output.writeRepeatedMessage(FieldNames.rewards, rewards);
      }
      output.endObject();
    }

    @Override
    public AffinityInfo mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 2017200945: {
            if (input.isAtField(FieldNames.charId)) {
              if (!input.trySkipNullValue()) {
                charId = input.readUInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 1094331164: {
            if (input.isAtField(FieldNames.affinityLevel)) {
              if (!input.trySkipNullValue()) {
                affinityLevel = input.readUInt32();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 1185488821: {
            if (input.isAtField(FieldNames.affinityExp)) {
              if (!input.trySkipNullValue()) {
                affinityExp = input.readUInt32();
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000008;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1529663740: {
            if (input.isAtField(FieldNames.rewards)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedMessage(rewards);
                bitField0_ |= 0x00000010;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public AffinityInfo clone() {
      return new AffinityInfo().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static AffinityInfo parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new AffinityInfo(), data).checkInitialized();
    }

    public static AffinityInfo parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new AffinityInfo(), input).checkInitialized();
    }

    public static AffinityInfo parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new AffinityInfo(), input).checkInitialized();
    }

    /**
     * @return factory for creating AffinityInfo messages
     */
    public static MessageFactory<AffinityInfo> getFactory() {
      return AffinityInfoFactory.INSTANCE;
    }

    private enum AffinityInfoFactory implements MessageFactory<AffinityInfo> {
      INSTANCE;

      @Override
      public AffinityInfo create() {
        return AffinityInfo.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName charId = FieldName.forField("CharId");

      static final FieldName affinityLevel = FieldName.forField("AffinityLevel");

      static final FieldName affinityExp = FieldName.forField("AffinityExp");

      static final FieldName nextPackage = FieldName.forField("NextPackage");

      static final FieldName rewards = FieldName.forField("Rewards");
    }
  }

  /**
   * Protobuf type {@code ActivityState}
   */
  public static final class ActivityState extends ProtoMessage<ActivityState> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional uint32 Id = 1;</code>
     */
    private int id;

    /**
     * <code>optional bool RedDot = 2;</code>
     */
    private boolean redDot;

    /**
     * <code>optional bool Banner = 3;</code>
     */
    private boolean banner;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    private ActivityState() {
    }

    /**
     * @return a new empty instance of {@code ActivityState}
     */
    public static ActivityState newInstance() {
      return new ActivityState();
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @return whether the id field is set
     */
    public boolean hasId() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @return this
     */
    public ActivityState clearId() {
      bitField0_ &= ~0x00000001;
      id = 0;
      return this;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @return the id
     */
    public int getId() {
      return id;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @param value the id to set
     * @return this
     */
    public ActivityState setId(final int value) {
      bitField0_ |= 0x00000001;
      id = value;
      return this;
    }

    /**
     * <code>optional bool RedDot = 2;</code>
     * @return whether the redDot field is set
     */
    public boolean hasRedDot() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional bool RedDot = 2;</code>
     * @return this
     */
    public ActivityState clearRedDot() {
      bitField0_ &= ~0x00000002;
      redDot = false;
      return this;
    }

    /**
     * <code>optional bool RedDot = 2;</code>
     * @return the redDot
     */
    public boolean getRedDot() {
      return redDot;
    }

    /**
     * <code>optional bool RedDot = 2;</code>
     * @param value the redDot to set
     * @return this
     */
    public ActivityState setRedDot(final boolean value) {
      bitField0_ |= 0x00000002;
      redDot = value;
      return this;
    }

    /**
     * <code>optional bool Banner = 3;</code>
     * @return whether the banner field is set
     */
    public boolean hasBanner() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional bool Banner = 3;</code>
     * @return this
     */
    public ActivityState clearBanner() {
      bitField0_ &= ~0x00000004;
      banner = false;
      return this;
    }

    /**
     * <code>optional bool Banner = 3;</code>
     * @return the banner
     */
    public boolean getBanner() {
      return banner;
    }

    /**
     * <code>optional bool Banner = 3;</code>
     * @param value the banner to set
     * @return this
     */
    public ActivityState setBanner(final boolean value) {
      bitField0_ |= 0x00000004;
      banner = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000008) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public ActivityState clearNextPackage() {
      bitField0_ &= ~0x00000008;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000008;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public ActivityState addNextPackage(final byte value) {
      bitField0_ |= 0x00000008;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public ActivityState addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000008;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public ActivityState setNextPackage(final byte... values) {
      bitField0_ |= 0x00000008;
      nextPackage.copyFrom(values);
      return this;
    }

    @Override
    public ActivityState copyFrom(final ActivityState other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        id = other.id;
        redDot = other.redDot;
        banner = other.banner;
        nextPackage.copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public ActivityState mergeFrom(final ActivityState other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasId()) {
        setId(other.id);
      }
      if (other.hasRedDot()) {
        setRedDot(other.redDot);
      }
      if (other.hasBanner()) {
        setBanner(other.banner);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public ActivityState clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      id = 0;
      redDot = false;
      banner = false;
      nextPackage.clear();
      return this;
    }

    @Override
    public ActivityState clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof ActivityState)) {
        return false;
      }
      ActivityState other = (ActivityState) o;
      return bitField0_ == other.bitField0_
        && (!hasId() || id == other.id)
        && (!hasRedDot() || redDot == other.redDot)
        && (!hasBanner() || banner == other.banner)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt32NoTag(id);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 16);
        output.writeBoolNoTag(redDot);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawByte((byte) 24);
        output.writeBoolNoTag(banner);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(id);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 2;
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 2;
      }
      if ((bitField0_ & 0x00000008) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public ActivityState mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            // id
            id = input.readUInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 16) {
              break;
            }
          }
          case 16: {
            // redDot
            redDot = input.readBool();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 24) {
              break;
            }
          }
          case 24: {
            // banner
            banner = input.readBool();
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000008;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeUInt32(FieldNames.id, id);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeBool(FieldNames.redDot, redDot);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeBool(FieldNames.banner, banner);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      output.endObject();
    }

    @Override
    public ActivityState mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 2363: {
            if (input.isAtField(FieldNames.id)) {
              if (!input.trySkipNullValue()) {
                id = input.readUInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1851053288: {
            if (input.isAtField(FieldNames.redDot)) {
              if (!input.trySkipNullValue()) {
                redDot = input.readBool();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 1982491468: {
            if (input.isAtField(FieldNames.banner)) {
              if (!input.trySkipNullValue()) {
                banner = input.readBool();
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000008;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public ActivityState clone() {
      return new ActivityState().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static ActivityState parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new ActivityState(), data).checkInitialized();
    }

    public static ActivityState parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new ActivityState(), input).checkInitialized();
    }

    public static ActivityState parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new ActivityState(), input).checkInitialized();
    }

    /**
     * @return factory for creating ActivityState messages
     */
    public static MessageFactory<ActivityState> getFactory() {
      return ActivityStateFactory.INSTANCE;
    }

    private enum ActivityStateFactory implements MessageFactory<ActivityState> {
      INSTANCE;

      @Override
      public ActivityState create() {
        return ActivityState.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName id = FieldName.forField("Id");

      static final FieldName redDot = FieldName.forField("RedDot");

      static final FieldName banner = FieldName.forField("Banner");

      static final FieldName nextPackage = FieldName.forField("NextPackage");
    }
  }

  /**
   * Protobuf type {@code Chat}
   */
  public static final class Chat extends ProtoMessage<Chat> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional uint32 Id = 1;</code>
     */
    private int id;

    /**
     * <code>optional uint32 Process = 3;</code>
     */
    private int process;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    /**
     * <code>repeated uint32 Options = 2;</code>
     */
    private final RepeatedInt options = RepeatedInt.newEmptyInstance();

    private Chat() {
    }

    /**
     * @return a new empty instance of {@code Chat}
     */
    public static Chat newInstance() {
      return new Chat();
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @return whether the id field is set
     */
    public boolean hasId() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @return this
     */
    public Chat clearId() {
      bitField0_ &= ~0x00000001;
      id = 0;
      return this;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @return the id
     */
    public int getId() {
      return id;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @param value the id to set
     * @return this
     */
    public Chat setId(final int value) {
      bitField0_ |= 0x00000001;
      id = value;
      return this;
    }

    /**
     * <code>optional uint32 Process = 3;</code>
     * @return whether the process field is set
     */
    public boolean hasProcess() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional uint32 Process = 3;</code>
     * @return this
     */
    public Chat clearProcess() {
      bitField0_ &= ~0x00000002;
      process = 0;
      return this;
    }

    /**
     * <code>optional uint32 Process = 3;</code>
     * @return the process
     */
    public int getProcess() {
      return process;
    }

    /**
     * <code>optional uint32 Process = 3;</code>
     * @param value the process to set
     * @return this
     */
    public Chat setProcess(final int value) {
      bitField0_ |= 0x00000002;
      process = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public Chat clearNextPackage() {
      bitField0_ &= ~0x00000004;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000004;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public Chat addNextPackage(final byte value) {
      bitField0_ |= 0x00000004;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public Chat addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000004;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public Chat setNextPackage(final byte... values) {
      bitField0_ |= 0x00000004;
      nextPackage.copyFrom(values);
      return this;
    }

    /**
     * <code>repeated uint32 Options = 2;</code>
     * @return whether the options field is set
     */
    public boolean hasOptions() {
      return (bitField0_ & 0x00000008) != 0;
    }

    /**
     * <code>repeated uint32 Options = 2;</code>
     * @return this
     */
    public Chat clearOptions() {
      bitField0_ &= ~0x00000008;
      options.clear();
      return this;
    }

    /**
     * <code>repeated uint32 Options = 2;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableOptions()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedInt getOptions() {
      return options;
    }

    /**
     * <code>repeated uint32 Options = 2;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedInt getMutableOptions() {
      bitField0_ |= 0x00000008;
      return options;
    }

    /**
     * <code>repeated uint32 Options = 2;</code>
     * @param value the options to add
     * @return this
     */
    public Chat addOptions(final int value) {
      bitField0_ |= 0x00000008;
      options.add(value);
      return this;
    }

    /**
     * <code>repeated uint32 Options = 2;</code>
     * @param values the options to add
     * @return this
     */
    public Chat addAllOptions(final int... values) {
      bitField0_ |= 0x00000008;
      options.addAll(values);
      return this;
    }

    @Override
    public Chat copyFrom(final Chat other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        id = other.id;
        process = other.process;
        nextPackage.copyFrom(other.nextPackage);
        options.copyFrom(other.options);
      }
      return this;
    }

    @Override
    public Chat mergeFrom(final Chat other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasId()) {
        setId(other.id);
      }
      if (other.hasProcess()) {
        setProcess(other.process);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      if (other.hasOptions()) {
        getMutableOptions().addAll(other.options);
      }
      return this;
    }

    @Override
    public Chat clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      id = 0;
      process = 0;
      nextPackage.clear();
      options.clear();
      return this;
    }

    @Override
    public Chat clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      options.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof Chat)) {
        return false;
      }
      Chat other = (Chat) o;
      return bitField0_ == other.bitField0_
        && (!hasId() || id == other.id)
        && (!hasProcess() || process == other.process)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage))
        && (!hasOptions() || options.equals(other.options));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt32NoTag(id);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 24);
        output.writeUInt32NoTag(process);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        for (int i = 0; i < options.length(); i++) {
          output.writeRawByte((byte) 16);
          output.writeUInt32NoTag(options.array()[i]);
        }
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(id);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(process);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        size += (1 * options.length()) + ProtoSink.computeRepeatedUInt32SizeNoTag(options);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public Chat mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            // id
            id = input.readUInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 24) {
              break;
            }
          }
          case 24: {
            // process
            process = input.readUInt32();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 18) {
              break;
            }
          }
          case 18: {
            // options [packed=true]
            input.readPackedUInt32(options, tag);
            bitField0_ |= 0x00000008;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
          case 16: {
            // options [packed=false]
            tag = input.readRepeatedUInt32(options, tag);
            bitField0_ |= 0x00000008;
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeUInt32(FieldNames.id, id);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeUInt32(FieldNames.process, process);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeRepeatedUInt32(FieldNames.options, options);
      }
      output.endObject();
    }

    @Override
    public Chat mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 2363: {
            if (input.isAtField(FieldNames.id)) {
              if (!input.trySkipNullValue()) {
                id = input.readUInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 1355134543: {
            if (input.isAtField(FieldNames.process)) {
              if (!input.trySkipNullValue()) {
                process = input.readUInt32();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 415178366: {
            if (input.isAtField(FieldNames.options)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedUInt32(options);
                bitField0_ |= 0x00000008;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public Chat clone() {
      return new Chat().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static Chat parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new Chat(), data).checkInitialized();
    }

    public static Chat parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new Chat(), input).checkInitialized();
    }

    public static Chat parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new Chat(), input).checkInitialized();
    }

    /**
     * @return factory for creating Chat messages
     */
    public static MessageFactory<Chat> getFactory() {
      return ChatFactory.INSTANCE;
    }

    private enum ChatFactory implements MessageFactory<Chat> {
      INSTANCE;

      @Override
      public Chat create() {
        return Chat.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName id = FieldName.forField("Id");

      static final FieldName process = FieldName.forField("Process");

      static final FieldName nextPackage = FieldName.forField("NextPackage");

      static final FieldName options = FieldName.forField("Options");
    }
  }

  /**
   * Protobuf type {@code Contacts}
   */
  public static final class Contacts extends ProtoMessage<Contacts> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional int64 TriggerTime = 2;</code>
     */
    private long triggerTime;

    /**
     * <code>optional int64 OptTime = 14;</code>
     */
    private long optTime;

    /**
     * <code>optional uint32 CharId = 1;</code>
     */
    private int charId;

    /**
     * <code>optional bool Top = 15;</code>
     */
    private boolean top;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    /**
     * <code>repeated .Chat Chats = 3;</code>
     */
    private final RepeatedMessage<Chat> chats = RepeatedMessage.newEmptyInstance(Chat.getFactory());

    private Contacts() {
    }

    /**
     * @return a new empty instance of {@code Contacts}
     */
    public static Contacts newInstance() {
      return new Contacts();
    }

    /**
     * <code>optional int64 TriggerTime = 2;</code>
     * @return whether the triggerTime field is set
     */
    public boolean hasTriggerTime() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional int64 TriggerTime = 2;</code>
     * @return this
     */
    public Contacts clearTriggerTime() {
      bitField0_ &= ~0x00000001;
      triggerTime = 0L;
      return this;
    }

    /**
     * <code>optional int64 TriggerTime = 2;</code>
     * @return the triggerTime
     */
    public long getTriggerTime() {
      return triggerTime;
    }

    /**
     * <code>optional int64 TriggerTime = 2;</code>
     * @param value the triggerTime to set
     * @return this
     */
    public Contacts setTriggerTime(final long value) {
      bitField0_ |= 0x00000001;
      triggerTime = value;
      return this;
    }

    /**
     * <code>optional int64 OptTime = 14;</code>
     * @return whether the optTime field is set
     */
    public boolean hasOptTime() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional int64 OptTime = 14;</code>
     * @return this
     */
    public Contacts clearOptTime() {
      bitField0_ &= ~0x00000002;
      optTime = 0L;
      return this;
    }

    /**
     * <code>optional int64 OptTime = 14;</code>
     * @return the optTime
     */
    public long getOptTime() {
      return optTime;
    }

    /**
     * <code>optional int64 OptTime = 14;</code>
     * @param value the optTime to set
     * @return this
     */
    public Contacts setOptTime(final long value) {
      bitField0_ |= 0x00000002;
      optTime = value;
      return this;
    }

    /**
     * <code>optional uint32 CharId = 1;</code>
     * @return whether the charId field is set
     */
    public boolean hasCharId() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional uint32 CharId = 1;</code>
     * @return this
     */
    public Contacts clearCharId() {
      bitField0_ &= ~0x00000004;
      charId = 0;
      return this;
    }

    /**
     * <code>optional uint32 CharId = 1;</code>
     * @return the charId
     */
    public int getCharId() {
      return charId;
    }

    /**
     * <code>optional uint32 CharId = 1;</code>
     * @param value the charId to set
     * @return this
     */
    public Contacts setCharId(final int value) {
      bitField0_ |= 0x00000004;
      charId = value;
      return this;
    }

    /**
     * <code>optional bool Top = 15;</code>
     * @return whether the top field is set
     */
    public boolean hasTop() {
      return (bitField0_ & 0x00000008) != 0;
    }

    /**
     * <code>optional bool Top = 15;</code>
     * @return this
     */
    public Contacts clearTop() {
      bitField0_ &= ~0x00000008;
      top = false;
      return this;
    }

    /**
     * <code>optional bool Top = 15;</code>
     * @return the top
     */
    public boolean getTop() {
      return top;
    }

    /**
     * <code>optional bool Top = 15;</code>
     * @param value the top to set
     * @return this
     */
    public Contacts setTop(final boolean value) {
      bitField0_ |= 0x00000008;
      top = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000010) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public Contacts clearNextPackage() {
      bitField0_ &= ~0x00000010;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000010;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public Contacts addNextPackage(final byte value) {
      bitField0_ |= 0x00000010;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public Contacts addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000010;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public Contacts setNextPackage(final byte... values) {
      bitField0_ |= 0x00000010;
      nextPackage.copyFrom(values);
      return this;
    }

    /**
     * <code>repeated .Chat Chats = 3;</code>
     * @return whether the chats field is set
     */
    public boolean hasChats() {
      return (bitField0_ & 0x00000020) != 0;
    }

    /**
     * <code>repeated .Chat Chats = 3;</code>
     * @return this
     */
    public Contacts clearChats() {
      bitField0_ &= ~0x00000020;
      chats.clear();
      return this;
    }

    /**
     * <code>repeated .Chat Chats = 3;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableChats()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<Chat> getChats() {
      return chats;
    }

    /**
     * <code>repeated .Chat Chats = 3;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<Chat> getMutableChats() {
      bitField0_ |= 0x00000020;
      return chats;
    }

    /**
     * <code>repeated .Chat Chats = 3;</code>
     * @param value the chats to add
     * @return this
     */
    public Contacts addChats(final Chat value) {
      bitField0_ |= 0x00000020;
      chats.add(value);
      return this;
    }

    /**
     * <code>repeated .Chat Chats = 3;</code>
     * @param values the chats to add
     * @return this
     */
    public Contacts addAllChats(final Chat... values) {
      bitField0_ |= 0x00000020;
      chats.addAll(values);
      return this;
    }

    @Override
    public Contacts copyFrom(final Contacts other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        triggerTime = other.triggerTime;
        optTime = other.optTime;
        charId = other.charId;
        top = other.top;
        nextPackage.copyFrom(other.nextPackage);
        chats.copyFrom(other.chats);
      }
      return this;
    }

    @Override
    public Contacts mergeFrom(final Contacts other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasTriggerTime()) {
        setTriggerTime(other.triggerTime);
      }
      if (other.hasOptTime()) {
        setOptTime(other.optTime);
      }
      if (other.hasCharId()) {
        setCharId(other.charId);
      }
      if (other.hasTop()) {
        setTop(other.top);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      if (other.hasChats()) {
        getMutableChats().addAll(other.chats);
      }
      return this;
    }

    @Override
    public Contacts clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      triggerTime = 0L;
      optTime = 0L;
      charId = 0;
      top = false;
      nextPackage.clear();
      chats.clear();
      return this;
    }

    @Override
    public Contacts clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      chats.clearQuick();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof Contacts)) {
        return false;
      }
      Contacts other = (Contacts) o;
      return bitField0_ == other.bitField0_
        && (!hasTriggerTime() || triggerTime == other.triggerTime)
        && (!hasOptTime() || optTime == other.optTime)
        && (!hasCharId() || charId == other.charId)
        && (!hasTop() || top == other.top)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage))
        && (!hasChats() || chats.equals(other.chats));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 16);
        output.writeInt64NoTag(triggerTime);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 112);
        output.writeInt64NoTag(optTime);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt32NoTag(charId);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeRawByte((byte) 120);
        output.writeBoolNoTag(top);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        for (int i = 0; i < chats.length(); i++) {
          output.writeRawByte((byte) 26);
          output.writeMessageNoTag(chats.get(i));
        }
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeInt64SizeNoTag(triggerTime);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeInt64SizeNoTag(optTime);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(charId);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        size += 2;
      }
      if ((bitField0_ & 0x00000010) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        size += (1 * chats.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(chats);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public Contacts mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 16: {
            // triggerTime
            triggerTime = input.readInt64();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 112) {
              break;
            }
          }
          case 112: {
            // optTime
            optTime = input.readInt64();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 8) {
              break;
            }
          }
          case 8: {
            // charId
            charId = input.readUInt32();
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 120) {
              break;
            }
          }
          case 120: {
            // top
            top = input.readBool();
            bitField0_ |= 0x00000008;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000010;
            tag = input.readTag();
            if (tag != 26) {
              break;
            }
          }
          case 26: {
            // chats
            tag = input.readRepeatedMessage(chats, tag);
            bitField0_ |= 0x00000020;
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeInt64(FieldNames.triggerTime, triggerTime);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeInt64(FieldNames.optTime, optTime);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeUInt32(FieldNames.charId, charId);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeBool(FieldNames.top, top);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        output.writeRepeatedMessage(FieldNames.chats, chats);
      }
      output.endObject();
    }

    @Override
    public Contacts mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 986916997: {
            if (input.isAtField(FieldNames.triggerTime)) {
              if (!input.trySkipNullValue()) {
                triggerTime = input.readInt64();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 414546944: {
            if (input.isAtField(FieldNames.optTime)) {
              if (!input.trySkipNullValue()) {
                optTime = input.readInt64();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 2017200945: {
            if (input.isAtField(FieldNames.charId)) {
              if (!input.trySkipNullValue()) {
                charId = input.readUInt32();
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 84277: {
            if (input.isAtField(FieldNames.top)) {
              if (!input.trySkipNullValue()) {
                top = input.readBool();
                bitField0_ |= 0x00000008;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000010;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 65071099: {
            if (input.isAtField(FieldNames.chats)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedMessage(chats);
                bitField0_ |= 0x00000020;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public Contacts clone() {
      return new Contacts().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static Contacts parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new Contacts(), data).checkInitialized();
    }

    public static Contacts parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new Contacts(), input).checkInitialized();
    }

    public static Contacts parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new Contacts(), input).checkInitialized();
    }

    /**
     * @return factory for creating Contacts messages
     */
    public static MessageFactory<Contacts> getFactory() {
      return ContactsFactory.INSTANCE;
    }

    private enum ContactsFactory implements MessageFactory<Contacts> {
      INSTANCE;

      @Override
      public Contacts create() {
        return Contacts.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName triggerTime = FieldName.forField("TriggerTime");

      static final FieldName optTime = FieldName.forField("OptTime");

      static final FieldName charId = FieldName.forField("CharId");

      static final FieldName top = FieldName.forField("Top");

      static final FieldName nextPackage = FieldName.forField("NextPackage");

      static final FieldName chats = FieldName.forField("Chats");
    }
  }

  /**
   * Protobuf type {@code InfinityTowerLevelInfo}
   */
  public static final class InfinityTowerLevelInfo extends ProtoMessage<InfinityTowerLevelInfo> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional uint32 Id = 1;</code>
     */
    private int id;

    /**
     * <code>optional uint32 LevelId = 2;</code>
     */
    private int levelId;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    /**
     * <code>repeated uint32 ChallengeIds = 3;</code>
     */
    private final RepeatedInt challengeIds = RepeatedInt.newEmptyInstance();

    private InfinityTowerLevelInfo() {
    }

    /**
     * @return a new empty instance of {@code InfinityTowerLevelInfo}
     */
    public static InfinityTowerLevelInfo newInstance() {
      return new InfinityTowerLevelInfo();
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @return whether the id field is set
     */
    public boolean hasId() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @return this
     */
    public InfinityTowerLevelInfo clearId() {
      bitField0_ &= ~0x00000001;
      id = 0;
      return this;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @return the id
     */
    public int getId() {
      return id;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @param value the id to set
     * @return this
     */
    public InfinityTowerLevelInfo setId(final int value) {
      bitField0_ |= 0x00000001;
      id = value;
      return this;
    }

    /**
     * <code>optional uint32 LevelId = 2;</code>
     * @return whether the levelId field is set
     */
    public boolean hasLevelId() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional uint32 LevelId = 2;</code>
     * @return this
     */
    public InfinityTowerLevelInfo clearLevelId() {
      bitField0_ &= ~0x00000002;
      levelId = 0;
      return this;
    }

    /**
     * <code>optional uint32 LevelId = 2;</code>
     * @return the levelId
     */
    public int getLevelId() {
      return levelId;
    }

    /**
     * <code>optional uint32 LevelId = 2;</code>
     * @param value the levelId to set
     * @return this
     */
    public InfinityTowerLevelInfo setLevelId(final int value) {
      bitField0_ |= 0x00000002;
      levelId = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public InfinityTowerLevelInfo clearNextPackage() {
      bitField0_ &= ~0x00000004;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000004;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public InfinityTowerLevelInfo addNextPackage(final byte value) {
      bitField0_ |= 0x00000004;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public InfinityTowerLevelInfo addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000004;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public InfinityTowerLevelInfo setNextPackage(final byte... values) {
      bitField0_ |= 0x00000004;
      nextPackage.copyFrom(values);
      return this;
    }

    /**
     * <code>repeated uint32 ChallengeIds = 3;</code>
     * @return whether the challengeIds field is set
     */
    public boolean hasChallengeIds() {
      return (bitField0_ & 0x00000008) != 0;
    }

    /**
     * <code>repeated uint32 ChallengeIds = 3;</code>
     * @return this
     */
    public InfinityTowerLevelInfo clearChallengeIds() {
      bitField0_ &= ~0x00000008;
      challengeIds.clear();
      return this;
    }

    /**
     * <code>repeated uint32 ChallengeIds = 3;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableChallengeIds()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedInt getChallengeIds() {
      return challengeIds;
    }

    /**
     * <code>repeated uint32 ChallengeIds = 3;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedInt getMutableChallengeIds() {
      bitField0_ |= 0x00000008;
      return challengeIds;
    }

    /**
     * <code>repeated uint32 ChallengeIds = 3;</code>
     * @param value the challengeIds to add
     * @return this
     */
    public InfinityTowerLevelInfo addChallengeIds(final int value) {
      bitField0_ |= 0x00000008;
      challengeIds.add(value);
      return this;
    }

    /**
     * <code>repeated uint32 ChallengeIds = 3;</code>
     * @param values the challengeIds to add
     * @return this
     */
    public InfinityTowerLevelInfo addAllChallengeIds(final int... values) {
      bitField0_ |= 0x00000008;
      challengeIds.addAll(values);
      return this;
    }

    @Override
    public InfinityTowerLevelInfo copyFrom(final InfinityTowerLevelInfo other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        id = other.id;
        levelId = other.levelId;
        nextPackage.copyFrom(other.nextPackage);
        challengeIds.copyFrom(other.challengeIds);
      }
      return this;
    }

    @Override
    public InfinityTowerLevelInfo mergeFrom(final InfinityTowerLevelInfo other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasId()) {
        setId(other.id);
      }
      if (other.hasLevelId()) {
        setLevelId(other.levelId);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      if (other.hasChallengeIds()) {
        getMutableChallengeIds().addAll(other.challengeIds);
      }
      return this;
    }

    @Override
    public InfinityTowerLevelInfo clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      id = 0;
      levelId = 0;
      nextPackage.clear();
      challengeIds.clear();
      return this;
    }

    @Override
    public InfinityTowerLevelInfo clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      challengeIds.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof InfinityTowerLevelInfo)) {
        return false;
      }
      InfinityTowerLevelInfo other = (InfinityTowerLevelInfo) o;
      return bitField0_ == other.bitField0_
        && (!hasId() || id == other.id)
        && (!hasLevelId() || levelId == other.levelId)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage))
        && (!hasChallengeIds() || challengeIds.equals(other.challengeIds));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt32NoTag(id);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 16);
        output.writeUInt32NoTag(levelId);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        for (int i = 0; i < challengeIds.length(); i++) {
          output.writeRawByte((byte) 24);
          output.writeUInt32NoTag(challengeIds.array()[i]);
        }
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(id);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(levelId);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        size += (1 * challengeIds.length()) + ProtoSink.computeRepeatedUInt32SizeNoTag(challengeIds);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public InfinityTowerLevelInfo mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            // id
            id = input.readUInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 16) {
              break;
            }
          }
          case 16: {
            // levelId
            levelId = input.readUInt32();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 26) {
              break;
            }
          }
          case 26: {
            // challengeIds [packed=true]
            input.readPackedUInt32(challengeIds, tag);
            bitField0_ |= 0x00000008;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
          case 24: {
            // challengeIds [packed=false]
            tag = input.readRepeatedUInt32(challengeIds, tag);
            bitField0_ |= 0x00000008;
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeUInt32(FieldNames.id, id);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeUInt32(FieldNames.levelId, levelId);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeRepeatedUInt32(FieldNames.challengeIds, challengeIds);
      }
      output.endObject();
    }

    @Override
    public InfinityTowerLevelInfo mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 2363: {
            if (input.isAtField(FieldNames.id)) {
              if (!input.trySkipNullValue()) {
                id = input.readUInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 1734437791: {
            if (input.isAtField(FieldNames.levelId)) {
              if (!input.trySkipNullValue()) {
                levelId = input.readUInt32();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 276658037: {
            if (input.isAtField(FieldNames.challengeIds)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedUInt32(challengeIds);
                bitField0_ |= 0x00000008;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public InfinityTowerLevelInfo clone() {
      return new InfinityTowerLevelInfo().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static InfinityTowerLevelInfo parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new InfinityTowerLevelInfo(), data).checkInitialized();
    }

    public static InfinityTowerLevelInfo parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new InfinityTowerLevelInfo(), input).checkInitialized();
    }

    public static InfinityTowerLevelInfo parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new InfinityTowerLevelInfo(), input).checkInitialized();
    }

    /**
     * @return factory for creating InfinityTowerLevelInfo messages
     */
    public static MessageFactory<InfinityTowerLevelInfo> getFactory() {
      return InfinityTowerLevelInfoFactory.INSTANCE;
    }

    private enum InfinityTowerLevelInfoFactory implements MessageFactory<InfinityTowerLevelInfo> {
      INSTANCE;

      @Override
      public InfinityTowerLevelInfo create() {
        return InfinityTowerLevelInfo.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName id = FieldName.forField("Id");

      static final FieldName levelId = FieldName.forField("LevelId");

      static final FieldName nextPackage = FieldName.forField("NextPackage");

      static final FieldName challengeIds = FieldName.forField("ChallengeIds");
    }
  }

  /**
   * Protobuf type {@code CollectResp}
   */
  public static final class CollectResp extends ProtoMessage<CollectResp> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional .CollectResp.StatusEnum Status = 1;</code>
     */
    private int status;

    /**
     * <code>optional .ChangeInfo Items = 2;</code>
     */
    private final ChangeInfo items = ChangeInfo.newInstance();

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    private CollectResp() {
    }

    /**
     * @return a new empty instance of {@code CollectResp}
     */
    public static CollectResp newInstance() {
      return new CollectResp();
    }

    /**
     * <code>optional .CollectResp.StatusEnum Status = 1;</code>
     * @return whether the status field is set
     */
    public boolean hasStatus() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional .CollectResp.StatusEnum Status = 1;</code>
     * @return this
     */
    public CollectResp clearStatus() {
      bitField0_ &= ~0x00000001;
      status = 0;
      return this;
    }

    /**
     * <code>optional .CollectResp.StatusEnum Status = 1;</code>
     * @return the status
     */
    public StatusEnum getStatus() {
      return StatusEnum.forNumber(status);
    }

    /**
     * Gets the value of the internal enum store. The result is
     * equivalent to {@link CollectResp#getStatus()}.getNumber().
     *
     * @return numeric wire representation
     */
    public int getStatusValue() {
      return status;
    }

    /**
     * Sets the value of the internal enum store. This does not
     * do any validity checks, so be sure to use appropriate value
     * constants from {@link StatusEnum}. Setting an invalid value
     * can cause {@link CollectResp#getStatus()} to return null
     *
     * @param value the numeric wire value to set
     * @return this
     */
    public CollectResp setStatusValue(final int value) {
      bitField0_ |= 0x00000001;
      status = value;
      return this;
    }

    /**
     * <code>optional .CollectResp.StatusEnum Status = 1;</code>
     * @param value the status to set
     * @return this
     */
    public CollectResp setStatus(final StatusEnum value) {
      bitField0_ |= 0x00000001;
      status = value.getNumber();
      return this;
    }

    /**
     * <code>optional .ChangeInfo Items = 2;</code>
     * @return whether the items field is set
     */
    public boolean hasItems() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional .ChangeInfo Items = 2;</code>
     * @return this
     */
    public CollectResp clearItems() {
      bitField0_ &= ~0x00000002;
      items.clear();
      return this;
    }

    /**
     * <code>optional .ChangeInfo Items = 2;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableItems()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public ChangeInfo getItems() {
      return items;
    }

    /**
     * <code>optional .ChangeInfo Items = 2;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public ChangeInfo getMutableItems() {
      bitField0_ |= 0x00000002;
      return items;
    }

    /**
     * <code>optional .ChangeInfo Items = 2;</code>
     * @param value the items to set
     * @return this
     */
    public CollectResp setItems(final ChangeInfo value) {
      bitField0_ |= 0x00000002;
      items.copyFrom(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public CollectResp clearNextPackage() {
      bitField0_ &= ~0x00000004;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000004;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public CollectResp addNextPackage(final byte value) {
      bitField0_ |= 0x00000004;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public CollectResp addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000004;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public CollectResp setNextPackage(final byte... values) {
      bitField0_ |= 0x00000004;
      nextPackage.copyFrom(values);
      return this;
    }

    @Override
    public CollectResp copyFrom(final CollectResp other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        status = other.status;
        items.copyFrom(other.items);
        nextPackage.copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public CollectResp mergeFrom(final CollectResp other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasStatus()) {
        setStatusValue(other.status);
      }
      if (other.hasItems()) {
        getMutableItems().mergeFrom(other.items);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public CollectResp clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      status = 0;
      items.clear();
      nextPackage.clear();
      return this;
    }

    @Override
    public CollectResp clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      items.clearQuick();
      nextPackage.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof CollectResp)) {
        return false;
      }
      CollectResp other = (CollectResp) o;
      return bitField0_ == other.bitField0_
        && (!hasStatus() || status == other.status)
        && (!hasItems() || items.equals(other.items))
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 8);
        output.writeEnumNoTag(status);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 18);
        output.writeMessageNoTag(items);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeEnumSizeNoTag(status);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeMessageSizeNoTag(items);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public CollectResp mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            // status
            final int value = input.readInt32();
            if (StatusEnum.forNumber(value) != null) {
              status = value;
              bitField0_ |= 0x00000001;
            }
            tag = input.readTag();
            if (tag != 18) {
              break;
            }
          }
          case 18: {
            // items
            input.readMessage(items);
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeEnum(FieldNames.status, status, StatusEnum.converter());
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeMessage(FieldNames.items, items);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      output.endObject();
    }

    @Override
    public CollectResp mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case -1808614382: {
            if (input.isAtField(FieldNames.status)) {
              if (!input.trySkipNullValue()) {
                final StatusEnum value = input.readEnum(StatusEnum.converter());
                if (value != null) {
                  status = value.getNumber();
                  bitField0_ |= 0x00000001;
                } else {
                  input.skipUnknownEnumValue();
                }
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 70973344: {
            if (input.isAtField(FieldNames.items)) {
              if (!input.trySkipNullValue()) {
                input.readMessage(items);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public CollectResp clone() {
      return new CollectResp().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static CollectResp parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new CollectResp(), data).checkInitialized();
    }

    public static CollectResp parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new CollectResp(), input).checkInitialized();
    }

    public static CollectResp parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new CollectResp(), input).checkInitialized();
    }

    /**
     * @return factory for creating CollectResp messages
     */
    public static MessageFactory<CollectResp> getFactory() {
      return CollectRespFactory.INSTANCE;
    }

    /**
     * Protobuf enum {@code StatusEnum}
     */
    public enum StatusEnum implements ProtoEnum<StatusEnum> {
      /**
       * <code>Unpaid = 0;</code>
       */
      Unpaid("Unpaid", 0),

      /**
       * <code>Done = 1;</code>
       */
      Done("Done", 1),

      /**
       * <code>Retry = 2;</code>
       */
      Retry("Retry", 2),

      /**
       * <code>Error = 3;</code>
       */
      Error("Error", 3);

      /**
       * <code>Unpaid = 0;</code>
       */
      public static final int Unpaid_VALUE = 0;

      /**
       * <code>Done = 1;</code>
       */
      public static final int Done_VALUE = 1;

      /**
       * <code>Retry = 2;</code>
       */
      public static final int Retry_VALUE = 2;

      /**
       * <code>Error = 3;</code>
       */
      public static final int Error_VALUE = 3;

      private final java.lang.String name;

      private final int number;

      private StatusEnum(java.lang.String name, int number) {
        this.name = name;
        this.number = number;
      }

      /**
       * @return the string representation of enum entry
       */
      @Override
      public java.lang.String getName() {
        return name;
      }

      /**
       * @return the numeric wire value of this enum entry
       */
      @Override
      public int getNumber() {
        return number;
      }

      /**
       * @return a converter that maps between this enum's numeric and text representations
       */
      public static ProtoEnum.EnumConverter<StatusEnum> converter() {
        return StatusEnumConverter.INSTANCE;
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value, or null if unknown.
       */
      public static StatusEnum forNumber(int value) {
        return StatusEnumConverter.INSTANCE.forNumber(value);
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @param other Fallback value in case the value is not known.
       * @return The enum associated with the given numeric wire value, or the fallback value if unknown.
       */
      public static StatusEnum forNumberOr(int number, StatusEnum other) {
        StatusEnum value = forNumber(number);
        return value == null ? other : value;
      }

      enum StatusEnumConverter implements ProtoEnum.EnumConverter<StatusEnum> {
        INSTANCE;

        private static final StatusEnum[] lookup = new StatusEnum[4];

        static {
          lookup[0] = Unpaid;
          lookup[1] = Done;
          lookup[2] = Retry;
          lookup[3] = Error;
        }

        @Override
        public final StatusEnum forNumber(final int value) {
          if (value >= 0 && value < lookup.length) {
            return lookup[value];
          }
          return null;
        }

        @Override
        public final StatusEnum forName(final CharSequence value) {
          if (value.length() == 4) {
            if (ProtoUtil.isEqual("Done", value)) {
              return Done;
            }
          }
          if (value.length() == 5) {
            if (ProtoUtil.isEqual("Retry", value)) {
              return Retry;
            }
            if (ProtoUtil.isEqual("Error", value)) {
              return Error;
            }
          }
          if (value.length() == 6) {
            if (ProtoUtil.isEqual("Unpaid", value)) {
              return Unpaid;
            }
          }
          return null;
        }
      }
    }

    private enum CollectRespFactory implements MessageFactory<CollectResp> {
      INSTANCE;

      @Override
      public CollectResp create() {
        return CollectResp.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName status = FieldName.forField("Status");

      static final FieldName items = FieldName.forField("Items");

      static final FieldName nextPackage = FieldName.forField("NextPackage");
    }
  }

  /**
   * Protobuf type {@code EquipmentAttr}
   */
  public static final class EquipmentAttr extends ProtoMessage<EquipmentAttr> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional int32 Value = 2;</code>
     */
    private int value_;

    /**
     * <code>optional uint32 Id = 1;</code>
     */
    private int id;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    private EquipmentAttr() {
    }

    /**
     * @return a new empty instance of {@code EquipmentAttr}
     */
    public static EquipmentAttr newInstance() {
      return new EquipmentAttr();
    }

    /**
     * <code>optional int32 Value = 2;</code>
     * @return whether the value_ field is set
     */
    public boolean hasValue() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional int32 Value = 2;</code>
     * @return this
     */
    public EquipmentAttr clearValue() {
      bitField0_ &= ~0x00000001;
      value_ = 0;
      return this;
    }

    /**
     * <code>optional int32 Value = 2;</code>
     * @return the value_
     */
    public int getValue() {
      return value_;
    }

    /**
     * <code>optional int32 Value = 2;</code>
     * @param value the value_ to set
     * @return this
     */
    public EquipmentAttr setValue(final int value) {
      bitField0_ |= 0x00000001;
      value_ = value;
      return this;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @return whether the id field is set
     */
    public boolean hasId() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @return this
     */
    public EquipmentAttr clearId() {
      bitField0_ &= ~0x00000002;
      id = 0;
      return this;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @return the id
     */
    public int getId() {
      return id;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @param value the id to set
     * @return this
     */
    public EquipmentAttr setId(final int value) {
      bitField0_ |= 0x00000002;
      id = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public EquipmentAttr clearNextPackage() {
      bitField0_ &= ~0x00000004;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000004;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public EquipmentAttr addNextPackage(final byte value) {
      bitField0_ |= 0x00000004;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public EquipmentAttr addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000004;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public EquipmentAttr setNextPackage(final byte... values) {
      bitField0_ |= 0x00000004;
      nextPackage.copyFrom(values);
      return this;
    }

    @Override
    public EquipmentAttr copyFrom(final EquipmentAttr other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        value_ = other.value_;
        id = other.id;
        nextPackage.copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public EquipmentAttr mergeFrom(final EquipmentAttr other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasValue()) {
        setValue(other.value_);
      }
      if (other.hasId()) {
        setId(other.id);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public EquipmentAttr clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      value_ = 0;
      id = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public EquipmentAttr clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof EquipmentAttr)) {
        return false;
      }
      EquipmentAttr other = (EquipmentAttr) o;
      return bitField0_ == other.bitField0_
        && (!hasValue() || value_ == other.value_)
        && (!hasId() || id == other.id)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 16);
        output.writeInt32NoTag(value_);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt32NoTag(id);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeInt32SizeNoTag(value_);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(id);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public EquipmentAttr mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 16: {
            // value_
            value_ = input.readInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 8) {
              break;
            }
          }
          case 8: {
            // id
            id = input.readUInt32();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeInt32(FieldNames.value_, value_);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeUInt32(FieldNames.id, id);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      output.endObject();
    }

    @Override
    public EquipmentAttr mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 82420049: {
            if (input.isAtField(FieldNames.value_)) {
              if (!input.trySkipNullValue()) {
                value_ = input.readInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 2363: {
            if (input.isAtField(FieldNames.id)) {
              if (!input.trySkipNullValue()) {
                id = input.readUInt32();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public EquipmentAttr clone() {
      return new EquipmentAttr().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static EquipmentAttr parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new EquipmentAttr(), data).checkInitialized();
    }

    public static EquipmentAttr parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new EquipmentAttr(), input).checkInitialized();
    }

    public static EquipmentAttr parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new EquipmentAttr(), input).checkInitialized();
    }

    /**
     * @return factory for creating EquipmentAttr messages
     */
    public static MessageFactory<EquipmentAttr> getFactory() {
      return EquipmentAttrFactory.INSTANCE;
    }

    private enum EquipmentAttrFactory implements MessageFactory<EquipmentAttr> {
      INSTANCE;

      @Override
      public EquipmentAttr create() {
        return EquipmentAttr.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName value_ = FieldName.forField("Value");

      static final FieldName id = FieldName.forField("Id");

      static final FieldName nextPackage = FieldName.forField("NextPackage");
    }
  }

  /**
   * Protobuf type {@code EquipmentInfo}
   */
  public static final class EquipmentInfo extends ProtoMessage<EquipmentInfo> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional uint64 Id = 1;</code>
     */
    private long id;

    /**
     * <code>optional uint32 Tid = 2;</code>
     */
    private int tid;

    /**
     * <code>optional uint32 Exp = 3;</code>
     */
    private int exp;

    /**
     * <code>optional bool Lock = 4;</code>
     */
    private boolean lock;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    /**
     * <code>repeated uint32 Tags = 5;</code>
     */
    private final RepeatedInt tags = RepeatedInt.newEmptyInstance();

    /**
     * <code>repeated .EquipmentAttr Attrs = 6;</code>
     */
    private final RepeatedMessage<EquipmentAttr> attrs = RepeatedMessage.newEmptyInstance(EquipmentAttr.getFactory());

    private EquipmentInfo() {
    }

    /**
     * @return a new empty instance of {@code EquipmentInfo}
     */
    public static EquipmentInfo newInstance() {
      return new EquipmentInfo();
    }

    /**
     * <code>optional uint64 Id = 1;</code>
     * @return whether the id field is set
     */
    public boolean hasId() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional uint64 Id = 1;</code>
     * @return this
     */
    public EquipmentInfo clearId() {
      bitField0_ &= ~0x00000001;
      id = 0L;
      return this;
    }

    /**
     * <code>optional uint64 Id = 1;</code>
     * @return the id
     */
    public long getId() {
      return id;
    }

    /**
     * <code>optional uint64 Id = 1;</code>
     * @param value the id to set
     * @return this
     */
    public EquipmentInfo setId(final long value) {
      bitField0_ |= 0x00000001;
      id = value;
      return this;
    }

    /**
     * <code>optional uint32 Tid = 2;</code>
     * @return whether the tid field is set
     */
    public boolean hasTid() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional uint32 Tid = 2;</code>
     * @return this
     */
    public EquipmentInfo clearTid() {
      bitField0_ &= ~0x00000002;
      tid = 0;
      return this;
    }

    /**
     * <code>optional uint32 Tid = 2;</code>
     * @return the tid
     */
    public int getTid() {
      return tid;
    }

    /**
     * <code>optional uint32 Tid = 2;</code>
     * @param value the tid to set
     * @return this
     */
    public EquipmentInfo setTid(final int value) {
      bitField0_ |= 0x00000002;
      tid = value;
      return this;
    }

    /**
     * <code>optional uint32 Exp = 3;</code>
     * @return whether the exp field is set
     */
    public boolean hasExp() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional uint32 Exp = 3;</code>
     * @return this
     */
    public EquipmentInfo clearExp() {
      bitField0_ &= ~0x00000004;
      exp = 0;
      return this;
    }

    /**
     * <code>optional uint32 Exp = 3;</code>
     * @return the exp
     */
    public int getExp() {
      return exp;
    }

    /**
     * <code>optional uint32 Exp = 3;</code>
     * @param value the exp to set
     * @return this
     */
    public EquipmentInfo setExp(final int value) {
      bitField0_ |= 0x00000004;
      exp = value;
      return this;
    }

    /**
     * <code>optional bool Lock = 4;</code>
     * @return whether the lock field is set
     */
    public boolean hasLock() {
      return (bitField0_ & 0x00000008) != 0;
    }

    /**
     * <code>optional bool Lock = 4;</code>
     * @return this
     */
    public EquipmentInfo clearLock() {
      bitField0_ &= ~0x00000008;
      lock = false;
      return this;
    }

    /**
     * <code>optional bool Lock = 4;</code>
     * @return the lock
     */
    public boolean getLock() {
      return lock;
    }

    /**
     * <code>optional bool Lock = 4;</code>
     * @param value the lock to set
     * @return this
     */
    public EquipmentInfo setLock(final boolean value) {
      bitField0_ |= 0x00000008;
      lock = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000010) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public EquipmentInfo clearNextPackage() {
      bitField0_ &= ~0x00000010;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000010;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public EquipmentInfo addNextPackage(final byte value) {
      bitField0_ |= 0x00000010;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public EquipmentInfo addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000010;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public EquipmentInfo setNextPackage(final byte... values) {
      bitField0_ |= 0x00000010;
      nextPackage.copyFrom(values);
      return this;
    }

    /**
     * <code>repeated uint32 Tags = 5;</code>
     * @return whether the tags field is set
     */
    public boolean hasTags() {
      return (bitField0_ & 0x00000020) != 0;
    }

    /**
     * <code>repeated uint32 Tags = 5;</code>
     * @return this
     */
    public EquipmentInfo clearTags() {
      bitField0_ &= ~0x00000020;
      tags.clear();
      return this;
    }

    /**
     * <code>repeated uint32 Tags = 5;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableTags()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedInt getTags() {
      return tags;
    }

    /**
     * <code>repeated uint32 Tags = 5;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedInt getMutableTags() {
      bitField0_ |= 0x00000020;
      return tags;
    }

    /**
     * <code>repeated uint32 Tags = 5;</code>
     * @param value the tags to add
     * @return this
     */
    public EquipmentInfo addTags(final int value) {
      bitField0_ |= 0x00000020;
      tags.add(value);
      return this;
    }

    /**
     * <code>repeated uint32 Tags = 5;</code>
     * @param values the tags to add
     * @return this
     */
    public EquipmentInfo addAllTags(final int... values) {
      bitField0_ |= 0x00000020;
      tags.addAll(values);
      return this;
    }

    /**
     * <code>repeated .EquipmentAttr Attrs = 6;</code>
     * @return whether the attrs field is set
     */
    public boolean hasAttrs() {
      return (bitField0_ & 0x00000040) != 0;
    }

    /**
     * <code>repeated .EquipmentAttr Attrs = 6;</code>
     * @return this
     */
    public EquipmentInfo clearAttrs() {
      bitField0_ &= ~0x00000040;
      attrs.clear();
      return this;
    }

    /**
     * <code>repeated .EquipmentAttr Attrs = 6;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableAttrs()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<EquipmentAttr> getAttrs() {
      return attrs;
    }

    /**
     * <code>repeated .EquipmentAttr Attrs = 6;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<EquipmentAttr> getMutableAttrs() {
      bitField0_ |= 0x00000040;
      return attrs;
    }

    /**
     * <code>repeated .EquipmentAttr Attrs = 6;</code>
     * @param value the attrs to add
     * @return this
     */
    public EquipmentInfo addAttrs(final EquipmentAttr value) {
      bitField0_ |= 0x00000040;
      attrs.add(value);
      return this;
    }

    /**
     * <code>repeated .EquipmentAttr Attrs = 6;</code>
     * @param values the attrs to add
     * @return this
     */
    public EquipmentInfo addAllAttrs(final EquipmentAttr... values) {
      bitField0_ |= 0x00000040;
      attrs.addAll(values);
      return this;
    }

    @Override
    public EquipmentInfo copyFrom(final EquipmentInfo other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        id = other.id;
        tid = other.tid;
        exp = other.exp;
        lock = other.lock;
        nextPackage.copyFrom(other.nextPackage);
        tags.copyFrom(other.tags);
        attrs.copyFrom(other.attrs);
      }
      return this;
    }

    @Override
    public EquipmentInfo mergeFrom(final EquipmentInfo other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasId()) {
        setId(other.id);
      }
      if (other.hasTid()) {
        setTid(other.tid);
      }
      if (other.hasExp()) {
        setExp(other.exp);
      }
      if (other.hasLock()) {
        setLock(other.lock);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      if (other.hasTags()) {
        getMutableTags().addAll(other.tags);
      }
      if (other.hasAttrs()) {
        getMutableAttrs().addAll(other.attrs);
      }
      return this;
    }

    @Override
    public EquipmentInfo clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      id = 0L;
      tid = 0;
      exp = 0;
      lock = false;
      nextPackage.clear();
      tags.clear();
      attrs.clear();
      return this;
    }

    @Override
    public EquipmentInfo clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      tags.clear();
      attrs.clearQuick();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof EquipmentInfo)) {
        return false;
      }
      EquipmentInfo other = (EquipmentInfo) o;
      return bitField0_ == other.bitField0_
        && (!hasId() || id == other.id)
        && (!hasTid() || tid == other.tid)
        && (!hasExp() || exp == other.exp)
        && (!hasLock() || lock == other.lock)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage))
        && (!hasTags() || tags.equals(other.tags))
        && (!hasAttrs() || attrs.equals(other.attrs));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt64NoTag(id);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 16);
        output.writeUInt32NoTag(tid);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawByte((byte) 24);
        output.writeUInt32NoTag(exp);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeRawByte((byte) 32);
        output.writeBoolNoTag(lock);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        for (int i = 0; i < tags.length(); i++) {
          output.writeRawByte((byte) 40);
          output.writeUInt32NoTag(tags.array()[i]);
        }
      }
      if ((bitField0_ & 0x00000040) != 0) {
        for (int i = 0; i < attrs.length(); i++) {
          output.writeRawByte((byte) 50);
          output.writeMessageNoTag(attrs.get(i));
        }
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeUInt64SizeNoTag(id);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(tid);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(exp);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        size += 2;
      }
      if ((bitField0_ & 0x00000010) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        size += (1 * tags.length()) + ProtoSink.computeRepeatedUInt32SizeNoTag(tags);
      }
      if ((bitField0_ & 0x00000040) != 0) {
        size += (1 * attrs.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(attrs);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public EquipmentInfo mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            // id
            id = input.readUInt64();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 16) {
              break;
            }
          }
          case 16: {
            // tid
            tid = input.readUInt32();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 24) {
              break;
            }
          }
          case 24: {
            // exp
            exp = input.readUInt32();
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 32) {
              break;
            }
          }
          case 32: {
            // lock
            lock = input.readBool();
            bitField0_ |= 0x00000008;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000010;
            tag = input.readTag();
            if (tag != 42) {
              break;
            }
          }
          case 42: {
            // tags [packed=true]
            input.readPackedUInt32(tags, tag);
            bitField0_ |= 0x00000020;
            tag = input.readTag();
            if (tag != 50) {
              break;
            }
          }
          case 50: {
            // attrs
            tag = input.readRepeatedMessage(attrs, tag);
            bitField0_ |= 0x00000040;
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
          case 40: {
            // tags [packed=false]
            tag = input.readRepeatedUInt32(tags, tag);
            bitField0_ |= 0x00000020;
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeUInt64(FieldNames.id, id);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeUInt32(FieldNames.tid, tid);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeUInt32(FieldNames.exp, exp);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeBool(FieldNames.lock, lock);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        output.writeRepeatedUInt32(FieldNames.tags, tags);
      }
      if ((bitField0_ & 0x00000040) != 0) {
        output.writeRepeatedMessage(FieldNames.attrs, attrs);
      }
      output.endObject();
    }

    @Override
    public EquipmentInfo mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 2363: {
            if (input.isAtField(FieldNames.id)) {
              if (!input.trySkipNullValue()) {
                id = input.readUInt64();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 84079: {
            if (input.isAtField(FieldNames.tid)) {
              if (!input.trySkipNullValue()) {
                tid = input.readUInt32();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 70141: {
            if (input.isAtField(FieldNames.exp)) {
              if (!input.trySkipNullValue()) {
                exp = input.readUInt32();
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 2373963: {
            if (input.isAtField(FieldNames.lock)) {
              if (!input.trySkipNullValue()) {
                lock = input.readBool();
                bitField0_ |= 0x00000008;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000010;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 2598969: {
            if (input.isAtField(FieldNames.tags)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedUInt32(tags);
                bitField0_ |= 0x00000020;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 63599746: {
            if (input.isAtField(FieldNames.attrs)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedMessage(attrs);
                bitField0_ |= 0x00000040;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public EquipmentInfo clone() {
      return new EquipmentInfo().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static EquipmentInfo parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new EquipmentInfo(), data).checkInitialized();
    }

    public static EquipmentInfo parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new EquipmentInfo(), input).checkInitialized();
    }

    public static EquipmentInfo parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new EquipmentInfo(), input).checkInitialized();
    }

    /**
     * @return factory for creating EquipmentInfo messages
     */
    public static MessageFactory<EquipmentInfo> getFactory() {
      return EquipmentInfoFactory.INSTANCE;
    }

    private enum EquipmentInfoFactory implements MessageFactory<EquipmentInfo> {
      INSTANCE;

      @Override
      public EquipmentInfo create() {
        return EquipmentInfo.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName id = FieldName.forField("Id");

      static final FieldName tid = FieldName.forField("Tid");

      static final FieldName exp = FieldName.forField("Exp");

      static final FieldName lock = FieldName.forField("Lock");

      static final FieldName nextPackage = FieldName.forField("NextPackage");

      static final FieldName tags = FieldName.forField("Tags");

      static final FieldName attrs = FieldName.forField("Attrs");
    }
  }

  /**
   * Protobuf type {@code EquipmentInstance}
   */
  public static final class EquipmentInstance extends ProtoMessage<EquipmentInstance> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional uint64 BuildId = 15;</code>
     */
    private long buildId;

    /**
     * <code>optional uint32 Id = 1;</code>
     */
    private int id;

    /**
     * <code>optional uint32 Star = 2;</code>
     */
    private int star;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    private EquipmentInstance() {
    }

    /**
     * @return a new empty instance of {@code EquipmentInstance}
     */
    public static EquipmentInstance newInstance() {
      return new EquipmentInstance();
    }

    /**
     * <code>optional uint64 BuildId = 15;</code>
     * @return whether the buildId field is set
     */
    public boolean hasBuildId() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional uint64 BuildId = 15;</code>
     * @return this
     */
    public EquipmentInstance clearBuildId() {
      bitField0_ &= ~0x00000001;
      buildId = 0L;
      return this;
    }

    /**
     * <code>optional uint64 BuildId = 15;</code>
     * @return the buildId
     */
    public long getBuildId() {
      return buildId;
    }

    /**
     * <code>optional uint64 BuildId = 15;</code>
     * @param value the buildId to set
     * @return this
     */
    public EquipmentInstance setBuildId(final long value) {
      bitField0_ |= 0x00000001;
      buildId = value;
      return this;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @return whether the id field is set
     */
    public boolean hasId() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @return this
     */
    public EquipmentInstance clearId() {
      bitField0_ &= ~0x00000002;
      id = 0;
      return this;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @return the id
     */
    public int getId() {
      return id;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @param value the id to set
     * @return this
     */
    public EquipmentInstance setId(final int value) {
      bitField0_ |= 0x00000002;
      id = value;
      return this;
    }

    /**
     * <code>optional uint32 Star = 2;</code>
     * @return whether the star field is set
     */
    public boolean hasStar() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional uint32 Star = 2;</code>
     * @return this
     */
    public EquipmentInstance clearStar() {
      bitField0_ &= ~0x00000004;
      star = 0;
      return this;
    }

    /**
     * <code>optional uint32 Star = 2;</code>
     * @return the star
     */
    public int getStar() {
      return star;
    }

    /**
     * <code>optional uint32 Star = 2;</code>
     * @param value the star to set
     * @return this
     */
    public EquipmentInstance setStar(final int value) {
      bitField0_ |= 0x00000004;
      star = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000008) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public EquipmentInstance clearNextPackage() {
      bitField0_ &= ~0x00000008;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000008;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public EquipmentInstance addNextPackage(final byte value) {
      bitField0_ |= 0x00000008;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public EquipmentInstance addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000008;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public EquipmentInstance setNextPackage(final byte... values) {
      bitField0_ |= 0x00000008;
      nextPackage.copyFrom(values);
      return this;
    }

    @Override
    public EquipmentInstance copyFrom(final EquipmentInstance other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        buildId = other.buildId;
        id = other.id;
        star = other.star;
        nextPackage.copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public EquipmentInstance mergeFrom(final EquipmentInstance other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasBuildId()) {
        setBuildId(other.buildId);
      }
      if (other.hasId()) {
        setId(other.id);
      }
      if (other.hasStar()) {
        setStar(other.star);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public EquipmentInstance clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      buildId = 0L;
      id = 0;
      star = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public EquipmentInstance clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof EquipmentInstance)) {
        return false;
      }
      EquipmentInstance other = (EquipmentInstance) o;
      return bitField0_ == other.bitField0_
        && (!hasBuildId() || buildId == other.buildId)
        && (!hasId() || id == other.id)
        && (!hasStar() || star == other.star)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 120);
        output.writeUInt64NoTag(buildId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt32NoTag(id);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawByte((byte) 16);
        output.writeUInt32NoTag(star);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeUInt64SizeNoTag(buildId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(id);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(star);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public EquipmentInstance mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 120: {
            // buildId
            buildId = input.readUInt64();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 8) {
              break;
            }
          }
          case 8: {
            // id
            id = input.readUInt32();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 16) {
              break;
            }
          }
          case 16: {
            // star
            star = input.readUInt32();
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000008;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeUInt64(FieldNames.buildId, buildId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeUInt32(FieldNames.id, id);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeUInt32(FieldNames.star, star);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      output.endObject();
    }

    @Override
    public EquipmentInstance mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 1895597065: {
            if (input.isAtField(FieldNames.buildId)) {
              if (!input.trySkipNullValue()) {
                buildId = input.readUInt64();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 2363: {
            if (input.isAtField(FieldNames.id)) {
              if (!input.trySkipNullValue()) {
                id = input.readUInt32();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 2587250: {
            if (input.isAtField(FieldNames.star)) {
              if (!input.trySkipNullValue()) {
                star = input.readUInt32();
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000008;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public EquipmentInstance clone() {
      return new EquipmentInstance().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static EquipmentInstance parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new EquipmentInstance(), data).checkInitialized();
    }

    public static EquipmentInstance parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new EquipmentInstance(), input).checkInitialized();
    }

    public static EquipmentInstance parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new EquipmentInstance(), input).checkInitialized();
    }

    /**
     * @return factory for creating EquipmentInstance messages
     */
    public static MessageFactory<EquipmentInstance> getFactory() {
      return EquipmentInstanceFactory.INSTANCE;
    }

    private enum EquipmentInstanceFactory implements MessageFactory<EquipmentInstance> {
      INSTANCE;

      @Override
      public EquipmentInstance create() {
        return EquipmentInstance.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName buildId = FieldName.forField("BuildId");

      static final FieldName id = FieldName.forField("Id");

      static final FieldName star = FieldName.forField("Star");

      static final FieldName nextPackage = FieldName.forField("NextPackage");
    }
  }

  /**
   * Protobuf type {@code AgentInfo}
   */
  public static final class AgentInfo extends ProtoMessage<AgentInfo> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional int64 StartTime = 5;</code>
     */
    private long startTime;

    /**
     * <code>optional uint64 BuildId = 4;</code>
     */
    private long buildId;

    /**
     * <code>optional uint32 Id = 1;</code>
     */
    private int id;

    /**
     * <code>optional uint32 ProcessTime = 2;</code>
     */
    private int processTime;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    /**
     * <code>repeated uint32 CharIds = 3;</code>
     */
    private final RepeatedInt charIds = RepeatedInt.newEmptyInstance();

    private AgentInfo() {
    }

    /**
     * @return a new empty instance of {@code AgentInfo}
     */
    public static AgentInfo newInstance() {
      return new AgentInfo();
    }

    /**
     * <code>optional int64 StartTime = 5;</code>
     * @return whether the startTime field is set
     */
    public boolean hasStartTime() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional int64 StartTime = 5;</code>
     * @return this
     */
    public AgentInfo clearStartTime() {
      bitField0_ &= ~0x00000001;
      startTime = 0L;
      return this;
    }

    /**
     * <code>optional int64 StartTime = 5;</code>
     * @return the startTime
     */
    public long getStartTime() {
      return startTime;
    }

    /**
     * <code>optional int64 StartTime = 5;</code>
     * @param value the startTime to set
     * @return this
     */
    public AgentInfo setStartTime(final long value) {
      bitField0_ |= 0x00000001;
      startTime = value;
      return this;
    }

    /**
     * <code>optional uint64 BuildId = 4;</code>
     * @return whether the buildId field is set
     */
    public boolean hasBuildId() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional uint64 BuildId = 4;</code>
     * @return this
     */
    public AgentInfo clearBuildId() {
      bitField0_ &= ~0x00000002;
      buildId = 0L;
      return this;
    }

    /**
     * <code>optional uint64 BuildId = 4;</code>
     * @return the buildId
     */
    public long getBuildId() {
      return buildId;
    }

    /**
     * <code>optional uint64 BuildId = 4;</code>
     * @param value the buildId to set
     * @return this
     */
    public AgentInfo setBuildId(final long value) {
      bitField0_ |= 0x00000002;
      buildId = value;
      return this;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @return whether the id field is set
     */
    public boolean hasId() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @return this
     */
    public AgentInfo clearId() {
      bitField0_ &= ~0x00000004;
      id = 0;
      return this;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @return the id
     */
    public int getId() {
      return id;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @param value the id to set
     * @return this
     */
    public AgentInfo setId(final int value) {
      bitField0_ |= 0x00000004;
      id = value;
      return this;
    }

    /**
     * <code>optional uint32 ProcessTime = 2;</code>
     * @return whether the processTime field is set
     */
    public boolean hasProcessTime() {
      return (bitField0_ & 0x00000008) != 0;
    }

    /**
     * <code>optional uint32 ProcessTime = 2;</code>
     * @return this
     */
    public AgentInfo clearProcessTime() {
      bitField0_ &= ~0x00000008;
      processTime = 0;
      return this;
    }

    /**
     * <code>optional uint32 ProcessTime = 2;</code>
     * @return the processTime
     */
    public int getProcessTime() {
      return processTime;
    }

    /**
     * <code>optional uint32 ProcessTime = 2;</code>
     * @param value the processTime to set
     * @return this
     */
    public AgentInfo setProcessTime(final int value) {
      bitField0_ |= 0x00000008;
      processTime = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000010) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public AgentInfo clearNextPackage() {
      bitField0_ &= ~0x00000010;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000010;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public AgentInfo addNextPackage(final byte value) {
      bitField0_ |= 0x00000010;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public AgentInfo addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000010;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public AgentInfo setNextPackage(final byte... values) {
      bitField0_ |= 0x00000010;
      nextPackage.copyFrom(values);
      return this;
    }

    /**
     * <code>repeated uint32 CharIds = 3;</code>
     * @return whether the charIds field is set
     */
    public boolean hasCharIds() {
      return (bitField0_ & 0x00000020) != 0;
    }

    /**
     * <code>repeated uint32 CharIds = 3;</code>
     * @return this
     */
    public AgentInfo clearCharIds() {
      bitField0_ &= ~0x00000020;
      charIds.clear();
      return this;
    }

    /**
     * <code>repeated uint32 CharIds = 3;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableCharIds()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedInt getCharIds() {
      return charIds;
    }

    /**
     * <code>repeated uint32 CharIds = 3;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedInt getMutableCharIds() {
      bitField0_ |= 0x00000020;
      return charIds;
    }

    /**
     * <code>repeated uint32 CharIds = 3;</code>
     * @param value the charIds to add
     * @return this
     */
    public AgentInfo addCharIds(final int value) {
      bitField0_ |= 0x00000020;
      charIds.add(value);
      return this;
    }

    /**
     * <code>repeated uint32 CharIds = 3;</code>
     * @param values the charIds to add
     * @return this
     */
    public AgentInfo addAllCharIds(final int... values) {
      bitField0_ |= 0x00000020;
      charIds.addAll(values);
      return this;
    }

    @Override
    public AgentInfo copyFrom(final AgentInfo other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        startTime = other.startTime;
        buildId = other.buildId;
        id = other.id;
        processTime = other.processTime;
        nextPackage.copyFrom(other.nextPackage);
        charIds.copyFrom(other.charIds);
      }
      return this;
    }

    @Override
    public AgentInfo mergeFrom(final AgentInfo other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasStartTime()) {
        setStartTime(other.startTime);
      }
      if (other.hasBuildId()) {
        setBuildId(other.buildId);
      }
      if (other.hasId()) {
        setId(other.id);
      }
      if (other.hasProcessTime()) {
        setProcessTime(other.processTime);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      if (other.hasCharIds()) {
        getMutableCharIds().addAll(other.charIds);
      }
      return this;
    }

    @Override
    public AgentInfo clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      startTime = 0L;
      buildId = 0L;
      id = 0;
      processTime = 0;
      nextPackage.clear();
      charIds.clear();
      return this;
    }

    @Override
    public AgentInfo clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      charIds.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof AgentInfo)) {
        return false;
      }
      AgentInfo other = (AgentInfo) o;
      return bitField0_ == other.bitField0_
        && (!hasStartTime() || startTime == other.startTime)
        && (!hasBuildId() || buildId == other.buildId)
        && (!hasId() || id == other.id)
        && (!hasProcessTime() || processTime == other.processTime)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage))
        && (!hasCharIds() || charIds.equals(other.charIds));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 40);
        output.writeInt64NoTag(startTime);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 32);
        output.writeUInt64NoTag(buildId);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt32NoTag(id);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeRawByte((byte) 16);
        output.writeUInt32NoTag(processTime);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        for (int i = 0; i < charIds.length(); i++) {
          output.writeRawByte((byte) 24);
          output.writeUInt32NoTag(charIds.array()[i]);
        }
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeInt64SizeNoTag(startTime);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeUInt64SizeNoTag(buildId);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(id);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(processTime);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        size += (1 * charIds.length()) + ProtoSink.computeRepeatedUInt32SizeNoTag(charIds);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public AgentInfo mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 40: {
            // startTime
            startTime = input.readInt64();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 32) {
              break;
            }
          }
          case 32: {
            // buildId
            buildId = input.readUInt64();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 8) {
              break;
            }
          }
          case 8: {
            // id
            id = input.readUInt32();
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 16) {
              break;
            }
          }
          case 16: {
            // processTime
            processTime = input.readUInt32();
            bitField0_ |= 0x00000008;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000010;
            tag = input.readTag();
            if (tag != 26) {
              break;
            }
          }
          case 26: {
            // charIds [packed=true]
            input.readPackedUInt32(charIds, tag);
            bitField0_ |= 0x00000020;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
          case 24: {
            // charIds [packed=false]
            tag = input.readRepeatedUInt32(charIds, tag);
            bitField0_ |= 0x00000020;
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeInt64(FieldNames.startTime, startTime);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeUInt64(FieldNames.buildId, buildId);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeUInt32(FieldNames.id, id);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeUInt32(FieldNames.processTime, processTime);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        output.writeRepeatedUInt32(FieldNames.charIds, charIds);
      }
      output.endObject();
    }

    @Override
    public AgentInfo mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case -125326801: {
            if (input.isAtField(FieldNames.startTime)) {
              if (!input.trySkipNullValue()) {
                startTime = input.readInt64();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 1895597065: {
            if (input.isAtField(FieldNames.buildId)) {
              if (!input.trySkipNullValue()) {
                buildId = input.readUInt64();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 2363: {
            if (input.isAtField(FieldNames.id)) {
              if (!input.trySkipNullValue()) {
                id = input.readUInt32();
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 1870380476: {
            if (input.isAtField(FieldNames.processTime)) {
              if (!input.trySkipNullValue()) {
                processTime = input.readUInt32();
                bitField0_ |= 0x00000008;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000010;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1891280030: {
            if (input.isAtField(FieldNames.charIds)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedUInt32(charIds);
                bitField0_ |= 0x00000020;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public AgentInfo clone() {
      return new AgentInfo().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static AgentInfo parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new AgentInfo(), data).checkInitialized();
    }

    public static AgentInfo parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new AgentInfo(), input).checkInitialized();
    }

    public static AgentInfo parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new AgentInfo(), input).checkInitialized();
    }

    /**
     * @return factory for creating AgentInfo messages
     */
    public static MessageFactory<AgentInfo> getFactory() {
      return AgentInfoFactory.INSTANCE;
    }

    private enum AgentInfoFactory implements MessageFactory<AgentInfo> {
      INSTANCE;

      @Override
      public AgentInfo create() {
        return AgentInfo.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName startTime = FieldName.forField("StartTime");

      static final FieldName buildId = FieldName.forField("BuildId");

      static final FieldName id = FieldName.forField("Id");

      static final FieldName processTime = FieldName.forField("ProcessTime");

      static final FieldName nextPackage = FieldName.forField("NextPackage");

      static final FieldName charIds = FieldName.forField("CharIds");
    }
  }

  /**
   * Protobuf type {@code AgentData}
   */
  public static final class AgentData extends ProtoMessage<AgentData> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    /**
     * <code>repeated uint32 NewAgentIds = 2;</code>
     */
    private final RepeatedInt newAgentIds = RepeatedInt.newEmptyInstance();

    /**
     * <code>repeated uint32 DailyIds = 3;</code>
     */
    private final RepeatedInt dailyIds = RepeatedInt.newEmptyInstance();

    /**
     * <code>repeated uint32 WeeklyIds = 4;</code>
     */
    private final RepeatedInt weeklyIds = RepeatedInt.newEmptyInstance();

    /**
     * <code>repeated .AgentInfo Infos = 1;</code>
     */
    private final RepeatedMessage<AgentInfo> infos = RepeatedMessage.newEmptyInstance(AgentInfo.getFactory());

    private AgentData() {
    }

    /**
     * @return a new empty instance of {@code AgentData}
     */
    public static AgentData newInstance() {
      return new AgentData();
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public AgentData clearNextPackage() {
      bitField0_ &= ~0x00000001;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000001;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public AgentData addNextPackage(final byte value) {
      bitField0_ |= 0x00000001;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public AgentData addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000001;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public AgentData setNextPackage(final byte... values) {
      bitField0_ |= 0x00000001;
      nextPackage.copyFrom(values);
      return this;
    }

    /**
     * <code>repeated uint32 NewAgentIds = 2;</code>
     * @return whether the newAgentIds field is set
     */
    public boolean hasNewAgentIds() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>repeated uint32 NewAgentIds = 2;</code>
     * @return this
     */
    public AgentData clearNewAgentIds() {
      bitField0_ &= ~0x00000002;
      newAgentIds.clear();
      return this;
    }

    /**
     * <code>repeated uint32 NewAgentIds = 2;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNewAgentIds()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedInt getNewAgentIds() {
      return newAgentIds;
    }

    /**
     * <code>repeated uint32 NewAgentIds = 2;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedInt getMutableNewAgentIds() {
      bitField0_ |= 0x00000002;
      return newAgentIds;
    }

    /**
     * <code>repeated uint32 NewAgentIds = 2;</code>
     * @param value the newAgentIds to add
     * @return this
     */
    public AgentData addNewAgentIds(final int value) {
      bitField0_ |= 0x00000002;
      newAgentIds.add(value);
      return this;
    }

    /**
     * <code>repeated uint32 NewAgentIds = 2;</code>
     * @param values the newAgentIds to add
     * @return this
     */
    public AgentData addAllNewAgentIds(final int... values) {
      bitField0_ |= 0x00000002;
      newAgentIds.addAll(values);
      return this;
    }

    /**
     * <code>repeated uint32 DailyIds = 3;</code>
     * @return whether the dailyIds field is set
     */
    public boolean hasDailyIds() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>repeated uint32 DailyIds = 3;</code>
     * @return this
     */
    public AgentData clearDailyIds() {
      bitField0_ &= ~0x00000004;
      dailyIds.clear();
      return this;
    }

    /**
     * <code>repeated uint32 DailyIds = 3;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableDailyIds()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedInt getDailyIds() {
      return dailyIds;
    }

    /**
     * <code>repeated uint32 DailyIds = 3;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedInt getMutableDailyIds() {
      bitField0_ |= 0x00000004;
      return dailyIds;
    }

    /**
     * <code>repeated uint32 DailyIds = 3;</code>
     * @param value the dailyIds to add
     * @return this
     */
    public AgentData addDailyIds(final int value) {
      bitField0_ |= 0x00000004;
      dailyIds.add(value);
      return this;
    }

    /**
     * <code>repeated uint32 DailyIds = 3;</code>
     * @param values the dailyIds to add
     * @return this
     */
    public AgentData addAllDailyIds(final int... values) {
      bitField0_ |= 0x00000004;
      dailyIds.addAll(values);
      return this;
    }

    /**
     * <code>repeated uint32 WeeklyIds = 4;</code>
     * @return whether the weeklyIds field is set
     */
    public boolean hasWeeklyIds() {
      return (bitField0_ & 0x00000008) != 0;
    }

    /**
     * <code>repeated uint32 WeeklyIds = 4;</code>
     * @return this
     */
    public AgentData clearWeeklyIds() {
      bitField0_ &= ~0x00000008;
      weeklyIds.clear();
      return this;
    }

    /**
     * <code>repeated uint32 WeeklyIds = 4;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableWeeklyIds()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedInt getWeeklyIds() {
      return weeklyIds;
    }

    /**
     * <code>repeated uint32 WeeklyIds = 4;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedInt getMutableWeeklyIds() {
      bitField0_ |= 0x00000008;
      return weeklyIds;
    }

    /**
     * <code>repeated uint32 WeeklyIds = 4;</code>
     * @param value the weeklyIds to add
     * @return this
     */
    public AgentData addWeeklyIds(final int value) {
      bitField0_ |= 0x00000008;
      weeklyIds.add(value);
      return this;
    }

    /**
     * <code>repeated uint32 WeeklyIds = 4;</code>
     * @param values the weeklyIds to add
     * @return this
     */
    public AgentData addAllWeeklyIds(final int... values) {
      bitField0_ |= 0x00000008;
      weeklyIds.addAll(values);
      return this;
    }

    /**
     * <code>repeated .AgentInfo Infos = 1;</code>
     * @return whether the infos field is set
     */
    public boolean hasInfos() {
      return (bitField0_ & 0x00000010) != 0;
    }

    /**
     * <code>repeated .AgentInfo Infos = 1;</code>
     * @return this
     */
    public AgentData clearInfos() {
      bitField0_ &= ~0x00000010;
      infos.clear();
      return this;
    }

    /**
     * <code>repeated .AgentInfo Infos = 1;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableInfos()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<AgentInfo> getInfos() {
      return infos;
    }

    /**
     * <code>repeated .AgentInfo Infos = 1;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<AgentInfo> getMutableInfos() {
      bitField0_ |= 0x00000010;
      return infos;
    }

    /**
     * <code>repeated .AgentInfo Infos = 1;</code>
     * @param value the infos to add
     * @return this
     */
    public AgentData addInfos(final AgentInfo value) {
      bitField0_ |= 0x00000010;
      infos.add(value);
      return this;
    }

    /**
     * <code>repeated .AgentInfo Infos = 1;</code>
     * @param values the infos to add
     * @return this
     */
    public AgentData addAllInfos(final AgentInfo... values) {
      bitField0_ |= 0x00000010;
      infos.addAll(values);
      return this;
    }

    @Override
    public AgentData copyFrom(final AgentData other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        nextPackage.copyFrom(other.nextPackage);
        newAgentIds.copyFrom(other.newAgentIds);
        dailyIds.copyFrom(other.dailyIds);
        weeklyIds.copyFrom(other.weeklyIds);
        infos.copyFrom(other.infos);
      }
      return this;
    }

    @Override
    public AgentData mergeFrom(final AgentData other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      if (other.hasNewAgentIds()) {
        getMutableNewAgentIds().addAll(other.newAgentIds);
      }
      if (other.hasDailyIds()) {
        getMutableDailyIds().addAll(other.dailyIds);
      }
      if (other.hasWeeklyIds()) {
        getMutableWeeklyIds().addAll(other.weeklyIds);
      }
      if (other.hasInfos()) {
        getMutableInfos().addAll(other.infos);
      }
      return this;
    }

    @Override
    public AgentData clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      newAgentIds.clear();
      dailyIds.clear();
      weeklyIds.clear();
      infos.clear();
      return this;
    }

    @Override
    public AgentData clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      newAgentIds.clear();
      dailyIds.clear();
      weeklyIds.clear();
      infos.clearQuick();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof AgentData)) {
        return false;
      }
      AgentData other = (AgentData) o;
      return bitField0_ == other.bitField0_
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage))
        && (!hasNewAgentIds() || newAgentIds.equals(other.newAgentIds))
        && (!hasDailyIds() || dailyIds.equals(other.dailyIds))
        && (!hasWeeklyIds() || weeklyIds.equals(other.weeklyIds))
        && (!hasInfos() || infos.equals(other.infos));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        for (int i = 0; i < newAgentIds.length(); i++) {
          output.writeRawByte((byte) 16);
          output.writeUInt32NoTag(newAgentIds.array()[i]);
        }
      }
      if ((bitField0_ & 0x00000004) != 0) {
        for (int i = 0; i < dailyIds.length(); i++) {
          output.writeRawByte((byte) 24);
          output.writeUInt32NoTag(dailyIds.array()[i]);
        }
      }
      if ((bitField0_ & 0x00000008) != 0) {
        for (int i = 0; i < weeklyIds.length(); i++) {
          output.writeRawByte((byte) 32);
          output.writeUInt32NoTag(weeklyIds.array()[i]);
        }
      }
      if ((bitField0_ & 0x00000010) != 0) {
        for (int i = 0; i < infos.length(); i++) {
          output.writeRawByte((byte) 10);
          output.writeMessageNoTag(infos.get(i));
        }
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += (1 * newAgentIds.length()) + ProtoSink.computeRepeatedUInt32SizeNoTag(newAgentIds);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += (1 * dailyIds.length()) + ProtoSink.computeRepeatedUInt32SizeNoTag(dailyIds);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        size += (1 * weeklyIds.length()) + ProtoSink.computeRepeatedUInt32SizeNoTag(weeklyIds);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        size += (1 * infos.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(infos);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public AgentData mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 18) {
              break;
            }
          }
          case 18: {
            // newAgentIds [packed=true]
            input.readPackedUInt32(newAgentIds, tag);
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 26) {
              break;
            }
          }
          case 26: {
            // dailyIds [packed=true]
            input.readPackedUInt32(dailyIds, tag);
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 34) {
              break;
            }
          }
          case 34: {
            // weeklyIds [packed=true]
            input.readPackedUInt32(weeklyIds, tag);
            bitField0_ |= 0x00000008;
            tag = input.readTag();
            if (tag != 10) {
              break;
            }
          }
          case 10: {
            // infos
            tag = input.readRepeatedMessage(infos, tag);
            bitField0_ |= 0x00000010;
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
          case 16: {
            // newAgentIds [packed=false]
            tag = input.readRepeatedUInt32(newAgentIds, tag);
            bitField0_ |= 0x00000002;
            break;
          }
          case 24: {
            // dailyIds [packed=false]
            tag = input.readRepeatedUInt32(dailyIds, tag);
            bitField0_ |= 0x00000004;
            break;
          }
          case 32: {
            // weeklyIds [packed=false]
            tag = input.readRepeatedUInt32(weeklyIds, tag);
            bitField0_ |= 0x00000008;
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRepeatedUInt32(FieldNames.newAgentIds, newAgentIds);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRepeatedUInt32(FieldNames.dailyIds, dailyIds);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeRepeatedUInt32(FieldNames.weeklyIds, weeklyIds);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        output.writeRepeatedMessage(FieldNames.infos, infos);
      }
      output.endObject();
    }

    @Override
    public AgentData mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 98785043: {
            if (input.isAtField(FieldNames.newAgentIds)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedUInt32(newAgentIds);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 1550008831: {
            if (input.isAtField(FieldNames.dailyIds)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedUInt32(dailyIds);
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -89234857: {
            if (input.isAtField(FieldNames.weeklyIds)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedUInt32(weeklyIds);
                bitField0_ |= 0x00000008;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 70795621: {
            if (input.isAtField(FieldNames.infos)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedMessage(infos);
                bitField0_ |= 0x00000010;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public AgentData clone() {
      return new AgentData().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static AgentData parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new AgentData(), data).checkInitialized();
    }

    public static AgentData parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new AgentData(), input).checkInitialized();
    }

    public static AgentData parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new AgentData(), input).checkInitialized();
    }

    /**
     * @return factory for creating AgentData messages
     */
    public static MessageFactory<AgentData> getFactory() {
      return AgentDataFactory.INSTANCE;
    }

    private enum AgentDataFactory implements MessageFactory<AgentData> {
      INSTANCE;

      @Override
      public AgentData create() {
        return AgentData.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName nextPackage = FieldName.forField("NextPackage");

      static final FieldName newAgentIds = FieldName.forField("NewAgentIds");

      static final FieldName dailyIds = FieldName.forField("DailyIds");

      static final FieldName weeklyIds = FieldName.forField("WeeklyIds");

      static final FieldName infos = FieldName.forField("Infos");
    }
  }

  /**
   * Protobuf type {@code HonorInfo}
   */
  public static final class HonorInfo extends ProtoMessage<HonorInfo> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional uint32 Id = 1;</code>
     */
    private int id;

    /**
     * <code>optional uint32 AffinityLV = 2;</code>
     */
    private int affinityLV;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    private HonorInfo() {
    }

    /**
     * @return a new empty instance of {@code HonorInfo}
     */
    public static HonorInfo newInstance() {
      return new HonorInfo();
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @return whether the id field is set
     */
    public boolean hasId() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @return this
     */
    public HonorInfo clearId() {
      bitField0_ &= ~0x00000001;
      id = 0;
      return this;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @return the id
     */
    public int getId() {
      return id;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @param value the id to set
     * @return this
     */
    public HonorInfo setId(final int value) {
      bitField0_ |= 0x00000001;
      id = value;
      return this;
    }

    /**
     * <code>optional uint32 AffinityLV = 2;</code>
     * @return whether the affinityLV field is set
     */
    public boolean hasAffinityLV() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional uint32 AffinityLV = 2;</code>
     * @return this
     */
    public HonorInfo clearAffinityLV() {
      bitField0_ &= ~0x00000002;
      affinityLV = 0;
      return this;
    }

    /**
     * <code>optional uint32 AffinityLV = 2;</code>
     * @return the affinityLV
     */
    public int getAffinityLV() {
      return affinityLV;
    }

    /**
     * <code>optional uint32 AffinityLV = 2;</code>
     * @param value the affinityLV to set
     * @return this
     */
    public HonorInfo setAffinityLV(final int value) {
      bitField0_ |= 0x00000002;
      affinityLV = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public HonorInfo clearNextPackage() {
      bitField0_ &= ~0x00000004;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000004;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public HonorInfo addNextPackage(final byte value) {
      bitField0_ |= 0x00000004;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public HonorInfo addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000004;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public HonorInfo setNextPackage(final byte... values) {
      bitField0_ |= 0x00000004;
      nextPackage.copyFrom(values);
      return this;
    }

    @Override
    public HonorInfo copyFrom(final HonorInfo other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        id = other.id;
        affinityLV = other.affinityLV;
        nextPackage.copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public HonorInfo mergeFrom(final HonorInfo other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasId()) {
        setId(other.id);
      }
      if (other.hasAffinityLV()) {
        setAffinityLV(other.affinityLV);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public HonorInfo clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      id = 0;
      affinityLV = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public HonorInfo clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof HonorInfo)) {
        return false;
      }
      HonorInfo other = (HonorInfo) o;
      return bitField0_ == other.bitField0_
        && (!hasId() || id == other.id)
        && (!hasAffinityLV() || affinityLV == other.affinityLV)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt32NoTag(id);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 16);
        output.writeUInt32NoTag(affinityLV);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(id);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(affinityLV);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public HonorInfo mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            // id
            id = input.readUInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 16) {
              break;
            }
          }
          case 16: {
            // affinityLV
            affinityLV = input.readUInt32();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeUInt32(FieldNames.id, id);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeUInt32(FieldNames.affinityLV, affinityLV);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      output.endObject();
    }

    @Override
    public HonorInfo mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 2363: {
            if (input.isAtField(FieldNames.id)) {
              if (!input.trySkipNullValue()) {
                id = input.readUInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -238852910: {
            if (input.isAtField(FieldNames.affinityLV)) {
              if (!input.trySkipNullValue()) {
                affinityLV = input.readUInt32();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public HonorInfo clone() {
      return new HonorInfo().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static HonorInfo parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new HonorInfo(), data).checkInitialized();
    }

    public static HonorInfo parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new HonorInfo(), input).checkInitialized();
    }

    public static HonorInfo parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new HonorInfo(), input).checkInitialized();
    }

    /**
     * @return factory for creating HonorInfo messages
     */
    public static MessageFactory<HonorInfo> getFactory() {
      return HonorInfoFactory.INSTANCE;
    }

    private enum HonorInfoFactory implements MessageFactory<HonorInfo> {
      INSTANCE;

      @Override
      public HonorInfo create() {
        return HonorInfo.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName id = FieldName.forField("Id");

      static final FieldName affinityLV = FieldName.forField("AffinityLV");

      static final FieldName nextPackage = FieldName.forField("NextPackage");
    }
  }

  /**
   * Protobuf type {@code CardInfo}
   */
  public static final class CardInfo extends ProtoMessage<CardInfo> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional uint32 Id = 1;</code>
     */
    private int id;

    /**
     * <code>optional bool New = 2;</code>
     */
    private boolean new_;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    private CardInfo() {
    }

    /**
     * @return a new empty instance of {@code CardInfo}
     */
    public static CardInfo newInstance() {
      return new CardInfo();
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @return whether the id field is set
     */
    public boolean hasId() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @return this
     */
    public CardInfo clearId() {
      bitField0_ &= ~0x00000001;
      id = 0;
      return this;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @return the id
     */
    public int getId() {
      return id;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @param value the id to set
     * @return this
     */
    public CardInfo setId(final int value) {
      bitField0_ |= 0x00000001;
      id = value;
      return this;
    }

    /**
     * <code>optional bool New = 2;</code>
     * @return whether the new_ field is set
     */
    public boolean hasNew() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional bool New = 2;</code>
     * @return this
     */
    public CardInfo clearNew() {
      bitField0_ &= ~0x00000002;
      new_ = false;
      return this;
    }

    /**
     * <code>optional bool New = 2;</code>
     * @return the new_
     */
    public boolean getNew() {
      return new_;
    }

    /**
     * <code>optional bool New = 2;</code>
     * @param value the new_ to set
     * @return this
     */
    public CardInfo setNew(final boolean value) {
      bitField0_ |= 0x00000002;
      new_ = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public CardInfo clearNextPackage() {
      bitField0_ &= ~0x00000004;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000004;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public CardInfo addNextPackage(final byte value) {
      bitField0_ |= 0x00000004;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public CardInfo addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000004;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public CardInfo setNextPackage(final byte... values) {
      bitField0_ |= 0x00000004;
      nextPackage.copyFrom(values);
      return this;
    }

    @Override
    public CardInfo copyFrom(final CardInfo other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        id = other.id;
        new_ = other.new_;
        nextPackage.copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public CardInfo mergeFrom(final CardInfo other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasId()) {
        setId(other.id);
      }
      if (other.hasNew()) {
        setNew(other.new_);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public CardInfo clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      id = 0;
      new_ = false;
      nextPackage.clear();
      return this;
    }

    @Override
    public CardInfo clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof CardInfo)) {
        return false;
      }
      CardInfo other = (CardInfo) o;
      return bitField0_ == other.bitField0_
        && (!hasId() || id == other.id)
        && (!hasNew() || new_ == other.new_)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt32NoTag(id);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 16);
        output.writeBoolNoTag(new_);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(id);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 2;
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public CardInfo mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            // id
            id = input.readUInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 16) {
              break;
            }
          }
          case 16: {
            // new_
            new_ = input.readBool();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeUInt32(FieldNames.id, id);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeBool(FieldNames.new_, new_);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      output.endObject();
    }

    @Override
    public CardInfo mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 2363: {
            if (input.isAtField(FieldNames.id)) {
              if (!input.trySkipNullValue()) {
                id = input.readUInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 78208: {
            if (input.isAtField(FieldNames.new_)) {
              if (!input.trySkipNullValue()) {
                new_ = input.readBool();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public CardInfo clone() {
      return new CardInfo().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static CardInfo parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new CardInfo(), data).checkInitialized();
    }

    public static CardInfo parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new CardInfo(), input).checkInitialized();
    }

    public static CardInfo parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new CardInfo(), input).checkInitialized();
    }

    /**
     * @return factory for creating CardInfo messages
     */
    public static MessageFactory<CardInfo> getFactory() {
      return CardInfoFactory.INSTANCE;
    }

    private enum CardInfoFactory implements MessageFactory<CardInfo> {
      INSTANCE;

      @Override
      public CardInfo create() {
        return CardInfo.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName id = FieldName.forField("Id");

      static final FieldName new_ = FieldName.forField("New");

      static final FieldName nextPackage = FieldName.forField("NextPackage");
    }
  }

  /**
   * Protobuf type {@code VampireSurvivorEvent}
   */
  public static final class VampireSurvivorEvent extends ProtoMessage<VampireSurvivorEvent> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional uint32 EventType = 1;</code>
     */
    private int eventType;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    /**
     * <code>repeated uint32 Numbers = 2;</code>
     */
    private final RepeatedInt numbers = RepeatedInt.newEmptyInstance();

    private VampireSurvivorEvent() {
    }

    /**
     * @return a new empty instance of {@code VampireSurvivorEvent}
     */
    public static VampireSurvivorEvent newInstance() {
      return new VampireSurvivorEvent();
    }

    /**
     * <code>optional uint32 EventType = 1;</code>
     * @return whether the eventType field is set
     */
    public boolean hasEventType() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional uint32 EventType = 1;</code>
     * @return this
     */
    public VampireSurvivorEvent clearEventType() {
      bitField0_ &= ~0x00000001;
      eventType = 0;
      return this;
    }

    /**
     * <code>optional uint32 EventType = 1;</code>
     * @return the eventType
     */
    public int getEventType() {
      return eventType;
    }

    /**
     * <code>optional uint32 EventType = 1;</code>
     * @param value the eventType to set
     * @return this
     */
    public VampireSurvivorEvent setEventType(final int value) {
      bitField0_ |= 0x00000001;
      eventType = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public VampireSurvivorEvent clearNextPackage() {
      bitField0_ &= ~0x00000002;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000002;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public VampireSurvivorEvent addNextPackage(final byte value) {
      bitField0_ |= 0x00000002;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public VampireSurvivorEvent addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000002;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public VampireSurvivorEvent setNextPackage(final byte... values) {
      bitField0_ |= 0x00000002;
      nextPackage.copyFrom(values);
      return this;
    }

    /**
     * <code>repeated uint32 Numbers = 2;</code>
     * @return whether the numbers field is set
     */
    public boolean hasNumbers() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>repeated uint32 Numbers = 2;</code>
     * @return this
     */
    public VampireSurvivorEvent clearNumbers() {
      bitField0_ &= ~0x00000004;
      numbers.clear();
      return this;
    }

    /**
     * <code>repeated uint32 Numbers = 2;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNumbers()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedInt getNumbers() {
      return numbers;
    }

    /**
     * <code>repeated uint32 Numbers = 2;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedInt getMutableNumbers() {
      bitField0_ |= 0x00000004;
      return numbers;
    }

    /**
     * <code>repeated uint32 Numbers = 2;</code>
     * @param value the numbers to add
     * @return this
     */
    public VampireSurvivorEvent addNumbers(final int value) {
      bitField0_ |= 0x00000004;
      numbers.add(value);
      return this;
    }

    /**
     * <code>repeated uint32 Numbers = 2;</code>
     * @param values the numbers to add
     * @return this
     */
    public VampireSurvivorEvent addAllNumbers(final int... values) {
      bitField0_ |= 0x00000004;
      numbers.addAll(values);
      return this;
    }

    @Override
    public VampireSurvivorEvent copyFrom(final VampireSurvivorEvent other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        eventType = other.eventType;
        nextPackage.copyFrom(other.nextPackage);
        numbers.copyFrom(other.numbers);
      }
      return this;
    }

    @Override
    public VampireSurvivorEvent mergeFrom(final VampireSurvivorEvent other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasEventType()) {
        setEventType(other.eventType);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      if (other.hasNumbers()) {
        getMutableNumbers().addAll(other.numbers);
      }
      return this;
    }

    @Override
    public VampireSurvivorEvent clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      eventType = 0;
      nextPackage.clear();
      numbers.clear();
      return this;
    }

    @Override
    public VampireSurvivorEvent clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      numbers.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof VampireSurvivorEvent)) {
        return false;
      }
      VampireSurvivorEvent other = (VampireSurvivorEvent) o;
      return bitField0_ == other.bitField0_
        && (!hasEventType() || eventType == other.eventType)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage))
        && (!hasNumbers() || numbers.equals(other.numbers));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt32NoTag(eventType);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        for (int i = 0; i < numbers.length(); i++) {
          output.writeRawByte((byte) 16);
          output.writeUInt32NoTag(numbers.array()[i]);
        }
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(eventType);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += (1 * numbers.length()) + ProtoSink.computeRepeatedUInt32SizeNoTag(numbers);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public VampireSurvivorEvent mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            // eventType
            eventType = input.readUInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 18) {
              break;
            }
          }
          case 18: {
            // numbers [packed=true]
            input.readPackedUInt32(numbers, tag);
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
          case 16: {
            // numbers [packed=false]
            tag = input.readRepeatedUInt32(numbers, tag);
            bitField0_ |= 0x00000004;
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeUInt32(FieldNames.eventType, eventType);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRepeatedUInt32(FieldNames.numbers, numbers);
      }
      output.endObject();
    }

    @Override
    public VampireSurvivorEvent mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 2035398868: {
            if (input.isAtField(FieldNames.eventType)) {
              if (!input.trySkipNullValue()) {
                eventType = input.readUInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -335862230: {
            if (input.isAtField(FieldNames.numbers)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedUInt32(numbers);
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public VampireSurvivorEvent clone() {
      return new VampireSurvivorEvent().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static VampireSurvivorEvent parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new VampireSurvivorEvent(), data).checkInitialized();
    }

    public static VampireSurvivorEvent parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new VampireSurvivorEvent(), input).checkInitialized();
    }

    public static VampireSurvivorEvent parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new VampireSurvivorEvent(), input).checkInitialized();
    }

    /**
     * @return factory for creating VampireSurvivorEvent messages
     */
    public static MessageFactory<VampireSurvivorEvent> getFactory() {
      return VampireSurvivorEventFactory.INSTANCE;
    }

    private enum VampireSurvivorEventFactory implements MessageFactory<VampireSurvivorEvent> {
      INSTANCE;

      @Override
      public VampireSurvivorEvent create() {
        return VampireSurvivorEvent.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName eventType = FieldName.forField("EventType");

      static final FieldName nextPackage = FieldName.forField("NextPackage");

      static final FieldName numbers = FieldName.forField("Numbers");
    }
  }

  /**
   * Protobuf type {@code VampireSurvivorLevelReward}
   */
  public static final class VampireSurvivorLevelReward extends ProtoMessage<VampireSurvivorLevelReward> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional uint32 Level = 1;</code>
     */
    private int level;

    /**
     * <code>optional .VampireSurvivorFateCardSelect Pkg = 2;</code>
     */
    private final VampireSurvivorFateCardSelect pkg = VampireSurvivorFateCardSelect.newInstance();

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    private VampireSurvivorLevelReward() {
    }

    /**
     * @return a new empty instance of {@code VampireSurvivorLevelReward}
     */
    public static VampireSurvivorLevelReward newInstance() {
      return new VampireSurvivorLevelReward();
    }

    /**
     * <code>optional uint32 Level = 1;</code>
     * @return whether the level field is set
     */
    public boolean hasLevel() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional uint32 Level = 1;</code>
     * @return this
     */
    public VampireSurvivorLevelReward clearLevel() {
      bitField0_ &= ~0x00000001;
      level = 0;
      return this;
    }

    /**
     * <code>optional uint32 Level = 1;</code>
     * @return the level
     */
    public int getLevel() {
      return level;
    }

    /**
     * <code>optional uint32 Level = 1;</code>
     * @param value the level to set
     * @return this
     */
    public VampireSurvivorLevelReward setLevel(final int value) {
      bitField0_ |= 0x00000001;
      level = value;
      return this;
    }

    /**
     * <code>optional .VampireSurvivorFateCardSelect Pkg = 2;</code>
     * @return whether the pkg field is set
     */
    public boolean hasPkg() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional .VampireSurvivorFateCardSelect Pkg = 2;</code>
     * @return this
     */
    public VampireSurvivorLevelReward clearPkg() {
      bitField0_ &= ~0x00000002;
      pkg.clear();
      return this;
    }

    /**
     * <code>optional .VampireSurvivorFateCardSelect Pkg = 2;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutablePkg()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public VampireSurvivorFateCardSelect getPkg() {
      return pkg;
    }

    /**
     * <code>optional .VampireSurvivorFateCardSelect Pkg = 2;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public VampireSurvivorFateCardSelect getMutablePkg() {
      bitField0_ |= 0x00000002;
      return pkg;
    }

    /**
     * <code>optional .VampireSurvivorFateCardSelect Pkg = 2;</code>
     * @param value the pkg to set
     * @return this
     */
    public VampireSurvivorLevelReward setPkg(final VampireSurvivorFateCardSelect value) {
      bitField0_ |= 0x00000002;
      pkg.copyFrom(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public VampireSurvivorLevelReward clearNextPackage() {
      bitField0_ &= ~0x00000004;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000004;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public VampireSurvivorLevelReward addNextPackage(final byte value) {
      bitField0_ |= 0x00000004;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public VampireSurvivorLevelReward addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000004;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public VampireSurvivorLevelReward setNextPackage(final byte... values) {
      bitField0_ |= 0x00000004;
      nextPackage.copyFrom(values);
      return this;
    }

    @Override
    public VampireSurvivorLevelReward copyFrom(final VampireSurvivorLevelReward other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        level = other.level;
        pkg.copyFrom(other.pkg);
        nextPackage.copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public VampireSurvivorLevelReward mergeFrom(final VampireSurvivorLevelReward other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasLevel()) {
        setLevel(other.level);
      }
      if (other.hasPkg()) {
        getMutablePkg().mergeFrom(other.pkg);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public VampireSurvivorLevelReward clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      level = 0;
      pkg.clear();
      nextPackage.clear();
      return this;
    }

    @Override
    public VampireSurvivorLevelReward clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      pkg.clearQuick();
      nextPackage.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof VampireSurvivorLevelReward)) {
        return false;
      }
      VampireSurvivorLevelReward other = (VampireSurvivorLevelReward) o;
      return bitField0_ == other.bitField0_
        && (!hasLevel() || level == other.level)
        && (!hasPkg() || pkg.equals(other.pkg))
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt32NoTag(level);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 18);
        output.writeMessageNoTag(pkg);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(level);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeMessageSizeNoTag(pkg);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public VampireSurvivorLevelReward mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            // level
            level = input.readUInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 18) {
              break;
            }
          }
          case 18: {
            // pkg
            input.readMessage(pkg);
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeUInt32(FieldNames.level, level);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeMessage(FieldNames.pkg, pkg);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      output.endObject();
    }

    @Override
    public VampireSurvivorLevelReward mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 73313124: {
            if (input.isAtField(FieldNames.level)) {
              if (!input.trySkipNullValue()) {
                level = input.readUInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 80300: {
            if (input.isAtField(FieldNames.pkg)) {
              if (!input.trySkipNullValue()) {
                input.readMessage(pkg);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public VampireSurvivorLevelReward clone() {
      return new VampireSurvivorLevelReward().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static VampireSurvivorLevelReward parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new VampireSurvivorLevelReward(), data).checkInitialized();
    }

    public static VampireSurvivorLevelReward parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new VampireSurvivorLevelReward(), input).checkInitialized();
    }

    public static VampireSurvivorLevelReward parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new VampireSurvivorLevelReward(), input).checkInitialized();
    }

    /**
     * @return factory for creating VampireSurvivorLevelReward messages
     */
    public static MessageFactory<VampireSurvivorLevelReward> getFactory() {
      return VampireSurvivorLevelRewardFactory.INSTANCE;
    }

    private enum VampireSurvivorLevelRewardFactory implements MessageFactory<VampireSurvivorLevelReward> {
      INSTANCE;

      @Override
      public VampireSurvivorLevelReward create() {
        return VampireSurvivorLevelReward.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName level = FieldName.forField("Level");

      static final FieldName pkg = FieldName.forField("Pkg");

      static final FieldName nextPackage = FieldName.forField("NextPackage");
    }
  }

  /**
   * Protobuf type {@code VampireSurvivorFateCardSelect}
   */
  public static final class VampireSurvivorFateCardSelect extends ProtoMessage<VampireSurvivorFateCardSelect> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional uint32 ReRoll = 2;</code>
     */
    private int reRoll;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    /**
     * <code>repeated .CardInfo Cards = 1;</code>
     */
    private final RepeatedMessage<CardInfo> cards = RepeatedMessage.newEmptyInstance(CardInfo.getFactory());

    private VampireSurvivorFateCardSelect() {
    }

    /**
     * @return a new empty instance of {@code VampireSurvivorFateCardSelect}
     */
    public static VampireSurvivorFateCardSelect newInstance() {
      return new VampireSurvivorFateCardSelect();
    }

    /**
     * <code>optional uint32 ReRoll = 2;</code>
     * @return whether the reRoll field is set
     */
    public boolean hasReRoll() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional uint32 ReRoll = 2;</code>
     * @return this
     */
    public VampireSurvivorFateCardSelect clearReRoll() {
      bitField0_ &= ~0x00000001;
      reRoll = 0;
      return this;
    }

    /**
     * <code>optional uint32 ReRoll = 2;</code>
     * @return the reRoll
     */
    public int getReRoll() {
      return reRoll;
    }

    /**
     * <code>optional uint32 ReRoll = 2;</code>
     * @param value the reRoll to set
     * @return this
     */
    public VampireSurvivorFateCardSelect setReRoll(final int value) {
      bitField0_ |= 0x00000001;
      reRoll = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public VampireSurvivorFateCardSelect clearNextPackage() {
      bitField0_ &= ~0x00000002;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000002;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public VampireSurvivorFateCardSelect addNextPackage(final byte value) {
      bitField0_ |= 0x00000002;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public VampireSurvivorFateCardSelect addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000002;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public VampireSurvivorFateCardSelect setNextPackage(final byte... values) {
      bitField0_ |= 0x00000002;
      nextPackage.copyFrom(values);
      return this;
    }

    /**
     * <code>repeated .CardInfo Cards = 1;</code>
     * @return whether the cards field is set
     */
    public boolean hasCards() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>repeated .CardInfo Cards = 1;</code>
     * @return this
     */
    public VampireSurvivorFateCardSelect clearCards() {
      bitField0_ &= ~0x00000004;
      cards.clear();
      return this;
    }

    /**
     * <code>repeated .CardInfo Cards = 1;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableCards()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<CardInfo> getCards() {
      return cards;
    }

    /**
     * <code>repeated .CardInfo Cards = 1;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<CardInfo> getMutableCards() {
      bitField0_ |= 0x00000004;
      return cards;
    }

    /**
     * <code>repeated .CardInfo Cards = 1;</code>
     * @param value the cards to add
     * @return this
     */
    public VampireSurvivorFateCardSelect addCards(final CardInfo value) {
      bitField0_ |= 0x00000004;
      cards.add(value);
      return this;
    }

    /**
     * <code>repeated .CardInfo Cards = 1;</code>
     * @param values the cards to add
     * @return this
     */
    public VampireSurvivorFateCardSelect addAllCards(final CardInfo... values) {
      bitField0_ |= 0x00000004;
      cards.addAll(values);
      return this;
    }

    @Override
    public VampireSurvivorFateCardSelect copyFrom(final VampireSurvivorFateCardSelect other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        reRoll = other.reRoll;
        nextPackage.copyFrom(other.nextPackage);
        cards.copyFrom(other.cards);
      }
      return this;
    }

    @Override
    public VampireSurvivorFateCardSelect mergeFrom(final VampireSurvivorFateCardSelect other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasReRoll()) {
        setReRoll(other.reRoll);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      if (other.hasCards()) {
        getMutableCards().addAll(other.cards);
      }
      return this;
    }

    @Override
    public VampireSurvivorFateCardSelect clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      reRoll = 0;
      nextPackage.clear();
      cards.clear();
      return this;
    }

    @Override
    public VampireSurvivorFateCardSelect clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      cards.clearQuick();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof VampireSurvivorFateCardSelect)) {
        return false;
      }
      VampireSurvivorFateCardSelect other = (VampireSurvivorFateCardSelect) o;
      return bitField0_ == other.bitField0_
        && (!hasReRoll() || reRoll == other.reRoll)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage))
        && (!hasCards() || cards.equals(other.cards));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 16);
        output.writeUInt32NoTag(reRoll);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        for (int i = 0; i < cards.length(); i++) {
          output.writeRawByte((byte) 10);
          output.writeMessageNoTag(cards.get(i));
        }
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(reRoll);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += (1 * cards.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(cards);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public VampireSurvivorFateCardSelect mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 16: {
            // reRoll
            reRoll = input.readUInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 10) {
              break;
            }
          }
          case 10: {
            // cards
            tag = input.readRepeatedMessage(cards, tag);
            bitField0_ |= 0x00000004;
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeUInt32(FieldNames.reRoll, reRoll);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRepeatedMessage(FieldNames.cards, cards);
      }
      output.endObject();
    }

    @Override
    public VampireSurvivorFateCardSelect mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case -1851548304: {
            if (input.isAtField(FieldNames.reRoll)) {
              if (!input.trySkipNullValue()) {
                reRoll = input.readUInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 64878403: {
            if (input.isAtField(FieldNames.cards)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedMessage(cards);
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public VampireSurvivorFateCardSelect clone() {
      return new VampireSurvivorFateCardSelect().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static VampireSurvivorFateCardSelect parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new VampireSurvivorFateCardSelect(), data).checkInitialized();
    }

    public static VampireSurvivorFateCardSelect parseFrom(final ProtoSource input) throws
        IOException {
      return ProtoMessage.mergeFrom(new VampireSurvivorFateCardSelect(), input).checkInitialized();
    }

    public static VampireSurvivorFateCardSelect parseFrom(final JsonSource input) throws
        IOException {
      return ProtoMessage.mergeFrom(new VampireSurvivorFateCardSelect(), input).checkInitialized();
    }

    /**
     * @return factory for creating VampireSurvivorFateCardSelect messages
     */
    public static MessageFactory<VampireSurvivorFateCardSelect> getFactory() {
      return VampireSurvivorFateCardSelectFactory.INSTANCE;
    }

    private enum VampireSurvivorFateCardSelectFactory implements MessageFactory<VampireSurvivorFateCardSelect> {
      INSTANCE;

      @Override
      public VampireSurvivorFateCardSelect create() {
        return VampireSurvivorFateCardSelect.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName reRoll = FieldName.forField("ReRoll");

      static final FieldName nextPackage = FieldName.forField("NextPackage");

      static final FieldName cards = FieldName.forField("Cards");
    }
  }

  /**
   * Protobuf type {@code ScoreBossLevel}
   */
  public static final class ScoreBossLevel extends ProtoMessage<ScoreBossLevel> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional uint64 BuildId = 2;</code>
     */
    private long buildId;

    /**
     * <code>optional uint32 LevelId = 1;</code>
     */
    private int levelId;

    /**
     * <code>optional uint32 Score = 3;</code>
     */
    private int score;

    /**
     * <code>optional uint32 Star = 4;</code>
     */
    private int star;

    /**
     * <code>optional uint32 SkillScore = 5;</code>
     */
    private int skillScore;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    /**
     * <code>repeated uint32 CharIds = 6;</code>
     */
    private final RepeatedInt charIds = RepeatedInt.newEmptyInstance();

    private ScoreBossLevel() {
    }

    /**
     * @return a new empty instance of {@code ScoreBossLevel}
     */
    public static ScoreBossLevel newInstance() {
      return new ScoreBossLevel();
    }

    /**
     * <code>optional uint64 BuildId = 2;</code>
     * @return whether the buildId field is set
     */
    public boolean hasBuildId() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional uint64 BuildId = 2;</code>
     * @return this
     */
    public ScoreBossLevel clearBuildId() {
      bitField0_ &= ~0x00000001;
      buildId = 0L;
      return this;
    }

    /**
     * <code>optional uint64 BuildId = 2;</code>
     * @return the buildId
     */
    public long getBuildId() {
      return buildId;
    }

    /**
     * <code>optional uint64 BuildId = 2;</code>
     * @param value the buildId to set
     * @return this
     */
    public ScoreBossLevel setBuildId(final long value) {
      bitField0_ |= 0x00000001;
      buildId = value;
      return this;
    }

    /**
     * <code>optional uint32 LevelId = 1;</code>
     * @return whether the levelId field is set
     */
    public boolean hasLevelId() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional uint32 LevelId = 1;</code>
     * @return this
     */
    public ScoreBossLevel clearLevelId() {
      bitField0_ &= ~0x00000002;
      levelId = 0;
      return this;
    }

    /**
     * <code>optional uint32 LevelId = 1;</code>
     * @return the levelId
     */
    public int getLevelId() {
      return levelId;
    }

    /**
     * <code>optional uint32 LevelId = 1;</code>
     * @param value the levelId to set
     * @return this
     */
    public ScoreBossLevel setLevelId(final int value) {
      bitField0_ |= 0x00000002;
      levelId = value;
      return this;
    }

    /**
     * <code>optional uint32 Score = 3;</code>
     * @return whether the score field is set
     */
    public boolean hasScore() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional uint32 Score = 3;</code>
     * @return this
     */
    public ScoreBossLevel clearScore() {
      bitField0_ &= ~0x00000004;
      score = 0;
      return this;
    }

    /**
     * <code>optional uint32 Score = 3;</code>
     * @return the score
     */
    public int getScore() {
      return score;
    }

    /**
     * <code>optional uint32 Score = 3;</code>
     * @param value the score to set
     * @return this
     */
    public ScoreBossLevel setScore(final int value) {
      bitField0_ |= 0x00000004;
      score = value;
      return this;
    }

    /**
     * <code>optional uint32 Star = 4;</code>
     * @return whether the star field is set
     */
    public boolean hasStar() {
      return (bitField0_ & 0x00000008) != 0;
    }

    /**
     * <code>optional uint32 Star = 4;</code>
     * @return this
     */
    public ScoreBossLevel clearStar() {
      bitField0_ &= ~0x00000008;
      star = 0;
      return this;
    }

    /**
     * <code>optional uint32 Star = 4;</code>
     * @return the star
     */
    public int getStar() {
      return star;
    }

    /**
     * <code>optional uint32 Star = 4;</code>
     * @param value the star to set
     * @return this
     */
    public ScoreBossLevel setStar(final int value) {
      bitField0_ |= 0x00000008;
      star = value;
      return this;
    }

    /**
     * <code>optional uint32 SkillScore = 5;</code>
     * @return whether the skillScore field is set
     */
    public boolean hasSkillScore() {
      return (bitField0_ & 0x00000010) != 0;
    }

    /**
     * <code>optional uint32 SkillScore = 5;</code>
     * @return this
     */
    public ScoreBossLevel clearSkillScore() {
      bitField0_ &= ~0x00000010;
      skillScore = 0;
      return this;
    }

    /**
     * <code>optional uint32 SkillScore = 5;</code>
     * @return the skillScore
     */
    public int getSkillScore() {
      return skillScore;
    }

    /**
     * <code>optional uint32 SkillScore = 5;</code>
     * @param value the skillScore to set
     * @return this
     */
    public ScoreBossLevel setSkillScore(final int value) {
      bitField0_ |= 0x00000010;
      skillScore = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000020) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public ScoreBossLevel clearNextPackage() {
      bitField0_ &= ~0x00000020;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000020;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public ScoreBossLevel addNextPackage(final byte value) {
      bitField0_ |= 0x00000020;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public ScoreBossLevel addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000020;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public ScoreBossLevel setNextPackage(final byte... values) {
      bitField0_ |= 0x00000020;
      nextPackage.copyFrom(values);
      return this;
    }

    /**
     * <code>repeated uint32 CharIds = 6;</code>
     * @return whether the charIds field is set
     */
    public boolean hasCharIds() {
      return (bitField0_ & 0x00000040) != 0;
    }

    /**
     * <code>repeated uint32 CharIds = 6;</code>
     * @return this
     */
    public ScoreBossLevel clearCharIds() {
      bitField0_ &= ~0x00000040;
      charIds.clear();
      return this;
    }

    /**
     * <code>repeated uint32 CharIds = 6;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableCharIds()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedInt getCharIds() {
      return charIds;
    }

    /**
     * <code>repeated uint32 CharIds = 6;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedInt getMutableCharIds() {
      bitField0_ |= 0x00000040;
      return charIds;
    }

    /**
     * <code>repeated uint32 CharIds = 6;</code>
     * @param value the charIds to add
     * @return this
     */
    public ScoreBossLevel addCharIds(final int value) {
      bitField0_ |= 0x00000040;
      charIds.add(value);
      return this;
    }

    /**
     * <code>repeated uint32 CharIds = 6;</code>
     * @param values the charIds to add
     * @return this
     */
    public ScoreBossLevel addAllCharIds(final int... values) {
      bitField0_ |= 0x00000040;
      charIds.addAll(values);
      return this;
    }

    @Override
    public ScoreBossLevel copyFrom(final ScoreBossLevel other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        buildId = other.buildId;
        levelId = other.levelId;
        score = other.score;
        star = other.star;
        skillScore = other.skillScore;
        nextPackage.copyFrom(other.nextPackage);
        charIds.copyFrom(other.charIds);
      }
      return this;
    }

    @Override
    public ScoreBossLevel mergeFrom(final ScoreBossLevel other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasBuildId()) {
        setBuildId(other.buildId);
      }
      if (other.hasLevelId()) {
        setLevelId(other.levelId);
      }
      if (other.hasScore()) {
        setScore(other.score);
      }
      if (other.hasStar()) {
        setStar(other.star);
      }
      if (other.hasSkillScore()) {
        setSkillScore(other.skillScore);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      if (other.hasCharIds()) {
        getMutableCharIds().addAll(other.charIds);
      }
      return this;
    }

    @Override
    public ScoreBossLevel clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      buildId = 0L;
      levelId = 0;
      score = 0;
      star = 0;
      skillScore = 0;
      nextPackage.clear();
      charIds.clear();
      return this;
    }

    @Override
    public ScoreBossLevel clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      charIds.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof ScoreBossLevel)) {
        return false;
      }
      ScoreBossLevel other = (ScoreBossLevel) o;
      return bitField0_ == other.bitField0_
        && (!hasBuildId() || buildId == other.buildId)
        && (!hasLevelId() || levelId == other.levelId)
        && (!hasScore() || score == other.score)
        && (!hasStar() || star == other.star)
        && (!hasSkillScore() || skillScore == other.skillScore)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage))
        && (!hasCharIds() || charIds.equals(other.charIds));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 16);
        output.writeUInt64NoTag(buildId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt32NoTag(levelId);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawByte((byte) 24);
        output.writeUInt32NoTag(score);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeRawByte((byte) 32);
        output.writeUInt32NoTag(star);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        output.writeRawByte((byte) 40);
        output.writeUInt32NoTag(skillScore);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000040) != 0) {
        for (int i = 0; i < charIds.length(); i++) {
          output.writeRawByte((byte) 48);
          output.writeUInt32NoTag(charIds.array()[i]);
        }
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeUInt64SizeNoTag(buildId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(levelId);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(score);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(star);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(skillScore);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000040) != 0) {
        size += (1 * charIds.length()) + ProtoSink.computeRepeatedUInt32SizeNoTag(charIds);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public ScoreBossLevel mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 16: {
            // buildId
            buildId = input.readUInt64();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 8) {
              break;
            }
          }
          case 8: {
            // levelId
            levelId = input.readUInt32();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 24) {
              break;
            }
          }
          case 24: {
            // score
            score = input.readUInt32();
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 32) {
              break;
            }
          }
          case 32: {
            // star
            star = input.readUInt32();
            bitField0_ |= 0x00000008;
            tag = input.readTag();
            if (tag != 40) {
              break;
            }
          }
          case 40: {
            // skillScore
            skillScore = input.readUInt32();
            bitField0_ |= 0x00000010;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000020;
            tag = input.readTag();
            if (tag != 50) {
              break;
            }
          }
          case 50: {
            // charIds [packed=true]
            input.readPackedUInt32(charIds, tag);
            bitField0_ |= 0x00000040;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
          case 48: {
            // charIds [packed=false]
            tag = input.readRepeatedUInt32(charIds, tag);
            bitField0_ |= 0x00000040;
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeUInt64(FieldNames.buildId, buildId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeUInt32(FieldNames.levelId, levelId);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeUInt32(FieldNames.score, score);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeUInt32(FieldNames.star, star);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        output.writeUInt32(FieldNames.skillScore, skillScore);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      if ((bitField0_ & 0x00000040) != 0) {
        output.writeRepeatedUInt32(FieldNames.charIds, charIds);
      }
      output.endObject();
    }

    @Override
    public ScoreBossLevel mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 1895597065: {
            if (input.isAtField(FieldNames.buildId)) {
              if (!input.trySkipNullValue()) {
                buildId = input.readUInt64();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 1734437791: {
            if (input.isAtField(FieldNames.levelId)) {
              if (!input.trySkipNullValue()) {
                levelId = input.readUInt32();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 79711858: {
            if (input.isAtField(FieldNames.score)) {
              if (!input.trySkipNullValue()) {
                score = input.readUInt32();
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 2587250: {
            if (input.isAtField(FieldNames.star)) {
              if (!input.trySkipNullValue()) {
                star = input.readUInt32();
                bitField0_ |= 0x00000008;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -705549599: {
            if (input.isAtField(FieldNames.skillScore)) {
              if (!input.trySkipNullValue()) {
                skillScore = input.readUInt32();
                bitField0_ |= 0x00000010;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000020;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1891280030: {
            if (input.isAtField(FieldNames.charIds)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedUInt32(charIds);
                bitField0_ |= 0x00000040;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public ScoreBossLevel clone() {
      return new ScoreBossLevel().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static ScoreBossLevel parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new ScoreBossLevel(), data).checkInitialized();
    }

    public static ScoreBossLevel parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new ScoreBossLevel(), input).checkInitialized();
    }

    public static ScoreBossLevel parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new ScoreBossLevel(), input).checkInitialized();
    }

    /**
     * @return factory for creating ScoreBossLevel messages
     */
    public static MessageFactory<ScoreBossLevel> getFactory() {
      return ScoreBossLevelFactory.INSTANCE;
    }

    private enum ScoreBossLevelFactory implements MessageFactory<ScoreBossLevel> {
      INSTANCE;

      @Override
      public ScoreBossLevel create() {
        return ScoreBossLevel.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName buildId = FieldName.forField("BuildId");

      static final FieldName levelId = FieldName.forField("LevelId");

      static final FieldName score = FieldName.forField("Score");

      static final FieldName star = FieldName.forField("Star");

      static final FieldName skillScore = FieldName.forField("SkillScore");

      static final FieldName nextPackage = FieldName.forField("NextPackage");

      static final FieldName charIds = FieldName.forField("CharIds");
    }
  }

  /**
   * Protobuf type {@code VampireSurvivorLevel}
   */
  public static final class VampireSurvivorLevel extends ProtoMessage<VampireSurvivorLevel> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional uint32 Id = 1;</code>
     */
    private int id;

    /**
     * <code>optional uint32 Score = 2;</code>
     */
    private int score;

    /**
     * <code>optional bool Passed = 4;</code>
     */
    private boolean passed;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    /**
     * <code>repeated uint64 BuildIds = 3;</code>
     */
    private final RepeatedLong buildIds = RepeatedLong.newEmptyInstance();

    private VampireSurvivorLevel() {
    }

    /**
     * @return a new empty instance of {@code VampireSurvivorLevel}
     */
    public static VampireSurvivorLevel newInstance() {
      return new VampireSurvivorLevel();
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @return whether the id field is set
     */
    public boolean hasId() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @return this
     */
    public VampireSurvivorLevel clearId() {
      bitField0_ &= ~0x00000001;
      id = 0;
      return this;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @return the id
     */
    public int getId() {
      return id;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @param value the id to set
     * @return this
     */
    public VampireSurvivorLevel setId(final int value) {
      bitField0_ |= 0x00000001;
      id = value;
      return this;
    }

    /**
     * <code>optional uint32 Score = 2;</code>
     * @return whether the score field is set
     */
    public boolean hasScore() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional uint32 Score = 2;</code>
     * @return this
     */
    public VampireSurvivorLevel clearScore() {
      bitField0_ &= ~0x00000002;
      score = 0;
      return this;
    }

    /**
     * <code>optional uint32 Score = 2;</code>
     * @return the score
     */
    public int getScore() {
      return score;
    }

    /**
     * <code>optional uint32 Score = 2;</code>
     * @param value the score to set
     * @return this
     */
    public VampireSurvivorLevel setScore(final int value) {
      bitField0_ |= 0x00000002;
      score = value;
      return this;
    }

    /**
     * <code>optional bool Passed = 4;</code>
     * @return whether the passed field is set
     */
    public boolean hasPassed() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional bool Passed = 4;</code>
     * @return this
     */
    public VampireSurvivorLevel clearPassed() {
      bitField0_ &= ~0x00000004;
      passed = false;
      return this;
    }

    /**
     * <code>optional bool Passed = 4;</code>
     * @return the passed
     */
    public boolean getPassed() {
      return passed;
    }

    /**
     * <code>optional bool Passed = 4;</code>
     * @param value the passed to set
     * @return this
     */
    public VampireSurvivorLevel setPassed(final boolean value) {
      bitField0_ |= 0x00000004;
      passed = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000008) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public VampireSurvivorLevel clearNextPackage() {
      bitField0_ &= ~0x00000008;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000008;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public VampireSurvivorLevel addNextPackage(final byte value) {
      bitField0_ |= 0x00000008;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public VampireSurvivorLevel addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000008;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public VampireSurvivorLevel setNextPackage(final byte... values) {
      bitField0_ |= 0x00000008;
      nextPackage.copyFrom(values);
      return this;
    }

    /**
     * <code>repeated uint64 BuildIds = 3;</code>
     * @return whether the buildIds field is set
     */
    public boolean hasBuildIds() {
      return (bitField0_ & 0x00000010) != 0;
    }

    /**
     * <code>repeated uint64 BuildIds = 3;</code>
     * @return this
     */
    public VampireSurvivorLevel clearBuildIds() {
      bitField0_ &= ~0x00000010;
      buildIds.clear();
      return this;
    }

    /**
     * <code>repeated uint64 BuildIds = 3;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableBuildIds()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedLong getBuildIds() {
      return buildIds;
    }

    /**
     * <code>repeated uint64 BuildIds = 3;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedLong getMutableBuildIds() {
      bitField0_ |= 0x00000010;
      return buildIds;
    }

    /**
     * <code>repeated uint64 BuildIds = 3;</code>
     * @param value the buildIds to add
     * @return this
     */
    public VampireSurvivorLevel addBuildIds(final long value) {
      bitField0_ |= 0x00000010;
      buildIds.add(value);
      return this;
    }

    /**
     * <code>repeated uint64 BuildIds = 3;</code>
     * @param values the buildIds to add
     * @return this
     */
    public VampireSurvivorLevel addAllBuildIds(final long... values) {
      bitField0_ |= 0x00000010;
      buildIds.addAll(values);
      return this;
    }

    @Override
    public VampireSurvivorLevel copyFrom(final VampireSurvivorLevel other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        id = other.id;
        score = other.score;
        passed = other.passed;
        nextPackage.copyFrom(other.nextPackage);
        buildIds.copyFrom(other.buildIds);
      }
      return this;
    }

    @Override
    public VampireSurvivorLevel mergeFrom(final VampireSurvivorLevel other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasId()) {
        setId(other.id);
      }
      if (other.hasScore()) {
        setScore(other.score);
      }
      if (other.hasPassed()) {
        setPassed(other.passed);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      if (other.hasBuildIds()) {
        getMutableBuildIds().addAll(other.buildIds);
      }
      return this;
    }

    @Override
    public VampireSurvivorLevel clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      id = 0;
      score = 0;
      passed = false;
      nextPackage.clear();
      buildIds.clear();
      return this;
    }

    @Override
    public VampireSurvivorLevel clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      buildIds.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof VampireSurvivorLevel)) {
        return false;
      }
      VampireSurvivorLevel other = (VampireSurvivorLevel) o;
      return bitField0_ == other.bitField0_
        && (!hasId() || id == other.id)
        && (!hasScore() || score == other.score)
        && (!hasPassed() || passed == other.passed)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage))
        && (!hasBuildIds() || buildIds.equals(other.buildIds));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt32NoTag(id);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 16);
        output.writeUInt32NoTag(score);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawByte((byte) 32);
        output.writeBoolNoTag(passed);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        for (int i = 0; i < buildIds.length(); i++) {
          output.writeRawByte((byte) 24);
          output.writeUInt64NoTag(buildIds.array()[i]);
        }
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(id);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(score);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 2;
      }
      if ((bitField0_ & 0x00000008) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        size += (1 * buildIds.length()) + ProtoSink.computeRepeatedUInt64SizeNoTag(buildIds);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public VampireSurvivorLevel mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            // id
            id = input.readUInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 16) {
              break;
            }
          }
          case 16: {
            // score
            score = input.readUInt32();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 32) {
              break;
            }
          }
          case 32: {
            // passed
            passed = input.readBool();
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000008;
            tag = input.readTag();
            if (tag != 26) {
              break;
            }
          }
          case 26: {
            // buildIds [packed=true]
            input.readPackedUInt64(buildIds, tag);
            bitField0_ |= 0x00000010;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
          case 24: {
            // buildIds [packed=false]
            tag = input.readRepeatedUInt64(buildIds, tag);
            bitField0_ |= 0x00000010;
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeUInt32(FieldNames.id, id);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeUInt32(FieldNames.score, score);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeBool(FieldNames.passed, passed);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        output.writeRepeatedUInt64(FieldNames.buildIds, buildIds);
      }
      output.endObject();
    }

    @Override
    public VampireSurvivorLevel mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 2363: {
            if (input.isAtField(FieldNames.id)) {
              if (!input.trySkipNullValue()) {
                id = input.readUInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 79711858: {
            if (input.isAtField(FieldNames.score)) {
              if (!input.trySkipNullValue()) {
                score = input.readUInt32();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1911513968: {
            if (input.isAtField(FieldNames.passed)) {
              if (!input.trySkipNullValue()) {
                passed = input.readBool();
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000008;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1366033014: {
            if (input.isAtField(FieldNames.buildIds)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedUInt64(buildIds);
                bitField0_ |= 0x00000010;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public VampireSurvivorLevel clone() {
      return new VampireSurvivorLevel().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static VampireSurvivorLevel parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new VampireSurvivorLevel(), data).checkInitialized();
    }

    public static VampireSurvivorLevel parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new VampireSurvivorLevel(), input).checkInitialized();
    }

    public static VampireSurvivorLevel parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new VampireSurvivorLevel(), input).checkInitialized();
    }

    /**
     * @return factory for creating VampireSurvivorLevel messages
     */
    public static MessageFactory<VampireSurvivorLevel> getFactory() {
      return VampireSurvivorLevelFactory.INSTANCE;
    }

    private enum VampireSurvivorLevelFactory implements MessageFactory<VampireSurvivorLevel> {
      INSTANCE;

      @Override
      public VampireSurvivorLevel create() {
        return VampireSurvivorLevel.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName id = FieldName.forField("Id");

      static final FieldName score = FieldName.forField("Score");

      static final FieldName passed = FieldName.forField("Passed");

      static final FieldName nextPackage = FieldName.forField("NextPackage");

      static final FieldName buildIds = FieldName.forField("BuildIds");
    }
  }

  /**
   * Protobuf type {@code VampireSurvivorRecordInfo}
   */
  public static final class VampireSurvivorRecordInfo extends ProtoMessage<VampireSurvivorRecordInfo> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional uint32 SeasonScore = 3;</code>
     */
    private int seasonScore;

    /**
     * <code>optional .VampireSurvivorLevel Season = 2;</code>
     */
    private final VampireSurvivorLevel season = VampireSurvivorLevel.newInstance();

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    /**
     * <code>repeated .VampireSurvivorLevel Records = 1;</code>
     */
    private final RepeatedMessage<VampireSurvivorLevel> records = RepeatedMessage.newEmptyInstance(VampireSurvivorLevel.getFactory());

    private VampireSurvivorRecordInfo() {
    }

    /**
     * @return a new empty instance of {@code VampireSurvivorRecordInfo}
     */
    public static VampireSurvivorRecordInfo newInstance() {
      return new VampireSurvivorRecordInfo();
    }

    /**
     * <code>optional uint32 SeasonScore = 3;</code>
     * @return whether the seasonScore field is set
     */
    public boolean hasSeasonScore() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional uint32 SeasonScore = 3;</code>
     * @return this
     */
    public VampireSurvivorRecordInfo clearSeasonScore() {
      bitField0_ &= ~0x00000001;
      seasonScore = 0;
      return this;
    }

    /**
     * <code>optional uint32 SeasonScore = 3;</code>
     * @return the seasonScore
     */
    public int getSeasonScore() {
      return seasonScore;
    }

    /**
     * <code>optional uint32 SeasonScore = 3;</code>
     * @param value the seasonScore to set
     * @return this
     */
    public VampireSurvivorRecordInfo setSeasonScore(final int value) {
      bitField0_ |= 0x00000001;
      seasonScore = value;
      return this;
    }

    /**
     * <code>optional .VampireSurvivorLevel Season = 2;</code>
     * @return whether the season field is set
     */
    public boolean hasSeason() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional .VampireSurvivorLevel Season = 2;</code>
     * @return this
     */
    public VampireSurvivorRecordInfo clearSeason() {
      bitField0_ &= ~0x00000002;
      season.clear();
      return this;
    }

    /**
     * <code>optional .VampireSurvivorLevel Season = 2;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableSeason()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public VampireSurvivorLevel getSeason() {
      return season;
    }

    /**
     * <code>optional .VampireSurvivorLevel Season = 2;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public VampireSurvivorLevel getMutableSeason() {
      bitField0_ |= 0x00000002;
      return season;
    }

    /**
     * <code>optional .VampireSurvivorLevel Season = 2;</code>
     * @param value the season to set
     * @return this
     */
    public VampireSurvivorRecordInfo setSeason(final VampireSurvivorLevel value) {
      bitField0_ |= 0x00000002;
      season.copyFrom(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public VampireSurvivorRecordInfo clearNextPackage() {
      bitField0_ &= ~0x00000004;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000004;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public VampireSurvivorRecordInfo addNextPackage(final byte value) {
      bitField0_ |= 0x00000004;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public VampireSurvivorRecordInfo addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000004;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public VampireSurvivorRecordInfo setNextPackage(final byte... values) {
      bitField0_ |= 0x00000004;
      nextPackage.copyFrom(values);
      return this;
    }

    /**
     * <code>repeated .VampireSurvivorLevel Records = 1;</code>
     * @return whether the records field is set
     */
    public boolean hasRecords() {
      return (bitField0_ & 0x00000008) != 0;
    }

    /**
     * <code>repeated .VampireSurvivorLevel Records = 1;</code>
     * @return this
     */
    public VampireSurvivorRecordInfo clearRecords() {
      bitField0_ &= ~0x00000008;
      records.clear();
      return this;
    }

    /**
     * <code>repeated .VampireSurvivorLevel Records = 1;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableRecords()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<VampireSurvivorLevel> getRecords() {
      return records;
    }

    /**
     * <code>repeated .VampireSurvivorLevel Records = 1;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<VampireSurvivorLevel> getMutableRecords() {
      bitField0_ |= 0x00000008;
      return records;
    }

    /**
     * <code>repeated .VampireSurvivorLevel Records = 1;</code>
     * @param value the records to add
     * @return this
     */
    public VampireSurvivorRecordInfo addRecords(final VampireSurvivorLevel value) {
      bitField0_ |= 0x00000008;
      records.add(value);
      return this;
    }

    /**
     * <code>repeated .VampireSurvivorLevel Records = 1;</code>
     * @param values the records to add
     * @return this
     */
    public VampireSurvivorRecordInfo addAllRecords(final VampireSurvivorLevel... values) {
      bitField0_ |= 0x00000008;
      records.addAll(values);
      return this;
    }

    @Override
    public VampireSurvivorRecordInfo copyFrom(final VampireSurvivorRecordInfo other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        seasonScore = other.seasonScore;
        season.copyFrom(other.season);
        nextPackage.copyFrom(other.nextPackage);
        records.copyFrom(other.records);
      }
      return this;
    }

    @Override
    public VampireSurvivorRecordInfo mergeFrom(final VampireSurvivorRecordInfo other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasSeasonScore()) {
        setSeasonScore(other.seasonScore);
      }
      if (other.hasSeason()) {
        getMutableSeason().mergeFrom(other.season);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      if (other.hasRecords()) {
        getMutableRecords().addAll(other.records);
      }
      return this;
    }

    @Override
    public VampireSurvivorRecordInfo clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      seasonScore = 0;
      season.clear();
      nextPackage.clear();
      records.clear();
      return this;
    }

    @Override
    public VampireSurvivorRecordInfo clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      season.clearQuick();
      nextPackage.clear();
      records.clearQuick();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof VampireSurvivorRecordInfo)) {
        return false;
      }
      VampireSurvivorRecordInfo other = (VampireSurvivorRecordInfo) o;
      return bitField0_ == other.bitField0_
        && (!hasSeasonScore() || seasonScore == other.seasonScore)
        && (!hasSeason() || season.equals(other.season))
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage))
        && (!hasRecords() || records.equals(other.records));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 24);
        output.writeUInt32NoTag(seasonScore);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 18);
        output.writeMessageNoTag(season);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        for (int i = 0; i < records.length(); i++) {
          output.writeRawByte((byte) 10);
          output.writeMessageNoTag(records.get(i));
        }
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(seasonScore);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeMessageSizeNoTag(season);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        size += (1 * records.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(records);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public VampireSurvivorRecordInfo mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 24: {
            // seasonScore
            seasonScore = input.readUInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 18) {
              break;
            }
          }
          case 18: {
            // season
            input.readMessage(season);
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 10) {
              break;
            }
          }
          case 10: {
            // records
            tag = input.readRepeatedMessage(records, tag);
            bitField0_ |= 0x00000008;
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeUInt32(FieldNames.seasonScore, seasonScore);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeMessage(FieldNames.season, season);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeRepeatedMessage(FieldNames.records, records);
      }
      output.endObject();
    }

    @Override
    public VampireSurvivorRecordInfo mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 796778831: {
            if (input.isAtField(FieldNames.seasonScore)) {
              if (!input.trySkipNullValue()) {
                seasonScore = input.readUInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1822468349: {
            if (input.isAtField(FieldNames.season)) {
              if (!input.trySkipNullValue()) {
                input.readMessage(season);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1547717086: {
            if (input.isAtField(FieldNames.records)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedMessage(records);
                bitField0_ |= 0x00000008;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public VampireSurvivorRecordInfo clone() {
      return new VampireSurvivorRecordInfo().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static VampireSurvivorRecordInfo parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new VampireSurvivorRecordInfo(), data).checkInitialized();
    }

    public static VampireSurvivorRecordInfo parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new VampireSurvivorRecordInfo(), input).checkInitialized();
    }

    public static VampireSurvivorRecordInfo parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new VampireSurvivorRecordInfo(), input).checkInitialized();
    }

    /**
     * @return factory for creating VampireSurvivorRecordInfo messages
     */
    public static MessageFactory<VampireSurvivorRecordInfo> getFactory() {
      return VampireSurvivorRecordInfoFactory.INSTANCE;
    }

    private enum VampireSurvivorRecordInfoFactory implements MessageFactory<VampireSurvivorRecordInfo> {
      INSTANCE;

      @Override
      public VampireSurvivorRecordInfo create() {
        return VampireSurvivorRecordInfo.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName seasonScore = FieldName.forField("SeasonScore");

      static final FieldName season = FieldName.forField("Season");

      static final FieldName nextPackage = FieldName.forField("NextPackage");

      static final FieldName records = FieldName.forField("Records");
    }
  }

  /**
   * Protobuf type {@code SkillInstance}
   */
  public static final class SkillInstance extends ProtoMessage<SkillInstance> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional uint64 BuildId = 5;</code>
     */
    private long buildId;

    /**
     * <code>optional uint32 Id = 1;</code>
     */
    private int id;

    /**
     * <code>optional uint32 Star = 2;</code>
     */
    private int star;

    /**
     * <code>optional bool First = 3;</code>
     */
    private boolean first;

    /**
     * <code>optional bool ThreeStar = 4;</code>
     */
    private boolean threeStar;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    private SkillInstance() {
    }

    /**
     * @return a new empty instance of {@code SkillInstance}
     */
    public static SkillInstance newInstance() {
      return new SkillInstance();
    }

    /**
     * <code>optional uint64 BuildId = 5;</code>
     * @return whether the buildId field is set
     */
    public boolean hasBuildId() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional uint64 BuildId = 5;</code>
     * @return this
     */
    public SkillInstance clearBuildId() {
      bitField0_ &= ~0x00000001;
      buildId = 0L;
      return this;
    }

    /**
     * <code>optional uint64 BuildId = 5;</code>
     * @return the buildId
     */
    public long getBuildId() {
      return buildId;
    }

    /**
     * <code>optional uint64 BuildId = 5;</code>
     * @param value the buildId to set
     * @return this
     */
    public SkillInstance setBuildId(final long value) {
      bitField0_ |= 0x00000001;
      buildId = value;
      return this;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @return whether the id field is set
     */
    public boolean hasId() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @return this
     */
    public SkillInstance clearId() {
      bitField0_ &= ~0x00000002;
      id = 0;
      return this;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @return the id
     */
    public int getId() {
      return id;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @param value the id to set
     * @return this
     */
    public SkillInstance setId(final int value) {
      bitField0_ |= 0x00000002;
      id = value;
      return this;
    }

    /**
     * <code>optional uint32 Star = 2;</code>
     * @return whether the star field is set
     */
    public boolean hasStar() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional uint32 Star = 2;</code>
     * @return this
     */
    public SkillInstance clearStar() {
      bitField0_ &= ~0x00000004;
      star = 0;
      return this;
    }

    /**
     * <code>optional uint32 Star = 2;</code>
     * @return the star
     */
    public int getStar() {
      return star;
    }

    /**
     * <code>optional uint32 Star = 2;</code>
     * @param value the star to set
     * @return this
     */
    public SkillInstance setStar(final int value) {
      bitField0_ |= 0x00000004;
      star = value;
      return this;
    }

    /**
     * <code>optional bool First = 3;</code>
     * @return whether the first field is set
     */
    public boolean hasFirst() {
      return (bitField0_ & 0x00000008) != 0;
    }

    /**
     * <code>optional bool First = 3;</code>
     * @return this
     */
    public SkillInstance clearFirst() {
      bitField0_ &= ~0x00000008;
      first = false;
      return this;
    }

    /**
     * <code>optional bool First = 3;</code>
     * @return the first
     */
    public boolean getFirst() {
      return first;
    }

    /**
     * <code>optional bool First = 3;</code>
     * @param value the first to set
     * @return this
     */
    public SkillInstance setFirst(final boolean value) {
      bitField0_ |= 0x00000008;
      first = value;
      return this;
    }

    /**
     * <code>optional bool ThreeStar = 4;</code>
     * @return whether the threeStar field is set
     */
    public boolean hasThreeStar() {
      return (bitField0_ & 0x00000010) != 0;
    }

    /**
     * <code>optional bool ThreeStar = 4;</code>
     * @return this
     */
    public SkillInstance clearThreeStar() {
      bitField0_ &= ~0x00000010;
      threeStar = false;
      return this;
    }

    /**
     * <code>optional bool ThreeStar = 4;</code>
     * @return the threeStar
     */
    public boolean getThreeStar() {
      return threeStar;
    }

    /**
     * <code>optional bool ThreeStar = 4;</code>
     * @param value the threeStar to set
     * @return this
     */
    public SkillInstance setThreeStar(final boolean value) {
      bitField0_ |= 0x00000010;
      threeStar = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000020) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public SkillInstance clearNextPackage() {
      bitField0_ &= ~0x00000020;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000020;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public SkillInstance addNextPackage(final byte value) {
      bitField0_ |= 0x00000020;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public SkillInstance addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000020;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public SkillInstance setNextPackage(final byte... values) {
      bitField0_ |= 0x00000020;
      nextPackage.copyFrom(values);
      return this;
    }

    @Override
    public SkillInstance copyFrom(final SkillInstance other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        buildId = other.buildId;
        id = other.id;
        star = other.star;
        first = other.first;
        threeStar = other.threeStar;
        nextPackage.copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public SkillInstance mergeFrom(final SkillInstance other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasBuildId()) {
        setBuildId(other.buildId);
      }
      if (other.hasId()) {
        setId(other.id);
      }
      if (other.hasStar()) {
        setStar(other.star);
      }
      if (other.hasFirst()) {
        setFirst(other.first);
      }
      if (other.hasThreeStar()) {
        setThreeStar(other.threeStar);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public SkillInstance clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      buildId = 0L;
      id = 0;
      star = 0;
      first = false;
      threeStar = false;
      nextPackage.clear();
      return this;
    }

    @Override
    public SkillInstance clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof SkillInstance)) {
        return false;
      }
      SkillInstance other = (SkillInstance) o;
      return bitField0_ == other.bitField0_
        && (!hasBuildId() || buildId == other.buildId)
        && (!hasId() || id == other.id)
        && (!hasStar() || star == other.star)
        && (!hasFirst() || first == other.first)
        && (!hasThreeStar() || threeStar == other.threeStar)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 40);
        output.writeUInt64NoTag(buildId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt32NoTag(id);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawByte((byte) 16);
        output.writeUInt32NoTag(star);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeRawByte((byte) 24);
        output.writeBoolNoTag(first);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        output.writeRawByte((byte) 32);
        output.writeBoolNoTag(threeStar);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeUInt64SizeNoTag(buildId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(id);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(star);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        size += 2;
      }
      if ((bitField0_ & 0x00000010) != 0) {
        size += 2;
      }
      if ((bitField0_ & 0x00000020) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public SkillInstance mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 40: {
            // buildId
            buildId = input.readUInt64();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 8) {
              break;
            }
          }
          case 8: {
            // id
            id = input.readUInt32();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 16) {
              break;
            }
          }
          case 16: {
            // star
            star = input.readUInt32();
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 24) {
              break;
            }
          }
          case 24: {
            // first
            first = input.readBool();
            bitField0_ |= 0x00000008;
            tag = input.readTag();
            if (tag != 32) {
              break;
            }
          }
          case 32: {
            // threeStar
            threeStar = input.readBool();
            bitField0_ |= 0x00000010;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000020;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeUInt64(FieldNames.buildId, buildId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeUInt32(FieldNames.id, id);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeUInt32(FieldNames.star, star);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeBool(FieldNames.first, first);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        output.writeBool(FieldNames.threeStar, threeStar);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      output.endObject();
    }

    @Override
    public SkillInstance mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 1895597065: {
            if (input.isAtField(FieldNames.buildId)) {
              if (!input.trySkipNullValue()) {
                buildId = input.readUInt64();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 2363: {
            if (input.isAtField(FieldNames.id)) {
              if (!input.trySkipNullValue()) {
                id = input.readUInt32();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 2587250: {
            if (input.isAtField(FieldNames.star)) {
              if (!input.trySkipNullValue()) {
                star = input.readUInt32();
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 67887760: {
            if (input.isAtField(FieldNames.first)) {
              if (!input.trySkipNullValue()) {
                first = input.readBool();
                bitField0_ |= 0x00000008;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 444940528: {
            if (input.isAtField(FieldNames.threeStar)) {
              if (!input.trySkipNullValue()) {
                threeStar = input.readBool();
                bitField0_ |= 0x00000010;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000020;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public SkillInstance clone() {
      return new SkillInstance().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static SkillInstance parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new SkillInstance(), data).checkInitialized();
    }

    public static SkillInstance parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new SkillInstance(), input).checkInitialized();
    }

    public static SkillInstance parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new SkillInstance(), input).checkInitialized();
    }

    /**
     * @return factory for creating SkillInstance messages
     */
    public static MessageFactory<SkillInstance> getFactory() {
      return SkillInstanceFactory.INSTANCE;
    }

    private enum SkillInstanceFactory implements MessageFactory<SkillInstance> {
      INSTANCE;

      @Override
      public SkillInstance create() {
        return SkillInstance.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName buildId = FieldName.forField("BuildId");

      static final FieldName id = FieldName.forField("Id");

      static final FieldName star = FieldName.forField("Star");

      static final FieldName first = FieldName.forField("First");

      static final FieldName threeStar = FieldName.forField("ThreeStar");

      static final FieldName nextPackage = FieldName.forField("NextPackage");
    }
  }

  /**
   * Protobuf type {@code WeekBossLevel}
   */
  public static final class WeekBossLevel extends ProtoMessage<WeekBossLevel> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional uint64 BuildId = 3;</code>
     */
    private long buildId;

    /**
     * <code>optional uint32 Id = 1;</code>
     */
    private int id;

    /**
     * <code>optional uint32 Time = 2;</code>
     */
    private int time;

    /**
     * <code>optional bool First = 4;</code>
     */
    private boolean first;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    private WeekBossLevel() {
    }

    /**
     * @return a new empty instance of {@code WeekBossLevel}
     */
    public static WeekBossLevel newInstance() {
      return new WeekBossLevel();
    }

    /**
     * <code>optional uint64 BuildId = 3;</code>
     * @return whether the buildId field is set
     */
    public boolean hasBuildId() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional uint64 BuildId = 3;</code>
     * @return this
     */
    public WeekBossLevel clearBuildId() {
      bitField0_ &= ~0x00000001;
      buildId = 0L;
      return this;
    }

    /**
     * <code>optional uint64 BuildId = 3;</code>
     * @return the buildId
     */
    public long getBuildId() {
      return buildId;
    }

    /**
     * <code>optional uint64 BuildId = 3;</code>
     * @param value the buildId to set
     * @return this
     */
    public WeekBossLevel setBuildId(final long value) {
      bitField0_ |= 0x00000001;
      buildId = value;
      return this;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @return whether the id field is set
     */
    public boolean hasId() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @return this
     */
    public WeekBossLevel clearId() {
      bitField0_ &= ~0x00000002;
      id = 0;
      return this;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @return the id
     */
    public int getId() {
      return id;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @param value the id to set
     * @return this
     */
    public WeekBossLevel setId(final int value) {
      bitField0_ |= 0x00000002;
      id = value;
      return this;
    }

    /**
     * <code>optional uint32 Time = 2;</code>
     * @return whether the time field is set
     */
    public boolean hasTime() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional uint32 Time = 2;</code>
     * @return this
     */
    public WeekBossLevel clearTime() {
      bitField0_ &= ~0x00000004;
      time = 0;
      return this;
    }

    /**
     * <code>optional uint32 Time = 2;</code>
     * @return the time
     */
    public int getTime() {
      return time;
    }

    /**
     * <code>optional uint32 Time = 2;</code>
     * @param value the time to set
     * @return this
     */
    public WeekBossLevel setTime(final int value) {
      bitField0_ |= 0x00000004;
      time = value;
      return this;
    }

    /**
     * <code>optional bool First = 4;</code>
     * @return whether the first field is set
     */
    public boolean hasFirst() {
      return (bitField0_ & 0x00000008) != 0;
    }

    /**
     * <code>optional bool First = 4;</code>
     * @return this
     */
    public WeekBossLevel clearFirst() {
      bitField0_ &= ~0x00000008;
      first = false;
      return this;
    }

    /**
     * <code>optional bool First = 4;</code>
     * @return the first
     */
    public boolean getFirst() {
      return first;
    }

    /**
     * <code>optional bool First = 4;</code>
     * @param value the first to set
     * @return this
     */
    public WeekBossLevel setFirst(final boolean value) {
      bitField0_ |= 0x00000008;
      first = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000010) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public WeekBossLevel clearNextPackage() {
      bitField0_ &= ~0x00000010;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000010;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public WeekBossLevel addNextPackage(final byte value) {
      bitField0_ |= 0x00000010;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public WeekBossLevel addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000010;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public WeekBossLevel setNextPackage(final byte... values) {
      bitField0_ |= 0x00000010;
      nextPackage.copyFrom(values);
      return this;
    }

    @Override
    public WeekBossLevel copyFrom(final WeekBossLevel other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        buildId = other.buildId;
        id = other.id;
        time = other.time;
        first = other.first;
        nextPackage.copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public WeekBossLevel mergeFrom(final WeekBossLevel other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasBuildId()) {
        setBuildId(other.buildId);
      }
      if (other.hasId()) {
        setId(other.id);
      }
      if (other.hasTime()) {
        setTime(other.time);
      }
      if (other.hasFirst()) {
        setFirst(other.first);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public WeekBossLevel clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      buildId = 0L;
      id = 0;
      time = 0;
      first = false;
      nextPackage.clear();
      return this;
    }

    @Override
    public WeekBossLevel clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof WeekBossLevel)) {
        return false;
      }
      WeekBossLevel other = (WeekBossLevel) o;
      return bitField0_ == other.bitField0_
        && (!hasBuildId() || buildId == other.buildId)
        && (!hasId() || id == other.id)
        && (!hasTime() || time == other.time)
        && (!hasFirst() || first == other.first)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 24);
        output.writeUInt64NoTag(buildId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt32NoTag(id);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawByte((byte) 16);
        output.writeUInt32NoTag(time);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeRawByte((byte) 32);
        output.writeBoolNoTag(first);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeUInt64SizeNoTag(buildId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(id);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(time);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        size += 2;
      }
      if ((bitField0_ & 0x00000010) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public WeekBossLevel mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 24: {
            // buildId
            buildId = input.readUInt64();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 8) {
              break;
            }
          }
          case 8: {
            // id
            id = input.readUInt32();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 16) {
              break;
            }
          }
          case 16: {
            // time
            time = input.readUInt32();
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 32) {
              break;
            }
          }
          case 32: {
            // first
            first = input.readBool();
            bitField0_ |= 0x00000008;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000010;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeUInt64(FieldNames.buildId, buildId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeUInt32(FieldNames.id, id);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeUInt32(FieldNames.time, time);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeBool(FieldNames.first, first);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      output.endObject();
    }

    @Override
    public WeekBossLevel mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 1895597065: {
            if (input.isAtField(FieldNames.buildId)) {
              if (!input.trySkipNullValue()) {
                buildId = input.readUInt64();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 2363: {
            if (input.isAtField(FieldNames.id)) {
              if (!input.trySkipNullValue()) {
                id = input.readUInt32();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 2606829: {
            if (input.isAtField(FieldNames.time)) {
              if (!input.trySkipNullValue()) {
                time = input.readUInt32();
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 67887760: {
            if (input.isAtField(FieldNames.first)) {
              if (!input.trySkipNullValue()) {
                first = input.readBool();
                bitField0_ |= 0x00000008;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000010;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public WeekBossLevel clone() {
      return new WeekBossLevel().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static WeekBossLevel parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new WeekBossLevel(), data).checkInitialized();
    }

    public static WeekBossLevel parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new WeekBossLevel(), input).checkInitialized();
    }

    public static WeekBossLevel parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new WeekBossLevel(), input).checkInitialized();
    }

    /**
     * @return factory for creating WeekBossLevel messages
     */
    public static MessageFactory<WeekBossLevel> getFactory() {
      return WeekBossLevelFactory.INSTANCE;
    }

    private enum WeekBossLevelFactory implements MessageFactory<WeekBossLevel> {
      INSTANCE;

      @Override
      public WeekBossLevel create() {
        return WeekBossLevel.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName buildId = FieldName.forField("BuildId");

      static final FieldName id = FieldName.forField("Id");

      static final FieldName time = FieldName.forField("Time");

      static final FieldName first = FieldName.forField("First");

      static final FieldName nextPackage = FieldName.forField("NextPackage");
    }
  }

  /**
   * Protobuf type {@code ScoreBossState}
   */
  public static final class ScoreBossState extends ProtoMessage<ScoreBossState> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional bool New = 1;</code>
     */
    private boolean new_;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    private ScoreBossState() {
    }

    /**
     * @return a new empty instance of {@code ScoreBossState}
     */
    public static ScoreBossState newInstance() {
      return new ScoreBossState();
    }

    /**
     * <code>optional bool New = 1;</code>
     * @return whether the new_ field is set
     */
    public boolean hasNew() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional bool New = 1;</code>
     * @return this
     */
    public ScoreBossState clearNew() {
      bitField0_ &= ~0x00000001;
      new_ = false;
      return this;
    }

    /**
     * <code>optional bool New = 1;</code>
     * @return the new_
     */
    public boolean getNew() {
      return new_;
    }

    /**
     * <code>optional bool New = 1;</code>
     * @param value the new_ to set
     * @return this
     */
    public ScoreBossState setNew(final boolean value) {
      bitField0_ |= 0x00000001;
      new_ = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public ScoreBossState clearNextPackage() {
      bitField0_ &= ~0x00000002;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000002;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public ScoreBossState addNextPackage(final byte value) {
      bitField0_ |= 0x00000002;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public ScoreBossState addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000002;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public ScoreBossState setNextPackage(final byte... values) {
      bitField0_ |= 0x00000002;
      nextPackage.copyFrom(values);
      return this;
    }

    @Override
    public ScoreBossState copyFrom(final ScoreBossState other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        new_ = other.new_;
        nextPackage.copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public ScoreBossState mergeFrom(final ScoreBossState other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasNew()) {
        setNew(other.new_);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public ScoreBossState clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      new_ = false;
      nextPackage.clear();
      return this;
    }

    @Override
    public ScoreBossState clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof ScoreBossState)) {
        return false;
      }
      ScoreBossState other = (ScoreBossState) o;
      return bitField0_ == other.bitField0_
        && (!hasNew() || new_ == other.new_)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 8);
        output.writeBoolNoTag(new_);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 2;
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public ScoreBossState mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            // new_
            new_ = input.readBool();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeBool(FieldNames.new_, new_);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      output.endObject();
    }

    @Override
    public ScoreBossState mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 78208: {
            if (input.isAtField(FieldNames.new_)) {
              if (!input.trySkipNullValue()) {
                new_ = input.readBool();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public ScoreBossState clone() {
      return new ScoreBossState().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static ScoreBossState parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new ScoreBossState(), data).checkInitialized();
    }

    public static ScoreBossState parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new ScoreBossState(), input).checkInitialized();
    }

    public static ScoreBossState parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new ScoreBossState(), input).checkInitialized();
    }

    /**
     * @return factory for creating ScoreBossState messages
     */
    public static MessageFactory<ScoreBossState> getFactory() {
      return ScoreBossStateFactory.INSTANCE;
    }

    private enum ScoreBossStateFactory implements MessageFactory<ScoreBossState> {
      INSTANCE;

      @Override
      public ScoreBossState create() {
        return ScoreBossState.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName new_ = FieldName.forField("New");

      static final FieldName nextPackage = FieldName.forField("NextPackage");
    }
  }

  /**
   * Protobuf type {@code NPCAffinity}
   */
  public static final class NPCAffinity extends ProtoMessage<NPCAffinity> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional uint32 NPCId = 1;</code>
     */
    private int nPCId;

    /**
     * <code>optional uint32 Affinity = 2;</code>
     */
    private int affinity;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    /**
     * <code>repeated uint32 PlotIds = 3;</code>
     */
    private final RepeatedInt plotIds = RepeatedInt.newEmptyInstance();

    private NPCAffinity() {
    }

    /**
     * @return a new empty instance of {@code NPCAffinity}
     */
    public static NPCAffinity newInstance() {
      return new NPCAffinity();
    }

    /**
     * <code>optional uint32 NPCId = 1;</code>
     * @return whether the nPCId field is set
     */
    public boolean hasNPCId() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional uint32 NPCId = 1;</code>
     * @return this
     */
    public NPCAffinity clearNPCId() {
      bitField0_ &= ~0x00000001;
      nPCId = 0;
      return this;
    }

    /**
     * <code>optional uint32 NPCId = 1;</code>
     * @return the nPCId
     */
    public int getNPCId() {
      return nPCId;
    }

    /**
     * <code>optional uint32 NPCId = 1;</code>
     * @param value the nPCId to set
     * @return this
     */
    public NPCAffinity setNPCId(final int value) {
      bitField0_ |= 0x00000001;
      nPCId = value;
      return this;
    }

    /**
     * <code>optional uint32 Affinity = 2;</code>
     * @return whether the affinity field is set
     */
    public boolean hasAffinity() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional uint32 Affinity = 2;</code>
     * @return this
     */
    public NPCAffinity clearAffinity() {
      bitField0_ &= ~0x00000002;
      affinity = 0;
      return this;
    }

    /**
     * <code>optional uint32 Affinity = 2;</code>
     * @return the affinity
     */
    public int getAffinity() {
      return affinity;
    }

    /**
     * <code>optional uint32 Affinity = 2;</code>
     * @param value the affinity to set
     * @return this
     */
    public NPCAffinity setAffinity(final int value) {
      bitField0_ |= 0x00000002;
      affinity = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public NPCAffinity clearNextPackage() {
      bitField0_ &= ~0x00000004;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000004;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public NPCAffinity addNextPackage(final byte value) {
      bitField0_ |= 0x00000004;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public NPCAffinity addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000004;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public NPCAffinity setNextPackage(final byte... values) {
      bitField0_ |= 0x00000004;
      nextPackage.copyFrom(values);
      return this;
    }

    /**
     * <code>repeated uint32 PlotIds = 3;</code>
     * @return whether the plotIds field is set
     */
    public boolean hasPlotIds() {
      return (bitField0_ & 0x00000008) != 0;
    }

    /**
     * <code>repeated uint32 PlotIds = 3;</code>
     * @return this
     */
    public NPCAffinity clearPlotIds() {
      bitField0_ &= ~0x00000008;
      plotIds.clear();
      return this;
    }

    /**
     * <code>repeated uint32 PlotIds = 3;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutablePlotIds()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedInt getPlotIds() {
      return plotIds;
    }

    /**
     * <code>repeated uint32 PlotIds = 3;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedInt getMutablePlotIds() {
      bitField0_ |= 0x00000008;
      return plotIds;
    }

    /**
     * <code>repeated uint32 PlotIds = 3;</code>
     * @param value the plotIds to add
     * @return this
     */
    public NPCAffinity addPlotIds(final int value) {
      bitField0_ |= 0x00000008;
      plotIds.add(value);
      return this;
    }

    /**
     * <code>repeated uint32 PlotIds = 3;</code>
     * @param values the plotIds to add
     * @return this
     */
    public NPCAffinity addAllPlotIds(final int... values) {
      bitField0_ |= 0x00000008;
      plotIds.addAll(values);
      return this;
    }

    @Override
    public NPCAffinity copyFrom(final NPCAffinity other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        nPCId = other.nPCId;
        affinity = other.affinity;
        nextPackage.copyFrom(other.nextPackage);
        plotIds.copyFrom(other.plotIds);
      }
      return this;
    }

    @Override
    public NPCAffinity mergeFrom(final NPCAffinity other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasNPCId()) {
        setNPCId(other.nPCId);
      }
      if (other.hasAffinity()) {
        setAffinity(other.affinity);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      if (other.hasPlotIds()) {
        getMutablePlotIds().addAll(other.plotIds);
      }
      return this;
    }

    @Override
    public NPCAffinity clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nPCId = 0;
      affinity = 0;
      nextPackage.clear();
      plotIds.clear();
      return this;
    }

    @Override
    public NPCAffinity clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      plotIds.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof NPCAffinity)) {
        return false;
      }
      NPCAffinity other = (NPCAffinity) o;
      return bitField0_ == other.bitField0_
        && (!hasNPCId() || nPCId == other.nPCId)
        && (!hasAffinity() || affinity == other.affinity)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage))
        && (!hasPlotIds() || plotIds.equals(other.plotIds));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt32NoTag(nPCId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 16);
        output.writeUInt32NoTag(affinity);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        for (int i = 0; i < plotIds.length(); i++) {
          output.writeRawByte((byte) 24);
          output.writeUInt32NoTag(plotIds.array()[i]);
        }
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(nPCId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(affinity);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        size += (1 * plotIds.length()) + ProtoSink.computeRepeatedUInt32SizeNoTag(plotIds);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public NPCAffinity mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            // nPCId
            nPCId = input.readUInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 16) {
              break;
            }
          }
          case 16: {
            // affinity
            affinity = input.readUInt32();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 26) {
              break;
            }
          }
          case 26: {
            // plotIds [packed=true]
            input.readPackedUInt32(plotIds, tag);
            bitField0_ |= 0x00000008;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
          case 24: {
            // plotIds [packed=false]
            tag = input.readRepeatedUInt32(plotIds, tag);
            bitField0_ |= 0x00000008;
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeUInt32(FieldNames.nPCId, nPCId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeUInt32(FieldNames.affinity, affinity);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeRepeatedUInt32(FieldNames.plotIds, plotIds);
      }
      output.endObject();
    }

    @Override
    public NPCAffinity mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 74484668: {
            if (input.isAtField(FieldNames.nPCId)) {
              if (!input.trySkipNullValue()) {
                nPCId = input.readUInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 670141768: {
            if (input.isAtField(FieldNames.affinity)) {
              if (!input.trySkipNullValue()) {
                affinity = input.readUInt32();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 1183838711: {
            if (input.isAtField(FieldNames.plotIds)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedUInt32(plotIds);
                bitField0_ |= 0x00000008;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public NPCAffinity clone() {
      return new NPCAffinity().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static NPCAffinity parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new NPCAffinity(), data).checkInitialized();
    }

    public static NPCAffinity parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new NPCAffinity(), input).checkInitialized();
    }

    public static NPCAffinity parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new NPCAffinity(), input).checkInitialized();
    }

    /**
     * @return factory for creating NPCAffinity messages
     */
    public static MessageFactory<NPCAffinity> getFactory() {
      return NPCAffinityFactory.INSTANCE;
    }

    private enum NPCAffinityFactory implements MessageFactory<NPCAffinity> {
      INSTANCE;

      @Override
      public NPCAffinity create() {
        return NPCAffinity.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName nPCId = FieldName.forField("NPCId");

      static final FieldName affinity = FieldName.forField("Affinity");

      static final FieldName nextPackage = FieldName.forField("NextPackage");

      static final FieldName plotIds = FieldName.forField("PlotIds");
    }
  }

  /**
   * Protobuf type {@code CharGemInstance}
   */
  public static final class CharGemInstance extends ProtoMessage<CharGemInstance> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional uint64 BuildId = 5;</code>
     */
    private long buildId;

    /**
     * <code>optional uint32 Id = 1;</code>
     */
    private int id;

    /**
     * <code>optional uint32 Star = 2;</code>
     */
    private int star;

    /**
     * <code>optional bool First = 3;</code>
     */
    private boolean first;

    /**
     * <code>optional bool ThreeStar = 4;</code>
     */
    private boolean threeStar;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    private CharGemInstance() {
    }

    /**
     * @return a new empty instance of {@code CharGemInstance}
     */
    public static CharGemInstance newInstance() {
      return new CharGemInstance();
    }

    /**
     * <code>optional uint64 BuildId = 5;</code>
     * @return whether the buildId field is set
     */
    public boolean hasBuildId() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional uint64 BuildId = 5;</code>
     * @return this
     */
    public CharGemInstance clearBuildId() {
      bitField0_ &= ~0x00000001;
      buildId = 0L;
      return this;
    }

    /**
     * <code>optional uint64 BuildId = 5;</code>
     * @return the buildId
     */
    public long getBuildId() {
      return buildId;
    }

    /**
     * <code>optional uint64 BuildId = 5;</code>
     * @param value the buildId to set
     * @return this
     */
    public CharGemInstance setBuildId(final long value) {
      bitField0_ |= 0x00000001;
      buildId = value;
      return this;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @return whether the id field is set
     */
    public boolean hasId() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @return this
     */
    public CharGemInstance clearId() {
      bitField0_ &= ~0x00000002;
      id = 0;
      return this;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @return the id
     */
    public int getId() {
      return id;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @param value the id to set
     * @return this
     */
    public CharGemInstance setId(final int value) {
      bitField0_ |= 0x00000002;
      id = value;
      return this;
    }

    /**
     * <code>optional uint32 Star = 2;</code>
     * @return whether the star field is set
     */
    public boolean hasStar() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional uint32 Star = 2;</code>
     * @return this
     */
    public CharGemInstance clearStar() {
      bitField0_ &= ~0x00000004;
      star = 0;
      return this;
    }

    /**
     * <code>optional uint32 Star = 2;</code>
     * @return the star
     */
    public int getStar() {
      return star;
    }

    /**
     * <code>optional uint32 Star = 2;</code>
     * @param value the star to set
     * @return this
     */
    public CharGemInstance setStar(final int value) {
      bitField0_ |= 0x00000004;
      star = value;
      return this;
    }

    /**
     * <code>optional bool First = 3;</code>
     * @return whether the first field is set
     */
    public boolean hasFirst() {
      return (bitField0_ & 0x00000008) != 0;
    }

    /**
     * <code>optional bool First = 3;</code>
     * @return this
     */
    public CharGemInstance clearFirst() {
      bitField0_ &= ~0x00000008;
      first = false;
      return this;
    }

    /**
     * <code>optional bool First = 3;</code>
     * @return the first
     */
    public boolean getFirst() {
      return first;
    }

    /**
     * <code>optional bool First = 3;</code>
     * @param value the first to set
     * @return this
     */
    public CharGemInstance setFirst(final boolean value) {
      bitField0_ |= 0x00000008;
      first = value;
      return this;
    }

    /**
     * <code>optional bool ThreeStar = 4;</code>
     * @return whether the threeStar field is set
     */
    public boolean hasThreeStar() {
      return (bitField0_ & 0x00000010) != 0;
    }

    /**
     * <code>optional bool ThreeStar = 4;</code>
     * @return this
     */
    public CharGemInstance clearThreeStar() {
      bitField0_ &= ~0x00000010;
      threeStar = false;
      return this;
    }

    /**
     * <code>optional bool ThreeStar = 4;</code>
     * @return the threeStar
     */
    public boolean getThreeStar() {
      return threeStar;
    }

    /**
     * <code>optional bool ThreeStar = 4;</code>
     * @param value the threeStar to set
     * @return this
     */
    public CharGemInstance setThreeStar(final boolean value) {
      bitField0_ |= 0x00000010;
      threeStar = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000020) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public CharGemInstance clearNextPackage() {
      bitField0_ &= ~0x00000020;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000020;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public CharGemInstance addNextPackage(final byte value) {
      bitField0_ |= 0x00000020;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public CharGemInstance addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000020;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public CharGemInstance setNextPackage(final byte... values) {
      bitField0_ |= 0x00000020;
      nextPackage.copyFrom(values);
      return this;
    }

    @Override
    public CharGemInstance copyFrom(final CharGemInstance other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        buildId = other.buildId;
        id = other.id;
        star = other.star;
        first = other.first;
        threeStar = other.threeStar;
        nextPackage.copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public CharGemInstance mergeFrom(final CharGemInstance other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasBuildId()) {
        setBuildId(other.buildId);
      }
      if (other.hasId()) {
        setId(other.id);
      }
      if (other.hasStar()) {
        setStar(other.star);
      }
      if (other.hasFirst()) {
        setFirst(other.first);
      }
      if (other.hasThreeStar()) {
        setThreeStar(other.threeStar);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public CharGemInstance clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      buildId = 0L;
      id = 0;
      star = 0;
      first = false;
      threeStar = false;
      nextPackage.clear();
      return this;
    }

    @Override
    public CharGemInstance clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof CharGemInstance)) {
        return false;
      }
      CharGemInstance other = (CharGemInstance) o;
      return bitField0_ == other.bitField0_
        && (!hasBuildId() || buildId == other.buildId)
        && (!hasId() || id == other.id)
        && (!hasStar() || star == other.star)
        && (!hasFirst() || first == other.first)
        && (!hasThreeStar() || threeStar == other.threeStar)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 40);
        output.writeUInt64NoTag(buildId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt32NoTag(id);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawByte((byte) 16);
        output.writeUInt32NoTag(star);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeRawByte((byte) 24);
        output.writeBoolNoTag(first);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        output.writeRawByte((byte) 32);
        output.writeBoolNoTag(threeStar);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeUInt64SizeNoTag(buildId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(id);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(star);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        size += 2;
      }
      if ((bitField0_ & 0x00000010) != 0) {
        size += 2;
      }
      if ((bitField0_ & 0x00000020) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public CharGemInstance mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 40: {
            // buildId
            buildId = input.readUInt64();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 8) {
              break;
            }
          }
          case 8: {
            // id
            id = input.readUInt32();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 16) {
              break;
            }
          }
          case 16: {
            // star
            star = input.readUInt32();
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 24) {
              break;
            }
          }
          case 24: {
            // first
            first = input.readBool();
            bitField0_ |= 0x00000008;
            tag = input.readTag();
            if (tag != 32) {
              break;
            }
          }
          case 32: {
            // threeStar
            threeStar = input.readBool();
            bitField0_ |= 0x00000010;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000020;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeUInt64(FieldNames.buildId, buildId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeUInt32(FieldNames.id, id);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeUInt32(FieldNames.star, star);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeBool(FieldNames.first, first);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        output.writeBool(FieldNames.threeStar, threeStar);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      output.endObject();
    }

    @Override
    public CharGemInstance mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 1895597065: {
            if (input.isAtField(FieldNames.buildId)) {
              if (!input.trySkipNullValue()) {
                buildId = input.readUInt64();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 2363: {
            if (input.isAtField(FieldNames.id)) {
              if (!input.trySkipNullValue()) {
                id = input.readUInt32();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 2587250: {
            if (input.isAtField(FieldNames.star)) {
              if (!input.trySkipNullValue()) {
                star = input.readUInt32();
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 67887760: {
            if (input.isAtField(FieldNames.first)) {
              if (!input.trySkipNullValue()) {
                first = input.readBool();
                bitField0_ |= 0x00000008;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 444940528: {
            if (input.isAtField(FieldNames.threeStar)) {
              if (!input.trySkipNullValue()) {
                threeStar = input.readBool();
                bitField0_ |= 0x00000010;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000020;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public CharGemInstance clone() {
      return new CharGemInstance().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static CharGemInstance parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new CharGemInstance(), data).checkInitialized();
    }

    public static CharGemInstance parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new CharGemInstance(), input).checkInitialized();
    }

    public static CharGemInstance parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new CharGemInstance(), input).checkInitialized();
    }

    /**
     * @return factory for creating CharGemInstance messages
     */
    public static MessageFactory<CharGemInstance> getFactory() {
      return CharGemInstanceFactory.INSTANCE;
    }

    private enum CharGemInstanceFactory implements MessageFactory<CharGemInstance> {
      INSTANCE;

      @Override
      public CharGemInstance create() {
        return CharGemInstance.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName buildId = FieldName.forField("BuildId");

      static final FieldName id = FieldName.forField("Id");

      static final FieldName star = FieldName.forField("Star");

      static final FieldName first = FieldName.forField("First");

      static final FieldName threeStar = FieldName.forField("ThreeStar");

      static final FieldName nextPackage = FieldName.forField("NextPackage");
    }
  }

  /**
   * Protobuf type {@code CharGemPreset}
   */
  public static final class CharGemPreset extends ProtoMessage<CharGemPreset> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    /**
     * <code>optional string Name = 1;</code>
     */
    private final Utf8String name = Utf8String.newEmptyInstance();

    /**
     * <code>repeated int32 SlotGem = 2;</code>
     */
    private final RepeatedInt slotGem = RepeatedInt.newEmptyInstance();

    private CharGemPreset() {
    }

    /**
     * @return a new empty instance of {@code CharGemPreset}
     */
    public static CharGemPreset newInstance() {
      return new CharGemPreset();
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public CharGemPreset clearNextPackage() {
      bitField0_ &= ~0x00000001;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000001;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public CharGemPreset addNextPackage(final byte value) {
      bitField0_ |= 0x00000001;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public CharGemPreset addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000001;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public CharGemPreset setNextPackage(final byte... values) {
      bitField0_ |= 0x00000001;
      nextPackage.copyFrom(values);
      return this;
    }

    /**
     * <code>optional string Name = 1;</code>
     * @return whether the name field is set
     */
    public boolean hasName() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional string Name = 1;</code>
     * @return this
     */
    public CharGemPreset clearName() {
      bitField0_ &= ~0x00000002;
      name.clear();
      return this;
    }

    /**
     * <code>optional string Name = 1;</code>
     * @return the name
     */
    public java.lang.String getName() {
      return name.getString();
    }

    /**
     * <code>optional string Name = 1;</code>
     * @return internal {@code Utf8String} representation of name for reading
     */
    public Utf8String getNameBytes() {
      return this.name;
    }

    /**
     * <code>optional string Name = 1;</code>
     * @return internal {@code Utf8String} representation of name for modifications
     */
    public Utf8String getMutableNameBytes() {
      bitField0_ |= 0x00000002;
      return this.name;
    }

    /**
     * <code>optional string Name = 1;</code>
     * @param value the name to set
     * @return this
     */
    public CharGemPreset setName(final CharSequence value) {
      bitField0_ |= 0x00000002;
      name.copyFrom(value);
      return this;
    }

    /**
     * <code>optional string Name = 1;</code>
     * @param value the name to set
     * @return this
     */
    public CharGemPreset setName(final Utf8String value) {
      bitField0_ |= 0x00000002;
      name.copyFrom(value);
      return this;
    }

    /**
     * <code>repeated int32 SlotGem = 2;</code>
     * @return whether the slotGem field is set
     */
    public boolean hasSlotGem() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>repeated int32 SlotGem = 2;</code>
     * @return this
     */
    public CharGemPreset clearSlotGem() {
      bitField0_ &= ~0x00000004;
      slotGem.clear();
      return this;
    }

    /**
     * <code>repeated int32 SlotGem = 2;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableSlotGem()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedInt getSlotGem() {
      return slotGem;
    }

    /**
     * <code>repeated int32 SlotGem = 2;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedInt getMutableSlotGem() {
      bitField0_ |= 0x00000004;
      return slotGem;
    }

    /**
     * <code>repeated int32 SlotGem = 2;</code>
     * @param value the slotGem to add
     * @return this
     */
    public CharGemPreset addSlotGem(final int value) {
      bitField0_ |= 0x00000004;
      slotGem.add(value);
      return this;
    }

    /**
     * <code>repeated int32 SlotGem = 2;</code>
     * @param values the slotGem to add
     * @return this
     */
    public CharGemPreset addAllSlotGem(final int... values) {
      bitField0_ |= 0x00000004;
      slotGem.addAll(values);
      return this;
    }

    @Override
    public CharGemPreset copyFrom(final CharGemPreset other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        nextPackage.copyFrom(other.nextPackage);
        name.copyFrom(other.name);
        slotGem.copyFrom(other.slotGem);
      }
      return this;
    }

    @Override
    public CharGemPreset mergeFrom(final CharGemPreset other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      if (other.hasName()) {
        getMutableNameBytes().copyFrom(other.name);
      }
      if (other.hasSlotGem()) {
        getMutableSlotGem().addAll(other.slotGem);
      }
      return this;
    }

    @Override
    public CharGemPreset clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      name.clear();
      slotGem.clear();
      return this;
    }

    @Override
    public CharGemPreset clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      name.clear();
      slotGem.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof CharGemPreset)) {
        return false;
      }
      CharGemPreset other = (CharGemPreset) o;
      return bitField0_ == other.bitField0_
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage))
        && (!hasName() || name.equals(other.name))
        && (!hasSlotGem() || slotGem.equals(other.slotGem));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 10);
        output.writeStringNoTag(name);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        for (int i = 0; i < slotGem.length(); i++) {
          output.writeRawByte((byte) 16);
          output.writeInt32NoTag(slotGem.array()[i]);
        }
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeStringSizeNoTag(name);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += (1 * slotGem.length()) + ProtoSink.computeRepeatedInt32SizeNoTag(slotGem);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public CharGemPreset mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 10) {
              break;
            }
          }
          case 10: {
            // name
            input.readString(name);
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 18) {
              break;
            }
          }
          case 18: {
            // slotGem [packed=true]
            input.readPackedInt32(slotGem, tag);
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
          case 16: {
            // slotGem [packed=false]
            tag = input.readRepeatedInt32(slotGem, tag);
            bitField0_ |= 0x00000004;
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeString(FieldNames.name, name);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRepeatedInt32(FieldNames.slotGem, slotGem);
      }
      output.endObject();
    }

    @Override
    public CharGemPreset mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 2420395: {
            if (input.isAtField(FieldNames.name)) {
              if (!input.trySkipNullValue()) {
                input.readString(name);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -448619439: {
            if (input.isAtField(FieldNames.slotGem)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedInt32(slotGem);
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public CharGemPreset clone() {
      return new CharGemPreset().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static CharGemPreset parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new CharGemPreset(), data).checkInitialized();
    }

    public static CharGemPreset parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new CharGemPreset(), input).checkInitialized();
    }

    public static CharGemPreset parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new CharGemPreset(), input).checkInitialized();
    }

    /**
     * @return factory for creating CharGemPreset messages
     */
    public static MessageFactory<CharGemPreset> getFactory() {
      return CharGemPresetFactory.INSTANCE;
    }

    private enum CharGemPresetFactory implements MessageFactory<CharGemPreset> {
      INSTANCE;

      @Override
      public CharGemPreset create() {
        return CharGemPreset.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName nextPackage = FieldName.forField("NextPackage");

      static final FieldName name = FieldName.forField("Name");

      static final FieldName slotGem = FieldName.forField("SlotGem");
    }
  }

  /**
   * Protobuf type {@code CharGemPresets}
   */
  public static final class CharGemPresets extends ProtoMessage<CharGemPresets> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional uint32 InUsePresetIndex = 1;</code>
     */
    private int inUsePresetIndex;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    /**
     * <code>repeated .CharGemPreset CharGemPresets = 2;</code>
     */
    private final RepeatedMessage<CharGemPreset> charGemPresets = RepeatedMessage.newEmptyInstance(CharGemPreset.getFactory());

    private CharGemPresets() {
    }

    /**
     * @return a new empty instance of {@code CharGemPresets}
     */
    public static CharGemPresets newInstance() {
      return new CharGemPresets();
    }

    /**
     * <code>optional uint32 InUsePresetIndex = 1;</code>
     * @return whether the inUsePresetIndex field is set
     */
    public boolean hasInUsePresetIndex() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional uint32 InUsePresetIndex = 1;</code>
     * @return this
     */
    public CharGemPresets clearInUsePresetIndex() {
      bitField0_ &= ~0x00000001;
      inUsePresetIndex = 0;
      return this;
    }

    /**
     * <code>optional uint32 InUsePresetIndex = 1;</code>
     * @return the inUsePresetIndex
     */
    public int getInUsePresetIndex() {
      return inUsePresetIndex;
    }

    /**
     * <code>optional uint32 InUsePresetIndex = 1;</code>
     * @param value the inUsePresetIndex to set
     * @return this
     */
    public CharGemPresets setInUsePresetIndex(final int value) {
      bitField0_ |= 0x00000001;
      inUsePresetIndex = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public CharGemPresets clearNextPackage() {
      bitField0_ &= ~0x00000002;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000002;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public CharGemPresets addNextPackage(final byte value) {
      bitField0_ |= 0x00000002;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public CharGemPresets addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000002;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public CharGemPresets setNextPackage(final byte... values) {
      bitField0_ |= 0x00000002;
      nextPackage.copyFrom(values);
      return this;
    }

    /**
     * <code>repeated .CharGemPreset CharGemPresets = 2;</code>
     * @return whether the charGemPresets field is set
     */
    public boolean hasCharGemPresets() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>repeated .CharGemPreset CharGemPresets = 2;</code>
     * @return this
     */
    public CharGemPresets clearCharGemPresets() {
      bitField0_ &= ~0x00000004;
      charGemPresets.clear();
      return this;
    }

    /**
     * <code>repeated .CharGemPreset CharGemPresets = 2;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableCharGemPresets()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<CharGemPreset> getCharGemPresets() {
      return charGemPresets;
    }

    /**
     * <code>repeated .CharGemPreset CharGemPresets = 2;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<CharGemPreset> getMutableCharGemPresets() {
      bitField0_ |= 0x00000004;
      return charGemPresets;
    }

    /**
     * <code>repeated .CharGemPreset CharGemPresets = 2;</code>
     * @param value the charGemPresets to add
     * @return this
     */
    public CharGemPresets addCharGemPresets(final CharGemPreset value) {
      bitField0_ |= 0x00000004;
      charGemPresets.add(value);
      return this;
    }

    /**
     * <code>repeated .CharGemPreset CharGemPresets = 2;</code>
     * @param values the charGemPresets to add
     * @return this
     */
    public CharGemPresets addAllCharGemPresets(final CharGemPreset... values) {
      bitField0_ |= 0x00000004;
      charGemPresets.addAll(values);
      return this;
    }

    @Override
    public CharGemPresets copyFrom(final CharGemPresets other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        inUsePresetIndex = other.inUsePresetIndex;
        nextPackage.copyFrom(other.nextPackage);
        charGemPresets.copyFrom(other.charGemPresets);
      }
      return this;
    }

    @Override
    public CharGemPresets mergeFrom(final CharGemPresets other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasInUsePresetIndex()) {
        setInUsePresetIndex(other.inUsePresetIndex);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      if (other.hasCharGemPresets()) {
        getMutableCharGemPresets().addAll(other.charGemPresets);
      }
      return this;
    }

    @Override
    public CharGemPresets clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      inUsePresetIndex = 0;
      nextPackage.clear();
      charGemPresets.clear();
      return this;
    }

    @Override
    public CharGemPresets clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      charGemPresets.clearQuick();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof CharGemPresets)) {
        return false;
      }
      CharGemPresets other = (CharGemPresets) o;
      return bitField0_ == other.bitField0_
        && (!hasInUsePresetIndex() || inUsePresetIndex == other.inUsePresetIndex)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage))
        && (!hasCharGemPresets() || charGemPresets.equals(other.charGemPresets));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt32NoTag(inUsePresetIndex);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        for (int i = 0; i < charGemPresets.length(); i++) {
          output.writeRawByte((byte) 18);
          output.writeMessageNoTag(charGemPresets.get(i));
        }
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(inUsePresetIndex);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += (1 * charGemPresets.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(charGemPresets);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public CharGemPresets mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            // inUsePresetIndex
            inUsePresetIndex = input.readUInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 18) {
              break;
            }
          }
          case 18: {
            // charGemPresets
            tag = input.readRepeatedMessage(charGemPresets, tag);
            bitField0_ |= 0x00000004;
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeUInt32(FieldNames.inUsePresetIndex, inUsePresetIndex);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRepeatedMessage(FieldNames.charGemPresets, charGemPresets);
      }
      output.endObject();
    }

    @Override
    public CharGemPresets mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 1036581329: {
            if (input.isAtField(FieldNames.inUsePresetIndex)) {
              if (!input.trySkipNullValue()) {
                inUsePresetIndex = input.readUInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 82576187: {
            if (input.isAtField(FieldNames.charGemPresets)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedMessage(charGemPresets);
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public CharGemPresets clone() {
      return new CharGemPresets().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static CharGemPresets parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new CharGemPresets(), data).checkInitialized();
    }

    public static CharGemPresets parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new CharGemPresets(), input).checkInitialized();
    }

    public static CharGemPresets parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new CharGemPresets(), input).checkInitialized();
    }

    /**
     * @return factory for creating CharGemPresets messages
     */
    public static MessageFactory<CharGemPresets> getFactory() {
      return CharGemPresetsFactory.INSTANCE;
    }

    private enum CharGemPresetsFactory implements MessageFactory<CharGemPresets> {
      INSTANCE;

      @Override
      public CharGemPresets create() {
        return CharGemPresets.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName inUsePresetIndex = FieldName.forField("InUsePresetIndex");

      static final FieldName nextPackage = FieldName.forField("NextPackage");

      static final FieldName charGemPresets = FieldName.forField("CharGemPresets");
    }
  }

  /**
   * Protobuf type {@code CharGem}
   */
  public static final class CharGem extends ProtoMessage<CharGem> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional bool Lock = 1;</code>
     */
    private boolean lock;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    /**
     * <code>repeated uint32 Attributes = 2;</code>
     */
    private final RepeatedInt attributes = RepeatedInt.newEmptyInstance();

    /**
     * <code>repeated uint32 AlterAttributes = 3;</code>
     */
    private final RepeatedInt alterAttributes = RepeatedInt.newEmptyInstance();

    private CharGem() {
    }

    /**
     * @return a new empty instance of {@code CharGem}
     */
    public static CharGem newInstance() {
      return new CharGem();
    }

    /**
     * <code>optional bool Lock = 1;</code>
     * @return whether the lock field is set
     */
    public boolean hasLock() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional bool Lock = 1;</code>
     * @return this
     */
    public CharGem clearLock() {
      bitField0_ &= ~0x00000001;
      lock = false;
      return this;
    }

    /**
     * <code>optional bool Lock = 1;</code>
     * @return the lock
     */
    public boolean getLock() {
      return lock;
    }

    /**
     * <code>optional bool Lock = 1;</code>
     * @param value the lock to set
     * @return this
     */
    public CharGem setLock(final boolean value) {
      bitField0_ |= 0x00000001;
      lock = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public CharGem clearNextPackage() {
      bitField0_ &= ~0x00000002;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000002;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public CharGem addNextPackage(final byte value) {
      bitField0_ |= 0x00000002;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public CharGem addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000002;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public CharGem setNextPackage(final byte... values) {
      bitField0_ |= 0x00000002;
      nextPackage.copyFrom(values);
      return this;
    }

    /**
     * <code>repeated uint32 Attributes = 2;</code>
     * @return whether the attributes field is set
     */
    public boolean hasAttributes() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>repeated uint32 Attributes = 2;</code>
     * @return this
     */
    public CharGem clearAttributes() {
      bitField0_ &= ~0x00000004;
      attributes.clear();
      return this;
    }

    /**
     * <code>repeated uint32 Attributes = 2;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableAttributes()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedInt getAttributes() {
      return attributes;
    }

    /**
     * <code>repeated uint32 Attributes = 2;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedInt getMutableAttributes() {
      bitField0_ |= 0x00000004;
      return attributes;
    }

    /**
     * <code>repeated uint32 Attributes = 2;</code>
     * @param value the attributes to add
     * @return this
     */
    public CharGem addAttributes(final int value) {
      bitField0_ |= 0x00000004;
      attributes.add(value);
      return this;
    }

    /**
     * <code>repeated uint32 Attributes = 2;</code>
     * @param values the attributes to add
     * @return this
     */
    public CharGem addAllAttributes(final int... values) {
      bitField0_ |= 0x00000004;
      attributes.addAll(values);
      return this;
    }

    /**
     * <code>repeated uint32 AlterAttributes = 3;</code>
     * @return whether the alterAttributes field is set
     */
    public boolean hasAlterAttributes() {
      return (bitField0_ & 0x00000008) != 0;
    }

    /**
     * <code>repeated uint32 AlterAttributes = 3;</code>
     * @return this
     */
    public CharGem clearAlterAttributes() {
      bitField0_ &= ~0x00000008;
      alterAttributes.clear();
      return this;
    }

    /**
     * <code>repeated uint32 AlterAttributes = 3;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableAlterAttributes()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedInt getAlterAttributes() {
      return alterAttributes;
    }

    /**
     * <code>repeated uint32 AlterAttributes = 3;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedInt getMutableAlterAttributes() {
      bitField0_ |= 0x00000008;
      return alterAttributes;
    }

    /**
     * <code>repeated uint32 AlterAttributes = 3;</code>
     * @param value the alterAttributes to add
     * @return this
     */
    public CharGem addAlterAttributes(final int value) {
      bitField0_ |= 0x00000008;
      alterAttributes.add(value);
      return this;
    }

    /**
     * <code>repeated uint32 AlterAttributes = 3;</code>
     * @param values the alterAttributes to add
     * @return this
     */
    public CharGem addAllAlterAttributes(final int... values) {
      bitField0_ |= 0x00000008;
      alterAttributes.addAll(values);
      return this;
    }

    @Override
    public CharGem copyFrom(final CharGem other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        lock = other.lock;
        nextPackage.copyFrom(other.nextPackage);
        attributes.copyFrom(other.attributes);
        alterAttributes.copyFrom(other.alterAttributes);
      }
      return this;
    }

    @Override
    public CharGem mergeFrom(final CharGem other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasLock()) {
        setLock(other.lock);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      if (other.hasAttributes()) {
        getMutableAttributes().addAll(other.attributes);
      }
      if (other.hasAlterAttributes()) {
        getMutableAlterAttributes().addAll(other.alterAttributes);
      }
      return this;
    }

    @Override
    public CharGem clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      lock = false;
      nextPackage.clear();
      attributes.clear();
      alterAttributes.clear();
      return this;
    }

    @Override
    public CharGem clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      attributes.clear();
      alterAttributes.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof CharGem)) {
        return false;
      }
      CharGem other = (CharGem) o;
      return bitField0_ == other.bitField0_
        && (!hasLock() || lock == other.lock)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage))
        && (!hasAttributes() || attributes.equals(other.attributes))
        && (!hasAlterAttributes() || alterAttributes.equals(other.alterAttributes));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 8);
        output.writeBoolNoTag(lock);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        for (int i = 0; i < attributes.length(); i++) {
          output.writeRawByte((byte) 16);
          output.writeUInt32NoTag(attributes.array()[i]);
        }
      }
      if ((bitField0_ & 0x00000008) != 0) {
        for (int i = 0; i < alterAttributes.length(); i++) {
          output.writeRawByte((byte) 24);
          output.writeUInt32NoTag(alterAttributes.array()[i]);
        }
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 2;
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += (1 * attributes.length()) + ProtoSink.computeRepeatedUInt32SizeNoTag(attributes);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        size += (1 * alterAttributes.length()) + ProtoSink.computeRepeatedUInt32SizeNoTag(alterAttributes);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public CharGem mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            // lock
            lock = input.readBool();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 18) {
              break;
            }
          }
          case 18: {
            // attributes [packed=true]
            input.readPackedUInt32(attributes, tag);
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 26) {
              break;
            }
          }
          case 26: {
            // alterAttributes [packed=true]
            input.readPackedUInt32(alterAttributes, tag);
            bitField0_ |= 0x00000008;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
          case 16: {
            // attributes [packed=false]
            tag = input.readRepeatedUInt32(attributes, tag);
            bitField0_ |= 0x00000004;
            break;
          }
          case 24: {
            // alterAttributes [packed=false]
            tag = input.readRepeatedUInt32(alterAttributes, tag);
            bitField0_ |= 0x00000008;
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeBool(FieldNames.lock, lock);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRepeatedUInt32(FieldNames.attributes, attributes);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeRepeatedUInt32(FieldNames.alterAttributes, alterAttributes);
      }
      output.endObject();
    }

    @Override
    public CharGem mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 2373963: {
            if (input.isAtField(FieldNames.lock)) {
              if (!input.trySkipNullValue()) {
                lock = input.readBool();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1895856777: {
            if (input.isAtField(FieldNames.attributes)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedUInt32(attributes);
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 328423917: {
            if (input.isAtField(FieldNames.alterAttributes)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedUInt32(alterAttributes);
                bitField0_ |= 0x00000008;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public CharGem clone() {
      return new CharGem().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static CharGem parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new CharGem(), data).checkInitialized();
    }

    public static CharGem parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new CharGem(), input).checkInitialized();
    }

    public static CharGem parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new CharGem(), input).checkInitialized();
    }

    /**
     * @return factory for creating CharGem messages
     */
    public static MessageFactory<CharGem> getFactory() {
      return CharGemFactory.INSTANCE;
    }

    private enum CharGemFactory implements MessageFactory<CharGem> {
      INSTANCE;

      @Override
      public CharGem create() {
        return CharGem.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName lock = FieldName.forField("Lock");

      static final FieldName nextPackage = FieldName.forField("NextPackage");

      static final FieldName attributes = FieldName.forField("Attributes");

      static final FieldName alterAttributes = FieldName.forField("AlterAttributes");
    }
  }

  /**
   * Protobuf type {@code CharGemSlot}
   */
  public static final class CharGemSlot extends ProtoMessage<CharGemSlot> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional uint32 Id = 1;</code>
     */
    private int id;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    /**
     * <code>repeated .CharGem AlterGems = 2;</code>
     */
    private final RepeatedMessage<CharGem> alterGems = RepeatedMessage.newEmptyInstance(CharGem.getFactory());

    private CharGemSlot() {
    }

    /**
     * @return a new empty instance of {@code CharGemSlot}
     */
    public static CharGemSlot newInstance() {
      return new CharGemSlot();
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @return whether the id field is set
     */
    public boolean hasId() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @return this
     */
    public CharGemSlot clearId() {
      bitField0_ &= ~0x00000001;
      id = 0;
      return this;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @return the id
     */
    public int getId() {
      return id;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @param value the id to set
     * @return this
     */
    public CharGemSlot setId(final int value) {
      bitField0_ |= 0x00000001;
      id = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public CharGemSlot clearNextPackage() {
      bitField0_ &= ~0x00000002;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000002;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public CharGemSlot addNextPackage(final byte value) {
      bitField0_ |= 0x00000002;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public CharGemSlot addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000002;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public CharGemSlot setNextPackage(final byte... values) {
      bitField0_ |= 0x00000002;
      nextPackage.copyFrom(values);
      return this;
    }

    /**
     * <code>repeated .CharGem AlterGems = 2;</code>
     * @return whether the alterGems field is set
     */
    public boolean hasAlterGems() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>repeated .CharGem AlterGems = 2;</code>
     * @return this
     */
    public CharGemSlot clearAlterGems() {
      bitField0_ &= ~0x00000004;
      alterGems.clear();
      return this;
    }

    /**
     * <code>repeated .CharGem AlterGems = 2;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableAlterGems()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<CharGem> getAlterGems() {
      return alterGems;
    }

    /**
     * <code>repeated .CharGem AlterGems = 2;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<CharGem> getMutableAlterGems() {
      bitField0_ |= 0x00000004;
      return alterGems;
    }

    /**
     * <code>repeated .CharGem AlterGems = 2;</code>
     * @param value the alterGems to add
     * @return this
     */
    public CharGemSlot addAlterGems(final CharGem value) {
      bitField0_ |= 0x00000004;
      alterGems.add(value);
      return this;
    }

    /**
     * <code>repeated .CharGem AlterGems = 2;</code>
     * @param values the alterGems to add
     * @return this
     */
    public CharGemSlot addAllAlterGems(final CharGem... values) {
      bitField0_ |= 0x00000004;
      alterGems.addAll(values);
      return this;
    }

    @Override
    public CharGemSlot copyFrom(final CharGemSlot other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        id = other.id;
        nextPackage.copyFrom(other.nextPackage);
        alterGems.copyFrom(other.alterGems);
      }
      return this;
    }

    @Override
    public CharGemSlot mergeFrom(final CharGemSlot other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasId()) {
        setId(other.id);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      if (other.hasAlterGems()) {
        getMutableAlterGems().addAll(other.alterGems);
      }
      return this;
    }

    @Override
    public CharGemSlot clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      id = 0;
      nextPackage.clear();
      alterGems.clear();
      return this;
    }

    @Override
    public CharGemSlot clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      alterGems.clearQuick();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof CharGemSlot)) {
        return false;
      }
      CharGemSlot other = (CharGemSlot) o;
      return bitField0_ == other.bitField0_
        && (!hasId() || id == other.id)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage))
        && (!hasAlterGems() || alterGems.equals(other.alterGems));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt32NoTag(id);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        for (int i = 0; i < alterGems.length(); i++) {
          output.writeRawByte((byte) 18);
          output.writeMessageNoTag(alterGems.get(i));
        }
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(id);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += (1 * alterGems.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(alterGems);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public CharGemSlot mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            // id
            id = input.readUInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 18) {
              break;
            }
          }
          case 18: {
            // alterGems
            tag = input.readRepeatedMessage(alterGems, tag);
            bitField0_ |= 0x00000004;
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeUInt32(FieldNames.id, id);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRepeatedMessage(FieldNames.alterGems, alterGems);
      }
      output.endObject();
    }

    @Override
    public CharGemSlot mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 2363: {
            if (input.isAtField(FieldNames.id)) {
              if (!input.trySkipNullValue()) {
                id = input.readUInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 594785306: {
            if (input.isAtField(FieldNames.alterGems)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedMessage(alterGems);
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public CharGemSlot clone() {
      return new CharGemSlot().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static CharGemSlot parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new CharGemSlot(), data).checkInitialized();
    }

    public static CharGemSlot parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new CharGemSlot(), input).checkInitialized();
    }

    public static CharGemSlot parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new CharGemSlot(), input).checkInitialized();
    }

    /**
     * @return factory for creating CharGemSlot messages
     */
    public static MessageFactory<CharGemSlot> getFactory() {
      return CharGemSlotFactory.INSTANCE;
    }

    private enum CharGemSlotFactory implements MessageFactory<CharGemSlot> {
      INSTANCE;

      @Override
      public CharGemSlot create() {
        return CharGemSlot.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName id = FieldName.forField("Id");

      static final FieldName nextPackage = FieldName.forField("NextPackage");

      static final FieldName alterGems = FieldName.forField("AlterGems");
    }
  }

  /**
   * Protobuf type {@code ActivityTask}
   */
  public static final class ActivityTask extends ProtoMessage<ActivityTask> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional .Quests ActivityTasks = 1;</code>
     */
    private final Quests activityTasks = Quests.newInstance();

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    /**
     * <code>repeated uint32 GroupIds = 2;</code>
     */
    private final RepeatedInt groupIds = RepeatedInt.newEmptyInstance();

    private ActivityTask() {
    }

    /**
     * @return a new empty instance of {@code ActivityTask}
     */
    public static ActivityTask newInstance() {
      return new ActivityTask();
    }

    /**
     * <code>optional .Quests ActivityTasks = 1;</code>
     * @return whether the activityTasks field is set
     */
    public boolean hasActivityTasks() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional .Quests ActivityTasks = 1;</code>
     * @return this
     */
    public ActivityTask clearActivityTasks() {
      bitField0_ &= ~0x00000001;
      activityTasks.clear();
      return this;
    }

    /**
     * <code>optional .Quests ActivityTasks = 1;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableActivityTasks()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public Quests getActivityTasks() {
      return activityTasks;
    }

    /**
     * <code>optional .Quests ActivityTasks = 1;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public Quests getMutableActivityTasks() {
      bitField0_ |= 0x00000001;
      return activityTasks;
    }

    /**
     * <code>optional .Quests ActivityTasks = 1;</code>
     * @param value the activityTasks to set
     * @return this
     */
    public ActivityTask setActivityTasks(final Quests value) {
      bitField0_ |= 0x00000001;
      activityTasks.copyFrom(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public ActivityTask clearNextPackage() {
      bitField0_ &= ~0x00000002;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000002;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public ActivityTask addNextPackage(final byte value) {
      bitField0_ |= 0x00000002;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public ActivityTask addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000002;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public ActivityTask setNextPackage(final byte... values) {
      bitField0_ |= 0x00000002;
      nextPackage.copyFrom(values);
      return this;
    }

    /**
     * <code>repeated uint32 GroupIds = 2;</code>
     * @return whether the groupIds field is set
     */
    public boolean hasGroupIds() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>repeated uint32 GroupIds = 2;</code>
     * @return this
     */
    public ActivityTask clearGroupIds() {
      bitField0_ &= ~0x00000004;
      groupIds.clear();
      return this;
    }

    /**
     * <code>repeated uint32 GroupIds = 2;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableGroupIds()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedInt getGroupIds() {
      return groupIds;
    }

    /**
     * <code>repeated uint32 GroupIds = 2;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedInt getMutableGroupIds() {
      bitField0_ |= 0x00000004;
      return groupIds;
    }

    /**
     * <code>repeated uint32 GroupIds = 2;</code>
     * @param value the groupIds to add
     * @return this
     */
    public ActivityTask addGroupIds(final int value) {
      bitField0_ |= 0x00000004;
      groupIds.add(value);
      return this;
    }

    /**
     * <code>repeated uint32 GroupIds = 2;</code>
     * @param values the groupIds to add
     * @return this
     */
    public ActivityTask addAllGroupIds(final int... values) {
      bitField0_ |= 0x00000004;
      groupIds.addAll(values);
      return this;
    }

    @Override
    public ActivityTask copyFrom(final ActivityTask other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        activityTasks.copyFrom(other.activityTasks);
        nextPackage.copyFrom(other.nextPackage);
        groupIds.copyFrom(other.groupIds);
      }
      return this;
    }

    @Override
    public ActivityTask mergeFrom(final ActivityTask other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasActivityTasks()) {
        getMutableActivityTasks().mergeFrom(other.activityTasks);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      if (other.hasGroupIds()) {
        getMutableGroupIds().addAll(other.groupIds);
      }
      return this;
    }

    @Override
    public ActivityTask clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      activityTasks.clear();
      nextPackage.clear();
      groupIds.clear();
      return this;
    }

    @Override
    public ActivityTask clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      activityTasks.clearQuick();
      nextPackage.clear();
      groupIds.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof ActivityTask)) {
        return false;
      }
      ActivityTask other = (ActivityTask) o;
      return bitField0_ == other.bitField0_
        && (!hasActivityTasks() || activityTasks.equals(other.activityTasks))
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage))
        && (!hasGroupIds() || groupIds.equals(other.groupIds));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 10);
        output.writeMessageNoTag(activityTasks);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        for (int i = 0; i < groupIds.length(); i++) {
          output.writeRawByte((byte) 16);
          output.writeUInt32NoTag(groupIds.array()[i]);
        }
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeMessageSizeNoTag(activityTasks);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += (1 * groupIds.length()) + ProtoSink.computeRepeatedUInt32SizeNoTag(groupIds);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public ActivityTask mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 10: {
            // activityTasks
            input.readMessage(activityTasks);
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 18) {
              break;
            }
          }
          case 18: {
            // groupIds [packed=true]
            input.readPackedUInt32(groupIds, tag);
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
          case 16: {
            // groupIds [packed=false]
            tag = input.readRepeatedUInt32(groupIds, tag);
            bitField0_ |= 0x00000004;
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeMessage(FieldNames.activityTasks, activityTasks);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRepeatedUInt32(FieldNames.groupIds, groupIds);
      }
      output.endObject();
    }

    @Override
    public ActivityTask mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case -247899745: {
            if (input.isAtField(FieldNames.activityTasks)) {
              if (!input.trySkipNullValue()) {
                input.readMessage(activityTasks);
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 570984409: {
            if (input.isAtField(FieldNames.groupIds)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedUInt32(groupIds);
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public ActivityTask clone() {
      return new ActivityTask().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static ActivityTask parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new ActivityTask(), data).checkInitialized();
    }

    public static ActivityTask parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new ActivityTask(), input).checkInitialized();
    }

    public static ActivityTask parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new ActivityTask(), input).checkInitialized();
    }

    /**
     * @return factory for creating ActivityTask messages
     */
    public static MessageFactory<ActivityTask> getFactory() {
      return ActivityTaskFactory.INSTANCE;
    }

    private enum ActivityTaskFactory implements MessageFactory<ActivityTask> {
      INSTANCE;

      @Override
      public ActivityTask create() {
        return ActivityTask.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName activityTasks = FieldName.forField("ActivityTasks");

      static final FieldName nextPackage = FieldName.forField("NextPackage");

      static final FieldName groupIds = FieldName.forField("GroupIds");
    }
  }

  /**
   * Protobuf type {@code ActivityShop}
   */
  public static final class ActivityShop extends ProtoMessage<ActivityShop> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    /**
     * <code>repeated .ResidentShop Shops = 1;</code>
     */
    private final RepeatedMessage<ResidentShop> shops = RepeatedMessage.newEmptyInstance(ResidentShop.getFactory());

    private ActivityShop() {
    }

    /**
     * @return a new empty instance of {@code ActivityShop}
     */
    public static ActivityShop newInstance() {
      return new ActivityShop();
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public ActivityShop clearNextPackage() {
      bitField0_ &= ~0x00000001;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000001;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public ActivityShop addNextPackage(final byte value) {
      bitField0_ |= 0x00000001;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public ActivityShop addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000001;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public ActivityShop setNextPackage(final byte... values) {
      bitField0_ |= 0x00000001;
      nextPackage.copyFrom(values);
      return this;
    }

    /**
     * <code>repeated .ResidentShop Shops = 1;</code>
     * @return whether the shops field is set
     */
    public boolean hasShops() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>repeated .ResidentShop Shops = 1;</code>
     * @return this
     */
    public ActivityShop clearShops() {
      bitField0_ &= ~0x00000002;
      shops.clear();
      return this;
    }

    /**
     * <code>repeated .ResidentShop Shops = 1;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableShops()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<ResidentShop> getShops() {
      return shops;
    }

    /**
     * <code>repeated .ResidentShop Shops = 1;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<ResidentShop> getMutableShops() {
      bitField0_ |= 0x00000002;
      return shops;
    }

    /**
     * <code>repeated .ResidentShop Shops = 1;</code>
     * @param value the shops to add
     * @return this
     */
    public ActivityShop addShops(final ResidentShop value) {
      bitField0_ |= 0x00000002;
      shops.add(value);
      return this;
    }

    /**
     * <code>repeated .ResidentShop Shops = 1;</code>
     * @param values the shops to add
     * @return this
     */
    public ActivityShop addAllShops(final ResidentShop... values) {
      bitField0_ |= 0x00000002;
      shops.addAll(values);
      return this;
    }

    @Override
    public ActivityShop copyFrom(final ActivityShop other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        nextPackage.copyFrom(other.nextPackage);
        shops.copyFrom(other.shops);
      }
      return this;
    }

    @Override
    public ActivityShop mergeFrom(final ActivityShop other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      if (other.hasShops()) {
        getMutableShops().addAll(other.shops);
      }
      return this;
    }

    @Override
    public ActivityShop clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      shops.clear();
      return this;
    }

    @Override
    public ActivityShop clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      shops.clearQuick();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof ActivityShop)) {
        return false;
      }
      ActivityShop other = (ActivityShop) o;
      return bitField0_ == other.bitField0_
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage))
        && (!hasShops() || shops.equals(other.shops));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        for (int i = 0; i < shops.length(); i++) {
          output.writeRawByte((byte) 10);
          output.writeMessageNoTag(shops.get(i));
        }
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += (1 * shops.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(shops);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public ActivityShop mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 10) {
              break;
            }
          }
          case 10: {
            // shops
            tag = input.readRepeatedMessage(shops, tag);
            bitField0_ |= 0x00000002;
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRepeatedMessage(FieldNames.shops, shops);
      }
      output.endObject();
    }

    @Override
    public ActivityShop mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 79860765: {
            if (input.isAtField(FieldNames.shops)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedMessage(shops);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public ActivityShop clone() {
      return new ActivityShop().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static ActivityShop parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new ActivityShop(), data).checkInitialized();
    }

    public static ActivityShop parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new ActivityShop(), input).checkInitialized();
    }

    public static ActivityShop parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new ActivityShop(), input).checkInitialized();
    }

    /**
     * @return factory for creating ActivityShop messages
     */
    public static MessageFactory<ActivityShop> getFactory() {
      return ActivityShopFactory.INSTANCE;
    }

    private enum ActivityShopFactory implements MessageFactory<ActivityShop> {
      INSTANCE;

      @Override
      public ActivityShop create() {
        return ActivityShop.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName nextPackage = FieldName.forField("NextPackage");

      static final FieldName shops = FieldName.forField("Shops");
    }
  }

  /**
   * Protobuf type {@code TutorialLevel}
   */
  public static final class TutorialLevel extends ProtoMessage<TutorialLevel> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional uint32 LevelId = 1;</code>
     */
    private int levelId;

    /**
     * <code>optional bool Passed = 2;</code>
     */
    private boolean passed;

    /**
     * <code>optional bool RewardReceived = 3;</code>
     */
    private boolean rewardReceived;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    private TutorialLevel() {
    }

    /**
     * @return a new empty instance of {@code TutorialLevel}
     */
    public static TutorialLevel newInstance() {
      return new TutorialLevel();
    }

    /**
     * <code>optional uint32 LevelId = 1;</code>
     * @return whether the levelId field is set
     */
    public boolean hasLevelId() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional uint32 LevelId = 1;</code>
     * @return this
     */
    public TutorialLevel clearLevelId() {
      bitField0_ &= ~0x00000001;
      levelId = 0;
      return this;
    }

    /**
     * <code>optional uint32 LevelId = 1;</code>
     * @return the levelId
     */
    public int getLevelId() {
      return levelId;
    }

    /**
     * <code>optional uint32 LevelId = 1;</code>
     * @param value the levelId to set
     * @return this
     */
    public TutorialLevel setLevelId(final int value) {
      bitField0_ |= 0x00000001;
      levelId = value;
      return this;
    }

    /**
     * <code>optional bool Passed = 2;</code>
     * @return whether the passed field is set
     */
    public boolean hasPassed() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional bool Passed = 2;</code>
     * @return this
     */
    public TutorialLevel clearPassed() {
      bitField0_ &= ~0x00000002;
      passed = false;
      return this;
    }

    /**
     * <code>optional bool Passed = 2;</code>
     * @return the passed
     */
    public boolean getPassed() {
      return passed;
    }

    /**
     * <code>optional bool Passed = 2;</code>
     * @param value the passed to set
     * @return this
     */
    public TutorialLevel setPassed(final boolean value) {
      bitField0_ |= 0x00000002;
      passed = value;
      return this;
    }

    /**
     * <code>optional bool RewardReceived = 3;</code>
     * @return whether the rewardReceived field is set
     */
    public boolean hasRewardReceived() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional bool RewardReceived = 3;</code>
     * @return this
     */
    public TutorialLevel clearRewardReceived() {
      bitField0_ &= ~0x00000004;
      rewardReceived = false;
      return this;
    }

    /**
     * <code>optional bool RewardReceived = 3;</code>
     * @return the rewardReceived
     */
    public boolean getRewardReceived() {
      return rewardReceived;
    }

    /**
     * <code>optional bool RewardReceived = 3;</code>
     * @param value the rewardReceived to set
     * @return this
     */
    public TutorialLevel setRewardReceived(final boolean value) {
      bitField0_ |= 0x00000004;
      rewardReceived = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000008) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public TutorialLevel clearNextPackage() {
      bitField0_ &= ~0x00000008;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000008;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public TutorialLevel addNextPackage(final byte value) {
      bitField0_ |= 0x00000008;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public TutorialLevel addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000008;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public TutorialLevel setNextPackage(final byte... values) {
      bitField0_ |= 0x00000008;
      nextPackage.copyFrom(values);
      return this;
    }

    @Override
    public TutorialLevel copyFrom(final TutorialLevel other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        levelId = other.levelId;
        passed = other.passed;
        rewardReceived = other.rewardReceived;
        nextPackage.copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public TutorialLevel mergeFrom(final TutorialLevel other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasLevelId()) {
        setLevelId(other.levelId);
      }
      if (other.hasPassed()) {
        setPassed(other.passed);
      }
      if (other.hasRewardReceived()) {
        setRewardReceived(other.rewardReceived);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public TutorialLevel clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      levelId = 0;
      passed = false;
      rewardReceived = false;
      nextPackage.clear();
      return this;
    }

    @Override
    public TutorialLevel clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof TutorialLevel)) {
        return false;
      }
      TutorialLevel other = (TutorialLevel) o;
      return bitField0_ == other.bitField0_
        && (!hasLevelId() || levelId == other.levelId)
        && (!hasPassed() || passed == other.passed)
        && (!hasRewardReceived() || rewardReceived == other.rewardReceived)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt32NoTag(levelId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 16);
        output.writeBoolNoTag(passed);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawByte((byte) 24);
        output.writeBoolNoTag(rewardReceived);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(levelId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 2;
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 2;
      }
      if ((bitField0_ & 0x00000008) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public TutorialLevel mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            // levelId
            levelId = input.readUInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 16) {
              break;
            }
          }
          case 16: {
            // passed
            passed = input.readBool();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 24) {
              break;
            }
          }
          case 24: {
            // rewardReceived
            rewardReceived = input.readBool();
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000008;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeUInt32(FieldNames.levelId, levelId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeBool(FieldNames.passed, passed);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeBool(FieldNames.rewardReceived, rewardReceived);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      output.endObject();
    }

    @Override
    public TutorialLevel mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 1734437791: {
            if (input.isAtField(FieldNames.levelId)) {
              if (!input.trySkipNullValue()) {
                levelId = input.readUInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1911513968: {
            if (input.isAtField(FieldNames.passed)) {
              if (!input.trySkipNullValue()) {
                passed = input.readBool();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -133313968: {
            if (input.isAtField(FieldNames.rewardReceived)) {
              if (!input.trySkipNullValue()) {
                rewardReceived = input.readBool();
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000008;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public TutorialLevel clone() {
      return new TutorialLevel().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static TutorialLevel parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new TutorialLevel(), data).checkInitialized();
    }

    public static TutorialLevel parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new TutorialLevel(), input).checkInitialized();
    }

    public static TutorialLevel parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new TutorialLevel(), input).checkInitialized();
    }

    /**
     * @return factory for creating TutorialLevel messages
     */
    public static MessageFactory<TutorialLevel> getFactory() {
      return TutorialLevelFactory.INSTANCE;
    }

    private enum TutorialLevelFactory implements MessageFactory<TutorialLevel> {
      INSTANCE;

      @Override
      public TutorialLevel create() {
        return TutorialLevel.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName levelId = FieldName.forField("LevelId");

      static final FieldName passed = FieldName.forField("Passed");

      static final FieldName rewardReceived = FieldName.forField("RewardReceived");

      static final FieldName nextPackage = FieldName.forField("NextPackage");
    }
  }

  /**
   * Protobuf type {@code BuildConvertContent}
   */
  public static final class BuildConvertContent extends ProtoMessage<BuildConvertContent> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional uint32 Id = 1;</code>
     */
    private int id;

    /**
     * <code>optional uint32 Num = 2;</code>
     */
    private int num;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    private BuildConvertContent() {
    }

    /**
     * @return a new empty instance of {@code BuildConvertContent}
     */
    public static BuildConvertContent newInstance() {
      return new BuildConvertContent();
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @return whether the id field is set
     */
    public boolean hasId() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @return this
     */
    public BuildConvertContent clearId() {
      bitField0_ &= ~0x00000001;
      id = 0;
      return this;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @return the id
     */
    public int getId() {
      return id;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @param value the id to set
     * @return this
     */
    public BuildConvertContent setId(final int value) {
      bitField0_ |= 0x00000001;
      id = value;
      return this;
    }

    /**
     * <code>optional uint32 Num = 2;</code>
     * @return whether the num field is set
     */
    public boolean hasNum() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional uint32 Num = 2;</code>
     * @return this
     */
    public BuildConvertContent clearNum() {
      bitField0_ &= ~0x00000002;
      num = 0;
      return this;
    }

    /**
     * <code>optional uint32 Num = 2;</code>
     * @return the num
     */
    public int getNum() {
      return num;
    }

    /**
     * <code>optional uint32 Num = 2;</code>
     * @param value the num to set
     * @return this
     */
    public BuildConvertContent setNum(final int value) {
      bitField0_ |= 0x00000002;
      num = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public BuildConvertContent clearNextPackage() {
      bitField0_ &= ~0x00000004;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000004;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public BuildConvertContent addNextPackage(final byte value) {
      bitField0_ |= 0x00000004;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public BuildConvertContent addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000004;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public BuildConvertContent setNextPackage(final byte... values) {
      bitField0_ |= 0x00000004;
      nextPackage.copyFrom(values);
      return this;
    }

    @Override
    public BuildConvertContent copyFrom(final BuildConvertContent other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        id = other.id;
        num = other.num;
        nextPackage.copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public BuildConvertContent mergeFrom(final BuildConvertContent other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasId()) {
        setId(other.id);
      }
      if (other.hasNum()) {
        setNum(other.num);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public BuildConvertContent clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      id = 0;
      num = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public BuildConvertContent clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof BuildConvertContent)) {
        return false;
      }
      BuildConvertContent other = (BuildConvertContent) o;
      return bitField0_ == other.bitField0_
        && (!hasId() || id == other.id)
        && (!hasNum() || num == other.num)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt32NoTag(id);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 16);
        output.writeUInt32NoTag(num);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(id);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(num);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public BuildConvertContent mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            // id
            id = input.readUInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 16) {
              break;
            }
          }
          case 16: {
            // num
            num = input.readUInt32();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeUInt32(FieldNames.id, id);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeUInt32(FieldNames.num, num);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      output.endObject();
    }

    @Override
    public BuildConvertContent mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 2363: {
            if (input.isAtField(FieldNames.id)) {
              if (!input.trySkipNullValue()) {
                id = input.readUInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 78694: {
            if (input.isAtField(FieldNames.num)) {
              if (!input.trySkipNullValue()) {
                num = input.readUInt32();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public BuildConvertContent clone() {
      return new BuildConvertContent().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static BuildConvertContent parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new BuildConvertContent(), data).checkInitialized();
    }

    public static BuildConvertContent parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new BuildConvertContent(), input).checkInitialized();
    }

    public static BuildConvertContent parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new BuildConvertContent(), input).checkInitialized();
    }

    /**
     * @return factory for creating BuildConvertContent messages
     */
    public static MessageFactory<BuildConvertContent> getFactory() {
      return BuildConvertContentFactory.INSTANCE;
    }

    private enum BuildConvertContentFactory implements MessageFactory<BuildConvertContent> {
      INSTANCE;

      @Override
      public BuildConvertContent create() {
        return BuildConvertContent.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName id = FieldName.forField("Id");

      static final FieldName num = FieldName.forField("Num");

      static final FieldName nextPackage = FieldName.forField("NextPackage");
    }
  }

  /**
   * Protobuf type {@code ActivityBuildConvert}
   */
  public static final class ActivityBuildConvert extends ProtoMessage<ActivityBuildConvert> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    /**
     * <code>repeated .BuildConvertContent Contents = 1;</code>
     */
    private final RepeatedMessage<BuildConvertContent> contents = RepeatedMessage.newEmptyInstance(BuildConvertContent.getFactory());

    /**
     * <code>repeated .ActivityQuest Quests = 2;</code>
     */
    private final RepeatedMessage<ActivityQuest> quests = RepeatedMessage.newEmptyInstance(ActivityQuest.getFactory());

    private ActivityBuildConvert() {
    }

    /**
     * @return a new empty instance of {@code ActivityBuildConvert}
     */
    public static ActivityBuildConvert newInstance() {
      return new ActivityBuildConvert();
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public ActivityBuildConvert clearNextPackage() {
      bitField0_ &= ~0x00000001;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000001;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public ActivityBuildConvert addNextPackage(final byte value) {
      bitField0_ |= 0x00000001;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public ActivityBuildConvert addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000001;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public ActivityBuildConvert setNextPackage(final byte... values) {
      bitField0_ |= 0x00000001;
      nextPackage.copyFrom(values);
      return this;
    }

    /**
     * <code>repeated .BuildConvertContent Contents = 1;</code>
     * @return whether the contents field is set
     */
    public boolean hasContents() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>repeated .BuildConvertContent Contents = 1;</code>
     * @return this
     */
    public ActivityBuildConvert clearContents() {
      bitField0_ &= ~0x00000002;
      contents.clear();
      return this;
    }

    /**
     * <code>repeated .BuildConvertContent Contents = 1;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableContents()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<BuildConvertContent> getContents() {
      return contents;
    }

    /**
     * <code>repeated .BuildConvertContent Contents = 1;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<BuildConvertContent> getMutableContents() {
      bitField0_ |= 0x00000002;
      return contents;
    }

    /**
     * <code>repeated .BuildConvertContent Contents = 1;</code>
     * @param value the contents to add
     * @return this
     */
    public ActivityBuildConvert addContents(final BuildConvertContent value) {
      bitField0_ |= 0x00000002;
      contents.add(value);
      return this;
    }

    /**
     * <code>repeated .BuildConvertContent Contents = 1;</code>
     * @param values the contents to add
     * @return this
     */
    public ActivityBuildConvert addAllContents(final BuildConvertContent... values) {
      bitField0_ |= 0x00000002;
      contents.addAll(values);
      return this;
    }

    /**
     * <code>repeated .ActivityQuest Quests = 2;</code>
     * @return whether the quests field is set
     */
    public boolean hasQuests() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>repeated .ActivityQuest Quests = 2;</code>
     * @return this
     */
    public ActivityBuildConvert clearQuests() {
      bitField0_ &= ~0x00000004;
      quests.clear();
      return this;
    }

    /**
     * <code>repeated .ActivityQuest Quests = 2;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableQuests()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<ActivityQuest> getQuests() {
      return quests;
    }

    /**
     * <code>repeated .ActivityQuest Quests = 2;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<ActivityQuest> getMutableQuests() {
      bitField0_ |= 0x00000004;
      return quests;
    }

    /**
     * <code>repeated .ActivityQuest Quests = 2;</code>
     * @param value the quests to add
     * @return this
     */
    public ActivityBuildConvert addQuests(final ActivityQuest value) {
      bitField0_ |= 0x00000004;
      quests.add(value);
      return this;
    }

    /**
     * <code>repeated .ActivityQuest Quests = 2;</code>
     * @param values the quests to add
     * @return this
     */
    public ActivityBuildConvert addAllQuests(final ActivityQuest... values) {
      bitField0_ |= 0x00000004;
      quests.addAll(values);
      return this;
    }

    @Override
    public ActivityBuildConvert copyFrom(final ActivityBuildConvert other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        nextPackage.copyFrom(other.nextPackage);
        contents.copyFrom(other.contents);
        quests.copyFrom(other.quests);
      }
      return this;
    }

    @Override
    public ActivityBuildConvert mergeFrom(final ActivityBuildConvert other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      if (other.hasContents()) {
        getMutableContents().addAll(other.contents);
      }
      if (other.hasQuests()) {
        getMutableQuests().addAll(other.quests);
      }
      return this;
    }

    @Override
    public ActivityBuildConvert clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      contents.clear();
      quests.clear();
      return this;
    }

    @Override
    public ActivityBuildConvert clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      contents.clearQuick();
      quests.clearQuick();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof ActivityBuildConvert)) {
        return false;
      }
      ActivityBuildConvert other = (ActivityBuildConvert) o;
      return bitField0_ == other.bitField0_
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage))
        && (!hasContents() || contents.equals(other.contents))
        && (!hasQuests() || quests.equals(other.quests));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        for (int i = 0; i < contents.length(); i++) {
          output.writeRawByte((byte) 10);
          output.writeMessageNoTag(contents.get(i));
        }
      }
      if ((bitField0_ & 0x00000004) != 0) {
        for (int i = 0; i < quests.length(); i++) {
          output.writeRawByte((byte) 18);
          output.writeMessageNoTag(quests.get(i));
        }
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += (1 * contents.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(contents);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += (1 * quests.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(quests);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public ActivityBuildConvert mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 10) {
              break;
            }
          }
          case 10: {
            // contents
            tag = input.readRepeatedMessage(contents, tag);
            bitField0_ |= 0x00000002;
            if (tag != 18) {
              break;
            }
          }
          case 18: {
            // quests
            tag = input.readRepeatedMessage(quests, tag);
            bitField0_ |= 0x00000004;
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRepeatedMessage(FieldNames.contents, contents);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRepeatedMessage(FieldNames.quests, quests);
      }
      output.endObject();
    }

    @Override
    public ActivityBuildConvert mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -502677702: {
            if (input.isAtField(FieldNames.contents)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedMessage(contents);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1864830991: {
            if (input.isAtField(FieldNames.quests)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedMessage(quests);
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public ActivityBuildConvert clone() {
      return new ActivityBuildConvert().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static ActivityBuildConvert parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new ActivityBuildConvert(), data).checkInitialized();
    }

    public static ActivityBuildConvert parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new ActivityBuildConvert(), input).checkInitialized();
    }

    public static ActivityBuildConvert parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new ActivityBuildConvert(), input).checkInitialized();
    }

    /**
     * @return factory for creating ActivityBuildConvert messages
     */
    public static MessageFactory<ActivityBuildConvert> getFactory() {
      return ActivityBuildConvertFactory.INSTANCE;
    }

    private enum ActivityBuildConvertFactory implements MessageFactory<ActivityBuildConvert> {
      INSTANCE;

      @Override
      public ActivityBuildConvert create() {
        return ActivityBuildConvert.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName nextPackage = FieldName.forField("NextPackage");

      static final FieldName contents = FieldName.forField("Contents");

      static final FieldName quests = FieldName.forField("Quests");
    }
  }

  /**
   * Protobuf type {@code VampireClientData}
   */
  public static final class VampireClientData extends ProtoMessage<VampireClientData> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional uint32 FateCardTimer = 3;</code>
     */
    private int fateCardTimer;

    /**
     * <code>optional uint32 Level = 4;</code>
     */
    private int level;

    /**
     * <code>optional uint32 Exp = 5;</code>
     */
    private int exp;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    /**
     * <code>repeated .FateCardEftCnt Efts = 1;</code>
     */
    private final RepeatedMessage<FateCardEftCnt> efts = RepeatedMessage.newEmptyInstance(FateCardEftCnt.getFactory());

    /**
     * <code>repeated .FateCardTimeLimit Limits = 2;</code>
     */
    private final RepeatedMessage<FateCardTimeLimit> limits = RepeatedMessage.newEmptyInstance(FateCardTimeLimit.getFactory());

    private VampireClientData() {
    }

    /**
     * @return a new empty instance of {@code VampireClientData}
     */
    public static VampireClientData newInstance() {
      return new VampireClientData();
    }

    /**
     * <code>optional uint32 FateCardTimer = 3;</code>
     * @return whether the fateCardTimer field is set
     */
    public boolean hasFateCardTimer() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional uint32 FateCardTimer = 3;</code>
     * @return this
     */
    public VampireClientData clearFateCardTimer() {
      bitField0_ &= ~0x00000001;
      fateCardTimer = 0;
      return this;
    }

    /**
     * <code>optional uint32 FateCardTimer = 3;</code>
     * @return the fateCardTimer
     */
    public int getFateCardTimer() {
      return fateCardTimer;
    }

    /**
     * <code>optional uint32 FateCardTimer = 3;</code>
     * @param value the fateCardTimer to set
     * @return this
     */
    public VampireClientData setFateCardTimer(final int value) {
      bitField0_ |= 0x00000001;
      fateCardTimer = value;
      return this;
    }

    /**
     * <code>optional uint32 Level = 4;</code>
     * @return whether the level field is set
     */
    public boolean hasLevel() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional uint32 Level = 4;</code>
     * @return this
     */
    public VampireClientData clearLevel() {
      bitField0_ &= ~0x00000002;
      level = 0;
      return this;
    }

    /**
     * <code>optional uint32 Level = 4;</code>
     * @return the level
     */
    public int getLevel() {
      return level;
    }

    /**
     * <code>optional uint32 Level = 4;</code>
     * @param value the level to set
     * @return this
     */
    public VampireClientData setLevel(final int value) {
      bitField0_ |= 0x00000002;
      level = value;
      return this;
    }

    /**
     * <code>optional uint32 Exp = 5;</code>
     * @return whether the exp field is set
     */
    public boolean hasExp() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional uint32 Exp = 5;</code>
     * @return this
     */
    public VampireClientData clearExp() {
      bitField0_ &= ~0x00000004;
      exp = 0;
      return this;
    }

    /**
     * <code>optional uint32 Exp = 5;</code>
     * @return the exp
     */
    public int getExp() {
      return exp;
    }

    /**
     * <code>optional uint32 Exp = 5;</code>
     * @param value the exp to set
     * @return this
     */
    public VampireClientData setExp(final int value) {
      bitField0_ |= 0x00000004;
      exp = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000008) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public VampireClientData clearNextPackage() {
      bitField0_ &= ~0x00000008;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000008;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public VampireClientData addNextPackage(final byte value) {
      bitField0_ |= 0x00000008;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public VampireClientData addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000008;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public VampireClientData setNextPackage(final byte... values) {
      bitField0_ |= 0x00000008;
      nextPackage.copyFrom(values);
      return this;
    }

    /**
     * <code>repeated .FateCardEftCnt Efts = 1;</code>
     * @return whether the efts field is set
     */
    public boolean hasEfts() {
      return (bitField0_ & 0x00000010) != 0;
    }

    /**
     * <code>repeated .FateCardEftCnt Efts = 1;</code>
     * @return this
     */
    public VampireClientData clearEfts() {
      bitField0_ &= ~0x00000010;
      efts.clear();
      return this;
    }

    /**
     * <code>repeated .FateCardEftCnt Efts = 1;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableEfts()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<FateCardEftCnt> getEfts() {
      return efts;
    }

    /**
     * <code>repeated .FateCardEftCnt Efts = 1;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<FateCardEftCnt> getMutableEfts() {
      bitField0_ |= 0x00000010;
      return efts;
    }

    /**
     * <code>repeated .FateCardEftCnt Efts = 1;</code>
     * @param value the efts to add
     * @return this
     */
    public VampireClientData addEfts(final FateCardEftCnt value) {
      bitField0_ |= 0x00000010;
      efts.add(value);
      return this;
    }

    /**
     * <code>repeated .FateCardEftCnt Efts = 1;</code>
     * @param values the efts to add
     * @return this
     */
    public VampireClientData addAllEfts(final FateCardEftCnt... values) {
      bitField0_ |= 0x00000010;
      efts.addAll(values);
      return this;
    }

    /**
     * <code>repeated .FateCardTimeLimit Limits = 2;</code>
     * @return whether the limits field is set
     */
    public boolean hasLimits() {
      return (bitField0_ & 0x00000020) != 0;
    }

    /**
     * <code>repeated .FateCardTimeLimit Limits = 2;</code>
     * @return this
     */
    public VampireClientData clearLimits() {
      bitField0_ &= ~0x00000020;
      limits.clear();
      return this;
    }

    /**
     * <code>repeated .FateCardTimeLimit Limits = 2;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableLimits()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<FateCardTimeLimit> getLimits() {
      return limits;
    }

    /**
     * <code>repeated .FateCardTimeLimit Limits = 2;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<FateCardTimeLimit> getMutableLimits() {
      bitField0_ |= 0x00000020;
      return limits;
    }

    /**
     * <code>repeated .FateCardTimeLimit Limits = 2;</code>
     * @param value the limits to add
     * @return this
     */
    public VampireClientData addLimits(final FateCardTimeLimit value) {
      bitField0_ |= 0x00000020;
      limits.add(value);
      return this;
    }

    /**
     * <code>repeated .FateCardTimeLimit Limits = 2;</code>
     * @param values the limits to add
     * @return this
     */
    public VampireClientData addAllLimits(final FateCardTimeLimit... values) {
      bitField0_ |= 0x00000020;
      limits.addAll(values);
      return this;
    }

    @Override
    public VampireClientData copyFrom(final VampireClientData other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        fateCardTimer = other.fateCardTimer;
        level = other.level;
        exp = other.exp;
        nextPackage.copyFrom(other.nextPackage);
        efts.copyFrom(other.efts);
        limits.copyFrom(other.limits);
      }
      return this;
    }

    @Override
    public VampireClientData mergeFrom(final VampireClientData other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasFateCardTimer()) {
        setFateCardTimer(other.fateCardTimer);
      }
      if (other.hasLevel()) {
        setLevel(other.level);
      }
      if (other.hasExp()) {
        setExp(other.exp);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      if (other.hasEfts()) {
        getMutableEfts().addAll(other.efts);
      }
      if (other.hasLimits()) {
        getMutableLimits().addAll(other.limits);
      }
      return this;
    }

    @Override
    public VampireClientData clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      fateCardTimer = 0;
      level = 0;
      exp = 0;
      nextPackage.clear();
      efts.clear();
      limits.clear();
      return this;
    }

    @Override
    public VampireClientData clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      efts.clearQuick();
      limits.clearQuick();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof VampireClientData)) {
        return false;
      }
      VampireClientData other = (VampireClientData) o;
      return bitField0_ == other.bitField0_
        && (!hasFateCardTimer() || fateCardTimer == other.fateCardTimer)
        && (!hasLevel() || level == other.level)
        && (!hasExp() || exp == other.exp)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage))
        && (!hasEfts() || efts.equals(other.efts))
        && (!hasLimits() || limits.equals(other.limits));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 24);
        output.writeUInt32NoTag(fateCardTimer);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 32);
        output.writeUInt32NoTag(level);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawByte((byte) 40);
        output.writeUInt32NoTag(exp);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        for (int i = 0; i < efts.length(); i++) {
          output.writeRawByte((byte) 10);
          output.writeMessageNoTag(efts.get(i));
        }
      }
      if ((bitField0_ & 0x00000020) != 0) {
        for (int i = 0; i < limits.length(); i++) {
          output.writeRawByte((byte) 18);
          output.writeMessageNoTag(limits.get(i));
        }
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(fateCardTimer);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(level);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(exp);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        size += (1 * efts.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(efts);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        size += (1 * limits.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(limits);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public VampireClientData mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 24: {
            // fateCardTimer
            fateCardTimer = input.readUInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 32) {
              break;
            }
          }
          case 32: {
            // level
            level = input.readUInt32();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 40) {
              break;
            }
          }
          case 40: {
            // exp
            exp = input.readUInt32();
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000008;
            tag = input.readTag();
            if (tag != 10) {
              break;
            }
          }
          case 10: {
            // efts
            tag = input.readRepeatedMessage(efts, tag);
            bitField0_ |= 0x00000010;
            if (tag != 18) {
              break;
            }
          }
          case 18: {
            // limits
            tag = input.readRepeatedMessage(limits, tag);
            bitField0_ |= 0x00000020;
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeUInt32(FieldNames.fateCardTimer, fateCardTimer);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeUInt32(FieldNames.level, level);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeUInt32(FieldNames.exp, exp);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        output.writeRepeatedMessage(FieldNames.efts, efts);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        output.writeRepeatedMessage(FieldNames.limits, limits);
      }
      output.endObject();
    }

    @Override
    public VampireClientData mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 1660237545: {
            if (input.isAtField(FieldNames.fateCardTimer)) {
              if (!input.trySkipNullValue()) {
                fateCardTimer = input.readUInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 73313124: {
            if (input.isAtField(FieldNames.level)) {
              if (!input.trySkipNullValue()) {
                level = input.readUInt32();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 70141: {
            if (input.isAtField(FieldNames.exp)) {
              if (!input.trySkipNullValue()) {
                exp = input.readUInt32();
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000008;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 2157312: {
            if (input.isAtField(FieldNames.efts)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedMessage(efts);
                bitField0_ |= 0x00000010;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2018830280: {
            if (input.isAtField(FieldNames.limits)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedMessage(limits);
                bitField0_ |= 0x00000020;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public VampireClientData clone() {
      return new VampireClientData().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static VampireClientData parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new VampireClientData(), data).checkInitialized();
    }

    public static VampireClientData parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new VampireClientData(), input).checkInitialized();
    }

    public static VampireClientData parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new VampireClientData(), input).checkInitialized();
    }

    /**
     * @return factory for creating VampireClientData messages
     */
    public static MessageFactory<VampireClientData> getFactory() {
      return VampireClientDataFactory.INSTANCE;
    }

    private enum VampireClientDataFactory implements MessageFactory<VampireClientData> {
      INSTANCE;

      @Override
      public VampireClientData create() {
        return VampireClientData.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName fateCardTimer = FieldName.forField("FateCardTimer");

      static final FieldName level = FieldName.forField("Level");

      static final FieldName exp = FieldName.forField("Exp");

      static final FieldName nextPackage = FieldName.forField("NextPackage");

      static final FieldName efts = FieldName.forField("Efts");

      static final FieldName limits = FieldName.forField("Limits");
    }
  }

  /**
   * Protobuf type {@code FateCardEftCnt}
   */
  public static final class FateCardEftCnt extends ProtoMessage<FateCardEftCnt> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional uint32 Id = 1;</code>
     */
    private int id;

    /**
     * <code>optional uint32 EftId = 2;</code>
     */
    private int eftId;

    /**
     * <code>optional uint32 Count = 3;</code>
     */
    private int count;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    private FateCardEftCnt() {
    }

    /**
     * @return a new empty instance of {@code FateCardEftCnt}
     */
    public static FateCardEftCnt newInstance() {
      return new FateCardEftCnt();
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @return whether the id field is set
     */
    public boolean hasId() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @return this
     */
    public FateCardEftCnt clearId() {
      bitField0_ &= ~0x00000001;
      id = 0;
      return this;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @return the id
     */
    public int getId() {
      return id;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @param value the id to set
     * @return this
     */
    public FateCardEftCnt setId(final int value) {
      bitField0_ |= 0x00000001;
      id = value;
      return this;
    }

    /**
     * <code>optional uint32 EftId = 2;</code>
     * @return whether the eftId field is set
     */
    public boolean hasEftId() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional uint32 EftId = 2;</code>
     * @return this
     */
    public FateCardEftCnt clearEftId() {
      bitField0_ &= ~0x00000002;
      eftId = 0;
      return this;
    }

    /**
     * <code>optional uint32 EftId = 2;</code>
     * @return the eftId
     */
    public int getEftId() {
      return eftId;
    }

    /**
     * <code>optional uint32 EftId = 2;</code>
     * @param value the eftId to set
     * @return this
     */
    public FateCardEftCnt setEftId(final int value) {
      bitField0_ |= 0x00000002;
      eftId = value;
      return this;
    }

    /**
     * <code>optional uint32 Count = 3;</code>
     * @return whether the count field is set
     */
    public boolean hasCount() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional uint32 Count = 3;</code>
     * @return this
     */
    public FateCardEftCnt clearCount() {
      bitField0_ &= ~0x00000004;
      count = 0;
      return this;
    }

    /**
     * <code>optional uint32 Count = 3;</code>
     * @return the count
     */
    public int getCount() {
      return count;
    }

    /**
     * <code>optional uint32 Count = 3;</code>
     * @param value the count to set
     * @return this
     */
    public FateCardEftCnt setCount(final int value) {
      bitField0_ |= 0x00000004;
      count = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000008) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public FateCardEftCnt clearNextPackage() {
      bitField0_ &= ~0x00000008;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000008;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public FateCardEftCnt addNextPackage(final byte value) {
      bitField0_ |= 0x00000008;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public FateCardEftCnt addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000008;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public FateCardEftCnt setNextPackage(final byte... values) {
      bitField0_ |= 0x00000008;
      nextPackage.copyFrom(values);
      return this;
    }

    @Override
    public FateCardEftCnt copyFrom(final FateCardEftCnt other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        id = other.id;
        eftId = other.eftId;
        count = other.count;
        nextPackage.copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public FateCardEftCnt mergeFrom(final FateCardEftCnt other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasId()) {
        setId(other.id);
      }
      if (other.hasEftId()) {
        setEftId(other.eftId);
      }
      if (other.hasCount()) {
        setCount(other.count);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public FateCardEftCnt clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      id = 0;
      eftId = 0;
      count = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public FateCardEftCnt clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof FateCardEftCnt)) {
        return false;
      }
      FateCardEftCnt other = (FateCardEftCnt) o;
      return bitField0_ == other.bitField0_
        && (!hasId() || id == other.id)
        && (!hasEftId() || eftId == other.eftId)
        && (!hasCount() || count == other.count)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt32NoTag(id);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 16);
        output.writeUInt32NoTag(eftId);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawByte((byte) 24);
        output.writeUInt32NoTag(count);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(id);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(eftId);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(count);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public FateCardEftCnt mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            // id
            id = input.readUInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 16) {
              break;
            }
          }
          case 16: {
            // eftId
            eftId = input.readUInt32();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 24) {
              break;
            }
          }
          case 24: {
            // count
            count = input.readUInt32();
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000008;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeUInt32(FieldNames.id, id);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeUInt32(FieldNames.eftId, eftId);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeUInt32(FieldNames.count, count);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      output.endObject();
    }

    @Override
    public FateCardEftCnt mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 2363: {
            if (input.isAtField(FieldNames.id)) {
              if (!input.trySkipNullValue()) {
                id = input.readUInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 66875470: {
            if (input.isAtField(FieldNames.eftId)) {
              if (!input.trySkipNullValue()) {
                eftId = input.readUInt32();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 65298671: {
            if (input.isAtField(FieldNames.count)) {
              if (!input.trySkipNullValue()) {
                count = input.readUInt32();
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000008;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public FateCardEftCnt clone() {
      return new FateCardEftCnt().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static FateCardEftCnt parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new FateCardEftCnt(), data).checkInitialized();
    }

    public static FateCardEftCnt parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new FateCardEftCnt(), input).checkInitialized();
    }

    public static FateCardEftCnt parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new FateCardEftCnt(), input).checkInitialized();
    }

    /**
     * @return factory for creating FateCardEftCnt messages
     */
    public static MessageFactory<FateCardEftCnt> getFactory() {
      return FateCardEftCntFactory.INSTANCE;
    }

    private enum FateCardEftCntFactory implements MessageFactory<FateCardEftCnt> {
      INSTANCE;

      @Override
      public FateCardEftCnt create() {
        return FateCardEftCnt.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName id = FieldName.forField("Id");

      static final FieldName eftId = FieldName.forField("EftId");

      static final FieldName count = FieldName.forField("Count");

      static final FieldName nextPackage = FieldName.forField("NextPackage");
    }
  }

  /**
   * Protobuf type {@code FateCardTimeLimit}
   */
  public static final class FateCardTimeLimit extends ProtoMessage<FateCardTimeLimit> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional uint32 Id = 1;</code>
     */
    private int id;

    /**
     * <code>optional uint32 TimeLimit = 2;</code>
     */
    private int timeLimit;

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     */
    private final RepeatedByte nextPackage = RepeatedByte.newEmptyInstance();

    private FateCardTimeLimit() {
    }

    /**
     * @return a new empty instance of {@code FateCardTimeLimit}
     */
    public static FateCardTimeLimit newInstance() {
      return new FateCardTimeLimit();
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @return whether the id field is set
     */
    public boolean hasId() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @return this
     */
    public FateCardTimeLimit clearId() {
      bitField0_ &= ~0x00000001;
      id = 0;
      return this;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @return the id
     */
    public int getId() {
      return id;
    }

    /**
     * <code>optional uint32 Id = 1;</code>
     * @param value the id to set
     * @return this
     */
    public FateCardTimeLimit setId(final int value) {
      bitField0_ |= 0x00000001;
      id = value;
      return this;
    }

    /**
     * <code>optional uint32 TimeLimit = 2;</code>
     * @return whether the timeLimit field is set
     */
    public boolean hasTimeLimit() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional uint32 TimeLimit = 2;</code>
     * @return this
     */
    public FateCardTimeLimit clearTimeLimit() {
      bitField0_ &= ~0x00000002;
      timeLimit = 0;
      return this;
    }

    /**
     * <code>optional uint32 TimeLimit = 2;</code>
     * @return the timeLimit
     */
    public int getTimeLimit() {
      return timeLimit;
    }

    /**
     * <code>optional uint32 TimeLimit = 2;</code>
     * @param value the timeLimit to set
     * @return this
     */
    public FateCardTimeLimit setTimeLimit(final int value) {
      bitField0_ |= 0x00000002;
      timeLimit = value;
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return whether the nextPackage field is set
     */
    public boolean hasNextPackage() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @return this
     */
    public FateCardTimeLimit clearNextPackage() {
      bitField0_ &= ~0x00000004;
      nextPackage.clear();
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNextPackage()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getNextPackage() {
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableNextPackage() {
      bitField0_ |= 0x00000004;
      return nextPackage;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param value the nextPackage to add
     * @return this
     */
    public FateCardTimeLimit addNextPackage(final byte value) {
      bitField0_ |= 0x00000004;
      nextPackage.add(value);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to add
     * @return this
     */
    public FateCardTimeLimit addAllNextPackage(final byte... values) {
      bitField0_ |= 0x00000004;
      nextPackage.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes NextPackage = 2047;</code>
     * @param values the nextPackage to set
     * @return this
     */
    public FateCardTimeLimit setNextPackage(final byte... values) {
      bitField0_ |= 0x00000004;
      nextPackage.copyFrom(values);
      return this;
    }

    @Override
    public FateCardTimeLimit copyFrom(final FateCardTimeLimit other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        id = other.id;
        timeLimit = other.timeLimit;
        nextPackage.copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public FateCardTimeLimit mergeFrom(final FateCardTimeLimit other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasId()) {
        setId(other.id);
      }
      if (other.hasTimeLimit()) {
        setTimeLimit(other.timeLimit);
      }
      if (other.hasNextPackage()) {
        getMutableNextPackage().copyFrom(other.nextPackage);
      }
      return this;
    }

    @Override
    public FateCardTimeLimit clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      id = 0;
      timeLimit = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public FateCardTimeLimit clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nextPackage.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof FateCardTimeLimit)) {
        return false;
      }
      FateCardTimeLimit other = (FateCardTimeLimit) o;
      return bitField0_ == other.bitField0_
        && (!hasId() || id == other.id)
        && (!hasTimeLimit() || timeLimit == other.timeLimit)
        && (!hasNextPackage() || nextPackage.equals(other.nextPackage));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt32NoTag(id);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 16);
        output.writeUInt32NoTag(timeLimit);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawLittleEndian16((short) 32762);
        output.writeBytesNoTag(nextPackage);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(id);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(timeLimit);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 2 + ProtoSink.computeBytesSizeNoTag(nextPackage);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public FateCardTimeLimit mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            // id
            id = input.readUInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 16) {
              break;
            }
          }
          case 16: {
            // timeLimit
            timeLimit = input.readUInt32();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 16378) {
              break;
            }
          }
          case 16378: {
            // nextPackage
            input.readBytes(nextPackage);
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeUInt32(FieldNames.id, id);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeUInt32(FieldNames.timeLimit, timeLimit);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeBytes(FieldNames.nextPackage, nextPackage);
      }
      output.endObject();
    }

    @Override
    public FateCardTimeLimit mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 2363: {
            if (input.isAtField(FieldNames.id)) {
              if (!input.trySkipNullValue()) {
                id = input.readUInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 2022760654: {
            if (input.isAtField(FieldNames.timeLimit)) {
              if (!input.trySkipNullValue()) {
                timeLimit = input.readUInt32();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2082324045: {
            if (input.isAtField(FieldNames.nextPackage)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(nextPackage);
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public FateCardTimeLimit clone() {
      return new FateCardTimeLimit().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static FateCardTimeLimit parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new FateCardTimeLimit(), data).checkInitialized();
    }

    public static FateCardTimeLimit parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new FateCardTimeLimit(), input).checkInitialized();
    }

    public static FateCardTimeLimit parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new FateCardTimeLimit(), input).checkInitialized();
    }

    /**
     * @return factory for creating FateCardTimeLimit messages
     */
    public static MessageFactory<FateCardTimeLimit> getFactory() {
      return FateCardTimeLimitFactory.INSTANCE;
    }

    private enum FateCardTimeLimitFactory implements MessageFactory<FateCardTimeLimit> {
      INSTANCE;

      @Override
      public FateCardTimeLimit create() {
        return FateCardTimeLimit.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName id = FieldName.forField("Id");

      static final FieldName timeLimit = FieldName.forField("TimeLimit");

      static final FieldName nextPackage = FieldName.forField("NextPackage");
    }
  }
}
